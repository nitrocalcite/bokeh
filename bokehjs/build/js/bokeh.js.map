{"version":3,"sources":["@@\\build\\js\\lib\\main.js","@@\\node_modules\\tslib\\tslib.es6.js","@@\\build\\js\\lib\\index.js","@@\\build\\js\\lib\\version.js","@@\\build\\js\\lib\\embed\\index.js","@@\\build\\js\\lib\\document\\index.js","@@\\build\\js\\lib\\document\\document.js","@@\\build\\js\\lib\\base.js","@@\\build\\js\\lib\\core\\util\\types.js","@@\\build\\js\\lib\\core\\util\\array.js","@@\\build\\js\\lib\\core\\util\\math.js","@@\\build\\js\\lib\\core\\util\\assert.js","@@\\build\\js\\lib\\core\\util\\arrayable.js","@@\\build\\js\\lib\\core\\util\\object.js","@@\\build\\js\\lib\\core\\has_props.js","@@\\build\\js\\lib\\core\\signaling.js","@@\\build\\js\\lib\\core\\util\\callback.js","@@\\build\\js\\lib\\core\\util\\refs.js","@@\\build\\js\\lib\\core\\properties.js","@@\\build\\js\\lib\\core\\logging.js","@@\\build\\js\\lib\\core\\enums.js","@@\\build\\js\\lib\\core\\kinds.js","@@\\build\\js\\lib\\core\\util\\color.js","@@\\build\\js\\lib\\core\\util\\svg_colors.js","@@\\build\\js\\lib\\core\\types.js","@@\\build\\js\\lib\\core\\util\\eq.js","@@\\build\\js\\lib\\core\\util\\data_structures.js","@@\\build\\js\\lib\\core\\settings.js","@@\\build\\js\\lib\\core\\property_mixins.js","@@\\build\\js\\lib\\core\\util\\string.js","@@\\build\\js\\lib\\core\\util\\ndarray.js","@@\\build\\js\\lib\\core\\util\\serialization.js","@@\\build\\js\\lib\\core\\util\\compat.js","@@\\build\\js\\lib\\core\\util\\pretty.js","@@\\build\\js\\lib\\models\\index.js","@@\\build\\js\\lib\\models\\annotations\\index.js","@@\\build\\js\\lib\\models\\annotations\\annotation.js","@@\\build\\js\\lib\\core\\util\\projections.js","@@\\node_modules\\proj4\\lib\\core.js","@@\\node_modules\\proj4\\lib\\Proj.js","@@\\node_modules\\proj4\\lib\\parseCode.js","@@\\node_modules\\proj4\\lib\\defs.js","@@\\node_modules\\proj4\\lib\\global.js","@@\\node_modules\\proj4\\lib\\projString.js","@@\\node_modules\\proj4\\lib\\constants\\values.js","@@\\node_modules\\proj4\\lib\\constants\\PrimeMeridian.js","@@\\node_modules\\proj4\\lib\\constants\\units.js","@@\\node_modules\\proj4\\lib\\match.js","@@\\node_modules\\wkt-parser\\index.js","@@\\node_modules\\wkt-parser\\parser.js","@@\\node_modules\\wkt-parser\\process.js","@@\\node_modules\\proj4\\lib\\extend.js","@@\\node_modules\\proj4\\lib\\projections.js","@@\\node_modules\\proj4\\lib\\projections\\merc.js","@@\\node_modules\\proj4\\lib\\common\\msfnz.js","@@\\node_modules\\proj4\\lib\\common\\adjust_lon.js","@@\\node_modules\\proj4\\lib\\common\\sign.js","@@\\node_modules\\proj4\\lib\\common\\tsfnz.js","@@\\node_modules\\proj4\\lib\\common\\phi2z.js","@@\\node_modules\\proj4\\lib\\projections\\longlat.js","@@\\node_modules\\proj4\\lib\\deriveConstants.js","@@\\node_modules\\proj4\\lib\\constants\\Ellipsoid.js","@@\\node_modules\\proj4\\lib\\constants\\Datum.js","@@\\node_modules\\proj4\\lib\\datum.js","@@\\node_modules\\proj4\\lib\\transform.js","@@\\node_modules\\proj4\\lib\\datum_transform.js","@@\\node_modules\\proj4\\lib\\datumUtils.js","@@\\node_modules\\proj4\\lib\\adjust_axis.js","@@\\node_modules\\proj4\\lib\\common\\toPoint.js","@@\\node_modules\\proj4\\lib\\checkSanity.js","@@\\build\\js\\lib\\models\\renderers\\renderer.js","@@\\build\\js\\lib\\core\\view.js","@@\\build\\js\\lib\\core\\dom.js","@@\\build\\js\\lib\\styles\\root.css.js","@@\\build\\js\\lib\\core\\visuals.js","@@\\build\\js\\lib\\core\\util\\svg.js","@@\\build\\js\\lib\\core\\util\\affine.js","@@\\build\\js\\lib\\models\\canvas\\canvas.js","@@\\build\\js\\lib\\core\\dom_view.js","@@\\build\\js\\lib\\core\\util\\bbox.js","@@\\build\\js\\lib\\core\\util\\canvas.js","@@\\build\\js\\lib\\model.js","@@\\build\\js\\lib\\models\\canvas\\coordinates.js","@@\\build\\js\\lib\\models\\annotations\\arrow.js","@@\\build\\js\\lib\\models\\annotations\\arrow_head.js","@@\\build\\js\\lib\\models\\sources\\column_data_source.js","@@\\build\\js\\lib\\models\\sources\\columnar_data_source.js","@@\\build\\js\\lib\\models\\sources\\data_source.js","@@\\build\\js\\lib\\models\\selections\\selection.js","@@\\build\\js\\lib\\core\\selection_manager.js","@@\\build\\js\\lib\\models\\renderers\\glyph_renderer.js","@@\\build\\js\\lib\\models\\renderers\\data_renderer.js","@@\\build\\js\\lib\\models\\glyphs\\line.js","@@\\build\\js\\lib\\models\\glyphs\\xy_glyph.js","@@\\build\\js\\lib\\models\\glyphs\\glyph.js","@@\\build\\js\\lib\\core\\util\\spatial.js","@@\\node_modules\\flatbush\\index.js","@@\\node_modules\\flatqueue\\index.mjs","@@\\build\\js\\lib\\models\\ranges\\factor_range.js","@@\\build\\js\\lib\\models\\ranges\\range.js","@@\\build\\js\\lib\\models\\glyphs\\utils.js","@@\\build\\js\\lib\\core\\hittest.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\line.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\utils\\index.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\utils\\program.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\utils\\buffer.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\utils\\texture.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\base.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\line.vert.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\line.frag.js","@@\\build\\js\\lib\\models\\glyphs\\patch.js","@@\\build\\js\\lib\\models\\glyphs\\harea.js","@@\\build\\js\\lib\\models\\glyphs\\area.js","@@\\build\\js\\lib\\models\\glyphs\\varea.js","@@\\build\\js\\lib\\models\\sources\\cds_view.js","@@\\build\\js\\lib\\core\\build_views.js","@@\\build\\js\\lib\\models\\renderers\\graph_renderer.js","@@\\build\\js\\lib\\models\\graphs\\graph_hit_test_policy.js","@@\\build\\js\\lib\\models\\selections\\interaction_policy.js","@@\\build\\js\\lib\\core\\util\\typed_array.js","@@\\build\\js\\lib\\core\\util\\set.js","@@\\build\\js\\lib\\document\\events.js","@@\\build\\js\\lib\\models\\annotations\\band.js","@@\\build\\js\\lib\\models\\annotations\\upper_lower.js","@@\\build\\js\\lib\\models\\annotations\\box_annotation.js","@@\\build\\js\\lib\\models\\annotations\\color_bar.js","@@\\build\\js\\lib\\models\\tickers\\basic_ticker.js","@@\\build\\js\\lib\\models\\tickers\\adaptive_ticker.js","@@\\build\\js\\lib\\models\\tickers\\continuous_ticker.js","@@\\build\\js\\lib\\models\\tickers\\ticker.js","@@\\build\\js\\lib\\models\\formatters\\basic_tick_formatter.js","@@\\build\\js\\lib\\models\\formatters\\tick_formatter.js","@@\\build\\js\\lib\\models\\mappers\\index.js","@@\\build\\js\\lib\\models\\mappers\\categorical_color_mapper.js","@@\\build\\js\\lib\\models\\mappers\\categorical_mapper.js","@@\\build\\js\\lib\\models\\mappers\\color_mapper.js","@@\\build\\js\\lib\\models\\mappers\\mapper.js","@@\\build\\js\\lib\\models\\transforms\\transform.js","@@\\build\\js\\lib\\models\\mappers\\categorical_marker_mapper.js","@@\\build\\js\\lib\\models\\mappers\\categorical_pattern_mapper.js","@@\\build\\js\\lib\\models\\mappers\\continuous_color_mapper.js","@@\\build\\js\\lib\\models\\mappers\\linear_color_mapper.js","@@\\build\\js\\lib\\models\\mappers\\log_color_mapper.js","@@\\build\\js\\lib\\models\\mappers\\scanning_color_mapper.js","@@\\build\\js\\lib\\models\\mappers\\eqhist_color_mapper.js","@@\\build\\js\\lib\\models\\scales\\linear_scale.js","@@\\build\\js\\lib\\models\\scales\\continuous_scale.js","@@\\build\\js\\lib\\models\\scales\\scale.js","@@\\build\\js\\lib\\models\\transforms\\index.js","@@\\build\\js\\lib\\models\\transforms\\customjs_transform.js","@@\\build\\js\\lib\\models\\transforms\\dodge.js","@@\\build\\js\\lib\\models\\transforms\\range_transform.js","@@\\build\\js\\lib\\models\\transforms\\interpolator.js","@@\\build\\js\\lib\\models\\transforms\\jitter.js","@@\\build\\js\\lib\\models\\transforms\\linear_interpolator.js","@@\\build\\js\\lib\\models\\transforms\\step_interpolator.js","@@\\build\\js\\lib\\models\\scales\\linear_interpolation_scale.js","@@\\build\\js\\lib\\models\\scales\\log_scale.js","@@\\build\\js\\lib\\models\\ranges\\range1d.js","@@\\build\\js\\lib\\core\\util\\text.js","@@\\build\\js\\lib\\models\\annotations\\label.js","@@\\build\\js\\lib\\models\\annotations\\text_annotation.js","@@\\build\\js\\lib\\models\\annotations\\label_set.js","@@\\build\\js\\lib\\models\\annotations\\legend.js","@@\\build\\js\\lib\\models\\annotations\\legend_item.js","@@\\build\\js\\lib\\core\\vectorization.js","@@\\build\\js\\lib\\models\\annotations\\poly_annotation.js","@@\\build\\js\\lib\\models\\annotations\\slope.js","@@\\build\\js\\lib\\models\\annotations\\span.js","@@\\build\\js\\lib\\models\\annotations\\title.js","@@\\build\\js\\lib\\models\\annotations\\toolbar_panel.js","@@\\build\\js\\lib\\models\\annotations\\tooltip.js","@@\\build\\js\\lib\\styles\\tooltips.js","@@\\build\\js\\lib\\styles\\mixins.js","@@\\build\\js\\lib\\styles\\tooltips.css.js","@@\\build\\js\\lib\\models\\annotations\\whisker.js","@@\\build\\js\\lib\\models\\axes\\index.js","@@\\build\\js\\lib\\models\\axes\\axis.js","@@\\build\\js\\lib\\models\\renderers\\guide_renderer.js","@@\\build\\js\\lib\\models\\axes\\categorical_axis.js","@@\\build\\js\\lib\\models\\tickers\\categorical_ticker.js","@@\\build\\js\\lib\\models\\formatters\\categorical_tick_formatter.js","@@\\build\\js\\lib\\models\\axes\\continuous_axis.js","@@\\build\\js\\lib\\models\\axes\\datetime_axis.js","@@\\build\\js\\lib\\models\\axes\\linear_axis.js","@@\\build\\js\\lib\\models\\formatters\\datetime_tick_formatter.js","@@\\node_modules\\timezone\\index.js","@@\\build\\js\\lib\\core\\util\\templating.js","@@\\node_modules\\@bokeh\\numbro\\numbro.js","@@\\node_modules\\sprintf-js\\src\\sprintf.js","@@\\build\\js\\lib\\models\\tickers\\datetime_ticker.js","@@\\build\\js\\lib\\models\\tickers\\composite_ticker.js","@@\\build\\js\\lib\\models\\tickers\\days_ticker.js","@@\\build\\js\\lib\\models\\tickers\\single_interval_ticker.js","@@\\build\\js\\lib\\models\\tickers\\util.js","@@\\build\\js\\lib\\models\\tickers\\months_ticker.js","@@\\build\\js\\lib\\models\\tickers\\years_ticker.js","@@\\build\\js\\lib\\models\\axes\\log_axis.js","@@\\build\\js\\lib\\models\\formatters\\log_tick_formatter.js","@@\\build\\js\\lib\\models\\tickers\\log_ticker.js","@@\\build\\js\\lib\\models\\axes\\mercator_axis.js","@@\\build\\js\\lib\\models\\formatters\\mercator_tick_formatter.js","@@\\build\\js\\lib\\models\\tickers\\mercator_ticker.js","@@\\build\\js\\lib\\models\\callbacks\\index.js","@@\\build\\js\\lib\\models\\callbacks\\customjs.js","@@\\build\\js\\lib\\models\\callbacks\\callback.js","@@\\build\\js\\lib\\models\\callbacks\\open_url.js","@@\\build\\js\\lib\\models\\canvas\\index.js","@@\\build\\js\\lib\\models\\canvas\\cartesian_frame.js","@@\\build\\js\\lib\\models\\scales\\categorical_scale.js","@@\\build\\js\\lib\\models\\ranges\\data_range1d.js","@@\\build\\js\\lib\\models\\ranges\\data_range.js","@@\\build\\js\\lib\\core\\layout\\index.js","@@\\build\\js\\lib\\core\\layout\\types.js","@@\\build\\js\\lib\\core\\layout\\layoutable.js","@@\\build\\js\\lib\\core\\layout\\alignments.js","@@\\build\\js\\lib\\core\\layout\\grid.js","@@\\build\\js\\lib\\core\\layout\\html.js","@@\\build\\js\\lib\\models\\expressions\\index.js","@@\\build\\js\\lib\\models\\expressions\\expression.js","@@\\build\\js\\lib\\models\\expressions\\stack.js","@@\\build\\js\\lib\\models\\expressions\\cumsum.js","@@\\build\\js\\lib\\models\\filters\\index.js","@@\\build\\js\\lib\\models\\filters\\boolean_filter.js","@@\\build\\js\\lib\\models\\filters\\filter.js","@@\\build\\js\\lib\\models\\filters\\customjs_filter.js","@@\\build\\js\\lib\\models\\filters\\group_filter.js","@@\\build\\js\\lib\\models\\filters\\index_filter.js","@@\\build\\js\\lib\\models\\formatters\\index.js","@@\\build\\js\\lib\\models\\formatters\\func_tick_formatter.js","@@\\build\\js\\lib\\models\\formatters\\numeral_tick_formatter.js","@@\\build\\js\\lib\\models\\formatters\\printf_tick_formatter.js","@@\\build\\js\\lib\\models\\glyphs\\index.js","@@\\build\\js\\lib\\models\\glyphs\\annular_wedge.js","@@\\build\\js\\lib\\models\\glyphs\\annulus.js","@@\\build\\js\\lib\\models\\glyphs\\arc.js","@@\\build\\js\\lib\\models\\glyphs\\bezier.js","@@\\build\\js\\lib\\models\\glyphs\\circle.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\markers.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\markers.vert.js","@@\\build\\js\\lib\\models\\glyphs\\webgl\\markers.frag.js","@@\\build\\js\\lib\\models\\glyphs\\center_rotatable.js","@@\\build\\js\\lib\\models\\glyphs\\ellipse.js","@@\\build\\js\\lib\\models\\glyphs\\ellipse_oval.js","@@\\build\\js\\lib\\models\\glyphs\\hbar.js","@@\\build\\js\\lib\\models\\glyphs\\box.js","@@\\build\\js\\lib\\models\\glyphs\\hex_tile.js","@@\\build\\js\\lib\\models\\glyphs\\image.js","@@\\build\\js\\lib\\models\\glyphs\\image_base.js","@@\\build\\js\\lib\\models\\glyphs\\image_rgba.js","@@\\build\\js\\lib\\models\\glyphs\\image_url.js","@@\\build\\js\\lib\\core\\util\\image.js","@@\\build\\js\\lib\\models\\glyphs\\multi_line.js","@@\\build\\js\\lib\\models\\glyphs\\multi_polygons.js","@@\\build\\js\\lib\\models\\glyphs\\oval.js","@@\\build\\js\\lib\\models\\glyphs\\patches.js","@@\\build\\js\\lib\\models\\glyphs\\quad.js","@@\\build\\js\\lib\\models\\glyphs\\quadratic.js","@@\\build\\js\\lib\\models\\glyphs\\ray.js","@@\\build\\js\\lib\\models\\glyphs\\rect.js","@@\\build\\js\\lib\\models\\glyphs\\segment.js","@@\\build\\js\\lib\\models\\glyphs\\step.js","@@\\build\\js\\lib\\models\\glyphs\\text.js","@@\\build\\js\\lib\\models\\glyphs\\vbar.js","@@\\build\\js\\lib\\models\\glyphs\\wedge.js","@@\\build\\js\\lib\\models\\graphs\\index.js","@@\\build\\js\\lib\\models\\graphs\\layout_provider.js","@@\\build\\js\\lib\\models\\graphs\\static_layout_provider.js","@@\\build\\js\\lib\\models\\grids\\index.js","@@\\build\\js\\lib\\models\\grids\\grid.js","@@\\build\\js\\lib\\models\\layouts\\index.js","@@\\build\\js\\lib\\models\\layouts\\box.js","@@\\build\\js\\lib\\models\\layouts\\layout_dom.js","@@\\build\\js\\lib\\styles\\root.js","@@\\build\\js\\lib\\models\\layouts\\column.js","@@\\build\\js\\lib\\models\\layouts\\grid_box.js","@@\\build\\js\\lib\\models\\layouts\\html_box.js","@@\\build\\js\\lib\\models\\layouts\\row.js","@@\\build\\js\\lib\\models\\layouts\\spacer.js","@@\\build\\js\\lib\\models\\layouts\\tabs.js","@@\\build\\js\\lib\\styles\\tabs.js","@@\\build\\js\\lib\\styles\\buttons.js","@@\\build\\js\\lib\\styles\\menus.js","@@\\build\\js\\lib\\styles\\buttons.css.js","@@\\build\\js\\lib\\styles\\menus.css.js","@@\\build\\js\\lib\\styles\\tabs.css.js","@@\\build\\js\\lib\\models\\layouts\\widget_box.js","@@\\build\\js\\lib\\models\\markers\\index.js","@@\\build\\js\\lib\\models\\markers\\defs.js","@@\\build\\js\\lib\\models\\markers\\marker.js","@@\\build\\js\\lib\\models\\markers\\scatter.js","@@\\build\\js\\lib\\models\\plots\\index.js","@@\\build\\js\\lib\\models\\plots\\gmap_plot.js","@@\\build\\js\\lib\\models\\plots\\plot.js","@@\\build\\js\\lib\\models\\tools\\toolbar.js","@@\\build\\js\\lib\\models\\tools\\inspectors\\inspect_tool.js","@@\\build\\js\\lib\\models\\tools\\button_tool.js","@@\\node_modules\\hammerjs\\hammer.js","@@\\build\\js\\lib\\models\\tools\\tool.js","@@\\build\\js\\lib\\styles\\toolbar.js","@@\\build\\js\\lib\\styles\\toolbar.css.js","@@\\build\\js\\lib\\styles\\icons.css.js","@@\\build\\js\\lib\\core\\util\\menus.js","@@\\build\\js\\lib\\core\\util\\iterator.js","@@\\build\\js\\lib\\models\\tools\\on_off_button.js","@@\\build\\js\\lib\\models\\tools\\toolbar_base.js","@@\\build\\js\\lib\\models\\tools\\gestures\\gesture_tool.js","@@\\build\\js\\lib\\models\\tools\\actions\\action_tool.js","@@\\build\\js\\lib\\models\\tools\\actions\\help_tool.js","@@\\build\\js\\lib\\styles\\icons.js","@@\\build\\js\\lib\\styles\\logo.js","@@\\build\\js\\lib\\styles\\logo.css.js","@@\\build\\js\\lib\\models\\plots\\plot_canvas.js","@@\\build\\js\\lib\\core\\bokeh_events.js","@@\\build\\js\\lib\\core\\ui_events.js","@@\\build\\js\\lib\\core\\util\\wheel.js","@@\\build\\js\\lib\\core\\util\\throttle.js","@@\\build\\js\\lib\\core\\layout\\border.js","@@\\build\\js\\lib\\core\\layout\\side_panel.js","@@\\build\\js\\lib\\models\\plots\\gmap_plot_canvas.js","@@\\build\\js\\lib\\models\\ranges\\index.js","@@\\build\\js\\lib\\models\\renderers\\index.js","@@\\build\\js\\lib\\models\\scales\\index.js","@@\\build\\js\\lib\\models\\selections\\index.js","@@\\build\\js\\lib\\models\\sources\\index.js","@@\\build\\js\\lib\\models\\sources\\server_sent_data_source.js","@@\\build\\js\\lib\\models\\sources\\web_data_source.js","@@\\build\\js\\lib\\models\\sources\\ajax_data_source.js","@@\\build\\js\\lib\\models\\sources\\geojson_data_source.js","@@\\build\\js\\lib\\models\\tickers\\index.js","@@\\build\\js\\lib\\models\\tickers\\fixed_ticker.js","@@\\build\\js\\lib\\models\\tiles\\index.js","@@\\build\\js\\lib\\models\\tiles\\bbox_tile_source.js","@@\\build\\js\\lib\\models\\tiles\\mercator_tile_source.js","@@\\build\\js\\lib\\models\\tiles\\tile_source.js","@@\\build\\js\\lib\\models\\tiles\\tile_utils.js","@@\\build\\js\\lib\\models\\tiles\\quadkey_tile_source.js","@@\\build\\js\\lib\\models\\tiles\\tile_renderer.js","@@\\build\\js\\lib\\models\\tiles\\wmts_tile_source.js","@@\\build\\js\\lib\\styles\\tiles.js","@@\\build\\js\\lib\\styles\\tiles.css.js","@@\\build\\js\\lib\\models\\tiles\\tms_tile_source.js","@@\\build\\js\\lib\\models\\textures\\index.js","@@\\build\\js\\lib\\models\\textures\\canvas_texture.js","@@\\build\\js\\lib\\models\\textures\\texture.js","@@\\build\\js\\lib\\models\\textures\\image_url_texture.js","@@\\build\\js\\lib\\models\\tools\\index.js","@@\\build\\js\\lib\\models\\tools\\actions\\custom_action.js","@@\\build\\js\\lib\\models\\tools\\actions\\redo_tool.js","@@\\build\\js\\lib\\models\\tools\\actions\\reset_tool.js","@@\\build\\js\\lib\\models\\tools\\actions\\save_tool.js","@@\\build\\js\\lib\\models\\tools\\actions\\undo_tool.js","@@\\build\\js\\lib\\models\\tools\\actions\\zoom_in_tool.js","@@\\build\\js\\lib\\models\\tools\\actions\\zoom_base_tool.js","@@\\build\\js\\lib\\core\\util\\zoom.js","@@\\build\\js\\lib\\models\\tools\\actions\\zoom_out_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\edit_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\box_edit_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\freehand_draw_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\point_draw_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\poly_draw_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\poly_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\poly_edit_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\box_select_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\select_tool.js","@@\\build\\js\\lib\\models\\tools\\util.js","@@\\build\\js\\lib\\models\\tools\\gestures\\box_zoom_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\lasso_select_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\poly_select_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\line_edit_tool.js","@@\\build\\js\\lib\\models\\tools\\edit\\line_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\pan_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\range_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\tap_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\wheel_pan_tool.js","@@\\build\\js\\lib\\models\\tools\\gestures\\wheel_zoom_tool.js","@@\\build\\js\\lib\\models\\tools\\inspectors\\crosshair_tool.js","@@\\build\\js\\lib\\models\\tools\\inspectors\\customjs_hover.js","@@\\build\\js\\lib\\models\\tools\\inspectors\\hover_tool.js","@@\\build\\js\\lib\\models\\tools\\tool_proxy.js","@@\\build\\js\\lib\\models\\tools\\toolbar_box.js","@@\\build\\js\\lib\\embed\\standalone.js","@@\\build\\js\\lib\\embed\\dom.js","@@\\build\\js\\lib\\embed\\server.js","@@\\build\\js\\lib\\client\\connection.js","@@\\build\\js\\lib\\protocol\\message.js","@@\\build\\js\\lib\\protocol\\receiver.js","@@\\build\\js\\lib\\client\\session.js","@@\\build\\js\\lib\\embed\\notebook.js","@@\\build\\js\\lib\\styles\\notebook.css.js","@@\\build\\js\\lib\\protocol\\index.js","@@\\build\\js\\lib\\testing.js","@@\\build\\js\\lib\\safely.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3EA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/gCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACngBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5UA;AACA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5wEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* main.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    tslib_1.__exportStar(require(2) /* ./index */, exports);\r\n}\r\n","/* tslib\\tslib.es6.js */ function _(require, module, exports) {\r\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n    \r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n    \r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) {\r\n                for (var p in b)\r\n                    if (b.hasOwnProperty(p))\r\n                        d[p] = b[p];\r\n            };\r\n        return extendStatics(d, b);\r\n    };\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n    exports.__extends = __extends;\r\n    exports.__assign = function () {\r\n        exports.__assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s)\r\n                    if (Object.prototype.hasOwnProperty.call(s, p))\r\n                        t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return exports.__assign.apply(this, arguments);\r\n    };\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s)\r\n            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n                t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    }\r\n    exports.__rest = __rest;\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n            r = Reflect.decorate(decorators, target, key, desc);\r\n        else\r\n            for (var i = decorators.length - 1; i >= 0; i--)\r\n                if (d = decorators[i])\r\n                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n    exports.__decorate = __decorate;\r\n    function __param(paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); };\r\n    }\r\n    exports.__param = __param;\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n            return Reflect.metadata(metadataKey, metadataValue);\r\n    }\r\n    exports.__metadata = __metadata;\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) {\r\n                try {\r\n                    step(generator.next(value));\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }\r\n            function rejected(value) {\r\n                try {\r\n                    step(generator[\"throw\"](value));\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n    exports.__awaiter = __awaiter;\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function () {\r\n                if (t[0] & 1)\r\n                    throw t[1];\r\n                return t[1];\r\n            }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f)\r\n                throw new TypeError(\"Generator is already executing.\");\r\n            while (_)\r\n                try {\r\n                    if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\r\n                        return t;\r\n                    if (y = 0, t)\r\n                        op = [op[0] & 2, t.value];\r\n                    switch (op[0]) {\r\n                        case 0:\r\n                        case 1:\r\n                            t = op;\r\n                            break;\r\n                        case 4:\r\n                            _.label++;\r\n                            return { value: op[1], done: false };\r\n                        case 5:\r\n                            _.label++;\r\n                            y = op[1];\r\n                            op = [0];\r\n                            continue;\r\n                        case 7:\r\n                            op = _.ops.pop();\r\n                            _.trys.pop();\r\n                            continue;\r\n                        default:\r\n                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\r\n                                _ = 0;\r\n                                continue;\r\n                            }\r\n                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\r\n                                _.label = op[1];\r\n                                break;\r\n                            }\r\n                            if (op[0] === 6 && _.label < t[1]) {\r\n                                _.label = t[1];\r\n                                t = op;\r\n                                break;\r\n                            }\r\n                            if (t && _.label < t[2]) {\r\n                                _.label = t[2];\r\n                                _.ops.push(op);\r\n                                break;\r\n                            }\r\n                            if (t[2])\r\n                                _.ops.pop();\r\n                            _.trys.pop();\r\n                            continue;\r\n                    }\r\n                    op = body.call(thisArg, _);\r\n                }\r\n                catch (e) {\r\n                    op = [6, e];\r\n                    y = 0;\r\n                }\r\n                finally {\r\n                    f = t = 0;\r\n                }\r\n            if (op[0] & 5)\r\n                throw op[1];\r\n            return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n    exports.__generator = __generator;\r\n    function __createBinding(o, m, k, k2) {\r\n        if (k2 === undefined)\r\n            k2 = k;\r\n        o[k2] = m[k];\r\n    }\r\n    exports.__createBinding = __createBinding;\r\n    function __exportStar(m, exports) {\r\n        for (var p in m)\r\n            if (p !== \"default\" && !exports.hasOwnProperty(p))\r\n                exports[p] = m[p];\r\n    }\r\n    exports.__exportStar = __exportStar;\r\n    function __values(o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m)\r\n            return m.call(o);\r\n        if (o && typeof o.length === \"number\")\r\n            return {\r\n                next: function () {\r\n                    if (o && i >= o.length)\r\n                        o = void 0;\r\n                    return { value: o && o[i++], done: !o };\r\n                }\r\n            };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    }\r\n    exports.__values = __values;\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m)\r\n            return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\r\n                ar.push(r.value);\r\n        }\r\n        catch (error) {\r\n            e = { error: error };\r\n        }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"]))\r\n                    m.call(i);\r\n            }\r\n            finally {\r\n                if (e)\r\n                    throw e.error;\r\n            }\r\n        }\r\n        return ar;\r\n    }\r\n    exports.__read = __read;\r\n    function __spread() {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    }\r\n    exports.__spread = __spread;\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++)\r\n            s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    }\r\n    exports.__spreadArrays = __spreadArrays;\r\n    ;\r\n    function __await(v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    }\r\n    exports.__await = __await;\r\n    function __asyncGenerator(thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator)\r\n            throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) {\r\n            if (g[n])\r\n                i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); };\r\n        }\r\n        function resume(n, v) {\r\n            try {\r\n                step(g[n](v));\r\n            }\r\n            catch (e) {\r\n                settle(q[0][3], e);\r\n            }\r\n        }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) {\r\n            if (f(v), q.shift(), q.length)\r\n                resume(q[0][0], q[0][1]);\r\n        }\r\n    }\r\n    exports.__asyncGenerator = __asyncGenerator;\r\n    function __asyncDelegator(o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    }\r\n    exports.__asyncDelegator = __asyncDelegator;\r\n    function __asyncValues(o) {\r\n        if (!Symbol.asyncIterator)\r\n            throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }\r\n    }\r\n    exports.__asyncValues = __asyncValues;\r\n    function __makeTemplateObject(cooked, raw) {\r\n        if (Object.defineProperty) {\r\n            Object.defineProperty(cooked, \"raw\", { value: raw });\r\n        }\r\n        else {\r\n            cooked.raw = raw;\r\n        }\r\n        return cooked;\r\n    }\r\n    exports.__makeTemplateObject = __makeTemplateObject;\r\n    ;\r\n    function __importStar(mod) {\r\n        if (mod && mod.__esModule)\r\n            return mod;\r\n        var result = {};\r\n        if (mod != null)\r\n            for (var k in mod)\r\n                if (Object.hasOwnProperty.call(mod, k))\r\n                    result[k] = mod[k];\r\n        result.default = mod;\r\n        return result;\r\n    }\r\n    exports.__importStar = __importStar;\r\n    function __importDefault(mod) {\r\n        return (mod && mod.__esModule) ? mod : { default: mod };\r\n    }\r\n    exports.__importDefault = __importDefault;\r\n    function __classPrivateFieldGet(receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    }\r\n    exports.__classPrivateFieldGet = __classPrivateFieldGet;\r\n    function __classPrivateFieldSet(receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    }\r\n    exports.__classPrivateFieldSet = __classPrivateFieldSet;\r\n}\r\n","/* index.js */ function _(require, module, exports) {\r\n    var __importStar = (this && this.__importStar) || function (mod) {\r\n        if (mod && mod.__esModule)\r\n            return mod;\r\n        var result = {};\r\n        if (mod != null)\r\n            for (var k in mod)\r\n                if (Object.hasOwnProperty.call(mod, k))\r\n                    result[k] = mod[k];\r\n        result[\"default\"] = mod;\r\n        return result;\r\n    };\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var version_1 = require(3) /* ./version */;\r\n    exports.version = version_1.version;\r\n    var embed_1 = require(4) /* ./embed */;\r\n    exports.index = embed_1.index;\r\n    exports.embed = __importStar(require(4) /* ./embed */);\r\n    exports.protocol = __importStar(require(390) /* ./protocol */);\r\n    exports._testing = __importStar(require(391) /* ./testing */);\r\n    var logging_1 = require(19) /* ./core/logging */;\r\n    exports.logger = logging_1.logger;\r\n    exports.set_log_level = logging_1.set_log_level;\r\n    var settings_1 = require(27) /* ./core/settings */;\r\n    exports.settings = settings_1.settings;\r\n    var base_1 = require(7) /* ./base */;\r\n    exports.Models = base_1.Models;\r\n    var document_1 = require(5) /* ./document */;\r\n    exports.documents = document_1.documents;\r\n    var safely_1 = require(392) /* ./safely */;\r\n    exports.safely = safely_1.safely;\r\n}\r\n","/* version.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.version = \"2.2.3\";\r\n}\r\n","/* embed\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const document_1 = require(5) /* ../document */;\r\n    const logging_1 = require(19) /* ../core/logging */;\r\n    const string_1 = require(29) /* ../core/util/string */;\r\n    const object_1 = require(13) /* ../core/util/object */;\r\n    const types_1 = require(8) /* ../core/util/types */;\r\n    const callback_1 = require(16) /* ../core/util/callback */;\r\n    const standalone_1 = require(381) /* ./standalone */;\r\n    const server_1 = require(383) /* ./server */;\r\n    const dom_1 = require(382) /* ./dom */;\r\n    var standalone_2 = require(381) /* ./standalone */;\r\n    exports.add_document_standalone = standalone_2.add_document_standalone;\r\n    exports.index = standalone_2.index;\r\n    var server_2 = require(383) /* ./server */;\r\n    exports.add_document_from_session = server_2.add_document_from_session;\r\n    var notebook_1 = require(388) /* ./notebook */;\r\n    exports.embed_items_notebook = notebook_1.embed_items_notebook;\r\n    exports.kernels = notebook_1.kernels;\r\n    var dom_2 = require(382) /* ./dom */;\r\n    exports.BOKEH_ROOT = dom_2.BOKEH_ROOT;\r\n    async function embed_item(item, target_id) {\r\n        const docs_json = {};\r\n        const doc_id = string_1.uuid4();\r\n        docs_json[doc_id] = item.doc;\r\n        if (target_id == null)\r\n            target_id = item.target_id;\r\n        const element = document.getElementById(target_id);\r\n        if (element != null)\r\n            element.classList.add(dom_1.BOKEH_ROOT);\r\n        const roots = { [item.root_id]: target_id };\r\n        const render_item = { roots, root_ids: [item.root_id], docid: doc_id };\r\n        const [views] = await callback_1.defer(() => _embed_items(docs_json, [render_item]));\r\n        return views;\r\n    }\r\n    exports.embed_item = embed_item;\r\n    // TODO (bev) this is currently clunky. Standalone embeds only provide\r\n    // the first two args, whereas server provide the app_app, and *may* prove and\r\n    // absolute_url as well if non-relative links are needed for resources. This function\r\n    // should probably be split in to two pieces to reflect the different usage patterns\r\n    async function embed_items(docs_json, render_items, app_path, absolute_url) {\r\n        return await callback_1.defer(() => _embed_items(docs_json, render_items, app_path, absolute_url));\r\n    }\r\n    exports.embed_items = embed_items;\r\n    async function _embed_items(docs_json, render_items, app_path, absolute_url) {\r\n        if (types_1.isString(docs_json))\r\n            docs_json = JSON.parse(string_1.unescape(docs_json));\r\n        const docs = {};\r\n        for (const [docid, doc_json] of object_1.entries(docs_json)) {\r\n            docs[docid] = document_1.Document.from_json(doc_json);\r\n        }\r\n        const views = [];\r\n        for (const item of render_items) {\r\n            const element = dom_1._resolve_element(item);\r\n            const roots = dom_1._resolve_root_elements(item);\r\n            if (item.docid != null) {\r\n                views.push(await standalone_1.add_document_standalone(docs[item.docid], element, roots, item.use_for_title));\r\n            }\r\n            else if (item.token != null) {\r\n                const websocket_url = server_1._get_ws_url(app_path, absolute_url);\r\n                logging_1.logger.debug(`embed: computed ws url: ${websocket_url}`);\r\n                try {\r\n                    views.push(await server_1.add_document_from_session(websocket_url, item.token, element, roots, item.use_for_title));\r\n                    console.log(\"Bokeh items were rendered successfully\");\r\n                }\r\n                catch (error) {\r\n                    console.log(\"Error rendering Bokeh items:\", error);\r\n                }\r\n            }\r\n            else\r\n                throw new Error(`Error rendering Bokeh items: either 'docid' or 'token' was expected.`);\r\n        }\r\n        return views;\r\n    }\r\n}\r\n","/* document\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    tslib_1.__exportStar(require(6) /* ./document */, exports);\r\n    tslib_1.__exportStar(require(121) /* ./events */, exports);\r\n}\r\n","/* document\\document.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const base_1 = require(7) /* ../base */;\r\n    const version_1 = require(3) /* ../version */;\r\n    const logging_1 = require(19) /* ../core/logging */;\r\n    const bokeh_events_1 = require(313) /* ../core/bokeh_events */;\r\n    const has_props_1 = require(14) /* ../core/has_props */;\r\n    const signaling_1 = require(15) /* ../core/signaling */;\r\n    const refs_1 = require(17) /* ../core/util/refs */;\r\n    const serialization_1 = require(31) /* ../core/util/serialization */;\r\n    const array_1 = require(9) /* ../core/util/array */;\r\n    const object_1 = require(13) /* ../core/util/object */;\r\n    const sets = tslib_1.__importStar(require(120) /* ../core/util/set */);\r\n    const eq_1 = require(25) /* ../core/util/eq */;\r\n    const types_1 = require(8) /* ../core/util/types */;\r\n    const layout_dom_1 = require(272) /* ../models/layouts/layout_dom */;\r\n    const column_data_source_1 = require(85) /* ../models/sources/column_data_source */;\r\n    const model_1 = require(81) /* ../model */;\r\n    const events_1 = require(121) /* ./events */;\r\n    // Dispatches events to the subscribed models\r\n    class EventManager {\r\n        constructor(document) {\r\n            this.document = document;\r\n            this.session = null;\r\n            this.subscribed_models = new Set();\r\n        }\r\n        send_event(bokeh_event) {\r\n            const event = new events_1.MessageSentEvent(this.document, \"bokeh_event\", bokeh_event.to_json());\r\n            this.document._trigger_on_change(event);\r\n        }\r\n        trigger(event) {\r\n            for (const model of this.subscribed_models) {\r\n                if (event.origin != null && event.origin != model)\r\n                    continue;\r\n                model._process_event(event);\r\n            }\r\n        }\r\n    }\r\n    exports.EventManager = EventManager;\r\n    EventManager.__name__ = \"EventManager\";\r\n    exports.documents = [];\r\n    exports.DEFAULT_TITLE = \"Bokeh Application\";\r\n    // This class should match the API of the Python Document class\r\n    // as much as possible.\r\n    class Document {\r\n        constructor() {\r\n            exports.documents.push(this);\r\n            this._init_timestamp = Date.now();\r\n            this._title = exports.DEFAULT_TITLE;\r\n            this._roots = [];\r\n            this._all_models = new Map();\r\n            this._all_models_freeze_count = 0;\r\n            this._callbacks = new Map();\r\n            this._message_callbacks = new Map();\r\n            this.event_manager = new EventManager(this);\r\n            this.idle = new signaling_1.Signal0(this, \"idle\");\r\n            this._idle_roots = new WeakMap(); // TODO: WeakSet would be better\r\n            this._interactive_timestamp = null;\r\n            this._interactive_plot = null;\r\n        }\r\n        get layoutables() {\r\n            return this._roots.filter((root) => root instanceof layout_dom_1.LayoutDOM);\r\n        }\r\n        get is_idle() {\r\n            for (const root of this.layoutables) {\r\n                if (!this._idle_roots.has(root))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        notify_idle(model) {\r\n            this._idle_roots.set(model, true);\r\n            if (this.is_idle) {\r\n                logging_1.logger.info(`document idle at ${Date.now() - this._init_timestamp} ms`);\r\n                this.event_manager.send_event(new bokeh_events_1.DocumentReady());\r\n                this.idle.emit();\r\n            }\r\n        }\r\n        clear() {\r\n            this._push_all_models_freeze();\r\n            try {\r\n                while (this._roots.length > 0) {\r\n                    this.remove_root(this._roots[0]);\r\n                }\r\n            }\r\n            finally {\r\n                this._pop_all_models_freeze();\r\n            }\r\n        }\r\n        interactive_start(plot) {\r\n            if (this._interactive_plot == null) {\r\n                this._interactive_plot = plot;\r\n                this._interactive_plot.trigger_event(new bokeh_events_1.LODStart());\r\n            }\r\n            this._interactive_timestamp = Date.now();\r\n        }\r\n        interactive_stop() {\r\n            if (this._interactive_plot != null) {\r\n                this._interactive_plot.trigger_event(new bokeh_events_1.LODEnd());\r\n            }\r\n            this._interactive_plot = null;\r\n            this._interactive_timestamp = null;\r\n        }\r\n        interactive_duration() {\r\n            if (this._interactive_timestamp == null)\r\n                return -1;\r\n            else\r\n                return Date.now() - this._interactive_timestamp;\r\n        }\r\n        destructively_move(dest_doc) {\r\n            if (dest_doc === this) {\r\n                throw new Error(\"Attempted to overwrite a document with itself\");\r\n            }\r\n            dest_doc.clear();\r\n            // we have to remove ALL roots before adding any\r\n            // to the new doc or else models referenced from multiple\r\n            // roots could be in both docs at once, which isn't allowed.\r\n            const roots = array_1.copy(this._roots);\r\n            this.clear();\r\n            for (const root of roots) {\r\n                if (root.document != null)\r\n                    throw new Error(`Somehow we didn't detach ${root}`);\r\n            }\r\n            if (this._all_models.size != 0) {\r\n                throw new Error(`this._all_models still had stuff in it: ${this._all_models}`);\r\n            }\r\n            for (const root of roots) {\r\n                dest_doc.add_root(root);\r\n            }\r\n            dest_doc.set_title(this._title);\r\n        }\r\n        // TODO other fields of doc\r\n        _push_all_models_freeze() {\r\n            this._all_models_freeze_count += 1;\r\n        }\r\n        _pop_all_models_freeze() {\r\n            this._all_models_freeze_count -= 1;\r\n            if (this._all_models_freeze_count === 0) {\r\n                this._recompute_all_models();\r\n            }\r\n        }\r\n        /*protected*/ _invalidate_all_models() {\r\n            logging_1.logger.debug(\"invalidating document models\");\r\n            // if freeze count is > 0, we'll recompute on unfreeze\r\n            if (this._all_models_freeze_count === 0) {\r\n                this._recompute_all_models();\r\n            }\r\n        }\r\n        _recompute_all_models() {\r\n            let new_all_models_set = new Set();\r\n            for (const r of this._roots) {\r\n                new_all_models_set = sets.union(new_all_models_set, r.references());\r\n            }\r\n            const old_all_models_set = new Set(this._all_models.values());\r\n            const to_detach = sets.difference(old_all_models_set, new_all_models_set);\r\n            const to_attach = sets.difference(new_all_models_set, old_all_models_set);\r\n            const recomputed = new Map();\r\n            for (const model of new_all_models_set) {\r\n                recomputed.set(model.id, model);\r\n            }\r\n            for (const d of to_detach) {\r\n                d.detach_document();\r\n            }\r\n            for (const a of to_attach) {\r\n                a.attach_document(this);\r\n            }\r\n            this._all_models = recomputed;\r\n        }\r\n        roots() {\r\n            return this._roots;\r\n        }\r\n        add_root(model, setter_id) {\r\n            logging_1.logger.debug(`Adding root: ${model}`);\r\n            if (array_1.includes(this._roots, model))\r\n                return;\r\n            this._push_all_models_freeze();\r\n            try {\r\n                this._roots.push(model);\r\n            }\r\n            finally {\r\n                this._pop_all_models_freeze();\r\n            }\r\n            this._trigger_on_change(new events_1.RootAddedEvent(this, model, setter_id));\r\n        }\r\n        remove_root(model, setter_id) {\r\n            const i = this._roots.indexOf(model);\r\n            if (i < 0)\r\n                return;\r\n            this._push_all_models_freeze();\r\n            try {\r\n                this._roots.splice(i, 1);\r\n            }\r\n            finally {\r\n                this._pop_all_models_freeze();\r\n            }\r\n            this._trigger_on_change(new events_1.RootRemovedEvent(this, model, setter_id));\r\n        }\r\n        title() {\r\n            return this._title;\r\n        }\r\n        set_title(title, setter_id) {\r\n            if (title !== this._title) {\r\n                this._title = title;\r\n                this._trigger_on_change(new events_1.TitleChangedEvent(this, title, setter_id));\r\n            }\r\n        }\r\n        get_model_by_id(model_id) {\r\n            var _a;\r\n            return (_a = this._all_models.get(model_id)) !== null && _a !== void 0 ? _a : null;\r\n        }\r\n        get_model_by_name(name) {\r\n            const found = [];\r\n            for (const model of this._all_models.values()) {\r\n                if (model instanceof model_1.Model && model.name == name)\r\n                    found.push(model);\r\n            }\r\n            switch (found.length) {\r\n                case 0:\r\n                    return null;\r\n                case 1:\r\n                    return found[0];\r\n                default:\r\n                    throw new Error(`Multiple models are named '${name}'`);\r\n            }\r\n        }\r\n        on_message(msg_type, callback) {\r\n            const message_callbacks = this._message_callbacks.get(msg_type);\r\n            if (message_callbacks == null)\r\n                this._message_callbacks.set(msg_type, new Set([callback]));\r\n            else\r\n                message_callbacks.add(callback);\r\n        }\r\n        remove_on_message(msg_type, callback) {\r\n            var _a;\r\n            (_a = this._message_callbacks.get(msg_type)) === null || _a === void 0 ? void 0 : _a.delete(callback);\r\n        }\r\n        _trigger_on_message(msg_type, msg_data) {\r\n            const message_callbacks = this._message_callbacks.get(msg_type);\r\n            if (message_callbacks != null) {\r\n                for (const cb of message_callbacks) {\r\n                    cb(msg_data);\r\n                }\r\n            }\r\n        }\r\n        on_change(callback, allow_batches = false) {\r\n            if (!this._callbacks.has(callback)) {\r\n                this._callbacks.set(callback, allow_batches);\r\n            }\r\n        }\r\n        remove_on_change(callback) {\r\n            this._callbacks.delete(callback);\r\n        }\r\n        _trigger_on_change(event) {\r\n            for (const [callback, allow_batches] of this._callbacks) {\r\n                if (!allow_batches && event instanceof events_1.DocumentEventBatch) {\r\n                    for (const ev of event.events) {\r\n                        callback(ev);\r\n                    }\r\n                }\r\n                else {\r\n                    callback(event);\r\n                }\r\n            }\r\n        }\r\n        _notify_change(model, attr, old_value, new_value, options) {\r\n            this._trigger_on_change(new events_1.ModelChangedEvent(this, model, attr, old_value, new_value, options === null || options === void 0 ? void 0 : options.setter_id, options === null || options === void 0 ? void 0 : options.hint));\r\n        }\r\n        static _references_json(references, include_defaults = true) {\r\n            const references_json = [];\r\n            for (const r of references) {\r\n                const struct = r.struct();\r\n                struct.attributes = r.attributes_as_json(include_defaults);\r\n                // server doesn't want id in here since it's already in ref above\r\n                delete struct.attributes.id;\r\n                references_json.push(struct);\r\n            }\r\n            return references_json;\r\n        }\r\n        static _instantiate_object(obj_id, obj_type, obj_attrs) {\r\n            const full_attrs = Object.assign(Object.assign({}, obj_attrs), { id: obj_id, __deferred__: true });\r\n            const model = base_1.Models(obj_type);\r\n            return new model(full_attrs);\r\n        }\r\n        // given a JSON representation of all models in a graph, return a\r\n        // dict of new model objects\r\n        static _instantiate_references_json(references_json, existing_models) {\r\n            // Create all instances, but without setting their props\r\n            const references = new Map();\r\n            for (const obj of references_json) {\r\n                const obj_id = obj.id;\r\n                const obj_type = obj.type;\r\n                const obj_attrs = obj.attributes || {};\r\n                let instance = existing_models.get(obj_id);\r\n                if (instance == null) {\r\n                    instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);\r\n                    if (obj.subtype != null)\r\n                        instance.set_subtype(obj.subtype);\r\n                }\r\n                references.set(instance.id, instance);\r\n            }\r\n            return references;\r\n        }\r\n        // if v looks like a ref, or a collection, resolve it, otherwise return it unchanged\r\n        // recurse into collections but not into HasProps\r\n        static _resolve_refs(value, old_references, new_references, buffers) {\r\n            function resolve_ref(v) {\r\n                if (refs_1.is_ref(v)) {\r\n                    if (old_references.has(v.id))\r\n                        return old_references.get(v.id);\r\n                    else if (new_references.has(v.id))\r\n                        return new_references.get(v.id);\r\n                    else\r\n                        throw new Error(`reference ${JSON.stringify(v)} isn't known (not in Document?)`);\r\n                }\r\n                else if (serialization_1.is_NDArray_ref(v)) {\r\n                    return serialization_1.decode_NDArray(v, buffers);\r\n                }\r\n                else if (types_1.isArray(v))\r\n                    return resolve_array(v);\r\n                else if (types_1.isPlainObject(v))\r\n                    return resolve_dict(v);\r\n                else\r\n                    return v;\r\n            }\r\n            function resolve_array(array) {\r\n                const results = [];\r\n                for (const v of array) {\r\n                    results.push(resolve_ref(v));\r\n                }\r\n                return results;\r\n            }\r\n            function resolve_dict(dict) {\r\n                const resolved = {};\r\n                for (const [k, v] of object_1.entries(dict)) {\r\n                    resolved[k] = resolve_ref(v);\r\n                }\r\n                return resolved;\r\n            }\r\n            return resolve_ref(value);\r\n        }\r\n        // given a JSON representation of all models in a graph and new\r\n        // model instances, set the properties on the models from the\r\n        // JSON\r\n        static _initialize_references_json(references_json, old_references, new_references, buffers) {\r\n            const to_update = new Map();\r\n            for (const { id, attributes } of references_json) {\r\n                const is_new = !old_references.has(id);\r\n                const instance = is_new ? new_references.get(id) : old_references.get(id);\r\n                // replace references with actual instances in obj_attrs\r\n                const resolved_attrs = Document._resolve_refs(attributes, old_references, new_references, buffers);\r\n                instance.setv(resolved_attrs, { silent: true });\r\n                to_update.set(id, { instance, is_new });\r\n            }\r\n            const ordered_instances = [];\r\n            const handled = new Set();\r\n            function finalize_all_by_dfs(v) {\r\n                if (v instanceof has_props_1.HasProps) {\r\n                    // note that we ignore instances that aren't updated (not in to_update)\r\n                    if (to_update.has(v.id) && !handled.has(v.id)) {\r\n                        handled.add(v.id);\r\n                        const { instance, is_new } = to_update.get(v.id);\r\n                        const { attributes } = instance;\r\n                        for (const value of object_1.values(attributes)) {\r\n                            finalize_all_by_dfs(value);\r\n                        }\r\n                        if (is_new) {\r\n                            // Finalizing here just to avoid iterating\r\n                            // over `ordered_instances` twice.\r\n                            instance.finalize();\r\n                            // Preserving an ordered collection of instances\r\n                            // to avoid having to go through DFS again.\r\n                            ordered_instances.push(instance);\r\n                        }\r\n                    }\r\n                }\r\n                else if (types_1.isArray(v)) {\r\n                    for (const e of v)\r\n                        finalize_all_by_dfs(e);\r\n                }\r\n                else if (types_1.isPlainObject(v)) {\r\n                    for (const value of object_1.values(v))\r\n                        finalize_all_by_dfs(value);\r\n                }\r\n            }\r\n            for (const item of to_update.values()) {\r\n                finalize_all_by_dfs(item.instance);\r\n            }\r\n            // `connect_signals` has to be executed last because it\r\n            // may rely on properties of dependencies that are initialized\r\n            // only in `finalize`. It's a problem that appears when\r\n            // there are circular references, e.g. as in\r\n            // CDS -> CustomJS (on data change) -> GlyphRenderer (in args) -> CDS.\r\n            for (const instance of ordered_instances) {\r\n                instance.connect_signals();\r\n            }\r\n        }\r\n        static _event_for_attribute_change(changed_obj, key, new_value, doc, value_refs) {\r\n            const changed_model = doc.get_model_by_id(changed_obj.id); // XXX!\r\n            if (!changed_model.property(key).syncable)\r\n                return null;\r\n            else {\r\n                const event = {\r\n                    kind: \"ModelChanged\",\r\n                    model: { id: changed_obj.id },\r\n                    attr: key,\r\n                    new: new_value,\r\n                };\r\n                has_props_1.HasProps._json_record_references(doc, new_value, value_refs, { recursive: true });\r\n                return event;\r\n            }\r\n        }\r\n        static _events_to_sync_objects(from_obj, to_obj, to_doc, value_refs) {\r\n            const from_keys = Object.keys(from_obj.attributes); //XXX!\r\n            const to_keys = Object.keys(to_obj.attributes); //XXX!\r\n            const removed = array_1.difference(from_keys, to_keys);\r\n            const added = array_1.difference(to_keys, from_keys);\r\n            const shared = array_1.intersection(from_keys, to_keys);\r\n            const events = [];\r\n            for (const key of removed) {\r\n                // we don't really have a \"remove\" event - not sure this ever\r\n                // happens even. One way this could happen is if the server\r\n                // does include_defaults=True and we do\r\n                // include_defaults=false ... in that case it'd be best to\r\n                // just ignore this probably. Warn about it, could mean\r\n                // there's a bug if we don't have a key that the server sent.\r\n                logging_1.logger.warn(`Server sent key ${key} but we don't seem to have it in our JSON`);\r\n            }\r\n            for (const key of added) {\r\n                const new_value = to_obj.attributes[key]; // XXX!\r\n                events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\r\n            }\r\n            for (const key of shared) {\r\n                const old_value = from_obj.attributes[key]; // XXX!\r\n                const new_value = to_obj.attributes[key]; // XXX!\r\n                if (old_value == null && new_value == null) {\r\n                }\r\n                else if (old_value == null || new_value == null) {\r\n                    events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\r\n                }\r\n                else {\r\n                    if (!eq_1.isEqual(old_value, new_value))\r\n                        events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\r\n                }\r\n            }\r\n            return events.filter((e) => e != null);\r\n        }\r\n        // we use this to detect changes during document deserialization\r\n        // (in model constructors and initializers)\r\n        static _compute_patch_since_json(from_json, to_doc) {\r\n            const to_json = to_doc.to_json(false); // include_defaults=false\r\n            function refs(json) {\r\n                const result = new Map();\r\n                for (const obj of json.roots.references)\r\n                    result.set(obj.id, obj);\r\n                return result;\r\n            }\r\n            const from_references = refs(from_json);\r\n            const from_roots = new Map();\r\n            const from_root_ids = [];\r\n            for (const r of from_json.roots.root_ids) {\r\n                from_roots.set(r, from_references.get(r));\r\n                from_root_ids.push(r);\r\n            }\r\n            const to_references = refs(to_json);\r\n            const to_roots = new Map();\r\n            const to_root_ids = [];\r\n            for (const r of to_json.roots.root_ids) {\r\n                to_roots.set(r, to_references.get(r));\r\n                to_root_ids.push(r);\r\n            }\r\n            from_root_ids.sort();\r\n            to_root_ids.sort();\r\n            if (array_1.difference(from_root_ids, to_root_ids).length > 0 ||\r\n                array_1.difference(to_root_ids, from_root_ids).length > 0) {\r\n                // this would arise if someone does add_root/remove_root during\r\n                // document deserialization, hopefully they won't ever do so.\r\n                throw new Error(\"Not implemented: computing add/remove of document roots\");\r\n            }\r\n            const value_refs = new Set();\r\n            let events = [];\r\n            for (const id of to_doc._all_models.keys()) {\r\n                if (from_references.has(id)) {\r\n                    const update_model_events = Document._events_to_sync_objects(from_references.get(id), to_references.get(id), to_doc, value_refs);\r\n                    events = events.concat(update_model_events);\r\n                }\r\n            }\r\n            return {\r\n                references: Document._references_json(value_refs, false),\r\n                events,\r\n            };\r\n        }\r\n        to_json_string(include_defaults = true) {\r\n            return JSON.stringify(this.to_json(include_defaults));\r\n        }\r\n        to_json(include_defaults = true) {\r\n            const root_ids = this._roots.map((r) => r.id);\r\n            const root_references = this._all_models.values();\r\n            return {\r\n                version: version_1.version,\r\n                title: this._title,\r\n                roots: {\r\n                    root_ids,\r\n                    references: Document._references_json(root_references, include_defaults),\r\n                },\r\n            };\r\n        }\r\n        static from_json_string(s) {\r\n            const json = JSON.parse(s);\r\n            return Document.from_json(json);\r\n        }\r\n        static from_json(json) {\r\n            logging_1.logger.debug(\"Creating Document from JSON\");\r\n            function pyify(version) {\r\n                return version.replace(/-(dev|rc)\\./, \"$1\");\r\n            }\r\n            const py_version = json.version; // XXX!\r\n            const is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;\r\n            const versions_string = `Library versions: JS (${version_1.version}) / Python (${py_version})`;\r\n            if (!is_dev && pyify(version_1.version) != py_version) {\r\n                logging_1.logger.warn(\"JS/Python version mismatch\");\r\n                logging_1.logger.warn(versions_string);\r\n            }\r\n            else\r\n                logging_1.logger.debug(versions_string);\r\n            const roots_json = json.roots;\r\n            const root_ids = roots_json.root_ids;\r\n            const references_json = roots_json.references;\r\n            const references = Document._instantiate_references_json(references_json, new Map());\r\n            Document._initialize_references_json(references_json, new Map(), references, new Map());\r\n            const doc = new Document();\r\n            for (const id of root_ids) {\r\n                const root = references.get(id);\r\n                if (root != null) {\r\n                    doc.add_root(root); // XXX: HasProps\r\n                }\r\n            }\r\n            doc.set_title(json.title); // XXX!\r\n            return doc;\r\n        }\r\n        replace_with_json(json) {\r\n            const replacement = Document.from_json(json);\r\n            replacement.destructively_move(this);\r\n        }\r\n        create_json_patch_string(events) {\r\n            return JSON.stringify(this.create_json_patch(events));\r\n        }\r\n        create_json_patch(events) {\r\n            const references = new Set();\r\n            const json_events = [];\r\n            for (const event of events) {\r\n                if (event.document !== this) {\r\n                    logging_1.logger.warn(\"Cannot create a patch using events from a different document, event had \", event.document, \" we are \", this);\r\n                    throw new Error(\"Cannot create a patch using events from a different document\");\r\n                }\r\n                json_events.push(event.json(references));\r\n            }\r\n            return {\r\n                events: json_events,\r\n                references: Document._references_json(references),\r\n            };\r\n        }\r\n        apply_json_patch(patch, buffers = new Map(), setter_id) {\r\n            const references_json = patch.references;\r\n            const events_json = patch.events;\r\n            const references = Document._instantiate_references_json(references_json, this._all_models);\r\n            if (!(buffers instanceof Map)) {\r\n                buffers = new Map(buffers);\r\n            }\r\n            // The model being changed isn't always in references so add it in\r\n            for (const event_json of events_json) {\r\n                switch (event_json.kind) {\r\n                    case \"RootAdded\":\r\n                    case \"RootRemoved\":\r\n                    case \"ModelChanged\": {\r\n                        const model_id = event_json.model.id;\r\n                        const model = this._all_models.get(model_id);\r\n                        if (model != null) {\r\n                            references.set(model_id, model);\r\n                        }\r\n                        else if (!references.has(model_id)) {\r\n                            logging_1.logger.warn(`Got an event for unknown model ${event_json.model}\"`);\r\n                            throw new Error(\"event model wasn't known\");\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // split references into old and new so we know whether to initialize or update\r\n            const old_references = new Map();\r\n            const new_references = new Map();\r\n            for (const [id, value] of references) {\r\n                if (this._all_models.has(id))\r\n                    old_references.set(id, value);\r\n                else\r\n                    new_references.set(id, value);\r\n            }\r\n            Document._initialize_references_json(references_json, old_references, new_references, buffers);\r\n            for (const event_json of events_json) {\r\n                switch (event_json.kind) {\r\n                    case 'MessageSent': {\r\n                        const { msg_type, msg_data } = event_json;\r\n                        let data;\r\n                        if (msg_data === undefined) {\r\n                            if (buffers.size == 1) {\r\n                                const [[, buffer]] = buffers;\r\n                                data = buffer;\r\n                            }\r\n                            else {\r\n                                throw new Error(\"expected exactly one buffer\");\r\n                            }\r\n                        }\r\n                        else {\r\n                            data = Document._resolve_refs(msg_data, old_references, new_references, buffers);\r\n                        }\r\n                        this._trigger_on_message(msg_type, data);\r\n                        break;\r\n                    }\r\n                    case 'ModelChanged': {\r\n                        const patched_id = event_json.model.id;\r\n                        const patched_obj = this._all_models.get(patched_id);\r\n                        if (patched_obj == null) {\r\n                            throw new Error(`Cannot apply patch to ${patched_id} which is not in the document`);\r\n                        }\r\n                        const attr = event_json.attr;\r\n                        const value = Document._resolve_refs(event_json.new, old_references, new_references, buffers);\r\n                        patched_obj.setv({ [attr]: value }, { setter_id });\r\n                        break;\r\n                    }\r\n                    case 'ColumnDataChanged': {\r\n                        const column_source_id = event_json.column_source.id;\r\n                        const column_source = this._all_models.get(column_source_id);\r\n                        if (column_source == null) {\r\n                            throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\r\n                        }\r\n                        const data = Document._resolve_refs(event_json.new, new Map(), new Map(), buffers);\r\n                        if (event_json.cols != null) {\r\n                            for (const k in column_source.data) {\r\n                                if (!(k in data)) {\r\n                                    data[k] = column_source.data[k];\r\n                                }\r\n                            }\r\n                        }\r\n                        column_source.setv({ data }, { setter_id, check_eq: false });\r\n                        break;\r\n                    }\r\n                    case 'ColumnsStreamed': {\r\n                        const column_source_id = event_json.column_source.id;\r\n                        const column_source = this._all_models.get(column_source_id);\r\n                        if (column_source == null) {\r\n                            throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\r\n                        }\r\n                        if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\r\n                            throw new Error(\"Cannot stream to non-ColumnDataSource\");\r\n                        }\r\n                        const data = event_json.data;\r\n                        const rollover = event_json.rollover;\r\n                        column_source.stream(data, rollover, setter_id);\r\n                        break;\r\n                    }\r\n                    case 'ColumnsPatched': {\r\n                        const column_source_id = event_json.column_source.id;\r\n                        const column_source = this._all_models.get(column_source_id);\r\n                        if (column_source == null) {\r\n                            throw new Error(`Cannot patch ${column_source_id} which is not in the document`);\r\n                        }\r\n                        if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\r\n                            throw new Error(\"Cannot patch non-ColumnDataSource\");\r\n                        }\r\n                        const patches = event_json.patches;\r\n                        column_source.patch(patches, setter_id);\r\n                        break;\r\n                    }\r\n                    case 'RootAdded': {\r\n                        const root_id = event_json.model.id;\r\n                        const root_obj = references.get(root_id);\r\n                        this.add_root(root_obj, setter_id); // XXX: HasProps\r\n                        break;\r\n                    }\r\n                    case 'RootRemoved': {\r\n                        const root_id = event_json.model.id;\r\n                        const root_obj = references.get(root_id);\r\n                        this.remove_root(root_obj, setter_id); // XXX: HasProps\r\n                        break;\r\n                    }\r\n                    case 'TitleChanged': {\r\n                        this.set_title(event_json.title, setter_id);\r\n                        break;\r\n                    }\r\n                    default:\r\n                        throw new Error(\"Unknown patch event \" + JSON.stringify(event_json));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.Document = Document;\r\n    Document.__name__ = \"Document\";\r\n}\r\n","/* base.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const types_1 = require(8) /* ./core/util/types */;\r\n    const object_1 = require(13) /* ./core/util/object */;\r\n    const has_props_1 = require(14) /* ./core/has_props */;\r\n    exports.overrides = {};\r\n    const _all_models = new Map();\r\n    exports.Models = ((name) => {\r\n        const model = exports.overrides[name] || _all_models.get(name);\r\n        if (model == null) {\r\n            throw new Error(`Model '${name}' does not exist. This could be due to a widget or a custom model not being registered before first usage.`);\r\n        }\r\n        return model;\r\n    });\r\n    exports.Models.register = (name, model) => {\r\n        exports.overrides[name] = model;\r\n    };\r\n    exports.Models.unregister = (name) => {\r\n        delete exports.overrides[name];\r\n    };\r\n    function is_HasProps(obj) {\r\n        return types_1.isObject(obj) && obj.prototype instanceof has_props_1.HasProps;\r\n    }\r\n    exports.Models.register_models = (models, force = false, errorFn) => {\r\n        if (models == null)\r\n            return;\r\n        for (const model of object_1.values(models)) {\r\n            if (is_HasProps(model)) {\r\n                const qualified = model.__qualified__;\r\n                if (force || !_all_models.has(qualified))\r\n                    _all_models.set(qualified, model);\r\n                else if (errorFn != null)\r\n                    errorFn(qualified);\r\n                else\r\n                    console.warn(`Model '${qualified}' was already registered`);\r\n            }\r\n        }\r\n    };\r\n    exports.register_models = exports.Models.register_models;\r\n    exports.Models.registered_names = () => Array.from(_all_models.keys());\r\n    // TODO: this doesn't belong here, but it's easier this way for backwards compatibility\r\n    const AllModels = tslib_1.__importStar(require(34) /* ./models */);\r\n    exports.register_models(AllModels);\r\n}\r\n","/* core\\util\\types.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    //     Underscore.js 1.8.3\r\n    //     http://underscorejs.org\r\n    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n    //     Underscore may be freely distributed under the MIT license.\r\n    const array_1 = require(9) /* ./array */;\r\n    const toString = Object.prototype.toString;\r\n    function isBoolean(obj) {\r\n        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\r\n    }\r\n    exports.isBoolean = isBoolean;\r\n    function isNumber(obj) {\r\n        return toString.call(obj) === \"[object Number]\";\r\n    }\r\n    exports.isNumber = isNumber;\r\n    function isInteger(obj) {\r\n        return isNumber(obj) && Number.isInteger(obj);\r\n    }\r\n    exports.isInteger = isInteger;\r\n    function isString(obj) {\r\n        return toString.call(obj) === \"[object String]\";\r\n    }\r\n    exports.isString = isString;\r\n    function isFunction(obj) {\r\n        return toString.call(obj) === \"[object Function]\";\r\n    }\r\n    exports.isFunction = isFunction;\r\n    function isArray(obj) {\r\n        return Array.isArray(obj);\r\n    }\r\n    exports.isArray = isArray;\r\n    function isArrayOf(arr, predicate) {\r\n        return array_1.every(arr, predicate);\r\n    }\r\n    exports.isArrayOf = isArrayOf;\r\n    function isArrayableOf(arr, predicate) {\r\n        for (let i = 0, end = arr.length; i < end; i++) {\r\n            if (!predicate(arr[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    exports.isArrayableOf = isArrayableOf;\r\n    function isTypedArray(obj) {\r\n        return ArrayBuffer.isView(obj) && !(obj instanceof DataView);\r\n    }\r\n    exports.isTypedArray = isTypedArray;\r\n    function isObject(obj) {\r\n        const tp = typeof obj;\r\n        return tp === 'function' || tp === 'object' && !!obj;\r\n    }\r\n    exports.isObject = isObject;\r\n    function isPlainObject(obj) {\r\n        return isObject(obj) && (obj.constructor == null || obj.constructor === Object);\r\n    }\r\n    exports.isPlainObject = isPlainObject;\r\n    function isIterable(obj) {\r\n        return Symbol.iterator in Object(obj);\r\n    }\r\n    exports.isIterable = isIterable;\r\n}\r\n","/* core\\util\\array.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    //     Underscore.js 1.8.3\r\n    //     http://underscorejs.org\r\n    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n    //     Underscore may be freely distributed under the MIT license.\r\n    const math_1 = require(10) /* ./math */;\r\n    const assert_1 = require(11) /* ./assert */;\r\n    const arrayable_1 = require(12) /* ./arrayable */;\r\n    exports.map = arrayable_1.map;\r\n    exports.reduce = arrayable_1.reduce;\r\n    exports.min = arrayable_1.min;\r\n    exports.min_by = arrayable_1.min_by;\r\n    exports.max = arrayable_1.max;\r\n    exports.max_by = arrayable_1.max_by;\r\n    exports.sum = arrayable_1.sum;\r\n    exports.cumsum = arrayable_1.cumsum;\r\n    exports.every = arrayable_1.every;\r\n    exports.some = arrayable_1.some;\r\n    exports.find = arrayable_1.find;\r\n    exports.find_last = arrayable_1.find_last;\r\n    exports.find_index = arrayable_1.find_index;\r\n    exports.find_last_index = arrayable_1.find_last_index;\r\n    exports.sorted_index = arrayable_1.sorted_index;\r\n    exports.is_empty = arrayable_1.is_empty;\r\n    const slice = Array.prototype.slice;\r\n    function head(array) {\r\n        return array[0];\r\n    }\r\n    exports.head = head;\r\n    function tail(array) {\r\n        return array[array.length - 1];\r\n    }\r\n    exports.tail = tail;\r\n    function last(array) {\r\n        return array[array.length - 1];\r\n    }\r\n    exports.last = last;\r\n    function copy(array) {\r\n        return slice.call(array);\r\n    }\r\n    exports.copy = copy;\r\n    function concat(arrays) {\r\n        return [].concat(...arrays);\r\n    }\r\n    exports.concat = concat;\r\n    function includes(array, value) {\r\n        return array.indexOf(value) !== -1;\r\n    }\r\n    exports.includes = includes;\r\n    exports.contains = includes;\r\n    function nth(array, index) {\r\n        return array[index >= 0 ? index : array.length + index];\r\n    }\r\n    exports.nth = nth;\r\n    function zip(...arrays) {\r\n        if (arrays.length == 0)\r\n            return [];\r\n        const n = arrayable_1.min(arrays.map((a) => a.length));\r\n        const k = arrays.length;\r\n        const result = new Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            result[i] = new Array(k);\r\n            for (let j = 0; j < k; j++)\r\n                result[i][j] = arrays[j][i];\r\n        }\r\n        return result;\r\n    }\r\n    exports.zip = zip;\r\n    function unzip(array) {\r\n        const n = array.length;\r\n        const k = arrayable_1.min(array.map((a) => a.length));\r\n        const results = Array(k);\r\n        for (let j = 0; j < k; j++)\r\n            results[j] = new Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = 0; j < k; j++)\r\n                results[j][i] = array[i][j];\r\n        }\r\n        return results;\r\n    }\r\n    exports.unzip = unzip;\r\n    function range(start, stop, step = 1) {\r\n        assert_1.assert(step > 0, \"'step' must be a positive number\");\r\n        if (stop == null) {\r\n            stop = start;\r\n            start = 0;\r\n        }\r\n        const { max, ceil, abs } = Math;\r\n        const delta = start <= stop ? step : -step;\r\n        const length = max(ceil(abs(stop - start) / step), 0);\r\n        const range = new Array(length);\r\n        for (let i = 0; i < length; i++, start += delta) {\r\n            range[i] = start;\r\n        }\r\n        return range;\r\n    }\r\n    exports.range = range;\r\n    function linspace(start, stop, num = 100) {\r\n        const step = (stop - start) / (num - 1);\r\n        const array = new Array(num);\r\n        for (let i = 0; i < num; i++) {\r\n            array[i] = start + step * i;\r\n        }\r\n        return array;\r\n    }\r\n    exports.linspace = linspace;\r\n    function transpose(array) {\r\n        const rows = array.length;\r\n        const cols = array[0].length;\r\n        const transposed = [];\r\n        for (let j = 0; j < cols; j++) {\r\n            transposed[j] = [];\r\n            for (let i = 0; i < rows; i++) {\r\n                transposed[j][i] = array[i][j];\r\n            }\r\n        }\r\n        return transposed;\r\n    }\r\n    exports.transpose = transpose;\r\n    function argmin(array) {\r\n        return arrayable_1.min_by(range(array.length), (i) => array[i]);\r\n    }\r\n    exports.argmin = argmin;\r\n    function argmax(array) {\r\n        return arrayable_1.max_by(range(array.length), (i) => array[i]);\r\n    }\r\n    exports.argmax = argmax;\r\n    function sort_by(array, key) {\r\n        const tmp = array.map((value, index) => {\r\n            return { value, index, key: key(value) };\r\n        });\r\n        tmp.sort((left, right) => {\r\n            const a = left.key;\r\n            const b = right.key;\r\n            if (a !== b) {\r\n                if (a > b || a === undefined)\r\n                    return 1;\r\n                if (a < b || b === undefined)\r\n                    return -1;\r\n            }\r\n            return left.index - right.index;\r\n        });\r\n        return tmp.map((item) => item.value);\r\n    }\r\n    exports.sort_by = sort_by;\r\n    function uniq(array) {\r\n        const result = new Set();\r\n        for (const value of array) {\r\n            result.add(value);\r\n        }\r\n        return [...result];\r\n    }\r\n    exports.uniq = uniq;\r\n    function uniq_by(array, key) {\r\n        const result = [];\r\n        const seen = [];\r\n        for (const value of array) {\r\n            const computed = key(value);\r\n            if (!includes(seen, computed)) {\r\n                seen.push(computed);\r\n                result.push(value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    exports.uniq_by = uniq_by;\r\n    function union(...arrays) {\r\n        const result = new Set();\r\n        for (const array of arrays) {\r\n            for (const value of array) {\r\n                result.add(value);\r\n            }\r\n        }\r\n        return [...result];\r\n    }\r\n    exports.union = union;\r\n    function intersection(array, ...arrays) {\r\n        const result = [];\r\n        top: for (const item of array) {\r\n            if (includes(result, item))\r\n                continue;\r\n            for (const other of arrays) {\r\n                if (!includes(other, item))\r\n                    continue top;\r\n            }\r\n            result.push(item);\r\n        }\r\n        return result;\r\n    }\r\n    exports.intersection = intersection;\r\n    function difference(array, ...arrays) {\r\n        const rest = concat(arrays);\r\n        return array.filter((value) => !includes(rest, value));\r\n    }\r\n    exports.difference = difference;\r\n    function remove_at(array, i) {\r\n        const result = copy(array);\r\n        result.splice(i, 1);\r\n        return result;\r\n    }\r\n    exports.remove_at = remove_at;\r\n    function remove_by(array, key) {\r\n        for (let i = 0; i < array.length;) {\r\n            if (key(array[i]))\r\n                array.splice(i, 1);\r\n            else\r\n                i++;\r\n        }\r\n    }\r\n    exports.remove_by = remove_by;\r\n    // Shuffle a collection, using the modern version of the\r\n    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\r\n    function shuffle(array) {\r\n        const length = array.length;\r\n        const shuffled = new Array(length);\r\n        for (let i = 0; i < length; i++) {\r\n            const rand = math_1.randomIn(0, i);\r\n            if (rand !== i)\r\n                shuffled[i] = shuffled[rand];\r\n            shuffled[rand] = array[i];\r\n        }\r\n        return shuffled;\r\n    }\r\n    exports.shuffle = shuffle;\r\n    function pairwise(array, fn) {\r\n        const n = array.length;\r\n        const result = new Array(n - 1);\r\n        for (let i = 0; i < n - 1; i++) {\r\n            result[i] = fn(array[i], array[i + 1]);\r\n        }\r\n        return result;\r\n    }\r\n    exports.pairwise = pairwise;\r\n    function reversed(array) {\r\n        const n = array.length;\r\n        const result = new Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            result[n - i - 1] = array[i];\r\n        }\r\n        return result;\r\n    }\r\n    exports.reversed = reversed;\r\n    function repeat(value, n) {\r\n        const result = new Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            result[i] = value;\r\n        }\r\n        return result;\r\n    }\r\n    exports.repeat = repeat;\r\n}\r\n","/* core\\util\\math.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function angle_norm(angle) {\r\n        if (angle == 0) {\r\n            return 0;\r\n        }\r\n        while (angle <= 0) {\r\n            angle += 2 * Math.PI;\r\n        }\r\n        while (angle > 2 * Math.PI) {\r\n            angle -= 2 * Math.PI;\r\n        }\r\n        return angle;\r\n    }\r\n    exports.angle_norm = angle_norm;\r\n    function angle_dist(lhs, rhs) {\r\n        return angle_norm(lhs - rhs);\r\n    }\r\n    exports.angle_dist = angle_dist;\r\n    function angle_between(mid, lhs, rhs, direction) {\r\n        const d = angle_dist(lhs, rhs);\r\n        if (d == 0)\r\n            return false;\r\n        if (d == 2 * Math.PI)\r\n            return true;\r\n        const norm_mid = angle_norm(mid);\r\n        const cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;\r\n        return (direction == 0 /* clock */) ? cond : !cond;\r\n    }\r\n    exports.angle_between = angle_between;\r\n    function random() {\r\n        return Math.random();\r\n    }\r\n    exports.random = random;\r\n    function randomIn(min, max) {\r\n        if (max == null) {\r\n            max = min;\r\n            min = 0;\r\n        }\r\n        return min + Math.floor(Math.random() * (max - min + 1));\r\n    }\r\n    exports.randomIn = randomIn;\r\n    function atan2(start, end) {\r\n        /*\r\n         * Calculate the angle between a line containing start and end points (composed\r\n         * of [x, y] arrays) and the positive x-axis.\r\n         */\r\n        return Math.atan2(end[1] - start[1], end[0] - start[0]);\r\n    }\r\n    exports.atan2 = atan2;\r\n    function radians(degrees) {\r\n        return degrees * (Math.PI / 180);\r\n    }\r\n    exports.radians = radians;\r\n    function degrees(radians) {\r\n        return radians / (Math.PI / 180);\r\n    }\r\n    exports.degrees = degrees;\r\n    // http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)\r\n    function rnorm(mu, sigma) {\r\n        // Generate a random normal with a mean of 0 and a sigma of 1\r\n        let r1;\r\n        let r2;\r\n        while (true) {\r\n            r1 = random();\r\n            r2 = random();\r\n            r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));\r\n            if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2)\r\n                break;\r\n        }\r\n        let rn = r2 / r1;\r\n        // Transform the standard normal to meet the characteristics that we want (mu, sigma)\r\n        rn = mu + sigma * rn;\r\n        return rn;\r\n    }\r\n    exports.rnorm = rnorm;\r\n    function clamp(val, min, max) {\r\n        if (val < min)\r\n            return min;\r\n        if (val > max)\r\n            return max;\r\n        return val;\r\n    }\r\n    exports.clamp = clamp;\r\n}\r\n","/* core\\util\\assert.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class AssertionError extends Error {\r\n    }\r\n    exports.AssertionError = AssertionError;\r\n    AssertionError.__name__ = \"AssertionError\";\r\n    function assert(condition, message) {\r\n        if (condition === true || (condition !== false && condition()))\r\n            return;\r\n        throw new AssertionError(message !== null && message !== void 0 ? message : \"Assertion failed\");\r\n    }\r\n    exports.assert = assert;\r\n    function unreachable() {\r\n        throw new Error(\"unreachable code\");\r\n    }\r\n    exports.unreachable = unreachable;\r\n}\r\n","/* core\\util\\arrayable.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(8) /* ./types */;\r\n    const math_1 = require(10) /* ./math */;\r\n    function is_empty(array) {\r\n        return array.length == 0;\r\n    }\r\n    exports.is_empty = is_empty;\r\n    function copy(array) {\r\n        if (types_1.isArray(array))\r\n            return array.slice();\r\n        else\r\n            return new array.constructor(array);\r\n    }\r\n    exports.copy = copy;\r\n    function splice(array, start, k, ...items) {\r\n        const len = array.length;\r\n        if (start < 0)\r\n            start += len;\r\n        if (start < 0)\r\n            start = 0;\r\n        else if (start > len)\r\n            start = len;\r\n        if (k == null || k > len - start)\r\n            k = len - start;\r\n        else if (k < 0)\r\n            k = 0;\r\n        const n = len - k + items.length;\r\n        const result = new array.constructor(n);\r\n        let i = 0;\r\n        for (; i < start; i++) {\r\n            result[i] = array[i];\r\n        }\r\n        for (const item of items) {\r\n            result[i++] = item;\r\n        }\r\n        for (let j = start + k; j < len; j++) {\r\n            result[i++] = array[j];\r\n        }\r\n        return result;\r\n    }\r\n    exports.splice = splice;\r\n    function head(array, n) {\r\n        return splice(array, n, array.length - n);\r\n    }\r\n    exports.head = head;\r\n    function insert(array, item, i) {\r\n        return splice(array, i, 0, item);\r\n    }\r\n    exports.insert = insert;\r\n    function append(array, item) {\r\n        return splice(array, array.length, 0, item);\r\n    }\r\n    exports.append = append;\r\n    function prepend(array, item) {\r\n        return splice(array, 0, 0, item);\r\n    }\r\n    exports.prepend = prepend;\r\n    function indexOf(array, item) {\r\n        for (let i = 0, n = array.length; i < n; i++) {\r\n            if (array[i] === item)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n    exports.indexOf = indexOf;\r\n    function subselect(array, indices) {\r\n        const n = indices.length;\r\n        const result = new array.constructor(n);\r\n        for (let i = 0; i < n; i++) {\r\n            result[i] = array[indices[i]];\r\n        }\r\n        return result;\r\n    }\r\n    exports.subselect = subselect;\r\n    function map(array, fn) {\r\n        const n = array.length;\r\n        const result = new array.constructor(n);\r\n        for (let i = 0; i < n; i++) {\r\n            result[i] = fn(array[i], i, array);\r\n        }\r\n        return result;\r\n    }\r\n    exports.map = map;\r\n    function filter(array, pred) {\r\n        const n = array.length;\r\n        const result = new array.constructor(n);\r\n        let k = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            const value = array[i];\r\n            if (pred(value, i, array))\r\n                result[k++] = value;\r\n        }\r\n        return head(result, k);\r\n    }\r\n    exports.filter = filter;\r\n    function reduce(array, fn, initial) {\r\n        const n = array.length;\r\n        if (initial === undefined && n == 0)\r\n            throw new Error(\"can't reduce an empty array without an initial value\");\r\n        let value;\r\n        let i;\r\n        if (initial === undefined) {\r\n            value = array[0];\r\n            i = 1;\r\n        }\r\n        else {\r\n            value = initial;\r\n            i = 0;\r\n        }\r\n        for (; i < n; i++) {\r\n            value = fn(value, array[i], i, array);\r\n        }\r\n        return value;\r\n    }\r\n    exports.reduce = reduce;\r\n    function min(array) {\r\n        let value;\r\n        let result = Infinity;\r\n        for (let i = 0, length = array.length; i < length; i++) {\r\n            value = array[i];\r\n            if (!isNaN(value) && value < result) {\r\n                result = value;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    exports.min = min;\r\n    function max(array) {\r\n        let value;\r\n        let result = -Infinity;\r\n        for (let i = 0, length = array.length; i < length; i++) {\r\n            value = array[i];\r\n            if (!isNaN(value) && value > result) {\r\n                result = value;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    exports.max = max;\r\n    function minmax(array) {\r\n        let value;\r\n        let min = +Infinity;\r\n        let max = -Infinity;\r\n        for (let i = 0, length = array.length; i < length; i++) {\r\n            value = array[i];\r\n            if (!isNaN(value)) {\r\n                if (value < min) {\r\n                    min = value;\r\n                }\r\n                if (value > max) {\r\n                    max = value;\r\n                }\r\n            }\r\n        }\r\n        return [min, max];\r\n    }\r\n    exports.minmax = minmax;\r\n    function min_by(array, key) {\r\n        if (array.length == 0)\r\n            throw new Error(\"min_by() called with an empty array\");\r\n        let result = array[0];\r\n        let resultComputed = key(result);\r\n        for (let i = 1, length = array.length; i < length; i++) {\r\n            const value = array[i];\r\n            const computed = key(value);\r\n            if (computed < resultComputed) {\r\n                result = value;\r\n                resultComputed = computed;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    exports.min_by = min_by;\r\n    function max_by(array, key) {\r\n        if (array.length == 0)\r\n            throw new Error(\"max_by() called with an empty array\");\r\n        let result = array[0];\r\n        let resultComputed = key(result);\r\n        for (let i = 1, length = array.length; i < length; i++) {\r\n            const value = array[i];\r\n            const computed = key(value);\r\n            if (computed > resultComputed) {\r\n                result = value;\r\n                resultComputed = computed;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    exports.max_by = max_by;\r\n    function sum(array) {\r\n        let result = 0;\r\n        for (let i = 0, n = array.length; i < n; i++) {\r\n            result += array[i];\r\n        }\r\n        return result;\r\n    }\r\n    exports.sum = sum;\r\n    function cumsum(array) {\r\n        const result = new array.constructor(array.length);\r\n        reduce(array, (a, b, i) => result[i] = a + b, 0);\r\n        return result;\r\n    }\r\n    exports.cumsum = cumsum;\r\n    function every(array, predicate) {\r\n        for (let i = 0, length = array.length; i < length; i++) {\r\n            if (!predicate(array[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    exports.every = every;\r\n    function some(array, predicate) {\r\n        for (let i = 0, length = array.length; i < length; i++) {\r\n            if (predicate(array[i]))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    exports.some = some;\r\n    function index_of(array, value) {\r\n        for (let i = 0, length = array.length; i < length; i++) {\r\n            if (array[i] === value)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n    exports.index_of = index_of;\r\n    function _find_index(dir) {\r\n        return function (array, predicate) {\r\n            const length = array.length;\r\n            let index = dir > 0 ? 0 : length - 1;\r\n            for (; index >= 0 && index < length; index += dir) {\r\n                if (predicate(array[index]))\r\n                    return index;\r\n            }\r\n            return -1;\r\n        };\r\n    }\r\n    exports.find_index = _find_index(1);\r\n    exports.find_last_index = _find_index(-1);\r\n    function find(array, predicate) {\r\n        const index = exports.find_index(array, predicate);\r\n        return index == -1 ? undefined : array[index];\r\n    }\r\n    exports.find = find;\r\n    function find_last(array, predicate) {\r\n        const index = exports.find_last_index(array, predicate);\r\n        return index == -1 ? undefined : array[index];\r\n    }\r\n    exports.find_last = find_last;\r\n    function sorted_index(array, value) {\r\n        let low = 0;\r\n        let high = array.length;\r\n        while (low < high) {\r\n            const mid = Math.floor((low + high) / 2);\r\n            if (array[mid] < value)\r\n                low = mid + 1;\r\n            else\r\n                high = mid;\r\n        }\r\n        return low;\r\n    }\r\n    exports.sorted_index = sorted_index;\r\n    function bin_counts(data, bin_edges) {\r\n        const nbins = bin_edges.length - 1;\r\n        const counts = Array(nbins).fill(0);\r\n        for (let i = 0; i < data.length; i++) {\r\n            const sample = data[i];\r\n            const index = sorted_index(bin_edges, sample);\r\n            const bin = math_1.clamp(index - 1, 0, nbins - 1);\r\n            counts[bin] += 1;\r\n        }\r\n        return counts;\r\n    }\r\n    exports.bin_counts = bin_counts;\r\n    function interpolate(points, x_values, y_values) {\r\n        // Implementation ported from np.interp\r\n        const n = points.length;\r\n        const results = new Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            const point = points[i];\r\n            if (isNaN(point)) {\r\n                results[i] = point;\r\n                continue;\r\n            }\r\n            const index = left_edge_index(point, x_values);\r\n            if (index == -1)\r\n                results[i] = y_values[0];\r\n            else if (index == x_values.length)\r\n                results[i] = y_values[y_values.length - 1];\r\n            else if (index == x_values.length - 1 || x_values[index] == point) {\r\n                results[i] = y_values[index];\r\n            }\r\n            else {\r\n                const x0 = x_values[index];\r\n                const y0 = y_values[index];\r\n                const x1 = x_values[index + 1];\r\n                const y1 = y_values[index + 1];\r\n                results[i] = lerp(point, x0, y0, x1, y1);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    exports.interpolate = interpolate;\r\n    function lerp(x, x0, y0, x1, y1) {\r\n        const slope = (y1 - y0) / (x1 - x0);\r\n        let res = slope * (x - x0) + y0;\r\n        if (!isFinite(res)) {\r\n            res = slope * (x - x1) + y1;\r\n            if (!isFinite(res) && (y0 == y1))\r\n                res = y0;\r\n        }\r\n        return res;\r\n    }\r\n    function left_edge_index(point, intervals) {\r\n        if (point < intervals[0])\r\n            return -1;\r\n        if (point > intervals[intervals.length - 1])\r\n            return intervals.length;\r\n        let leftEdgeIndex = 0;\r\n        let rightEdgeIndex = intervals.length - 1;\r\n        while (rightEdgeIndex - leftEdgeIndex != 1) {\r\n            const indexOfNumberToCompare = leftEdgeIndex + Math.floor((rightEdgeIndex - leftEdgeIndex) / 2);\r\n            if (point >= intervals[indexOfNumberToCompare])\r\n                leftEdgeIndex = indexOfNumberToCompare;\r\n            else\r\n                rightEdgeIndex = indexOfNumberToCompare;\r\n        }\r\n        return leftEdgeIndex;\r\n    }\r\n    exports.left_edge_index = left_edge_index;\r\n    function norm(array, start, end) {\r\n        const span = end - start;\r\n        return map(array, (x) => (x - start) / span);\r\n    }\r\n    exports.norm = norm;\r\n}\r\n","/* core\\util\\object.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const array_1 = require(9) /* ./array */;\r\n    exports.keys = Object.keys, exports.values = Object.values, exports.entries = Object.entries, exports.extend = Object.assign;\r\n    function clone(obj) {\r\n        return Object.assign({}, obj);\r\n    }\r\n    exports.clone = clone;\r\n    function merge(obj1, obj2) {\r\n        /*\r\n         * Returns an object with the array values for obj1 and obj2 unioned by key.\r\n         */\r\n        const result = Object.create(Object.prototype);\r\n        const keys = array_1.concat([Object.keys(obj1), Object.keys(obj2)]);\r\n        for (const key of keys) {\r\n            const arr1 = obj1.hasOwnProperty(key) ? obj1[key] : [];\r\n            const arr2 = obj2.hasOwnProperty(key) ? obj2[key] : [];\r\n            result[key] = array_1.union(arr1, arr2);\r\n        }\r\n        return result;\r\n    }\r\n    exports.merge = merge;\r\n    function size(obj) {\r\n        return Object.keys(obj).length;\r\n    }\r\n    exports.size = size;\r\n    function isEmpty(obj) {\r\n        return size(obj) == 0;\r\n    }\r\n    exports.isEmpty = isEmpty;\r\n    function to_object(map) {\r\n        const obj = {};\r\n        for (const [key, val] of map) {\r\n            obj[key] = val;\r\n        }\r\n        return obj;\r\n    }\r\n    exports.to_object = to_object;\r\n}\r\n","/* core\\has_props.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const signaling_1 = require(15) /* ./signaling */;\r\n    const refs_1 = require(17) /* ./util/refs */;\r\n    const p = tslib_1.__importStar(require(18) /* ./properties */);\r\n    const k = tslib_1.__importStar(require(21) /* ./kinds */);\r\n    const mixins = tslib_1.__importStar(require(28) /* ./property_mixins */);\r\n    const string_1 = require(29) /* ./util/string */;\r\n    const array_1 = require(9) /* ./util/array */;\r\n    const object_1 = require(13) /* ./util/object */;\r\n    const types_1 = require(8) /* ./util/types */;\r\n    const eq_1 = require(25) /* ./util/eq */;\r\n    const document_1 = require(5) /* ../document */;\r\n    const ndarray_1 = require(30) /* ./util/ndarray */;\r\n    const serialization_1 = require(31) /* ./util/serialization */;\r\n    const eq_2 = require(25) /* ./util/eq */;\r\n    const pretty_1 = require(33) /* ./util/pretty */;\r\n    const kinds = tslib_1.__importStar(require(21) /* ./kinds */);\r\n    class HasProps extends signaling_1.Signalable() {\r\n        constructor(attrs = {}) {\r\n            var _a;\r\n            super();\r\n            this._subtype = undefined;\r\n            this.document = null;\r\n            this.destroyed = new signaling_1.Signal0(this, \"destroyed\");\r\n            this.change = new signaling_1.Signal0(this, \"change\");\r\n            this.transformchange = new signaling_1.Signal0(this, \"transformchange\");\r\n            this.properties = {}; // Object.create(null)\r\n            this._pending = false;\r\n            this._changing = false;\r\n            const get = attrs instanceof Map ? attrs.get : (name) => attrs[name];\r\n            for (const [name, { type, default_value, options }] of object_1.entries(this._props)) {\r\n                let property;\r\n                if (type instanceof k.Kind)\r\n                    property = new p.PrimitiveProperty(this, name, type, default_value, get(name), options);\r\n                else\r\n                    property = new type(this, name, k.Any, default_value, get(name), options);\r\n                this.properties[name] = property;\r\n            }\r\n            // allowing us to defer initialization when loading many models\r\n            // when loading a bunch of models, we want to do initialization as a second pass\r\n            // because other objects that this one depends on might not be loaded yet\r\n            if (!((_a = get(\"__deferred__\")) !== null && _a !== void 0 ? _a : false)) {\r\n                this.finalize();\r\n                this.connect_signals();\r\n            }\r\n        }\r\n        // XXX: setter is only required for backwards compatibility\r\n        set type(name) {\r\n            console.warn(\"prototype.type = 'ModelName' is deprecated, use static __name__ instead\");\r\n            this.constructor.__name__ = name;\r\n        }\r\n        get type() {\r\n            return this.constructor.__qualified__;\r\n        }\r\n        static get __qualified__() {\r\n            const { __module__, __name__ } = this;\r\n            return __module__ != null ? `${__module__}.${__name__}` : __name__;\r\n        }\r\n        static get [Symbol.toStringTag]() {\r\n            return this.__name__;\r\n        }\r\n        static init_HasProps() {\r\n            this.prototype._props = {};\r\n            this.prototype._mixins = [];\r\n            this.define({\r\n                id: [p.String, () => string_1.uniqueId()],\r\n            });\r\n        }\r\n        static _fix_default(default_value, _attr) {\r\n            if (default_value === undefined)\r\n                return undefined;\r\n            else if (types_1.isFunction(default_value))\r\n                return default_value;\r\n            else if (types_1.isArray(default_value))\r\n                return () => array_1.copy(default_value);\r\n            else if (types_1.isPlainObject(default_value))\r\n                return () => object_1.clone(default_value);\r\n            else if (!types_1.isObject(default_value))\r\n                return () => default_value;\r\n            else\r\n                throw new Error(`${default_value} must be explicitly wrapped in a function`);\r\n        }\r\n        // TODO: don't use Partial<>, but exclude inherited properties\r\n        static define(obj) {\r\n            for (const [name, prop] of object_1.entries(types_1.isFunction(obj) ? obj(kinds) : obj)) {\r\n                if (this.prototype._props[name] != null)\r\n                    throw new Error(`attempted to redefine property '${this.prototype.type}.${name}'`);\r\n                if (this.prototype[name] != null)\r\n                    throw new Error(`attempted to redefine attribute '${this.prototype.type}.${name}'`);\r\n                Object.defineProperty(this.prototype, name, {\r\n                    // XXX: don't use tail calls in getters/setters due to https://bugs.webkit.org/show_bug.cgi?id=164306\r\n                    get() {\r\n                        const value = this.properties[name].get_value();\r\n                        return value;\r\n                    },\r\n                    set(value) {\r\n                        this.setv({ [name]: value });\r\n                        return this;\r\n                    },\r\n                    configurable: false,\r\n                    enumerable: true,\r\n                });\r\n                const [type, default_value, options] = prop;\r\n                const refined_prop = {\r\n                    type,\r\n                    default_value: this._fix_default(default_value, name),\r\n                    options,\r\n                };\r\n                const props = object_1.clone(this.prototype._props);\r\n                props[name] = refined_prop;\r\n                this.prototype._props = props;\r\n            }\r\n        }\r\n        static internal(obj) {\r\n            const _object = {};\r\n            for (const [name, entry] of object_1.entries(obj)) {\r\n                const [type, default_value, options = {}] = entry;\r\n                _object[name] = [type, default_value, Object.assign(Object.assign({}, options), { internal: true })];\r\n            }\r\n            this.define(_object);\r\n        }\r\n        static mixins(defs) {\r\n            if (!types_1.isArray(defs))\r\n                defs = [defs];\r\n            function resolve(kind) {\r\n                switch (kind) {\r\n                    case \"line\": return mixins.LineVector;\r\n                    case \"fill\": return mixins.FillVector;\r\n                    case \"hatch\": return mixins.HatchVector;\r\n                    case \"text\": return mixins.TextVector;\r\n                    default:\r\n                        throw new Error(`Unknown property mixin kind '${kind}'`);\r\n                }\r\n            }\r\n            function rename(prefix, mixin) {\r\n                const result = {};\r\n                for (const [name, prop] of object_1.entries(mixin)) {\r\n                    result[prefix + name] = prop;\r\n                }\r\n                return result;\r\n            }\r\n            function kind_of(mixin) {\r\n                const [key] = Object.keys(mixin);\r\n                const [kind] = key.split(\"_\", 1);\r\n                return kind;\r\n            }\r\n            const mixin_defs = {};\r\n            const names = [];\r\n            for (const def of defs) {\r\n                if (types_1.isString(def)) {\r\n                    // TODO: remove this branch in 3.0\r\n                    const [kind, prefix = \"\"] = def.split(\":\");\r\n                    const mixin = resolve(kind);\r\n                    names.push(def);\r\n                    object_1.extend(mixin_defs, rename(prefix, mixin));\r\n                }\r\n                else if (types_1.isArray(def)) {\r\n                    const [prefix, mixin] = def;\r\n                    names.push(`${kind_of(mixin)}:${prefix}`);\r\n                    object_1.extend(mixin_defs, rename(prefix, mixin));\r\n                }\r\n                else {\r\n                    const mixin = def;\r\n                    names.push(kind_of(mixin));\r\n                    object_1.extend(mixin_defs, mixin);\r\n                }\r\n            }\r\n            this.define(mixin_defs);\r\n            this.prototype._mixins = [...this.prototype._mixins, ...names];\r\n        }\r\n        static override(obj) {\r\n            for (const [name, prop] of object_1.entries(obj)) {\r\n                const default_value = this._fix_default(prop, name);\r\n                const value = this.prototype._props[name];\r\n                if (value == null)\r\n                    throw new Error(`attempted to override nonexistent '${this.prototype.type}.${name}'`);\r\n                const props = object_1.clone(this.prototype._props);\r\n                props[name] = Object.assign(Object.assign({}, value), { default_value });\r\n                this.prototype._props = props;\r\n            }\r\n        }\r\n        toString() {\r\n            return `${this.type}(${this.id})`;\r\n        }\r\n        property(name) {\r\n            const prop = this.properties[name];\r\n            if (prop != null)\r\n                return prop;\r\n            else\r\n                throw new Error(`unknown property ${this.type}.${name}`);\r\n        }\r\n        get attributes() {\r\n            const attrs = {}; // Object.create(null)\r\n            for (const prop of this) {\r\n                attrs[prop.attr] = prop.get_value();\r\n            }\r\n            return attrs;\r\n        }\r\n        [eq_2.equals](that, cmp) {\r\n            for (const p0 of this) {\r\n                const p1 = that.property(p0.attr);\r\n                if (cmp.eq(p0.get_value(), p1.get_value()))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        [pretty_1.pretty](printer) {\r\n            const T = printer.token;\r\n            const items = [];\r\n            for (const prop of this) {\r\n                if (prop.dirty) {\r\n                    const value = prop.get_value();\r\n                    items.push(`${prop.attr}${T(\":\")} ${printer.to_string(value)}`);\r\n                }\r\n            }\r\n            const cls = this.constructor.__qualified__;\r\n            return `${cls}${T(\"(\")}${T(\"{\")}${items.join(`${T(\",\")} `)}${T(\"}\")}${T(\")\")}`;\r\n        }\r\n        finalize() {\r\n            for (const prop of this) {\r\n                if (prop.spec.transform != null)\r\n                    this.connect(prop.spec.transform.change, () => this.transformchange.emit());\r\n            }\r\n            this.initialize();\r\n        }\r\n        initialize() { }\r\n        connect_signals() { }\r\n        disconnect_signals() {\r\n            signaling_1.Signal.disconnectReceiver(this);\r\n        }\r\n        destroy() {\r\n            this.disconnect_signals();\r\n            this.destroyed.emit();\r\n        }\r\n        // Create a new model with identical attributes to this one.\r\n        clone() {\r\n            return new this.constructor(this.attributes);\r\n        }\r\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\r\n        // the core primitive operation of a model, updating the data and notifying\r\n        // anyone who needs to know about the change in state. The heart of the beast.\r\n        _setv(changes, options) {\r\n            // Extract attributes and options.\r\n            const check_eq = options.check_eq;\r\n            const changed = [];\r\n            const changing = this._changing;\r\n            this._changing = true;\r\n            for (const [prop, value] of changes) {\r\n                if (check_eq === false || !eq_1.isEqual(prop.get_value(), value)) {\r\n                    prop.set_value(value);\r\n                    changed.push(prop);\r\n                }\r\n            }\r\n            // Trigger all relevant attribute changes.\r\n            if (changed.length > 0)\r\n                this._pending = true;\r\n            for (const prop of changed) {\r\n                prop.change.emit();\r\n            }\r\n            // You might be wondering why there's a `while` loop here. Changes can\r\n            // be recursively nested within `\"change\"` events.\r\n            if (changing)\r\n                return;\r\n            if (!options.no_change) {\r\n                while (this._pending) {\r\n                    this._pending = false;\r\n                    this.change.emit();\r\n                }\r\n            }\r\n            this._pending = false;\r\n            this._changing = false;\r\n        }\r\n        setv(changed_attrs, options = {}) {\r\n            const changes = object_1.entries(changed_attrs);\r\n            if (changes.length == 0)\r\n                return;\r\n            if (options.silent === true) {\r\n                for (const [attr, value] of changes) {\r\n                    this.properties[attr].set_value(value);\r\n                }\r\n                return;\r\n            }\r\n            const changed = new Map();\r\n            const previous = new Map();\r\n            for (const [attr, value] of changes) {\r\n                const prop = this.properties[attr];\r\n                changed.set(prop, value);\r\n                previous.set(prop, prop.get_value());\r\n            }\r\n            this._setv(changed, options);\r\n            const { document } = this;\r\n            if (document != null) {\r\n                const changed = [];\r\n                for (const [prop, value] of previous) {\r\n                    changed.push([prop, value, prop.get_value()]);\r\n                }\r\n                for (const [, old_value, new_value] of changed) {\r\n                    if (this._needs_invalidate(old_value, new_value)) {\r\n                        document._invalidate_all_models();\r\n                        break;\r\n                    }\r\n                }\r\n                this._push_changes(changed, options);\r\n            }\r\n        }\r\n        /** @deprecated */\r\n        getv(name) {\r\n            return this.property(name).get_value();\r\n        }\r\n        ref() {\r\n            return { id: this.id };\r\n        }\r\n        struct() {\r\n            const struct = {\r\n                type: this.type,\r\n                id: this.id,\r\n                attributes: {},\r\n            };\r\n            if (this._subtype != null) {\r\n                struct.subtype = this._subtype;\r\n            }\r\n            return struct;\r\n        }\r\n        // we only keep the subtype so we match Python;\r\n        // only Python cares about this\r\n        set_subtype(subtype) {\r\n            this._subtype = subtype;\r\n        }\r\n        *[Symbol.iterator]() {\r\n            yield* object_1.values(this.properties);\r\n        }\r\n        *syncable_properties() {\r\n            for (const prop of this) {\r\n                if (prop.syncable)\r\n                    yield prop;\r\n            }\r\n        }\r\n        /** @deprecated */\r\n        serializable_attributes() {\r\n            const attrs = {};\r\n            for (const prop of this.syncable_properties()) {\r\n                attrs[prop.attr] = prop.get_value();\r\n            }\r\n            return attrs;\r\n        }\r\n        static _value_to_json(value) {\r\n            if (value instanceof HasProps)\r\n                return value.ref();\r\n            else if (ndarray_1.is_NDArray(value))\r\n                return serialization_1.encode_NDArray(value);\r\n            else if (types_1.isArray(value) || types_1.isTypedArray(value)) {\r\n                const n = value.length;\r\n                const ref_array = new Array(n);\r\n                for (let i = 0; i < n; i++) {\r\n                    const v = value[i];\r\n                    ref_array[i] = HasProps._value_to_json(v);\r\n                }\r\n                return ref_array;\r\n            }\r\n            else if (types_1.isPlainObject(value)) {\r\n                const ref_obj = {};\r\n                for (const [subkey, subvalue] of object_1.entries(value)) {\r\n                    ref_obj[subkey] = HasProps._value_to_json(subvalue);\r\n                }\r\n                return ref_obj;\r\n            }\r\n            else\r\n                return value;\r\n        }\r\n        // Convert attributes to \"shallow\" JSON (values which are themselves models\r\n        // are included as just references)\r\n        attributes_as_json(include_defaults = true, value_to_json = HasProps._value_to_json) {\r\n            const attributes = {}; // Object.create(null)\r\n            for (const prop of this) {\r\n                if (prop.syncable && (include_defaults || prop.dirty)) {\r\n                    attributes[prop.attr] = value_to_json(prop.get_value());\r\n                }\r\n            }\r\n            return attributes;\r\n        }\r\n        // this is like _value_record_references but expects to find refs\r\n        // instead of models, and takes a doc to look up the refs in\r\n        static _json_record_references(doc, v, refs, options) {\r\n            const { recursive } = options;\r\n            if (refs_1.is_ref(v)) {\r\n                const model = doc.get_model_by_id(v.id);\r\n                if (model != null && !refs.has(model)) {\r\n                    HasProps._value_record_references(model, refs, { recursive });\r\n                }\r\n            }\r\n            else if (types_1.isArray(v)) {\r\n                for (const elem of v)\r\n                    HasProps._json_record_references(doc, elem, refs, { recursive });\r\n            }\r\n            else if (types_1.isPlainObject(v)) {\r\n                for (const elem of object_1.values(v)) {\r\n                    HasProps._json_record_references(doc, elem, refs, { recursive });\r\n                }\r\n            }\r\n        }\r\n        // add all references from 'v' to 'result', if recurse\r\n        // is true then descend into refs, if false only\r\n        // descend into non-refs\r\n        static _value_record_references(v, refs, options) {\r\n            const { recursive } = options;\r\n            if (v instanceof HasProps) {\r\n                if (!refs.has(v)) {\r\n                    refs.add(v);\r\n                    if (recursive) {\r\n                        const immediate = v._immediate_references();\r\n                        for (const obj of immediate)\r\n                            HasProps._value_record_references(obj, refs, { recursive: true });\r\n                    }\r\n                }\r\n            }\r\n            else if (types_1.isArray(v)) {\r\n                for (const elem of v)\r\n                    HasProps._value_record_references(elem, refs, { recursive });\r\n            }\r\n            else if (types_1.isPlainObject(v)) {\r\n                for (const elem of object_1.values(v)) {\r\n                    HasProps._value_record_references(elem, refs, { recursive });\r\n                }\r\n            }\r\n        }\r\n        // Get models that are immediately referenced by our properties\r\n        // (do not recurse, do not include ourselves)\r\n        _immediate_references() {\r\n            const refs = new Set();\r\n            for (const prop of this.syncable_properties()) {\r\n                const value = prop.get_value();\r\n                HasProps._value_record_references(value, refs, { recursive: false });\r\n            }\r\n            return refs;\r\n        }\r\n        references() {\r\n            const refs = new Set();\r\n            HasProps._value_record_references(this, refs, { recursive: true });\r\n            return refs;\r\n        }\r\n        _doc_attached() { }\r\n        _doc_detached() { }\r\n        attach_document(doc) {\r\n            // This should only be called by the Document implementation to set the document field\r\n            if (this.document != null && this.document != doc)\r\n                throw new Error(\"models must be owned by only a single document\");\r\n            this.document = doc;\r\n            this._doc_attached();\r\n        }\r\n        detach_document() {\r\n            // This should only be called by the Document implementation to unset the document field\r\n            this._doc_detached();\r\n            this.document = null;\r\n        }\r\n        _needs_invalidate(old_value, new_value) {\r\n            const new_refs = new Set();\r\n            HasProps._value_record_references(new_value, new_refs, { recursive: false });\r\n            const old_refs = new Set();\r\n            HasProps._value_record_references(old_value, old_refs, { recursive: false });\r\n            for (const new_id of new_refs) {\r\n                if (!old_refs.has(new_id))\r\n                    return true;\r\n            }\r\n            for (const old_id of old_refs) {\r\n                if (!new_refs.has(old_id))\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n        _push_changes(changes, options = {}) {\r\n            const { document } = this;\r\n            if (document == null)\r\n                return;\r\n            const { setter_id } = options;\r\n            const events = [];\r\n            for (const [prop, old_value, new_value] of changes) {\r\n                if (prop.syncable)\r\n                    events.push(new document_1.ModelChangedEvent(document, this, prop.attr, old_value, new_value, setter_id));\r\n            }\r\n            if (events.length != 0) {\r\n                let event;\r\n                if (events.length == 1)\r\n                    [event] = events;\r\n                else\r\n                    event = new document_1.DocumentEventBatch(document, events, setter_id);\r\n                document._trigger_on_change(event);\r\n            }\r\n        }\r\n        materialize_dataspecs(source) {\r\n            // Note: this should be moved to a function separate from HasProps\r\n            const data = {};\r\n            for (const prop of this) {\r\n                if (!(prop instanceof p.VectorSpec))\r\n                    continue;\r\n                // this skips optional properties like radius for circles\r\n                if (prop.optional && prop.spec.value == null && !prop.dirty)\r\n                    continue;\r\n                const name = prop.attr;\r\n                const array = prop.array(source);\r\n                data[`_${name}`] = array;\r\n                if (prop instanceof p.DistanceSpec)\r\n                    data[`max_${name}`] = array_1.max(array);\r\n            }\r\n            return data;\r\n        }\r\n        on_change(properties, fn) {\r\n            for (const property of types_1.isArray(properties) ? properties : [properties]) {\r\n                this.connect(property.change, fn);\r\n            }\r\n        }\r\n    }\r\n    exports.HasProps = HasProps;\r\n    HasProps.init_HasProps();\r\n}\r\n","/* core\\signaling.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    // Based on https://github.com/phosphorjs/phosphor/blob/master/packages/signaling/src/index.ts\r\n    const callback_1 = require(16) /* ./util/callback */;\r\n    const array_1 = require(9) /* ./util/array */;\r\n    class Signal {\r\n        constructor(sender, name) {\r\n            this.sender = sender;\r\n            this.name = name;\r\n        }\r\n        connect(slot, context = null) {\r\n            if (!receiversForSender.has(this.sender)) {\r\n                receiversForSender.set(this.sender, []);\r\n            }\r\n            const receivers = receiversForSender.get(this.sender);\r\n            if (findConnection(receivers, this, slot, context) != null) {\r\n                return false;\r\n            }\r\n            const receiver = context !== null && context !== void 0 ? context : slot;\r\n            if (!sendersForReceiver.has(receiver)) {\r\n                sendersForReceiver.set(receiver, []);\r\n            }\r\n            const senders = sendersForReceiver.get(receiver);\r\n            const connection = { signal: this, slot, context };\r\n            receivers.push(connection);\r\n            senders.push(connection);\r\n            return true;\r\n        }\r\n        disconnect(slot, context = null) {\r\n            const receivers = receiversForSender.get(this.sender);\r\n            if (receivers == null || receivers.length === 0) {\r\n                return false;\r\n            }\r\n            const connection = findConnection(receivers, this, slot, context);\r\n            if (connection == null) {\r\n                return false;\r\n            }\r\n            const receiver = context !== null && context !== void 0 ? context : slot;\r\n            const senders = sendersForReceiver.get(receiver);\r\n            connection.signal = null;\r\n            scheduleCleanup(receivers);\r\n            scheduleCleanup(senders);\r\n            return true;\r\n        }\r\n        emit(args) {\r\n            var _a;\r\n            const receivers = (_a = receiversForSender.get(this.sender)) !== null && _a !== void 0 ? _a : [];\r\n            for (const { signal, slot, context } of receivers) {\r\n                if (signal === this) {\r\n                    slot.call(context, args, this.sender);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.Signal = Signal;\r\n    Signal.__name__ = \"Signal\";\r\n    class Signal0 extends Signal {\r\n        emit() {\r\n            super.emit(undefined);\r\n        }\r\n    }\r\n    exports.Signal0 = Signal0;\r\n    Signal0.__name__ = \"Signal0\";\r\n    (function (Signal) {\r\n        function disconnectBetween(sender, receiver) {\r\n            const receivers = receiversForSender.get(sender);\r\n            if (receivers == null || receivers.length === 0)\r\n                return;\r\n            const senders = sendersForReceiver.get(receiver);\r\n            if (senders == null || senders.length === 0)\r\n                return;\r\n            for (const connection of senders) {\r\n                if (connection.signal == null)\r\n                    return;\r\n                if (connection.signal.sender === sender)\r\n                    connection.signal = null;\r\n            }\r\n            scheduleCleanup(receivers);\r\n            scheduleCleanup(senders);\r\n        }\r\n        Signal.disconnectBetween = disconnectBetween;\r\n        function disconnectSender(sender) {\r\n            var _a;\r\n            const receivers = receiversForSender.get(sender);\r\n            if (receivers == null || receivers.length === 0)\r\n                return;\r\n            for (const connection of receivers) {\r\n                if (connection.signal == null)\r\n                    return;\r\n                const receiver = (_a = connection.context) !== null && _a !== void 0 ? _a : connection.slot;\r\n                connection.signal = null;\r\n                scheduleCleanup(sendersForReceiver.get(receiver));\r\n            }\r\n            scheduleCleanup(receivers);\r\n        }\r\n        Signal.disconnectSender = disconnectSender;\r\n        function disconnectReceiver(receiver) {\r\n            const senders = sendersForReceiver.get(receiver);\r\n            if (senders == null || senders.length === 0)\r\n                return;\r\n            for (const connection of senders) {\r\n                if (connection.signal == null)\r\n                    return;\r\n                const sender = connection.signal.sender;\r\n                connection.signal = null;\r\n                scheduleCleanup(receiversForSender.get(sender));\r\n            }\r\n            scheduleCleanup(senders);\r\n        }\r\n        Signal.disconnectReceiver = disconnectReceiver;\r\n        function disconnectAll(obj) {\r\n            const receivers = receiversForSender.get(obj);\r\n            if (receivers != null && receivers.length !== 0) {\r\n                for (const connection of receivers) {\r\n                    connection.signal = null;\r\n                }\r\n                scheduleCleanup(receivers);\r\n            }\r\n            const senders = sendersForReceiver.get(obj);\r\n            if (senders != null && senders.length !== 0) {\r\n                for (const connection of senders) {\r\n                    connection.signal = null;\r\n                }\r\n                scheduleCleanup(senders);\r\n            }\r\n        }\r\n        Signal.disconnectAll = disconnectAll;\r\n    })(Signal || (exports.Signal = Signal = {}));\r\n    function Signalable() {\r\n        return class {\r\n            connect(signal, slot) {\r\n                return signal.connect(slot, this);\r\n            }\r\n            disconnect(signal, slot) {\r\n                return signal.disconnect(slot, this);\r\n            }\r\n        };\r\n    }\r\n    exports.Signalable = Signalable;\r\n    const receiversForSender = new WeakMap();\r\n    const sendersForReceiver = new WeakMap();\r\n    function findConnection(conns, signal, slot, context) {\r\n        return array_1.find(conns, conn => conn.signal === signal && conn.slot === slot && conn.context === context);\r\n    }\r\n    const dirty_set = new Set();\r\n    function scheduleCleanup(connections) {\r\n        if (dirty_set.size === 0) {\r\n            callback_1.defer(cleanup_dirty_set);\r\n        }\r\n        dirty_set.add(connections);\r\n    }\r\n    function cleanup_dirty_set() {\r\n        for (const connections of dirty_set) {\r\n            array_1.remove_by(connections, (connection) => connection.signal == null);\r\n        }\r\n        dirty_set.clear();\r\n    }\r\n}\r\n","/* core\\util\\callback.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    //     Underscore.js 1.8.3\r\n    //     http://underscorejs.org\r\n    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n    //     Underscore may be freely distributed under the MIT license.\r\n    function delay(func, wait) {\r\n        return setTimeout(func, wait);\r\n    }\r\n    exports.delay = delay;\r\n    const _defer = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setImmediate;\r\n    function defer(func) {\r\n        return new Promise((resolve) => {\r\n            _defer(() => resolve(func()));\r\n        });\r\n    }\r\n    exports.defer = defer;\r\n    function throttle(func, wait, options = {}) {\r\n        let context, args, result;\r\n        let timeout = null;\r\n        let previous = 0;\r\n        const later = function () {\r\n            previous = options.leading === false ? 0 : Date.now();\r\n            timeout = null;\r\n            result = func.apply(context, args);\r\n            if (!timeout)\r\n                context = args = null;\r\n        };\r\n        return function () {\r\n            const now = Date.now();\r\n            if (!previous && options.leading === false)\r\n                previous = now;\r\n            const remaining = wait - (now - previous);\r\n            context = this;\r\n            args = arguments;\r\n            if (remaining <= 0 || remaining > wait) {\r\n                if (timeout) {\r\n                    clearTimeout(timeout);\r\n                    timeout = null;\r\n                }\r\n                previous = now;\r\n                result = func.apply(context, args);\r\n                if (!timeout)\r\n                    context = args = null;\r\n            }\r\n            else if (!timeout && options.trailing !== false) {\r\n                timeout = setTimeout(later, remaining);\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    exports.throttle = throttle;\r\n    function once(func) {\r\n        let done = false;\r\n        let memo;\r\n        return function () {\r\n            if (!done) {\r\n                done = true;\r\n                memo = func();\r\n            }\r\n            return memo;\r\n        };\r\n    }\r\n    exports.once = once;\r\n}\r\n","/* core\\util\\refs.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(8) /* ./types */;\r\n    const object_1 = require(13) /* ./object */;\r\n    // Determine whether an object has the proper format of a Bokeh reference\r\n    //\r\n    // @param arg [Object] the object to test\r\n    // @return [bool] whether the object is a reference\r\n    //\r\n    // @note this function does not check that the id and types are valid,\r\n    //   only that the format is correct (all required keys are present)\r\n    //\r\n    function is_ref(arg) {\r\n        if (types_1.isPlainObject(arg)) {\r\n            const attrs = object_1.keys(arg);\r\n            return attrs.length == 1 && attrs[0] == \"id\";\r\n        }\r\n        return false;\r\n    }\r\n    exports.is_ref = is_ref;\r\n}\r\n","/* core\\properties.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const signaling_1 = require(15) /* ./signaling */;\r\n    const logging_1 = require(19) /* ./logging */;\r\n    const enums = tslib_1.__importStar(require(20) /* ./enums */);\r\n    const types_1 = require(24) /* ./types */;\r\n    const array_1 = require(9) /* ./util/array */;\r\n    const arrayable_1 = require(12) /* ./util/arrayable */;\r\n    const color_1 = require(22) /* ./util/color */;\r\n    const types_2 = require(8) /* ./util/types */;\r\n    const settings_1 = require(27) /* ./settings */;\r\n    function valueToString(value) {\r\n        try {\r\n            return JSON.stringify(value);\r\n        }\r\n        catch (_a) {\r\n            return value.toString();\r\n        }\r\n    }\r\n    function isSpec(obj) {\r\n        return types_2.isPlainObject(obj) &&\r\n            ((obj.value === undefined ? 0 : 1) +\r\n                (obj.field === undefined ? 0 : 1) +\r\n                (obj.expr === undefined ? 0 : 1) == 1); // garbage JS XOR\r\n    }\r\n    exports.isSpec = isSpec;\r\n    class Property {\r\n        constructor(obj, attr, kind, default_value, initial_value, options = {}) {\r\n            var _a, _b;\r\n            this.obj = obj;\r\n            this.attr = attr;\r\n            this.kind = kind;\r\n            this.default_value = default_value;\r\n            this._dirty = false;\r\n            this.change = new signaling_1.Signal0(this.obj, \"change\");\r\n            this.internal = (_a = options.internal) !== null && _a !== void 0 ? _a : false;\r\n            this.optional = (_b = options.optional) !== null && _b !== void 0 ? _b : false;\r\n            let attr_value;\r\n            if (initial_value !== undefined) {\r\n                attr_value = initial_value;\r\n                this._dirty = true;\r\n            }\r\n            else {\r\n                const value = this._default_override();\r\n                if (value !== undefined)\r\n                    attr_value = value;\r\n                else if (default_value !== undefined)\r\n                    attr_value = default_value(obj);\r\n                else {\r\n                    //throw new Error(\"no default\")\r\n                    attr_value = null; // XXX: nullable properties\r\n                }\r\n            }\r\n            this._update(attr_value);\r\n        }\r\n        get is_value() {\r\n            return this.spec.value !== undefined;\r\n        }\r\n        get syncable() {\r\n            return !this.internal;\r\n        }\r\n        get_value() {\r\n            return this.spec.value;\r\n        }\r\n        set_value(val) {\r\n            this._update(val);\r\n            this._dirty = true;\r\n        }\r\n        // abstract _intrinsic_default(): T\r\n        _default_override() {\r\n            return undefined;\r\n        }\r\n        get dirty() {\r\n            return this._dirty;\r\n        }\r\n        //protected abstract _update(attr_value: T): void\r\n        _update(attr_value) {\r\n            if (attr_value != null) // XXX: non-nullalble types\r\n                this.validate(attr_value);\r\n            this.spec = { value: attr_value };\r\n        }\r\n        toString() {\r\n            /*${this.name}*/\r\n            return `Prop(${this.obj}.${this.attr}, spec: ${valueToString(this.spec)})`;\r\n        }\r\n        // ----- customizable policies\r\n        normalize(values) {\r\n            return values;\r\n        }\r\n        validate(value) {\r\n            if (!this.valid(value))\r\n                throw new Error(`${this.obj.type}.${this.attr} given invalid value: ${valueToString(value)}`);\r\n        }\r\n        valid(value) {\r\n            return this.kind.valid(value);\r\n        }\r\n        // ----- property accessors\r\n        value(do_spec_transform = true) {\r\n            if (!this.is_value)\r\n                throw new Error(\"attempted to retrieve property value for property without value specification\");\r\n            let ret = this.normalize([this.spec.value])[0];\r\n            if (this.spec.transform != null && do_spec_transform)\r\n                ret = this.spec.transform.compute(ret);\r\n            return ret;\r\n        }\r\n    }\r\n    exports.Property = Property;\r\n    Property.__name__ = \"Property\";\r\n    //\r\n    // Primitive Properties\r\n    //\r\n    class PrimitiveProperty extends Property {\r\n    }\r\n    exports.PrimitiveProperty = PrimitiveProperty;\r\n    PrimitiveProperty.__name__ = \"PrimitiveProperty\";\r\n    class Any extends Property {\r\n    }\r\n    exports.Any = Any;\r\n    Any.__name__ = \"Any\";\r\n    class Array extends Property {\r\n        valid(value) {\r\n            return types_2.isArray(value) || value instanceof Float32Array || value instanceof Float64Array;\r\n        }\r\n    }\r\n    exports.Array = Array;\r\n    Array.__name__ = \"Array\";\r\n    class Boolean extends Property {\r\n        valid(value) {\r\n            return types_2.isBoolean(value);\r\n        }\r\n    }\r\n    exports.Boolean = Boolean;\r\n    Boolean.__name__ = \"Boolean\";\r\n    class Color extends Property {\r\n        valid(value) {\r\n            return types_2.isString(value) && color_1.is_color(value);\r\n        }\r\n    }\r\n    exports.Color = Color;\r\n    Color.__name__ = \"Color\";\r\n    class Instance extends Property {\r\n    }\r\n    exports.Instance = Instance;\r\n    Instance.__name__ = \"Instance\";\r\n    class Number extends Property {\r\n        valid(value) {\r\n            return types_2.isNumber(value);\r\n        }\r\n    }\r\n    exports.Number = Number;\r\n    Number.__name__ = \"Number\";\r\n    class Int extends Number {\r\n        valid(value) {\r\n            return types_2.isNumber(value) && (value | 0) == value;\r\n        }\r\n    }\r\n    exports.Int = Int;\r\n    Int.__name__ = \"Int\";\r\n    class Angle extends Number {\r\n    }\r\n    exports.Angle = Angle;\r\n    Angle.__name__ = \"Angle\";\r\n    class Percent extends Number {\r\n        valid(value) {\r\n            return types_2.isNumber(value) && 0 <= value && value <= 1.0;\r\n        }\r\n    }\r\n    exports.Percent = Percent;\r\n    Percent.__name__ = \"Percent\";\r\n    class String extends Property {\r\n        valid(value) {\r\n            return types_2.isString(value);\r\n        }\r\n    }\r\n    exports.String = String;\r\n    String.__name__ = \"String\";\r\n    class NullString extends Property {\r\n        valid(value) {\r\n            return value === null || types_2.isString(value);\r\n        }\r\n    }\r\n    exports.NullString = NullString;\r\n    NullString.__name__ = \"NullString\";\r\n    class FontSize extends String {\r\n    }\r\n    exports.FontSize = FontSize;\r\n    FontSize.__name__ = \"FontSize\";\r\n    class Font extends String {\r\n        _default_override() {\r\n            return settings_1.settings.dev ? \"Bokeh\" : undefined;\r\n        }\r\n    }\r\n    exports.Font = Font;\r\n    Font.__name__ = \"Font\";\r\n    //\r\n    // Enum properties\r\n    //\r\n    class EnumProperty extends Property {\r\n        valid(value) {\r\n            return types_2.isString(value) && array_1.includes(this.enum_values, value);\r\n        }\r\n    }\r\n    exports.EnumProperty = EnumProperty;\r\n    EnumProperty.__name__ = \"EnumProperty\";\r\n    function Enum(values) {\r\n        return class extends EnumProperty {\r\n            get enum_values() {\r\n                return [...values];\r\n            }\r\n        };\r\n    }\r\n    exports.Enum = Enum;\r\n    class Direction extends EnumProperty {\r\n        get enum_values() {\r\n            return [...enums.Direction];\r\n        }\r\n        normalize(values) {\r\n            const result = new Uint8Array(values.length);\r\n            for (let i = 0; i < values.length; i++) {\r\n                switch (values[i]) {\r\n                    case \"clock\":\r\n                        result[i] = 0;\r\n                        break;\r\n                    case \"anticlock\":\r\n                        result[i] = 1;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.Direction = Direction;\r\n    Direction.__name__ = \"Direction\";\r\n    /* TODO: remove this {{{ */\r\n    exports.Anchor = Enum(enums.Anchor);\r\n    exports.AngleUnits = Enum(enums.AngleUnits);\r\n    exports.BoxOrigin = Enum(enums.BoxOrigin);\r\n    exports.ButtonType = Enum(enums.ButtonType);\r\n    exports.CalendarPosition = Enum(enums.CalendarPosition);\r\n    exports.Dimension = Enum(enums.Dimension);\r\n    exports.Dimensions = Enum(enums.Dimensions);\r\n    exports.Distribution = Enum(enums.Distribution);\r\n    exports.FontStyle = Enum(enums.FontStyle);\r\n    exports.HatchPatternType = Enum(enums.HatchPatternType);\r\n    exports.HTTPMethod = Enum(enums.HTTPMethod);\r\n    exports.HexTileOrientation = Enum(enums.HexTileOrientation);\r\n    exports.HoverMode = Enum(enums.HoverMode);\r\n    exports.LatLon = Enum(enums.LatLon);\r\n    exports.LegendClickPolicy = Enum(enums.LegendClickPolicy);\r\n    exports.LegendLocation = Enum(enums.LegendLocation);\r\n    exports.LineCap = Enum(enums.LineCap);\r\n    exports.LineJoin = Enum(enums.LineJoin);\r\n    exports.LinePolicy = Enum(enums.LinePolicy);\r\n    exports.Location = Enum(enums.Location);\r\n    exports.Logo = Enum(enums.Logo);\r\n    exports.MarkerType = Enum(enums.MarkerType);\r\n    exports.MutedPolicy = Enum(enums.MutedPolicy);\r\n    exports.Orientation = Enum(enums.Orientation);\r\n    exports.OutputBackend = Enum(enums.OutputBackend);\r\n    exports.PaddingUnits = Enum(enums.PaddingUnits);\r\n    exports.Place = Enum(enums.Place);\r\n    exports.PointPolicy = Enum(enums.PointPolicy);\r\n    exports.RadiusDimension = Enum(enums.RadiusDimension);\r\n    exports.RenderLevel = Enum(enums.RenderLevel);\r\n    exports.RenderMode = Enum(enums.RenderMode);\r\n    exports.ResetPolicy = Enum(enums.ResetPolicy);\r\n    exports.RoundingFunction = Enum(enums.RoundingFunction);\r\n    exports.Side = Enum(enums.Side);\r\n    exports.SizingMode = Enum(enums.SizingMode);\r\n    exports.Sort = Enum(enums.Sort);\r\n    exports.SpatialUnits = Enum(enums.SpatialUnits);\r\n    exports.StartEnd = Enum(enums.StartEnd);\r\n    exports.StepMode = Enum(enums.StepMode);\r\n    exports.TapBehavior = Enum(enums.TapBehavior);\r\n    exports.TextAlign = Enum(enums.TextAlign);\r\n    exports.TextBaseline = Enum(enums.TextBaseline);\r\n    exports.TextureRepetition = Enum(enums.TextureRepetition);\r\n    exports.TickLabelOrientation = Enum(enums.TickLabelOrientation);\r\n    exports.TooltipAttachment = Enum(enums.TooltipAttachment);\r\n    exports.UpdateMode = Enum(enums.UpdateMode);\r\n    exports.VerticalAlign = Enum(enums.VerticalAlign);\r\n    /* }}} */\r\n    //\r\n    // DataSpec properties\r\n    //\r\n    class ScalarSpec extends Property {\r\n        get_value() {\r\n            // XXX: allow obj.x = null; obj.x == null\r\n            return this.spec.value === null ? null : this.spec;\r\n        }\r\n        _update(attr_value) {\r\n            if (isSpec(attr_value))\r\n                this.spec = attr_value;\r\n            else\r\n                this.spec = { value: attr_value };\r\n            if (this.spec.value != null)\r\n                this.validate(this.spec.value);\r\n        }\r\n    }\r\n    exports.ScalarSpec = ScalarSpec;\r\n    ScalarSpec.__name__ = \"ScalarSpec\";\r\n    class AnyScalar extends ScalarSpec {\r\n    }\r\n    exports.AnyScalar = AnyScalar;\r\n    AnyScalar.__name__ = \"AnyScalar\";\r\n    class ColorScalar extends ScalarSpec {\r\n    }\r\n    exports.ColorScalar = ColorScalar;\r\n    ColorScalar.__name__ = \"ColorScalar\";\r\n    class NumberScalar extends ScalarSpec {\r\n    }\r\n    exports.NumberScalar = NumberScalar;\r\n    NumberScalar.__name__ = \"NumberScalar\";\r\n    class StringScalar extends ScalarSpec {\r\n    }\r\n    exports.StringScalar = StringScalar;\r\n    StringScalar.__name__ = \"StringScalar\";\r\n    class NullStringScalar extends ScalarSpec {\r\n    }\r\n    exports.NullStringScalar = NullStringScalar;\r\n    NullStringScalar.__name__ = \"NullStringScalar\";\r\n    class ArrayScalar extends ScalarSpec {\r\n    }\r\n    exports.ArrayScalar = ArrayScalar;\r\n    ArrayScalar.__name__ = \"ArrayScalar\";\r\n    class LineJoinScalar extends ScalarSpec {\r\n    }\r\n    exports.LineJoinScalar = LineJoinScalar;\r\n    LineJoinScalar.__name__ = \"LineJoinScalar\";\r\n    class LineCapScalar extends ScalarSpec {\r\n    }\r\n    exports.LineCapScalar = LineCapScalar;\r\n    LineCapScalar.__name__ = \"LineCapScalar\";\r\n    class FontSizeScalar extends ScalarSpec {\r\n    }\r\n    exports.FontSizeScalar = FontSizeScalar;\r\n    FontSizeScalar.__name__ = \"FontSizeScalar\";\r\n    class FontStyleScalar extends ScalarSpec {\r\n    }\r\n    exports.FontStyleScalar = FontStyleScalar;\r\n    FontStyleScalar.__name__ = \"FontStyleScalar\";\r\n    class TextAlignScalar extends ScalarSpec {\r\n    }\r\n    exports.TextAlignScalar = TextAlignScalar;\r\n    TextAlignScalar.__name__ = \"TextAlignScalar\";\r\n    class TextBaselineScalar extends ScalarSpec {\r\n    }\r\n    exports.TextBaselineScalar = TextBaselineScalar;\r\n    TextBaselineScalar.__name__ = \"TextBaselineScalar\";\r\n    class VectorSpec extends Property {\r\n        get_value() {\r\n            // XXX: allow obj.x = null; obj.x == null\r\n            return this.spec.value === null ? null : this.spec;\r\n        }\r\n        _update(attr_value) {\r\n            if (isSpec(attr_value))\r\n                this.spec = attr_value;\r\n            else\r\n                this.spec = { value: attr_value };\r\n            if (this.spec.value != null)\r\n                this.validate(this.spec.value);\r\n        }\r\n        array(source) {\r\n            var _a;\r\n            let array;\r\n            const length = (_a = source.get_length()) !== null && _a !== void 0 ? _a : 1;\r\n            if (this.spec.field != null) {\r\n                const column = source.get_column(this.spec.field);\r\n                if (column != null)\r\n                    array = this.normalize(column);\r\n                else {\r\n                    logging_1.logger.warn(`attempted to retrieve property array for nonexistent field '${this.spec.field}'`);\r\n                    const missing = new types_1.NumberArray(length);\r\n                    missing.fill(NaN);\r\n                    array = missing;\r\n                }\r\n            }\r\n            else if (this.spec.expr != null) {\r\n                array = this.normalize(this.spec.expr.v_compute(source));\r\n            }\r\n            else {\r\n                const value = this.value(false); // don't apply any spec transform\r\n                if (types_2.isNumber(value)) {\r\n                    const values = new types_1.NumberArray(length);\r\n                    values.fill(value);\r\n                    array = values;\r\n                }\r\n                else\r\n                    array = array_1.repeat(value, length);\r\n            }\r\n            if (this.spec.transform != null)\r\n                array = this.spec.transform.v_compute(array);\r\n            return array;\r\n        }\r\n    }\r\n    exports.VectorSpec = VectorSpec;\r\n    VectorSpec.__name__ = \"VectorSpec\";\r\n    class DataSpec extends VectorSpec {\r\n    }\r\n    exports.DataSpec = DataSpec;\r\n    DataSpec.__name__ = \"DataSpec\";\r\n    class UnitsSpec extends VectorSpec {\r\n        _update(attr_value) {\r\n            super._update(attr_value);\r\n            if (this.spec.units == null)\r\n                this.spec.units = this.default_units;\r\n            const units = this.spec.units;\r\n            if (!array_1.includes(this.valid_units, units))\r\n                throw new Error(`units must be one of ${this.valid_units.join(\", \")}; got: ${units}`);\r\n        }\r\n        get units() {\r\n            return this.spec.units;\r\n        }\r\n        set units(units) {\r\n            this.spec.units = units;\r\n        }\r\n    }\r\n    exports.UnitsSpec = UnitsSpec;\r\n    UnitsSpec.__name__ = \"UnitsSpec\";\r\n    class NumberUnitsSpec extends UnitsSpec {\r\n        array(source) {\r\n            return new types_1.NumberArray(super.array(source));\r\n        }\r\n    }\r\n    exports.NumberUnitsSpec = NumberUnitsSpec;\r\n    NumberUnitsSpec.__name__ = \"NumberUnitsSpec\";\r\n    class BaseCoordinateSpec extends DataSpec {\r\n    }\r\n    exports.BaseCoordinateSpec = BaseCoordinateSpec;\r\n    BaseCoordinateSpec.__name__ = \"BaseCoordinateSpec\";\r\n    class CoordinateSpec extends BaseCoordinateSpec {\r\n    }\r\n    exports.CoordinateSpec = CoordinateSpec;\r\n    CoordinateSpec.__name__ = \"CoordinateSpec\";\r\n    class CoordinateSeqSpec extends BaseCoordinateSpec {\r\n    }\r\n    exports.CoordinateSeqSpec = CoordinateSeqSpec;\r\n    CoordinateSeqSpec.__name__ = \"CoordinateSeqSpec\";\r\n    class CoordinateSeqSeqSeqSpec extends BaseCoordinateSpec {\r\n    }\r\n    exports.CoordinateSeqSeqSeqSpec = CoordinateSeqSeqSeqSpec;\r\n    CoordinateSeqSeqSeqSpec.__name__ = \"CoordinateSeqSeqSeqSpec\";\r\n    class XCoordinateSpec extends CoordinateSpec {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.dimension = \"x\";\r\n        }\r\n    }\r\n    exports.XCoordinateSpec = XCoordinateSpec;\r\n    XCoordinateSpec.__name__ = \"XCoordinateSpec\";\r\n    class YCoordinateSpec extends CoordinateSpec {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.dimension = \"y\";\r\n        }\r\n    }\r\n    exports.YCoordinateSpec = YCoordinateSpec;\r\n    YCoordinateSpec.__name__ = \"YCoordinateSpec\";\r\n    class XCoordinateSeqSpec extends CoordinateSeqSpec {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.dimension = \"x\";\r\n        }\r\n    }\r\n    exports.XCoordinateSeqSpec = XCoordinateSeqSpec;\r\n    XCoordinateSeqSpec.__name__ = \"XCoordinateSeqSpec\";\r\n    class YCoordinateSeqSpec extends CoordinateSeqSpec {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.dimension = \"y\";\r\n        }\r\n    }\r\n    exports.YCoordinateSeqSpec = YCoordinateSeqSpec;\r\n    YCoordinateSeqSpec.__name__ = \"YCoordinateSeqSpec\";\r\n    class XCoordinateSeqSeqSeqSpec extends CoordinateSeqSeqSeqSpec {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.dimension = \"x\";\r\n        }\r\n    }\r\n    exports.XCoordinateSeqSeqSeqSpec = XCoordinateSeqSeqSeqSpec;\r\n    XCoordinateSeqSeqSeqSpec.__name__ = \"XCoordinateSeqSeqSeqSpec\";\r\n    class YCoordinateSeqSeqSeqSpec extends CoordinateSeqSeqSeqSpec {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.dimension = \"y\";\r\n        }\r\n    }\r\n    exports.YCoordinateSeqSeqSeqSpec = YCoordinateSeqSeqSeqSpec;\r\n    YCoordinateSeqSeqSeqSpec.__name__ = \"YCoordinateSeqSeqSeqSpec\";\r\n    class AngleSpec extends NumberUnitsSpec {\r\n        get default_units() { return \"rad\"; }\r\n        get valid_units() { return [...enums.AngleUnits]; }\r\n        normalize(values) {\r\n            if (this.spec.units == \"deg\")\r\n                values = arrayable_1.map(values, (x) => x * Math.PI / 180.0);\r\n            values = arrayable_1.map(values, (x) => -x);\r\n            return super.normalize(values);\r\n        }\r\n    }\r\n    exports.AngleSpec = AngleSpec;\r\n    AngleSpec.__name__ = \"AngleSpec\";\r\n    class DistanceSpec extends NumberUnitsSpec {\r\n        get default_units() { return \"data\"; }\r\n        get valid_units() { return [...enums.SpatialUnits]; }\r\n    }\r\n    exports.DistanceSpec = DistanceSpec;\r\n    DistanceSpec.__name__ = \"DistanceSpec\";\r\n    class BooleanSpec extends DataSpec {\r\n        array(source) {\r\n            return new Uint8Array(super.array(source));\r\n        }\r\n    }\r\n    exports.BooleanSpec = BooleanSpec;\r\n    BooleanSpec.__name__ = \"BooleanSpec\";\r\n    class NumberSpec extends DataSpec {\r\n        array(source) {\r\n            return new types_1.NumberArray(super.array(source));\r\n        }\r\n    }\r\n    exports.NumberSpec = NumberSpec;\r\n    NumberSpec.__name__ = \"NumberSpec\";\r\n    class ColorSpec extends DataSpec {\r\n        array(source) {\r\n            const colors = super.array(source);\r\n            const n = colors.length;\r\n            const array = new types_1.ColorArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                const color = colors[i];\r\n                if (types_2.isNumber(color))\r\n                    array[i] = color;\r\n                else {\r\n                    const rgba = color_1.color2rgba(color);\r\n                    array[i] = color_1.encode_rgba(rgba);\r\n                }\r\n            }\r\n            return array;\r\n        }\r\n    }\r\n    exports.ColorSpec = ColorSpec;\r\n    ColorSpec.__name__ = \"ColorSpec\";\r\n    class FontSizeSpec extends DataSpec {\r\n    }\r\n    exports.FontSizeSpec = FontSizeSpec;\r\n    FontSizeSpec.__name__ = \"FontSizeSpec\";\r\n    class MarkerSpec extends DataSpec {\r\n    }\r\n    exports.MarkerSpec = MarkerSpec;\r\n    MarkerSpec.__name__ = \"MarkerSpec\";\r\n    class StringSpec extends DataSpec {\r\n    }\r\n    exports.StringSpec = StringSpec;\r\n    StringSpec.__name__ = \"StringSpec\";\r\n    class NullStringSpec extends DataSpec {\r\n    }\r\n    exports.NullStringSpec = NullStringSpec;\r\n    NullStringSpec.__name__ = \"NullStringSpec\";\r\n    class NDArraySpec extends DataSpec {\r\n    }\r\n    exports.NDArraySpec = NDArraySpec;\r\n    NDArraySpec.__name__ = \"NDArraySpec\";\r\n}\r\n","/* core\\logging.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    // This is based on https://github.com/pimterry/loglevel\r\n    const types_1 = require(8) /* ./util/types */;\r\n    const object_1 = require(13) /* ./util/object */;\r\n    const _loggers = {};\r\n    class LogLevel {\r\n        constructor(name, level) {\r\n            this.name = name;\r\n            this.level = level;\r\n        }\r\n    }\r\n    exports.LogLevel = LogLevel;\r\n    LogLevel.__name__ = \"LogLevel\";\r\n    class Logger {\r\n        constructor(name, level = Logger.INFO) {\r\n            this._name = name;\r\n            this.set_level(level);\r\n        }\r\n        static get levels() {\r\n            return Object.keys(Logger.log_levels);\r\n        }\r\n        static get(name, level = Logger.INFO) {\r\n            if (name.length > 0) {\r\n                let logger = _loggers[name];\r\n                if (logger == null)\r\n                    _loggers[name] = logger = new Logger(name, level);\r\n                return logger;\r\n            }\r\n            else\r\n                throw new TypeError(\"Logger.get() expects a non-empty string name and an optional log-level\");\r\n        }\r\n        get level() {\r\n            return this.get_level();\r\n        }\r\n        get_level() {\r\n            return this._log_level;\r\n        }\r\n        set_level(log_level) {\r\n            if (log_level instanceof LogLevel)\r\n                this._log_level = log_level;\r\n            else if (types_1.isString(log_level) && Logger.log_levels[log_level] != null)\r\n                this._log_level = Logger.log_levels[log_level];\r\n            else\r\n                throw new Error(\"Logger.set_level() expects a log-level object or a string name of a log-level\");\r\n            const logger_name = `[${this._name}]`;\r\n            for (const [name, log_level] of object_1.entries(Logger.log_levels)) {\r\n                if (log_level.level < this._log_level.level || this._log_level.level === Logger.OFF.level)\r\n                    this[name] = function () { };\r\n                else\r\n                    this[name] = _method_factory(name, logger_name);\r\n            }\r\n        }\r\n        trace(..._args) { }\r\n        debug(..._args) { }\r\n        info(..._args) { }\r\n        warn(..._args) { }\r\n        error(..._args) { }\r\n    }\r\n    exports.Logger = Logger;\r\n    Logger.__name__ = \"Logger\";\r\n    Logger.TRACE = new LogLevel(\"trace\", 0);\r\n    Logger.DEBUG = new LogLevel(\"debug\", 1);\r\n    Logger.INFO = new LogLevel(\"info\", 2);\r\n    Logger.WARN = new LogLevel(\"warn\", 6);\r\n    Logger.ERROR = new LogLevel(\"error\", 7);\r\n    Logger.FATAL = new LogLevel(\"fatal\", 8);\r\n    Logger.OFF = new LogLevel(\"off\", 9);\r\n    Logger.log_levels = {\r\n        trace: Logger.TRACE,\r\n        debug: Logger.DEBUG,\r\n        info: Logger.INFO,\r\n        warn: Logger.WARN,\r\n        error: Logger.ERROR,\r\n        fatal: Logger.FATAL,\r\n        off: Logger.OFF,\r\n    };\r\n    function _method_factory(method_name, logger_name) {\r\n        if (console[method_name] != null)\r\n            return console[method_name].bind(console, logger_name);\r\n        else if (console.log != null)\r\n            return console.log.bind(console, logger_name);\r\n        else\r\n            return function () { };\r\n    }\r\n    exports.logger = Logger.get(\"bokeh\");\r\n    function set_log_level(level) {\r\n        const previous_level = exports.logger.level;\r\n        if (types_1.isString(level) && Logger.log_levels[level] == null) {\r\n            console.log(`[bokeh] unrecognized logging level '${level}' passed to Bokeh.set_log_level(), ignoring`);\r\n            console.log(`[bokeh] valid log levels are: ${Logger.levels.join(', ')}`);\r\n        }\r\n        else {\r\n            console.log(`[bokeh] setting log level to: '${types_1.isString(level) ? level : level.level}'`);\r\n            exports.logger.set_level(level);\r\n        }\r\n        return previous_level;\r\n    }\r\n    exports.set_log_level = set_log_level;\r\n    function with_log_level(level, fn) {\r\n        const original = set_log_level(level);\r\n        try {\r\n            fn();\r\n        }\r\n        finally {\r\n            set_log_level(original);\r\n        }\r\n    }\r\n    exports.with_log_level = with_log_level;\r\n}\r\n","/* core\\enums.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const kinds_1 = require(21) /* ./kinds */;\r\n    exports.Align = kinds_1.Enum(\"start\", \"center\", \"end\");\r\n    exports.Anchor = kinds_1.Enum(\"top_left\", \"top_center\", \"top_right\", \"center_left\", \"center\", \"center_right\", \"bottom_left\", \"bottom_center\", \"bottom_right\");\r\n    exports.AngleUnits = kinds_1.Enum(\"deg\", \"rad\");\r\n    exports.BoxOrigin = kinds_1.Enum(\"corner\", \"center\");\r\n    exports.ButtonType = kinds_1.Enum(\"default\", \"primary\", \"success\", \"warning\", \"danger\");\r\n    exports.CalendarPosition = kinds_1.Enum(\"auto\", \"above\", \"below\");\r\n    exports.Dimension = kinds_1.Enum(\"width\", \"height\");\r\n    exports.Dimensions = kinds_1.Enum(\"width\", \"height\", \"both\");\r\n    exports.Direction = kinds_1.Enum(\"clock\", \"anticlock\");\r\n    exports.Distribution = kinds_1.Enum(\"uniform\", \"normal\");\r\n    exports.FontStyle = kinds_1.Enum(\"normal\", \"italic\", \"bold\", \"bold italic\");\r\n    exports.HatchPatternType = kinds_1.Enum('blank', 'dot', 'ring', 'horizontal_line', 'vertical_line', 'cross', 'horizontal_dash', 'vertical_dash', 'spiral', 'right_diagonal_line', 'left_diagonal_line', 'diagonal_cross', 'right_diagonal_dash', 'left_diagonal_dash', 'horizontal_wave', 'vertical_wave', 'criss_cross', ' ', '.', 'o', '-', '|', '+', '\"', ':', '@', '/', '\\\\', 'x', ',', '`', 'v', '>', '*');\r\n    exports.HTTPMethod = kinds_1.Enum(\"POST\", \"GET\");\r\n    exports.HexTileOrientation = kinds_1.Enum(\"pointytop\", \"flattop\");\r\n    exports.HoverMode = kinds_1.Enum(\"mouse\", \"hline\", \"vline\");\r\n    exports.LatLon = kinds_1.Enum(\"lat\", \"lon\");\r\n    exports.LegendClickPolicy = kinds_1.Enum(\"none\", \"hide\", \"mute\");\r\n    exports.LegendLocation = exports.Anchor;\r\n    exports.LineCap = kinds_1.Enum(\"butt\", \"round\", \"square\");\r\n    exports.LineJoin = kinds_1.Enum(\"miter\", \"round\", \"bevel\");\r\n    exports.LinePolicy = kinds_1.Enum(\"prev\", \"next\", \"nearest\", \"interp\", \"none\");\r\n    exports.Location = kinds_1.Enum(\"above\", \"below\", \"left\", \"right\");\r\n    exports.Logo = kinds_1.Enum(\"normal\", \"grey\");\r\n    exports.MarkerType = kinds_1.Enum(\"asterisk\", \"circle\", \"circle_cross\", \"circle_dot\", \"circle_x\", \"circle_y\", \"cross\", \"dash\", \"diamond\", \"diamond_cross\", \"diamond_dot\", \"dot\", \"hex\", \"hex_dot\", \"inverted_triangle\", \"plus\", \"square\", \"square_cross\", \"square_dot\", \"square_pin\", \"square_x\", \"triangle\", \"triangle_dot\", \"triangle_pin\", \"x\", \"y\");\r\n    exports.MutedPolicy = kinds_1.Enum(\"show\", \"ignore\");\r\n    exports.Orientation = kinds_1.Enum(\"vertical\", \"horizontal\");\r\n    exports.OutputBackend = kinds_1.Enum(\"canvas\", \"svg\", \"webgl\");\r\n    exports.PaddingUnits = kinds_1.Enum(\"percent\", \"absolute\");\r\n    exports.Place = kinds_1.Enum(\"above\", \"below\", \"left\", \"right\", \"center\");\r\n    exports.PointPolicy = kinds_1.Enum(\"snap_to_data\", \"follow_mouse\", \"none\");\r\n    exports.RadiusDimension = kinds_1.Enum(\"x\", \"y\", \"max\", \"min\");\r\n    exports.RenderLevel = kinds_1.Enum(\"image\", \"underlay\", \"glyph\", \"guide\", \"annotation\", \"overlay\");\r\n    exports.RenderMode = kinds_1.Enum(\"canvas\", \"css\");\r\n    exports.ResetPolicy = kinds_1.Enum(\"standard\", \"event_only\");\r\n    exports.RoundingFunction = kinds_1.Enum(\"round\", \"nearest\", \"floor\", \"rounddown\", \"ceil\", \"roundup\");\r\n    exports.SelectionMode = kinds_1.Enum(\"replace\", \"append\", \"intersect\", \"subtract\");\r\n    exports.Side = kinds_1.Enum(\"above\", \"below\", \"left\", \"right\");\r\n    exports.SizingMode = kinds_1.Enum(\"stretch_width\", \"stretch_height\", \"stretch_both\", \"scale_width\", \"scale_height\", \"scale_both\", \"fixed\");\r\n    exports.Sort = kinds_1.Enum(\"ascending\", \"descending\");\r\n    exports.SpatialUnits = kinds_1.Enum(\"screen\", \"data\");\r\n    exports.StartEnd = kinds_1.Enum(\"start\", \"end\");\r\n    exports.StepMode = kinds_1.Enum(\"after\", \"before\", \"center\");\r\n    exports.TapBehavior = kinds_1.Enum(\"select\", \"inspect\");\r\n    exports.TextAlign = kinds_1.Enum(\"left\", \"right\", \"center\");\r\n    exports.TextBaseline = kinds_1.Enum(\"top\", \"middle\", \"bottom\", \"alphabetic\", \"hanging\", \"ideographic\");\r\n    exports.TextureRepetition = kinds_1.Enum(\"repeat\", \"repeat_x\", \"repeat_y\", \"no_repeat\");\r\n    exports.TickLabelOrientation = kinds_1.Enum(\"vertical\", \"horizontal\", \"parallel\", \"normal\");\r\n    exports.TooltipAttachment = kinds_1.Enum(\"horizontal\", \"vertical\", \"left\", \"right\", \"above\", \"below\");\r\n    exports.UpdateMode = kinds_1.Enum(\"replace\", \"append\");\r\n    exports.VerticalAlign = kinds_1.Enum(\"top\", \"middle\", \"bottom\");\r\n}\r\n","/* core\\kinds.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const tp = tslib_1.__importStar(require(8) /* ./util/types */);\r\n    const color_1 = require(22) /* ./util/color */;\r\n    class Kind {\r\n    }\r\n    exports.Kind = Kind;\r\n    Kind.__name__ = \"Kind\";\r\n    (function (Kinds) {\r\n        class Any extends Kind {\r\n            valid(_value) {\r\n                return true;\r\n            }\r\n        }\r\n        Any.__name__ = \"Any\";\r\n        Kinds.Any = Any;\r\n        class Unknown extends Kind {\r\n            valid(_value) {\r\n                return true;\r\n            }\r\n        }\r\n        Unknown.__name__ = \"Unknown\";\r\n        Kinds.Unknown = Unknown;\r\n        class Boolean extends Kind {\r\n            valid(value) {\r\n                return tp.isBoolean(value);\r\n            }\r\n        }\r\n        Boolean.__name__ = \"Boolean\";\r\n        Kinds.Boolean = Boolean;\r\n        class Ref extends Kind {\r\n            constructor(obj_type) {\r\n                super();\r\n                this.obj_type = obj_type;\r\n            }\r\n            valid(value) {\r\n                // XXX: disable validation for now, because object graph\r\n                // initialization depends on this.\r\n                value;\r\n                return true;\r\n                //return value instanceof this.obj_type\r\n            }\r\n        }\r\n        Ref.__name__ = \"Ref\";\r\n        Kinds.Ref = Ref;\r\n        class Number extends Kind {\r\n            valid(value) {\r\n                return tp.isNumber(value);\r\n            }\r\n        }\r\n        Number.__name__ = \"Number\";\r\n        Kinds.Number = Number;\r\n        class Int extends Number {\r\n            valid(value) {\r\n                return super.valid(value) && tp.isInteger(value);\r\n            }\r\n        }\r\n        Int.__name__ = \"Int\";\r\n        Kinds.Int = Int;\r\n        class Or extends Kind {\r\n            constructor(types) {\r\n                super();\r\n                this.types = types;\r\n                this.types = types;\r\n            }\r\n            valid(value) {\r\n                return this.types.some((type) => type.valid(value));\r\n            }\r\n        }\r\n        Or.__name__ = \"Or\";\r\n        Kinds.Or = Or;\r\n        class Tuple extends Kind {\r\n            constructor(types) {\r\n                super();\r\n                this.types = types;\r\n                this.types = types;\r\n            }\r\n            valid(value) {\r\n                if (!tp.isArray(value))\r\n                    return false;\r\n                for (let i = 0; i < this.types.length; i++) {\r\n                    const type = this.types[i];\r\n                    const item = value[i];\r\n                    if (!type.valid(item))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        Tuple.__name__ = \"Tuple\";\r\n        Kinds.Tuple = Tuple;\r\n        class Array extends Kind {\r\n            constructor(item_type) {\r\n                super();\r\n                this.item_type = item_type;\r\n            }\r\n            valid(value) {\r\n                return tp.isArray(value) && value.every((item) => this.item_type.valid(item));\r\n            }\r\n        }\r\n        Array.__name__ = \"Array\";\r\n        Kinds.Array = Array;\r\n        class Null extends Kind {\r\n            valid(value) {\r\n                return value === null;\r\n            }\r\n        }\r\n        Null.__name__ = \"Null\";\r\n        Kinds.Null = Null;\r\n        class Nullable extends Kind {\r\n            constructor(base_type) {\r\n                super();\r\n                this.base_type = base_type;\r\n            }\r\n            valid(value) {\r\n                return value === null || this.base_type.valid(value);\r\n            }\r\n        }\r\n        Nullable.__name__ = \"Nullable\";\r\n        Kinds.Nullable = Nullable;\r\n        class String extends Kind {\r\n            valid(value) {\r\n                return tp.isString(value);\r\n            }\r\n        }\r\n        String.__name__ = \"String\";\r\n        Kinds.String = String;\r\n        class Enum extends Kind {\r\n            constructor(values) {\r\n                super();\r\n                this.values = new Set(values);\r\n            }\r\n            valid(value) {\r\n                return this.values.has(value);\r\n            }\r\n            *[Symbol.iterator]() {\r\n                yield* this.values;\r\n            }\r\n        }\r\n        Enum.__name__ = \"Enum\";\r\n        Kinds.Enum = Enum;\r\n        class Struct extends Kind {\r\n            constructor(item_type) {\r\n                super();\r\n                this.item_type = item_type;\r\n            }\r\n            valid(value) {\r\n                if (!tp.isPlainObject(value))\r\n                    return false;\r\n                for (const key in value) {\r\n                    if (value.hasOwnProperty(key)) {\r\n                        const item = value[key];\r\n                        if (!this.item_type.valid(item))\r\n                            return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        Struct.__name__ = \"Struct\";\r\n        Kinds.Struct = Struct;\r\n        class Dict extends Kind {\r\n            constructor(key_type, item_type) {\r\n                super();\r\n                this.key_type = key_type;\r\n                this.item_type = item_type;\r\n            }\r\n            valid(value) {\r\n                if (!(value instanceof Map))\r\n                    return false;\r\n                for (const [key, item] of value.entries()) {\r\n                    if (!(this.key_type.valid(key) && this.item_type.valid(item)))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        Dict.__name__ = \"Dict\";\r\n        Kinds.Dict = Dict;\r\n        class Color extends Kind {\r\n            valid(value) {\r\n                return tp.isString(value) && color_1.is_color(value);\r\n            }\r\n        }\r\n        Color.__name__ = \"Color\";\r\n        Kinds.Color = Color;\r\n        class Percent extends Number {\r\n            valid(value) {\r\n                return super.valid(value) && 0 <= value && value <= 1.0;\r\n            }\r\n        }\r\n        Percent.__name__ = \"Percent\";\r\n        Kinds.Percent = Percent;\r\n    })(exports.Kinds || (exports.Kinds = {}));\r\n    exports.Any = new exports.Kinds.Any();\r\n    exports.Unknown = new exports.Kinds.Unknown();\r\n    exports.Boolean = new exports.Kinds.Boolean();\r\n    exports.Number = new exports.Kinds.Number();\r\n    exports.Int = new exports.Kinds.Int();\r\n    exports.String = new exports.Kinds.String();\r\n    exports.Null = new exports.Kinds.Null();\r\n    exports.Nullable = (base_type) => new exports.Kinds.Nullable(base_type);\r\n    exports.Or = (...types) => new exports.Kinds.Or(types);\r\n    exports.Tuple = (...types) => new exports.Kinds.Tuple(types);\r\n    exports.Array = (item_type) => new exports.Kinds.Array(item_type);\r\n    exports.Struct = (item_type) => new exports.Kinds.Struct(item_type);\r\n    exports.Dict = (key_type, item_type) => new exports.Kinds.Dict(key_type, item_type);\r\n    exports.Enum = (...values) => new exports.Kinds.Enum(values);\r\n    exports.Ref = (obj_type) => new exports.Kinds.Ref(obj_type);\r\n    exports.Percent = new exports.Kinds.Percent();\r\n    exports.Color = new exports.Kinds.Color();\r\n    exports.Auto = exports.Enum(\"auto\");\r\n    exports.FontSize = exports.String;\r\n    exports.Font = exports.String;\r\n    exports.Angle = exports.Number;\r\n}\r\n","/* core\\util\\color.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const svg_colors_1 = require(23) /* ./svg_colors */;\r\n    const array_1 = require(9) /* ./array */;\r\n    function is_color(value) {\r\n        return svg_colors_1.is_svg_color(value.toLowerCase()) || value.substring(0, 1) == \"#\" || valid_rgb(value);\r\n    }\r\n    exports.is_color = is_color;\r\n    function _component2hex(v) {\r\n        const h = Number(v).toString(16);\r\n        return h.length == 1 ? `0${h}` : h;\r\n    }\r\n    function rgb2hex(r, g, b) {\r\n        const R = _component2hex(r & 0xFF);\r\n        const G = _component2hex(g & 0xFF);\r\n        const B = _component2hex(b & 0xFF);\r\n        return `#${R}${G}${B}`;\r\n    }\r\n    exports.rgb2hex = rgb2hex;\r\n    function color2hex(color) {\r\n        color = color + '';\r\n        if (color.indexOf('#') == 0)\r\n            return color;\r\n        else if (svg_colors_1.is_svg_color(color))\r\n            return svg_colors_1.svg_colors[color];\r\n        else if (color.indexOf('rgb') == 0) {\r\n            const rgb = color.replace(/^rgba?\\(|\\s+|\\)$/g, '').split(',');\r\n            let hex = rgb.slice(0, 3).map(_component2hex).join('');\r\n            if (rgb.length == 4)\r\n                hex += _component2hex(Math.floor(parseFloat(rgb[3]) * 255));\r\n            return `#${hex.slice(0, 8)}`; // can also be rgba\r\n        }\r\n        else\r\n            return color;\r\n    }\r\n    exports.color2hex = color2hex;\r\n    function encode_rgba([r, g, b, a]) {\r\n        return (r * 255 | 0) << 24 | (g * 255 | 0) << 16 | (b * 255 | 0) << 8 | (a * 255 | 0);\r\n    }\r\n    exports.encode_rgba = encode_rgba;\r\n    function decode_rgba(rgba) {\r\n        const r = ((rgba >> 24) & 0xff) / 255;\r\n        const g = ((rgba >> 16) & 0xff) / 255;\r\n        const b = ((rgba >> 8) & 0xff) / 255;\r\n        const a = ((rgba >> 0) & 0xff) / 255;\r\n        return [r, g, b, a];\r\n    }\r\n    exports.decode_rgba = decode_rgba;\r\n    function color2rgba(color, alpha = 1.0) {\r\n        if (!color) // NaN, null, '', etc.\r\n            return [0, 0, 0, 0]; // transparent\r\n        // Convert to hex and then to clean version of 6 or 8 chars\r\n        let hex = color2hex(color);\r\n        hex = hex.replace(/ |#/g, '');\r\n        if (hex.length <= 4) {\r\n            hex = hex.replace(/(.)/g, '$1$1');\r\n        }\r\n        // Convert pairs to numbers\r\n        const rgba = hex.match(/../g).map((i) => parseInt(i, 16) / 255);\r\n        // Ensure correct length, add alpha if necessary\r\n        while (rgba.length < 3)\r\n            rgba.push(0);\r\n        if (rgba.length < 4)\r\n            rgba.push(alpha);\r\n        return rgba.slice(0, 4);\r\n    }\r\n    exports.color2rgba = color2rgba;\r\n    function valid_rgb(value) {\r\n        let params;\r\n        switch (value.substring(0, 4)) {\r\n            case \"rgba\": {\r\n                params = { start: \"rgba(\", len: 4, alpha: true };\r\n                break;\r\n            }\r\n            case \"rgb(\": {\r\n                params = { start: \"rgb(\", len: 3, alpha: false };\r\n                break;\r\n            }\r\n            default:\r\n                return false;\r\n        }\r\n        // if '.' and then ',' found, we know decimals are used on rgb\r\n        if (new RegExp(\".*?(\\\\.).*(,)\").test(value))\r\n            return false;\r\n        // throw new Error(`color expects integers for rgb in rgb/rgba tuple, received ${value}`)\r\n        // extract the numerical values from inside parens\r\n        const contents = value.replace(params.start, \"\").replace(\")\", \"\").split(',').map(parseFloat);\r\n        // check length of array based on rgb/rgba\r\n        if (contents.length != params.len)\r\n            return false;\r\n        // throw new Error(`color expects rgba ${params.len}-tuple, received ${value}`)\r\n        // check for valid numerical values for rgba\r\n        if (params.alpha && !(0 <= contents[3] && contents[3] <= 1))\r\n            return false;\r\n        // throw new Error(\"color expects rgba 4-tuple to have alpha value between 0 and 1\")\r\n        if (array_1.includes(contents.slice(0, 3).map((rgb) => 0 <= rgb && rgb <= 255), false))\r\n            return false;\r\n        // throw new Error(\"color expects rgb to have value between 0 and 255\")\r\n        return true;\r\n    }\r\n    exports.valid_rgb = valid_rgb;\r\n}\r\n","/* core\\util\\svg_colors.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.svg_colors = {\r\n        indianred: \"#CD5C5C\",\r\n        lightcoral: \"#F08080\",\r\n        salmon: \"#FA8072\",\r\n        darksalmon: \"#E9967A\",\r\n        lightsalmon: \"#FFA07A\",\r\n        crimson: \"#DC143C\",\r\n        red: \"#FF0000\",\r\n        firebrick: \"#B22222\",\r\n        darkred: \"#8B0000\",\r\n        pink: \"#FFC0CB\",\r\n        lightpink: \"#FFB6C1\",\r\n        hotpink: \"#FF69B4\",\r\n        deeppink: \"#FF1493\",\r\n        mediumvioletred: \"#C71585\",\r\n        palevioletred: \"#DB7093\",\r\n        coral: \"#FF7F50\",\r\n        tomato: \"#FF6347\",\r\n        orangered: \"#FF4500\",\r\n        darkorange: \"#FF8C00\",\r\n        orange: \"#FFA500\",\r\n        gold: \"#FFD700\",\r\n        yellow: \"#FFFF00\",\r\n        lightyellow: \"#FFFFE0\",\r\n        lemonchiffon: \"#FFFACD\",\r\n        lightgoldenrodyellow: \"#FAFAD2\",\r\n        papayawhip: \"#FFEFD5\",\r\n        moccasin: \"#FFE4B5\",\r\n        peachpuff: \"#FFDAB9\",\r\n        palegoldenrod: \"#EEE8AA\",\r\n        khaki: \"#F0E68C\",\r\n        darkkhaki: \"#BDB76B\",\r\n        lavender: \"#E6E6FA\",\r\n        thistle: \"#D8BFD8\",\r\n        plum: \"#DDA0DD\",\r\n        violet: \"#EE82EE\",\r\n        orchid: \"#DA70D6\",\r\n        fuchsia: \"#FF00FF\",\r\n        magenta: \"#FF00FF\",\r\n        mediumorchid: \"#BA55D3\",\r\n        mediumpurple: \"#9370DB\",\r\n        blueviolet: \"#8A2BE2\",\r\n        darkviolet: \"#9400D3\",\r\n        darkorchid: \"#9932CC\",\r\n        darkmagenta: \"#8B008B\",\r\n        purple: \"#800080\",\r\n        indigo: \"#4B0082\",\r\n        slateblue: \"#6A5ACD\",\r\n        darkslateblue: \"#483D8B\",\r\n        mediumslateblue: \"#7B68EE\",\r\n        greenyellow: \"#ADFF2F\",\r\n        chartreuse: \"#7FFF00\",\r\n        lawngreen: \"#7CFC00\",\r\n        lime: \"#00FF00\",\r\n        limegreen: \"#32CD32\",\r\n        palegreen: \"#98FB98\",\r\n        lightgreen: \"#90EE90\",\r\n        mediumspringgreen: \"#00FA9A\",\r\n        springgreen: \"#00FF7F\",\r\n        mediumseagreen: \"#3CB371\",\r\n        seagreen: \"#2E8B57\",\r\n        forestgreen: \"#228B22\",\r\n        green: \"#008000\",\r\n        darkgreen: \"#006400\",\r\n        yellowgreen: \"#9ACD32\",\r\n        olivedrab: \"#6B8E23\",\r\n        olive: \"#808000\",\r\n        darkolivegreen: \"#556B2F\",\r\n        mediumaquamarine: \"#66CDAA\",\r\n        darkseagreen: \"#8FBC8F\",\r\n        lightseagreen: \"#20B2AA\",\r\n        darkcyan: \"#008B8B\",\r\n        teal: \"#008080\",\r\n        aqua: \"#00FFFF\",\r\n        cyan: \"#00FFFF\",\r\n        lightcyan: \"#E0FFFF\",\r\n        paleturquoise: \"#AFEEEE\",\r\n        aquamarine: \"#7FFFD4\",\r\n        turquoise: \"#40E0D0\",\r\n        mediumturquoise: \"#48D1CC\",\r\n        darkturquoise: \"#00CED1\",\r\n        cadetblue: \"#5F9EA0\",\r\n        steelblue: \"#4682B4\",\r\n        lightsteelblue: \"#B0C4DE\",\r\n        powderblue: \"#B0E0E6\",\r\n        lightblue: \"#ADD8E6\",\r\n        skyblue: \"#87CEEB\",\r\n        lightskyblue: \"#87CEFA\",\r\n        deepskyblue: \"#00BFFF\",\r\n        dodgerblue: \"#1E90FF\",\r\n        cornflowerblue: \"#6495ED\",\r\n        royalblue: \"#4169E1\",\r\n        blue: \"#0000FF\",\r\n        mediumblue: \"#0000CD\",\r\n        darkblue: \"#00008B\",\r\n        navy: \"#000080\",\r\n        midnightblue: \"#191970\",\r\n        cornsilk: \"#FFF8DC\",\r\n        blanchedalmond: \"#FFEBCD\",\r\n        bisque: \"#FFE4C4\",\r\n        navajowhite: \"#FFDEAD\",\r\n        wheat: \"#F5DEB3\",\r\n        burlywood: \"#DEB887\",\r\n        tan: \"#D2B48C\",\r\n        rosybrown: \"#BC8F8F\",\r\n        sandybrown: \"#F4A460\",\r\n        goldenrod: \"#DAA520\",\r\n        darkgoldenrod: \"#B8860B\",\r\n        peru: \"#CD853F\",\r\n        chocolate: \"#D2691E\",\r\n        saddlebrown: \"#8B4513\",\r\n        sienna: \"#A0522D\",\r\n        brown: \"#A52A2A\",\r\n        maroon: \"#800000\",\r\n        white: \"#FFFFFF\",\r\n        snow: \"#FFFAFA\",\r\n        honeydew: \"#F0FFF0\",\r\n        mintcream: \"#F5FFFA\",\r\n        azure: \"#F0FFFF\",\r\n        aliceblue: \"#F0F8FF\",\r\n        ghostwhite: \"#F8F8FF\",\r\n        whitesmoke: \"#F5F5F5\",\r\n        seashell: \"#FFF5EE\",\r\n        beige: \"#F5F5DC\",\r\n        oldlace: \"#FDF5E6\",\r\n        floralwhite: \"#FFFAF0\",\r\n        ivory: \"#FFFFF0\",\r\n        antiquewhite: \"#FAEBD7\",\r\n        linen: \"#FAF0E6\",\r\n        lavenderblush: \"#FFF0F5\",\r\n        mistyrose: \"#FFE4E1\",\r\n        gainsboro: \"#DCDCDC\",\r\n        lightgray: \"#D3D3D3\",\r\n        lightgrey: \"#D3D3D3\",\r\n        silver: \"#C0C0C0\",\r\n        darkgray: \"#A9A9A9\",\r\n        darkgrey: \"#A9A9A9\",\r\n        gray: \"#808080\",\r\n        grey: \"#808080\",\r\n        dimgray: \"#696969\",\r\n        dimgrey: \"#696969\",\r\n        lightslategray: \"#778899\",\r\n        lightslategrey: \"#778899\",\r\n        slategray: \"#708090\",\r\n        slategrey: \"#708090\",\r\n        darkslategray: \"#2F4F4F\",\r\n        darkslategrey: \"#2F4F4F\",\r\n        black: \"#000000\",\r\n    };\r\n    function is_svg_color(color) {\r\n        return color in exports.svg_colors;\r\n    }\r\n    exports.is_svg_color = is_svg_color;\r\n}\r\n","/* core\\types.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.NumberArray = Float32Array;\r\n    exports.ColorArray = Uint32Array;\r\n    const eq_1 = require(25) /* ./util/eq */;\r\n    class RaggedArray {\r\n        constructor(offsets, array) {\r\n            this.offsets = offsets;\r\n            this.array = array;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.arrays(this.offsets, that.offsets) && cmp.arrays(this.array, that.array);\r\n        }\r\n        get length() {\r\n            return this.offsets.length;\r\n        }\r\n        clone() {\r\n            return new RaggedArray(new Uint32Array(this.offsets), new exports.NumberArray(this.array));\r\n        }\r\n        static from(items) {\r\n            const n = items.length;\r\n            const offsets = new Uint32Array(n);\r\n            let offset = 0;\r\n            for (let i = 0; i < n; i++) {\r\n                const length = items[i].length;\r\n                offsets[i] = offset;\r\n                offset += length;\r\n            }\r\n            const array = new exports.NumberArray(offset);\r\n            for (let i = 0; i < n; i++) {\r\n                array.set(items[i], offsets[i]);\r\n            }\r\n            return new RaggedArray(offsets, array);\r\n        }\r\n        *[Symbol.iterator]() {\r\n            const { offsets, length } = this;\r\n            for (let i = 0; i < length; i++) {\r\n                yield this.array.subarray(offsets[i], offsets[i + 1]);\r\n            }\r\n        }\r\n        get(i) {\r\n            const { offsets } = this;\r\n            return this.array.subarray(offsets[i], offsets[i + 1]);\r\n        }\r\n        set(i, array) {\r\n            this.array.set(array, this.offsets[i]);\r\n        }\r\n    }\r\n    exports.RaggedArray = RaggedArray;\r\n    RaggedArray.__name__ = \"RaggedArray\";\r\n    RaggedArray[Symbol.toStringTag] = \"RaggedArray\";\r\n    var data_structures_1 = require(26) /* ./util/data_structures */;\r\n    exports.Indices = data_structures_1.BitSet;\r\n}\r\n","/* core\\util\\eq.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    // Based on Underscore.js 1.8.3 (http://underscorejs.org)\r\n    exports.equals = Symbol(\"equals\");\r\n    exports.wildcard = Symbol(\"wildcard\");\r\n    const toString = Object.prototype.toString;\r\n    class Comparator {\r\n        constructor() {\r\n            this.a_stack = [];\r\n            this.b_stack = [];\r\n        }\r\n        eq(a, b) {\r\n            if (Object.is(a, b))\r\n                return true;\r\n            if (a === exports.wildcard || b === exports.wildcard)\r\n                return true;\r\n            if (a == null || b == null)\r\n                return a === b;\r\n            const class_name = toString.call(a);\r\n            if (class_name != toString.call(b))\r\n                return false;\r\n            switch (class_name) {\r\n                case '[object Number]':\r\n                    return this.numbers(a, b);\r\n                case '[object RegExp]':\r\n                case '[object String]':\r\n                    return `${a}` == `${b}`;\r\n                case '[object Date]':\r\n                case '[object Boolean]':\r\n                    return +a === +b;\r\n            }\r\n            // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n            // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n            // Initializing stack of traversed objects.\r\n            // It's done here since we only need them for objects and arrays comparison.\r\n            const { a_stack, b_stack } = this;\r\n            let length = a_stack.length;\r\n            while (length--) {\r\n                // Linear search. Performance is inversely proportional to the number of\r\n                // unique nested structures.\r\n                if (a_stack[length] === a)\r\n                    return b_stack[length] === b;\r\n            }\r\n            a_stack.push(a);\r\n            b_stack.push(b);\r\n            const result = (() => {\r\n                if (a[exports.equals] != null && b[exports.equals] != null) {\r\n                    return a[exports.equals](b, this);\r\n                }\r\n                switch (class_name) {\r\n                    case \"[object Array]\":\r\n                    case \"[object Uint8Array]\":\r\n                    case \"[object Int8Array]\":\r\n                    case \"[object Uint16Array]\":\r\n                    case \"[object Int16Array]\":\r\n                    case \"[object Uint32Array]\":\r\n                    case \"[object Int32Array]\":\r\n                    case \"[object Float32Array]\":\r\n                    case \"[object Float64Array]\": {\r\n                        return this.arrays(a, b);\r\n                    }\r\n                    case \"[object Map]\":\r\n                        return this.maps(a, b);\r\n                    case \"[object Set]\":\r\n                        return this.sets(a, b);\r\n                    case \"[object Object]\": {\r\n                        if (a.constructor == b.constructor && (a.constructor == null || a.constructor === Object)) {\r\n                            return this.objects(a, b);\r\n                        }\r\n                    }\r\n                    case \"[object Function]\": {\r\n                        if (a.constructor == b.constructor && a.constructor === Function) {\r\n                            return this.eq(`${a}`, `${b}`);\r\n                        }\r\n                    }\r\n                }\r\n                if (a instanceof Node) {\r\n                    return this.nodes(a, b);\r\n                }\r\n                throw Error(`can't compare objects of type ${class_name}`);\r\n            })();\r\n            a_stack.pop();\r\n            b_stack.pop();\r\n            return result;\r\n        }\r\n        numbers(a, b) {\r\n            return Object.is(a, b);\r\n        }\r\n        arrays(a, b) {\r\n            const { length } = a;\r\n            if (length != b.length)\r\n                return false;\r\n            for (let i = 0; i < length; i++) {\r\n                if (!this.eq(a[i], b[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        iterables(a, b) {\r\n            const ai = a[Symbol.iterator]();\r\n            const bi = b[Symbol.iterator]();\r\n            while (true) {\r\n                const an = ai.next();\r\n                const bn = bi.next();\r\n                if (an.done && bn.done)\r\n                    return true;\r\n                if (an.done || bn.done)\r\n                    return false;\r\n                if (!this.eq(an.value, bn.value))\r\n                    return false;\r\n            }\r\n        }\r\n        maps(a, b) {\r\n            if (a.size != b.size)\r\n                return false;\r\n            for (const [key, val] of a) {\r\n                if (!b.has(key) || !this.eq(val, b.get(key)))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        sets(a, b) {\r\n            if (a.size != b.size)\r\n                return false;\r\n            for (const key of a) {\r\n                if (!b.has(key))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        objects(a, b) {\r\n            const keys = Object.keys(a);\r\n            if (keys.length != Object.keys(b).length)\r\n                return false;\r\n            for (const key of keys) {\r\n                if (!b.hasOwnProperty(key) || !this.eq(a[key], b[key]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        nodes(a, b) {\r\n            if (a.nodeType != b.nodeType)\r\n                return false;\r\n            if (a.textContent != b.textContent)\r\n                return false;\r\n            if (!this.iterables(a.childNodes, b.childNodes))\r\n                return false;\r\n            return true;\r\n        }\r\n    }\r\n    exports.Comparator = Comparator;\r\n    Comparator.__name__ = \"Comparator\";\r\n    const { abs } = Math;\r\n    class SimilarComparator extends Comparator {\r\n        constructor(tolerance = 1e-4) {\r\n            super();\r\n            this.tolerance = tolerance;\r\n        }\r\n        numbers(a, b) {\r\n            return super.numbers(a, b) || abs(a - b) < this.tolerance;\r\n        }\r\n    }\r\n    exports.SimilarComparator = SimilarComparator;\r\n    SimilarComparator.__name__ = \"SimilarComparator\";\r\n    function is_equal(a, b) {\r\n        const comparator = new Comparator();\r\n        return comparator.eq(a, b);\r\n    }\r\n    exports.is_equal = is_equal;\r\n    function is_similar(a, b, tolerance) {\r\n        const comparator = new SimilarComparator(tolerance);\r\n        return comparator.eq(a, b);\r\n    }\r\n    exports.is_similar = is_similar;\r\n    /** @deprecated */\r\n    exports.isEqual = is_equal;\r\n}\r\n","/* core\\util\\data_structures.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const assert_1 = require(11) /* ./assert */;\r\n    const array_1 = require(9) /* ./array */;\r\n    const eq_1 = require(25) /* ./eq */;\r\n    class BitSet {\r\n        constructor(size, init = 0) {\r\n            this.size = size;\r\n            this[Symbol.toStringTag] = \"BitSet\";\r\n            this._count = null;\r\n            this._nwords = Math.ceil(size / 32);\r\n            if (init == 0 || init == 1) {\r\n                this._array = new Uint32Array(this._nwords);\r\n                if (init == 1) {\r\n                    this._array.fill(0xffffffff);\r\n                }\r\n            }\r\n            else {\r\n                assert_1.assert(init.length == this._nwords, \"Initializer size mismatch\");\r\n                this._array = init;\r\n            }\r\n        }\r\n        clone() {\r\n            return new BitSet(this.size, new Uint32Array(this._array));\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            if (!cmp.eq(this.size, that.size))\r\n                return false;\r\n            const { _nwords } = this;\r\n            const trailing = this.size % _nwords;\r\n            const n = trailing == 0 ? _nwords : _nwords - 1;\r\n            for (let i = 0; i < n; i++) {\r\n                if (this._array[i] != that._array[i])\r\n                    return false;\r\n            }\r\n            if (trailing == 0)\r\n                return true;\r\n            else {\r\n                const msb = 1 << (trailing - 1);\r\n                const mask = (msb - 1) ^ msb;\r\n                return (this._array[n] & mask) == (that._array[n] & mask);\r\n            }\r\n        }\r\n        static all_set(size) {\r\n            return new BitSet(size, 1);\r\n        }\r\n        static all_unset(size) {\r\n            return new BitSet(size, 0);\r\n        }\r\n        static from_indices(size, indices) {\r\n            const bits = new BitSet(size);\r\n            for (const i of indices) {\r\n                bits.set(i);\r\n            }\r\n            return bits;\r\n        }\r\n        static from_booleans(size, booleans) {\r\n            const bits = new BitSet(size);\r\n            const n = Math.min(size, booleans.length);\r\n            for (let i = 0; i < n; i++) {\r\n                if (booleans[i])\r\n                    bits.set(i);\r\n            }\r\n            return bits;\r\n        }\r\n        _check_bounds(k) {\r\n            assert_1.assert(0 <= k && k < this.size, \"Out of bounds\");\r\n        }\r\n        get(k) {\r\n            this._check_bounds(k);\r\n            const i = k >>> 5; // Math.floor(k/32)\r\n            const j = k & 0x1f; // k % 32\r\n            return !!((this._array[i] >> j) & 0x1);\r\n        }\r\n        set(k, v = true) {\r\n            this._check_bounds(k);\r\n            this._count = null;\r\n            const i = k >>> 5; // Math.floor(k/32)\r\n            const j = k & 0x1f; // k % 32\r\n            if (v)\r\n                this._array[i] |= 0x1 << j;\r\n            else\r\n                this._array[i] &= ~(0x1 << j);\r\n        }\r\n        unset(k) {\r\n            this.set(k, false);\r\n        }\r\n        *[Symbol.iterator]() {\r\n            yield* this.ones();\r\n        }\r\n        get count() {\r\n            let count = this._count;\r\n            if (count == null)\r\n                this._count = count = this._get_count();\r\n            return count;\r\n        }\r\n        _get_count() {\r\n            const { _array, _nwords, size } = this;\r\n            let c = 0;\r\n            for (let k = 0, i = 0; i < _nwords; i++) {\r\n                const word = _array[i];\r\n                if (word == 0) {\r\n                    k += 32;\r\n                }\r\n                else {\r\n                    for (let j = 0; j < 32 && k < size; j++, k++) {\r\n                        if ((word >>> j) & 0x1)\r\n                            c += 1;\r\n                    }\r\n                }\r\n            }\r\n            return c;\r\n        }\r\n        *ones() {\r\n            const { _array, _nwords, size } = this;\r\n            for (let k = 0, i = 0; i < _nwords; i++) {\r\n                const word = _array[i];\r\n                if (word == 0) {\r\n                    k += 32;\r\n                    continue;\r\n                }\r\n                for (let j = 0; j < 32 && k < size; j++, k++) {\r\n                    if ((word >>> j) & 0x1)\r\n                        yield k;\r\n                }\r\n            }\r\n        }\r\n        *zeros() {\r\n            const { _array, _nwords, size } = this;\r\n            for (let k = 0, i = 0; i < _nwords; i++) {\r\n                const word = _array[i];\r\n                if (word == 0xffffffff) {\r\n                    k += 32;\r\n                    continue;\r\n                }\r\n                for (let j = 0; j < 32 && k < size; j++, k++) {\r\n                    if (!((word >>> j) & 0x1))\r\n                        yield k;\r\n                }\r\n            }\r\n        }\r\n        _check_size(other) {\r\n            assert_1.assert(this.size == other.size, \"Size mismatch\");\r\n        }\r\n        add(other) {\r\n            this._check_size(other);\r\n            for (let i = 0; i < this._nwords; i++) {\r\n                this._array[i] |= other._array[i];\r\n            }\r\n        }\r\n        intersect(other) {\r\n            this._check_size(other);\r\n            for (let i = 0; i < this._nwords; i++) {\r\n                this._array[i] &= other._array[i];\r\n            }\r\n        }\r\n        subtract(other) {\r\n            this._check_size(other);\r\n            for (let i = 0; i < this._nwords; i++) {\r\n                const a = this._array[i];\r\n                const b = other._array[i];\r\n                this._array[i] = (a ^ b) & a;\r\n            }\r\n        }\r\n        union(other) {\r\n            this._check_size(other);\r\n            const result = this.clone();\r\n            for (let i = 0; i < this._nwords; i++) {\r\n                result._array[i] |= other._array[i];\r\n            }\r\n            return result;\r\n        }\r\n        intersection(other) {\r\n            this._check_size(other);\r\n            const result = this.clone();\r\n            for (let i = 0; i < this._nwords; i++) {\r\n                result._array[i] &= other._array[i];\r\n            }\r\n            return result;\r\n        }\r\n        difference(other) {\r\n            this._check_size(other);\r\n            const result = this.clone();\r\n            for (let i = 0; i < this._nwords; i++) {\r\n                const a = this._array[i];\r\n                const b = other._array[i];\r\n                result._array[i] = (a ^ b) & a;\r\n            }\r\n            return result;\r\n        }\r\n        select(array) {\r\n            const n = this.count;\r\n            const result = new array.constructor(n);\r\n            let i = 0;\r\n            for (const j of this) {\r\n                result[i++] = array[j];\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.BitSet = BitSet;\r\n    BitSet.__name__ = \"BitSet\";\r\n    class Matrix {\r\n        constructor(nrows, ncols, init) {\r\n            this.nrows = nrows;\r\n            this.ncols = ncols;\r\n            this._matrix = new Array(nrows);\r\n            for (let y = 0; y < nrows; y++) {\r\n                this._matrix[y] = new Array(ncols);\r\n                for (let x = 0; x < ncols; x++) {\r\n                    this._matrix[y][x] = init(y, x);\r\n                }\r\n            }\r\n        }\r\n        at(row, col) {\r\n            return this._matrix[row][col];\r\n        }\r\n        *[Symbol.iterator]() {\r\n            for (let y = 0; y < this.nrows; y++) {\r\n                for (let x = 0; x < this.ncols; x++) {\r\n                    const value = this._matrix[y][x];\r\n                    yield [value, y, x];\r\n                }\r\n            }\r\n        }\r\n        *values() {\r\n            for (const [item] of this) {\r\n                yield item;\r\n            }\r\n        }\r\n        map(fn) {\r\n            return new Matrix(this.nrows, this.ncols, (row, col) => fn(this.at(row, col), row, col));\r\n        }\r\n        apply(obj) {\r\n            const fn = Matrix.from(obj);\r\n            const { nrows, ncols } = this;\r\n            if (nrows == fn.nrows && ncols == fn.ncols)\r\n                return new Matrix(nrows, ncols, (row, col) => fn.at(row, col)(this.at(row, col), row, col));\r\n            else\r\n                throw new Error(\"dimensions don't match\");\r\n        }\r\n        to_sparse() {\r\n            return [...this];\r\n        }\r\n        static from(obj, ncols) {\r\n            if (obj instanceof Matrix) {\r\n                return obj;\r\n            }\r\n            else if (ncols != null) {\r\n                const entries = obj;\r\n                const nrows = Math.floor(entries.length / ncols);\r\n                return new Matrix(nrows, ncols, (row, col) => entries[row * ncols + col]);\r\n            }\r\n            else {\r\n                const arrays = obj;\r\n                const nrows = obj.length;\r\n                const ncols = array_1.min(arrays.map((row) => row.length));\r\n                return new Matrix(nrows, ncols, (row, col) => arrays[row][col]);\r\n            }\r\n        }\r\n    }\r\n    exports.Matrix = Matrix;\r\n    Matrix.__name__ = \"Matrix\";\r\n}\r\n","/* core\\settings.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class Settings {\r\n        constructor() {\r\n            this._dev = false;\r\n        }\r\n        set dev(dev) {\r\n            this._dev = dev;\r\n        }\r\n        get dev() {\r\n            return this._dev;\r\n        }\r\n    }\r\n    exports.Settings = Settings;\r\n    Settings.__name__ = \"Settings\";\r\n    exports.settings = new Settings();\r\n}\r\n","/* core\\property_mixins.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ./properties */);\r\n    exports.Line = {\r\n        line_color: [p.Color, \"black\"],\r\n        line_alpha: [p.Number, 1.0],\r\n        line_width: [p.Number, 1],\r\n        line_join: [p.LineJoin, \"bevel\"],\r\n        line_cap: [p.LineCap, \"butt\"],\r\n        line_dash: [p.Array, []],\r\n        line_dash_offset: [p.Number, 0],\r\n    };\r\n    exports.Fill = {\r\n        fill_color: [p.Color, \"gray\"],\r\n        fill_alpha: [p.Number, 1.0],\r\n    };\r\n    exports.Hatch = {\r\n        hatch_color: [p.Color, \"black\"],\r\n        hatch_alpha: [p.Number, 1.0],\r\n        hatch_scale: [p.Number, 12.0],\r\n        hatch_pattern: [p.NullString, null],\r\n        hatch_weight: [p.Number, 1.0],\r\n        hatch_extra: [p.Any, {}],\r\n    };\r\n    exports.Text = {\r\n        text_color: [p.Color, \"#444444\"],\r\n        text_alpha: [p.Number, 1.0],\r\n        text_font: [p.Font, \"helvetica\"],\r\n        text_font_size: [p.FontSize, \"16px\"],\r\n        text_font_style: [p.FontStyle, \"normal\"],\r\n        text_align: [p.TextAlign, \"left\"],\r\n        text_baseline: [p.TextBaseline, \"bottom\"],\r\n        text_line_height: [p.Number, 1.2],\r\n    };\r\n    exports.LineScalar = {\r\n        line_color: [p.ColorScalar, \"black\"],\r\n        line_alpha: [p.NumberScalar, 1.0],\r\n        line_width: [p.NumberScalar, 1],\r\n        line_join: [p.LineJoinScalar, \"bevel\"],\r\n        line_cap: [p.LineCapScalar, \"butt\"],\r\n        line_dash: [p.ArrayScalar, []],\r\n        line_dash_offset: [p.NumberScalar, 0],\r\n    };\r\n    exports.FillScalar = {\r\n        fill_color: [p.ColorScalar, \"gray\"],\r\n        fill_alpha: [p.NumberScalar, 1.0],\r\n    };\r\n    exports.HatchScalar = {\r\n        hatch_color: [p.ColorScalar, \"black\"],\r\n        hatch_alpha: [p.NumberScalar, 1.0],\r\n        hatch_scale: [p.NumberScalar, 12.0],\r\n        hatch_pattern: [p.NullStringScalar, null],\r\n        hatch_weight: [p.NumberScalar, 1.0],\r\n        hatch_extra: [p.AnyScalar, {}],\r\n    };\r\n    exports.TextScalar = {\r\n        text_color: [p.ColorScalar, \"#444444\"],\r\n        text_alpha: [p.NumberScalar, 1.0],\r\n        text_font: [p.Font, \"helvetica\"],\r\n        text_font_size: [p.FontSizeScalar, \"16px\"],\r\n        text_font_style: [p.FontStyleScalar, \"normal\"],\r\n        text_align: [p.TextAlignScalar, \"left\"],\r\n        text_baseline: [p.TextBaselineScalar, \"bottom\"],\r\n        text_line_height: [p.NumberScalar, 1.2],\r\n    };\r\n    exports.LineVector = {\r\n        line_color: [p.ColorSpec, \"black\"],\r\n        line_alpha: [p.NumberSpec, 1.0],\r\n        line_width: [p.NumberSpec, 1],\r\n        line_join: [p.LineJoin, \"bevel\"],\r\n        line_cap: [p.LineCap, \"butt\"],\r\n        line_dash: [p.Array, []],\r\n        line_dash_offset: [p.Number, 0],\r\n    };\r\n    exports.FillVector = {\r\n        fill_color: [p.ColorSpec, \"gray\"],\r\n        fill_alpha: [p.NumberSpec, 1.0],\r\n    };\r\n    exports.HatchVector = {\r\n        hatch_color: [p.ColorSpec, \"black\"],\r\n        hatch_alpha: [p.NumberSpec, 1.0],\r\n        hatch_scale: [p.NumberSpec, 12.0],\r\n        hatch_pattern: [p.NullStringSpec, null],\r\n        hatch_weight: [p.NumberSpec, 1.0],\r\n        hatch_extra: [p.Any, {}],\r\n    };\r\n    exports.TextVector = {\r\n        text_color: [p.ColorSpec, \"#444444\"],\r\n        text_alpha: [p.NumberSpec, 1.0],\r\n        text_font: [p.Font, \"helvetica\"],\r\n        text_font_size: [p.FontSizeSpec, \"16px\"],\r\n        text_font_style: [p.FontStyle, \"normal\"],\r\n        text_align: [p.TextAlign, \"left\"],\r\n        text_baseline: [p.TextBaseline, \"bottom\"],\r\n        text_line_height: [p.Number, 1.2],\r\n    };\r\n}\r\n","/* core\\util\\string.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const settings_1 = require(27) /* ../settings */;\r\n    function startsWith(str, searchString, position = 0) {\r\n        return str.substr(position, searchString.length) == searchString;\r\n    }\r\n    exports.startsWith = startsWith;\r\n    function uuid4() {\r\n        // from ipython project\r\n        // http://www.ietf.org/rfc/rfc4122.txt\r\n        const s = new Array(32);\r\n        const hexDigits = \"0123456789ABCDEF\";\r\n        for (let i = 0; i < 32; i++) {\r\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\r\n        }\r\n        s[12] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\r\n        s[16] = hexDigits.substr((s[16].charCodeAt(0) & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\r\n        return s.join(\"\");\r\n    }\r\n    exports.uuid4 = uuid4;\r\n    let counter = 1000;\r\n    function uniqueId(prefix) {\r\n        const id = settings_1.settings.dev ? `j${counter++}` : uuid4();\r\n        if (prefix != null)\r\n            return `${prefix}-${id}`;\r\n        else\r\n            return id;\r\n    }\r\n    exports.uniqueId = uniqueId;\r\n    function escape(s) {\r\n        return s.replace(/(?:[&<>\"'`])/g, (ch) => {\r\n            switch (ch) {\r\n                case '&': return '&amp;';\r\n                case '<': return '&lt;';\r\n                case '>': return '&gt;';\r\n                case '\"': return '&quot;';\r\n                case \"'\": return '&#x27;';\r\n                case '`': return '&#x60;';\r\n                default: return ch;\r\n            }\r\n        });\r\n    }\r\n    exports.escape = escape;\r\n    function unescape(s) {\r\n        return s.replace(/&(amp|lt|gt|quot|#x27|#x60);/g, (_, entity) => {\r\n            switch (entity) {\r\n                case 'amp': return '&';\r\n                case 'lt': return '<';\r\n                case 'gt': return '>';\r\n                case 'quot': return '\"';\r\n                case '#x27': return \"'\";\r\n                case '#x60': return '`';\r\n                default: return entity;\r\n            }\r\n        });\r\n    }\r\n    exports.unescape = unescape;\r\n    function use_strict(code) {\r\n        return `'use strict';\\n${code}`;\r\n    }\r\n    exports.use_strict = use_strict;\r\n}\r\n","/* core\\util\\ndarray.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(8) /* ./types */;\r\n    const assert_1 = require(11) /* ./assert */;\r\n    const eq_1 = require(25) /* ./eq */;\r\n    const __ndarray__ = Symbol(\"__ndarray__\");\r\n    class Uint8NDArray extends Uint8Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"uint8\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Uint8NDArray = Uint8NDArray;\r\n    Uint8NDArray.__name__ = \"Uint8NDArray\";\r\n    class Int8NDArray extends Int8Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"int8\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Int8NDArray = Int8NDArray;\r\n    Int8NDArray.__name__ = \"Int8NDArray\";\r\n    class Uint16NDArray extends Uint16Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"uint16\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Uint16NDArray = Uint16NDArray;\r\n    Uint16NDArray.__name__ = \"Uint16NDArray\";\r\n    class Int16NDArray extends Int16Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"int16\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Int16NDArray = Int16NDArray;\r\n    Int16NDArray.__name__ = \"Int16NDArray\";\r\n    class Uint32NDArray extends Uint32Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"uint32\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Uint32NDArray = Uint32NDArray;\r\n    Uint32NDArray.__name__ = \"Uint32NDArray\";\r\n    class Int32NDArray extends Int32Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"int32\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Int32NDArray = Int32NDArray;\r\n    Int32NDArray.__name__ = \"Int32NDArray\";\r\n    class Float32NDArray extends Float32Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"float32\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Float32NDArray = Float32NDArray;\r\n    Float32NDArray.__name__ = \"Float32NDArray\";\r\n    class Float64NDArray extends Float64Array {\r\n        constructor(seq, shape) {\r\n            super(seq);\r\n            this.__ndarray__ = __ndarray__;\r\n            this.dtype = \"float64\";\r\n            this.shape = shape !== null && shape !== void 0 ? shape : (is_NDArray(seq) ? seq.shape : [this.length]);\r\n            this.dimension = this.shape.length;\r\n        }\r\n        [eq_1.equals](that, cmp) {\r\n            return cmp.eq(this.shape, that.shape) && cmp.arrays(this, that);\r\n        }\r\n    }\r\n    exports.Float64NDArray = Float64NDArray;\r\n    Float64NDArray.__name__ = \"Float64NDArray\";\r\n    function is_NDArray(v) {\r\n        return types_1.isObject(v) && v.__ndarray__ == __ndarray__;\r\n    }\r\n    exports.is_NDArray = is_NDArray;\r\n    function ndarray(array, options = {}) {\r\n        let { dtype } = options;\r\n        if (dtype == null) {\r\n            if (array instanceof ArrayBuffer || types_1.isArray(array)) {\r\n                dtype = \"float32\";\r\n            }\r\n            else {\r\n                dtype = (() => {\r\n                    switch (true) {\r\n                        case array instanceof Uint8Array: return \"uint8\";\r\n                        case array instanceof Int8Array: return \"int8\";\r\n                        case array instanceof Uint16Array: return \"uint16\";\r\n                        case array instanceof Int16Array: return \"int16\";\r\n                        case array instanceof Uint32Array: return \"uint32\";\r\n                        case array instanceof Int32Array: return \"int32\";\r\n                        case array instanceof Float32Array: return \"float32\";\r\n                        case array instanceof Float64Array: return \"float64\";\r\n                        default:\r\n                            assert_1.unreachable();\r\n                    }\r\n                })();\r\n            }\r\n        }\r\n        const { shape } = options;\r\n        switch (dtype) {\r\n            case \"uint8\": return new Uint8NDArray(array, shape);\r\n            case \"int8\": return new Int8NDArray(array, shape);\r\n            case \"uint16\": return new Uint16NDArray(array, shape);\r\n            case \"int16\": return new Int16NDArray(array, shape);\r\n            case \"uint32\": return new Uint32NDArray(array, shape);\r\n            case \"int32\": return new Int32NDArray(array, shape);\r\n            case \"float32\": return new Float32NDArray(array, shape);\r\n            case \"float64\": return new Float64NDArray(array, shape);\r\n        }\r\n    }\r\n    exports.ndarray = ndarray;\r\n}\r\n","/* core\\util\\serialization.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const types_1 = require(8) /* ./types */;\r\n    const compat_1 = require(32) /* ./compat */;\r\n    const ndarray = tslib_1.__importStar(require(30) /* ./ndarray */);\r\n    function buffer_to_base64(buffer) {\r\n        const bytes = new Uint8Array(buffer);\r\n        const chars = Array.from(bytes).map((b) => String.fromCharCode(b));\r\n        return btoa(chars.join(\"\"));\r\n    }\r\n    exports.buffer_to_base64 = buffer_to_base64;\r\n    function base64_to_buffer(base64) {\r\n        const binary_string = atob(base64);\r\n        const len = binary_string.length;\r\n        const bytes = new Uint8Array(len);\r\n        for (let i = 0, end = len; i < end; i++) {\r\n            bytes[i] = binary_string.charCodeAt(i);\r\n        }\r\n        return bytes.buffer;\r\n    }\r\n    exports.base64_to_buffer = base64_to_buffer;\r\n    exports.BYTE_ORDER = compat_1.is_little_endian ? \"little\" : \"big\";\r\n    function swap16(a) {\r\n        const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 2);\r\n        for (let i = 0, end = x.length; i < end; i += 2) {\r\n            const t = x[i];\r\n            x[i] = x[i + 1];\r\n            x[i + 1] = t;\r\n        }\r\n    }\r\n    exports.swap16 = swap16;\r\n    function swap32(a) {\r\n        const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 4);\r\n        for (let i = 0, end = x.length; i < end; i += 4) {\r\n            let t = x[i];\r\n            x[i] = x[i + 3];\r\n            x[i + 3] = t;\r\n            t = x[i + 1];\r\n            x[i + 1] = x[i + 2];\r\n            x[i + 2] = t;\r\n        }\r\n    }\r\n    exports.swap32 = swap32;\r\n    function swap64(a) {\r\n        const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 8);\r\n        for (let i = 0, end = x.length; i < end; i += 8) {\r\n            let t = x[i];\r\n            x[i] = x[i + 7];\r\n            x[i + 7] = t;\r\n            t = x[i + 1];\r\n            x[i + 1] = x[i + 6];\r\n            x[i + 6] = t;\r\n            t = x[i + 2];\r\n            x[i + 2] = x[i + 5];\r\n            x[i + 5] = t;\r\n            t = x[i + 3];\r\n            x[i + 3] = x[i + 4];\r\n            x[i + 4] = t;\r\n        }\r\n    }\r\n    exports.swap64 = swap64;\r\n    function is_NDArray_ref(v) {\r\n        return types_1.isPlainObject(v) && (\"__buffer__\" in v || \"__ndarray__\" in v);\r\n    }\r\n    exports.is_NDArray_ref = is_NDArray_ref;\r\n    function decode_NDArray(ref, buffers) {\r\n        const { shape, dtype, order } = ref;\r\n        let bytes;\r\n        if (\"__buffer__\" in ref) {\r\n            const buffer = buffers.get(ref.__buffer__);\r\n            if (buffer != null)\r\n                bytes = buffer;\r\n            else\r\n                throw new Error(`buffer for ${ref.__buffer__} not found`);\r\n        }\r\n        else {\r\n            bytes = base64_to_buffer(ref.__ndarray__);\r\n        }\r\n        const array = (() => {\r\n            switch (dtype) {\r\n                case \"uint8\": return new ndarray.Uint8NDArray(bytes, shape);\r\n                case \"int8\": return new ndarray.Int8NDArray(bytes, shape);\r\n                case \"uint16\": return new ndarray.Uint16NDArray(bytes, shape);\r\n                case \"int16\": return new ndarray.Int16NDArray(bytes, shape);\r\n                case \"uint32\": return new ndarray.Uint32NDArray(bytes, shape);\r\n                case \"int32\": return new ndarray.Int32NDArray(bytes, shape);\r\n                case \"float32\": return new ndarray.Float32NDArray(bytes, shape);\r\n                case \"float64\": return new ndarray.Float64NDArray(bytes, shape);\r\n            }\r\n        })();\r\n        if (order !== exports.BYTE_ORDER) {\r\n            switch (array.BYTES_PER_ELEMENT) {\r\n                case 2:\r\n                    swap16(array);\r\n                    break;\r\n                case 4:\r\n                    swap32(array);\r\n                    break;\r\n                case 8:\r\n                    swap64(array);\r\n                    break;\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n    exports.decode_NDArray = decode_NDArray;\r\n    function encode_NDArray(array, buffers) {\r\n        const data = {\r\n            order: exports.BYTE_ORDER,\r\n            dtype: array.dtype,\r\n            shape: array.shape,\r\n        };\r\n        if (buffers != null) {\r\n            const __buffer__ = `${buffers.size}`;\r\n            buffers.set(__buffer__, array.buffer);\r\n            return Object.assign({ __buffer__ }, data);\r\n        }\r\n        else {\r\n            const __ndarray__ = buffer_to_base64(array.buffer);\r\n            return Object.assign({ __ndarray__ }, data);\r\n        }\r\n    }\r\n    exports.encode_NDArray = encode_NDArray;\r\n}\r\n","/* core\\util\\compat.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.is_ie = (() => {\r\n        const ua = typeof navigator !== \"undefined\" ? navigator.userAgent : \"\";\r\n        return ua.indexOf('MSIE') >= 0 || ua.indexOf('Trident') > 0 || ua.indexOf('Edge') > 0;\r\n    })();\r\n    exports.is_mobile = (() => {\r\n        return typeof window !== \"undefined\" && (\"ontouchstart\" in window || navigator.maxTouchPoints > 0);\r\n    })();\r\n    exports.is_little_endian = (() => {\r\n        const buf = new ArrayBuffer(4);\r\n        const buf8 = new Uint8Array(buf);\r\n        const buf32 = new Uint32Array(buf);\r\n        buf32[1] = 0x0a0b0c0d;\r\n        let little_endian = true;\r\n        if (buf8[4] == 0x0a && buf8[5] == 0x0b && buf8[6] == 0x0c && buf8[7] == 0x0d) {\r\n            little_endian = false;\r\n        }\r\n        return little_endian;\r\n    })();\r\n}\r\n","/* core\\util\\pretty.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(8) /* ./types */;\r\n    const object_1 = require(13) /* ./object */;\r\n    exports.pretty = Symbol(\"pretty\");\r\n    function isPrintable(obj) {\r\n        return exports.pretty in Object(obj);\r\n    }\r\n    class Printer {\r\n        constructor(options) {\r\n            this.precision = options === null || options === void 0 ? void 0 : options.precision;\r\n        }\r\n        to_string(obj) {\r\n            if (isPrintable(obj))\r\n                return obj[exports.pretty](this);\r\n            else if (types_1.isBoolean(obj))\r\n                return this.boolean(obj);\r\n            else if (types_1.isNumber(obj))\r\n                return this.number(obj);\r\n            else if (types_1.isString(obj))\r\n                return this.string(obj);\r\n            else if (types_1.isArray(obj))\r\n                return this.array(obj);\r\n            else if (types_1.isIterable(obj))\r\n                return this.iterable(obj);\r\n            else if (types_1.isPlainObject(obj))\r\n                return this.object(obj);\r\n            else\r\n                return `${obj}`;\r\n        }\r\n        token(val) {\r\n            return val;\r\n        }\r\n        boolean(val) {\r\n            return `${val}`;\r\n        }\r\n        number(val) {\r\n            if (this.precision != null)\r\n                return val.toFixed(this.precision);\r\n            else\r\n                return `${val}`;\r\n        }\r\n        string(val) {\r\n            return `\"${val.replace(/'/g, \"\\\\'\")}\"`; // lgtm [js/incomplete-sanitization]\r\n        }\r\n        array(obj) {\r\n            const T = this.token;\r\n            const items = [];\r\n            for (const entry of obj) {\r\n                items.push(this.to_string(entry));\r\n            }\r\n            return `${T(\"[\")}${items.join(`${T(\",\")} `)}${T(\"]\")}`;\r\n        }\r\n        iterable(obj) {\r\n            var _a;\r\n            const T = this.token;\r\n            const tag = (_a = Object(obj)[Symbol.toStringTag]) !== null && _a !== void 0 ? _a : \"Object\";\r\n            const items = this.array(obj);\r\n            return `${tag}${T(\"(\")}${items}${T(\")\")}`;\r\n        }\r\n        object(obj) {\r\n            const T = this.token;\r\n            const items = [];\r\n            for (const [key, val] of object_1.entries(obj)) {\r\n                items.push(`${key}${T(\":\")} ${this.to_string(val)}`);\r\n            }\r\n            return `${T(\"{\")}${items.join(`${T(\",\")} `)}${T(\"}\")}`;\r\n        }\r\n    }\r\n    exports.Printer = Printer;\r\n    Printer.__name__ = \"Printer\";\r\n    function to_string(obj, options) {\r\n        const printer = new Printer(options);\r\n        return printer.to_string(obj);\r\n    }\r\n    exports.to_string = to_string;\r\n}\r\n","/* models\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    tslib_1.__exportStar(require(35) /* ./annotations */, exports);\r\n    tslib_1.__exportStar(require(176) /* ./axes */, exports);\r\n    tslib_1.__exportStar(require(203) /* ./callbacks */, exports);\r\n    tslib_1.__exportStar(require(207) /* ./canvas */, exports);\r\n    tslib_1.__exportStar(require(218) /* ./expressions */, exports);\r\n    tslib_1.__exportStar(require(222) /* ./filters */, exports);\r\n    tslib_1.__exportStar(require(228) /* ./formatters */, exports);\r\n    tslib_1.__exportStar(require(232) /* ./glyphs */, exports);\r\n    tslib_1.__exportStar(require(265) /* ./graphs */, exports);\r\n    tslib_1.__exportStar(require(268) /* ./grids */, exports);\r\n    tslib_1.__exportStar(require(270) /* ./layouts */, exports);\r\n    tslib_1.__exportStar(require(132) /* ./mappers */, exports);\r\n    tslib_1.__exportStar(require(148) /* ./transforms */, exports);\r\n    tslib_1.__exportStar(require(287) /* ./markers */, exports);\r\n    tslib_1.__exportStar(require(291) /* ./plots */, exports);\r\n    tslib_1.__exportStar(require(320) /* ./ranges */, exports);\r\n    tslib_1.__exportStar(require(321) /* ./renderers */, exports);\r\n    tslib_1.__exportStar(require(322) /* ./scales */, exports);\r\n    tslib_1.__exportStar(require(323) /* ./selections */, exports);\r\n    tslib_1.__exportStar(require(324) /* ./sources */, exports);\r\n    tslib_1.__exportStar(require(329) /* ./tickers */, exports);\r\n    tslib_1.__exportStar(require(331) /* ./tiles */, exports);\r\n    tslib_1.__exportStar(require(342) /* ./textures */, exports);\r\n    tslib_1.__exportStar(require(346) /* ./tools */, exports);\r\n}\r\n","/* models\\annotations\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var annotation_1 = require(36) /* ./annotation */;\r\n    exports.Annotation = annotation_1.Annotation;\r\n    var arrow_1 = require(83) /* ./arrow */;\r\n    exports.Arrow = arrow_1.Arrow;\r\n    var arrow_head_1 = require(84) /* ./arrow_head */;\r\n    exports.ArrowHead = arrow_head_1.ArrowHead;\r\n    var arrow_head_2 = require(84) /* ./arrow_head */;\r\n    exports.OpenHead = arrow_head_2.OpenHead;\r\n    var arrow_head_3 = require(84) /* ./arrow_head */;\r\n    exports.NormalHead = arrow_head_3.NormalHead;\r\n    var arrow_head_4 = require(84) /* ./arrow_head */;\r\n    exports.TeeHead = arrow_head_4.TeeHead;\r\n    var arrow_head_5 = require(84) /* ./arrow_head */;\r\n    exports.VeeHead = arrow_head_5.VeeHead;\r\n    var band_1 = require(122) /* ./band */;\r\n    exports.Band = band_1.Band;\r\n    var box_annotation_1 = require(124) /* ./box_annotation */;\r\n    exports.BoxAnnotation = box_annotation_1.BoxAnnotation;\r\n    var color_bar_1 = require(125) /* ./color_bar */;\r\n    exports.ColorBar = color_bar_1.ColorBar;\r\n    var label_1 = require(160) /* ./label */;\r\n    exports.Label = label_1.Label;\r\n    var label_set_1 = require(162) /* ./label_set */;\r\n    exports.LabelSet = label_set_1.LabelSet;\r\n    var legend_1 = require(163) /* ./legend */;\r\n    exports.Legend = legend_1.Legend;\r\n    var legend_item_1 = require(164) /* ./legend_item */;\r\n    exports.LegendItem = legend_item_1.LegendItem;\r\n    var poly_annotation_1 = require(166) /* ./poly_annotation */;\r\n    exports.PolyAnnotation = poly_annotation_1.PolyAnnotation;\r\n    var slope_1 = require(167) /* ./slope */;\r\n    exports.Slope = slope_1.Slope;\r\n    var span_1 = require(168) /* ./span */;\r\n    exports.Span = span_1.Span;\r\n    var text_annotation_1 = require(161) /* ./text_annotation */;\r\n    exports.TextAnnotation = text_annotation_1.TextAnnotation;\r\n    var title_1 = require(169) /* ./title */;\r\n    exports.Title = title_1.Title;\r\n    var toolbar_panel_1 = require(170) /* ./toolbar_panel */;\r\n    exports.ToolbarPanel = toolbar_panel_1.ToolbarPanel;\r\n    var tooltip_1 = require(171) /* ./tooltip */;\r\n    exports.Tooltip = tooltip_1.Tooltip;\r\n    var whisker_1 = require(175) /* ./whisker */;\r\n    exports.Whisker = whisker_1.Whisker;\r\n}\r\n","/* models\\annotations\\annotation.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const proj = tslib_1.__importStar(require(37) /* ../../core/util/projections */);\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const renderer_1 = require(70) /* ../renderers/renderer */;\r\n    class AnnotationView extends renderer_1.RendererView {\r\n        get panel() {\r\n            return this.layout;\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            const p = this.model.properties;\r\n            this.on_change(p.visible, () => this.plot_view.request_layout());\r\n        }\r\n        get_size() {\r\n            if (this.model.visible) {\r\n                const { width, height } = this._get_size();\r\n                return { width: Math.round(width), height: Math.round(height) };\r\n            }\r\n            else\r\n                return { width: 0, height: 0 };\r\n        }\r\n        _get_size() {\r\n            throw new Error(\"not implemented\");\r\n        }\r\n        set_data(source) {\r\n            const data = this.model.materialize_dataspecs(source);\r\n            object_1.extend(this, data);\r\n            if (this.plot_model.use_map) {\r\n                const self = this;\r\n                if (self._x != null)\r\n                    [self._x, self._y] = proj.project_xy(self._x, self._y);\r\n                if (self._xs != null)\r\n                    [self._xs, self._ys] = proj.project_xsys(self._xs, self._ys);\r\n            }\r\n        }\r\n        get needs_clip() {\r\n            return this.layout == null; // TODO: change this, when center layout is fully implemented\r\n        }\r\n        serializable_state() {\r\n            const state = super.serializable_state();\r\n            return this.layout == null ? state : Object.assign(Object.assign({}, state), { bbox: this.layout.bbox.box });\r\n        }\r\n    }\r\n    exports.AnnotationView = AnnotationView;\r\n    AnnotationView.__name__ = \"AnnotationView\";\r\n    class Annotation extends renderer_1.Renderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Annotation() {\r\n            this.override({\r\n                level: 'annotation',\r\n            });\r\n        }\r\n    }\r\n    exports.Annotation = Annotation;\r\n    Annotation.__name__ = \"Annotation\";\r\n    Annotation.init_Annotation();\r\n}\r\n","/* core\\util\\projections.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const core_1 = tslib_1.__importDefault(require(38) /* proj4/lib/core */);\r\n    const Proj_1 = tslib_1.__importDefault(require(39) /* proj4/lib/Proj */);\r\n    const types_1 = require(24) /* ../types */;\r\n    const mercator = new Proj_1.default('GOOGLE');\r\n    const wgs84 = new Proj_1.default('WGS84');\r\n    const _wgs84_mercator = core_1.default(wgs84, mercator);\r\n    exports.wgs84_mercator = {\r\n        compute(x, y) {\r\n            if (isFinite(x) && isFinite(y))\r\n                return _wgs84_mercator.forward([x, y]);\r\n            else\r\n                return [NaN, NaN];\r\n        },\r\n        invert(merc_x, merc_y) {\r\n            if (isFinite(merc_x) && isFinite(merc_y))\r\n                return _wgs84_mercator.inverse([merc_x, merc_y]);\r\n            else\r\n                return [NaN, NaN];\r\n        },\r\n    };\r\n    const mercator_bounds = {\r\n        lon: [-20026376.39, 20026376.39],\r\n        lat: [-20048966.10, 20048966.10],\r\n    };\r\n    const latlon_bounds = {\r\n        lon: [-180, 180],\r\n        lat: [-85.06, 85.06],\r\n    };\r\n    const { min, max } = Math;\r\n    function clip_mercator(low, high, dimension) {\r\n        const [vmin, vmax] = mercator_bounds[dimension];\r\n        return [max(low, vmin), min(high, vmax)];\r\n    }\r\n    exports.clip_mercator = clip_mercator;\r\n    function in_bounds(value, dimension) {\r\n        const [min, max] = latlon_bounds[dimension];\r\n        return min < value && value < max;\r\n    }\r\n    exports.in_bounds = in_bounds;\r\n    (function (inplace) {\r\n        function project_xy(x, y, merc_x, merc_y) {\r\n            const n = min(x.length, y.length);\r\n            merc_x = merc_x !== null && merc_x !== void 0 ? merc_x : x;\r\n            merc_y = merc_y !== null && merc_y !== void 0 ? merc_y : y;\r\n            for (let i = 0; i < n; i++) {\r\n                const xi = x[i];\r\n                const yi = y[i];\r\n                const [merc_xi, merc_yi] = exports.wgs84_mercator.compute(xi, yi);\r\n                merc_x[i] = merc_xi;\r\n                merc_y[i] = merc_yi;\r\n            }\r\n        }\r\n        inplace.project_xy = project_xy;\r\n        function project_xsys(xs, ys, merc_xs, merc_ys) {\r\n            const n = min(xs.length, ys.length);\r\n            merc_xs = merc_xs !== null && merc_xs !== void 0 ? merc_xs : xs;\r\n            merc_ys = merc_ys !== null && merc_ys !== void 0 ? merc_ys : ys;\r\n            for (let i = 0; i < n; i++) {\r\n                project_xy(xs[i], ys[i], merc_xs[i], merc_ys[i]);\r\n            }\r\n        }\r\n        inplace.project_xsys = project_xsys;\r\n    })(exports.inplace || (exports.inplace = {}));\r\n    function project_xy(x, y) {\r\n        const n = min(x.length, y.length);\r\n        const merc_x = new types_1.NumberArray(n);\r\n        const merc_y = new types_1.NumberArray(n);\r\n        exports.inplace.project_xy(x, y, merc_x, merc_y);\r\n        return [merc_x, merc_y];\r\n    }\r\n    exports.project_xy = project_xy;\r\n    function project_xsys(xs, ys) {\r\n        const n = min(xs.length, ys.length);\r\n        const merc_xs = new Array(n);\r\n        const merc_ys = new Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            const [merc_x, merc_y] = project_xy(xs[i], ys[i]);\r\n            merc_xs[i] = merc_x;\r\n            merc_ys[i] = merc_y;\r\n        }\r\n        return [merc_xs, merc_ys];\r\n    }\r\n    exports.project_xsys = project_xsys;\r\n}\r\n","/* proj4\\lib\\core.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const Proj_1 = tslib_1.__importDefault(require(39) /* ./Proj */);\r\n    const transform_1 = tslib_1.__importDefault(require(64) /* ./transform */);\r\n    var wgs84 = Proj_1.default('WGS84');\r\n    function transformer(from, to, coords) {\r\n        var transformedArray, out, keys;\r\n        if (Array.isArray(coords)) {\r\n            transformedArray = transform_1.default(from, to, coords) || { x: NaN, y: NaN };\r\n            if (coords.length > 2) {\r\n                if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\r\n                    if (typeof transformedArray.z === 'number') {\r\n                        return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));\r\n                    }\r\n                    else {\r\n                        return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));\r\n                    }\r\n                }\r\n                else {\r\n                    return [transformedArray.x, transformedArray.y].concat(coords.splice(2));\r\n                }\r\n            }\r\n            else {\r\n                return [transformedArray.x, transformedArray.y];\r\n            }\r\n        }\r\n        else {\r\n            out = transform_1.default(from, to, coords);\r\n            keys = Object.keys(coords);\r\n            if (keys.length === 2) {\r\n                return out;\r\n            }\r\n            keys.forEach(function (key) {\r\n                if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {\r\n                    if (key === 'x' || key === 'y' || key === 'z') {\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    if (key === 'x' || key === 'y') {\r\n                        return;\r\n                    }\r\n                }\r\n                out[key] = coords[key];\r\n            });\r\n            return out;\r\n        }\r\n    }\r\n    function checkProj(item) {\r\n        if (item instanceof Proj_1.default) {\r\n            return item;\r\n        }\r\n        if (item.oProj) {\r\n            return item.oProj;\r\n        }\r\n        return Proj_1.default(item);\r\n    }\r\n    function proj4(fromProj, toProj, coord) {\r\n        fromProj = checkProj(fromProj);\r\n        var single = false;\r\n        var obj;\r\n        if (typeof toProj === 'undefined') {\r\n            toProj = fromProj;\r\n            fromProj = wgs84;\r\n            single = true;\r\n        }\r\n        else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\r\n            coord = toProj;\r\n            toProj = fromProj;\r\n            fromProj = wgs84;\r\n            single = true;\r\n        }\r\n        toProj = checkProj(toProj);\r\n        if (coord) {\r\n            return transformer(fromProj, toProj, coord);\r\n        }\r\n        else {\r\n            obj = {\r\n                forward: function (coords) {\r\n                    return transformer(fromProj, toProj, coords);\r\n                },\r\n                inverse: function (coords) {\r\n                    return transformer(toProj, fromProj, coords);\r\n                }\r\n            };\r\n            if (single) {\r\n                obj.oProj = toProj;\r\n            }\r\n            return obj;\r\n        }\r\n    }\r\n    exports.default = proj4;\r\n}\r\n","/* proj4\\lib\\Proj.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const parseCode_1 = tslib_1.__importDefault(require(40) /* ./parseCode */);\r\n    const extend_1 = tslib_1.__importDefault(require(51) /* ./extend */);\r\n    const projections_1 = tslib_1.__importDefault(require(52) /* ./projections */);\r\n    const deriveConstants_1 = require(60) /* ./deriveConstants */;\r\n    const Datum_1 = tslib_1.__importDefault(require(62) /* ./constants/Datum */);\r\n    const datum_1 = tslib_1.__importDefault(require(63) /* ./datum */);\r\n    const match_1 = tslib_1.__importDefault(require(47) /* ./match */);\r\n    function Projection(srsCode, callback) {\r\n        if (!(this instanceof Projection)) {\r\n            return new Projection(srsCode);\r\n        }\r\n        callback = callback || function (error) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n        };\r\n        var json = parseCode_1.default(srsCode);\r\n        if (typeof json !== 'object') {\r\n            callback(srsCode);\r\n            return;\r\n        }\r\n        var ourProj = Projection.projections.get(json.projName);\r\n        if (!ourProj) {\r\n            callback(srsCode);\r\n            return;\r\n        }\r\n        if (json.datumCode && json.datumCode !== 'none') {\r\n            var datumDef = match_1.default(Datum_1.default, json.datumCode);\r\n            if (datumDef) {\r\n                json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\r\n                json.ellps = datumDef.ellipse;\r\n                json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\r\n            }\r\n        }\r\n        json.k0 = json.k0 || 1.0;\r\n        json.axis = json.axis || 'enu';\r\n        json.ellps = json.ellps || 'wgs84';\r\n        var sphere_ = deriveConstants_1.sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\r\n        var ecc = deriveConstants_1.eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\r\n        var datumObj = json.datum || datum_1.default(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);\r\n        extend_1.default(this, json); // transfer everything over from the projection because we don't know what we'll need\r\n        extend_1.default(this, ourProj); // transfer all the methods from the projection\r\n        // copy the 4 things over we calulated in deriveConstants.sphere\r\n        this.a = sphere_.a;\r\n        this.b = sphere_.b;\r\n        this.rf = sphere_.rf;\r\n        this.sphere = sphere_.sphere;\r\n        // copy the 3 things we calculated in deriveConstants.eccentricity\r\n        this.es = ecc.es;\r\n        this.e = ecc.e;\r\n        this.ep2 = ecc.ep2;\r\n        // add in the datum object\r\n        this.datum = datumObj;\r\n        // init the projection\r\n        this.init();\r\n        // legecy callback from back in the day when it went to spatialreference.org\r\n        callback(null, this);\r\n    }\r\n    Projection.projections = projections_1.default;\r\n    Projection.projections.start();\r\n    exports.default = Projection;\r\n}\r\n","/* proj4\\lib\\parseCode.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const defs_1 = tslib_1.__importDefault(require(41) /* ./defs */);\r\n    const wkt_parser_1 = tslib_1.__importDefault(require(48) /* wkt-parser */);\r\n    const projString_1 = tslib_1.__importDefault(require(43) /* ./projString */);\r\n    const match_1 = tslib_1.__importDefault(require(47) /* ./match */);\r\n    function testObj(code) {\r\n        return typeof code === 'string';\r\n    }\r\n    function testDef(code) {\r\n        return code in defs_1.default;\r\n    }\r\n    var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];\r\n    function testWKT(code) {\r\n        return codeWords.some(function (word) {\r\n            return code.indexOf(word) > -1;\r\n        });\r\n    }\r\n    var codes = ['3857', '900913', '3785', '102113'];\r\n    function checkMercator(item) {\r\n        var auth = match_1.default(item, 'authority');\r\n        if (!auth) {\r\n            return;\r\n        }\r\n        var code = match_1.default(auth, 'epsg');\r\n        return code && codes.indexOf(code) > -1;\r\n    }\r\n    function checkProjStr(item) {\r\n        var ext = match_1.default(item, 'extension');\r\n        if (!ext) {\r\n            return;\r\n        }\r\n        return match_1.default(ext, 'proj4');\r\n    }\r\n    function testProj(code) {\r\n        return code[0] === '+';\r\n    }\r\n    function parse(code) {\r\n        if (testObj(code)) {\r\n            //check to see if this is a WKT string\r\n            if (testDef(code)) {\r\n                return defs_1.default[code];\r\n            }\r\n            if (testWKT(code)) {\r\n                var out = wkt_parser_1.default(code);\r\n                // test of spetial case, due to this being a very common and often malformed\r\n                if (checkMercator(out)) {\r\n                    return defs_1.default['EPSG:3857'];\r\n                }\r\n                var maybeProjStr = checkProjStr(out);\r\n                if (maybeProjStr) {\r\n                    return projString_1.default(maybeProjStr);\r\n                }\r\n                return out;\r\n            }\r\n            if (testProj(code)) {\r\n                return projString_1.default(code);\r\n            }\r\n        }\r\n        else {\r\n            return code;\r\n        }\r\n    }\r\n    exports.default = parse;\r\n}\r\n","/* proj4\\lib\\defs.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const global_1 = tslib_1.__importDefault(require(42) /* ./global */);\r\n    const projString_1 = tslib_1.__importDefault(require(43) /* ./projString */);\r\n    const wkt_parser_1 = tslib_1.__importDefault(require(48) /* wkt-parser */);\r\n    function defs(name) {\r\n        /*global console*/\r\n        var that = this;\r\n        if (arguments.length === 2) {\r\n            var def = arguments[1];\r\n            if (typeof def === 'string') {\r\n                if (def.charAt(0) === '+') {\r\n                    defs[name] = projString_1.default(arguments[1]);\r\n                }\r\n                else {\r\n                    defs[name] = wkt_parser_1.default(arguments[1]);\r\n                }\r\n            }\r\n            else {\r\n                defs[name] = def;\r\n            }\r\n        }\r\n        else if (arguments.length === 1) {\r\n            if (Array.isArray(name)) {\r\n                return name.map(function (v) {\r\n                    if (Array.isArray(v)) {\r\n                        defs.apply(that, v);\r\n                    }\r\n                    else {\r\n                        defs(v);\r\n                    }\r\n                });\r\n            }\r\n            else if (typeof name === 'string') {\r\n                if (name in defs) {\r\n                    return defs[name];\r\n                }\r\n            }\r\n            else if ('EPSG' in name) {\r\n                defs['EPSG:' + name.EPSG] = name;\r\n            }\r\n            else if ('ESRI' in name) {\r\n                defs['ESRI:' + name.ESRI] = name;\r\n            }\r\n            else if ('IAU2000' in name) {\r\n                defs['IAU2000:' + name.IAU2000] = name;\r\n            }\r\n            else {\r\n                console.log(name);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    global_1.default(defs);\r\n    exports.default = defs;\r\n}\r\n","/* proj4\\lib\\global.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function default_1(defs) {\r\n        defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\r\n        defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\r\n        defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\r\n        defs.WGS84 = defs['EPSG:4326'];\r\n        defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\r\n        defs.GOOGLE = defs['EPSG:3857'];\r\n        defs['EPSG:900913'] = defs['EPSG:3857'];\r\n        defs['EPSG:102113'] = defs['EPSG:3857'];\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\projString.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const values_1 = require(44) /* ./constants/values */;\r\n    const PrimeMeridian_1 = tslib_1.__importDefault(require(45) /* ./constants/PrimeMeridian */);\r\n    const units_1 = tslib_1.__importDefault(require(46) /* ./constants/units */);\r\n    const match_1 = tslib_1.__importDefault(require(47) /* ./match */);\r\n    function default_1(defData) {\r\n        var self = {};\r\n        var paramObj = defData.split('+').map(function (v) {\r\n            return v.trim();\r\n        }).filter(function (a) {\r\n            return a;\r\n        }).reduce(function (p, a) {\r\n            var split = a.split('=');\r\n            split.push(true);\r\n            p[split[0].toLowerCase()] = split[1];\r\n            return p;\r\n        }, {});\r\n        var paramName, paramVal, paramOutname;\r\n        var params = {\r\n            proj: 'projName',\r\n            datum: 'datumCode',\r\n            rf: function (v) {\r\n                self.rf = parseFloat(v);\r\n            },\r\n            lat_0: function (v) {\r\n                self.lat0 = v * values_1.D2R;\r\n            },\r\n            lat_1: function (v) {\r\n                self.lat1 = v * values_1.D2R;\r\n            },\r\n            lat_2: function (v) {\r\n                self.lat2 = v * values_1.D2R;\r\n            },\r\n            lat_ts: function (v) {\r\n                self.lat_ts = v * values_1.D2R;\r\n            },\r\n            lon_0: function (v) {\r\n                self.long0 = v * values_1.D2R;\r\n            },\r\n            lon_1: function (v) {\r\n                self.long1 = v * values_1.D2R;\r\n            },\r\n            lon_2: function (v) {\r\n                self.long2 = v * values_1.D2R;\r\n            },\r\n            alpha: function (v) {\r\n                self.alpha = parseFloat(v) * values_1.D2R;\r\n            },\r\n            lonc: function (v) {\r\n                self.longc = v * values_1.D2R;\r\n            },\r\n            x_0: function (v) {\r\n                self.x0 = parseFloat(v);\r\n            },\r\n            y_0: function (v) {\r\n                self.y0 = parseFloat(v);\r\n            },\r\n            k_0: function (v) {\r\n                self.k0 = parseFloat(v);\r\n            },\r\n            k: function (v) {\r\n                self.k0 = parseFloat(v);\r\n            },\r\n            a: function (v) {\r\n                self.a = parseFloat(v);\r\n            },\r\n            b: function (v) {\r\n                self.b = parseFloat(v);\r\n            },\r\n            r_a: function () {\r\n                self.R_A = true;\r\n            },\r\n            zone: function (v) {\r\n                self.zone = parseInt(v, 10);\r\n            },\r\n            south: function () {\r\n                self.utmSouth = true;\r\n            },\r\n            towgs84: function (v) {\r\n                self.datum_params = v.split(\",\").map(function (a) {\r\n                    return parseFloat(a);\r\n                });\r\n            },\r\n            to_meter: function (v) {\r\n                self.to_meter = parseFloat(v);\r\n            },\r\n            units: function (v) {\r\n                self.units = v;\r\n                var unit = match_1.default(units_1.default, v);\r\n                if (unit) {\r\n                    self.to_meter = unit.to_meter;\r\n                }\r\n            },\r\n            from_greenwich: function (v) {\r\n                self.from_greenwich = v * values_1.D2R;\r\n            },\r\n            pm: function (v) {\r\n                var pm = match_1.default(PrimeMeridian_1.default, v);\r\n                self.from_greenwich = (pm ? pm : parseFloat(v)) * values_1.D2R;\r\n            },\r\n            nadgrids: function (v) {\r\n                if (v === '@null') {\r\n                    self.datumCode = 'none';\r\n                }\r\n                else {\r\n                    self.nadgrids = v;\r\n                }\r\n            },\r\n            axis: function (v) {\r\n                var legalAxis = \"ewnsud\";\r\n                if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\r\n                    self.axis = v;\r\n                }\r\n            }\r\n        };\r\n        for (paramName in paramObj) {\r\n            paramVal = paramObj[paramName];\r\n            if (paramName in params) {\r\n                paramOutname = params[paramName];\r\n                if (typeof paramOutname === 'function') {\r\n                    paramOutname(paramVal);\r\n                }\r\n                else {\r\n                    self[paramOutname] = paramVal;\r\n                }\r\n            }\r\n            else {\r\n                self[paramName] = paramVal;\r\n            }\r\n        }\r\n        if (typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\") {\r\n            self.datumCode = self.datumCode.toLowerCase();\r\n        }\r\n        return self;\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\constants\\values.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.PJD_3PARAM = 1;\r\n    exports.PJD_7PARAM = 2;\r\n    exports.PJD_WGS84 = 4; // WGS84 or equivalent\r\n    exports.PJD_NODATUM = 5; // WGS84 or equivalent\r\n    exports.SEC_TO_RAD = 4.84813681109535993589914102357e-6;\r\n    exports.HALF_PI = Math.PI / 2;\r\n    // ellipoid pj_set_ell.c\r\n    exports.SIXTH = 0.1666666666666666667;\r\n    /* 1/6 */\r\n    exports.RA4 = 0.04722222222222222222;\r\n    /* 17/360 */\r\n    exports.RA6 = 0.02215608465608465608;\r\n    exports.EPSLN = 1.0e-10;\r\n    // you'd think you could use Number.EPSILON above but that makes\r\n    // Mollweide get into an infinate loop.\r\n    exports.D2R = 0.01745329251994329577;\r\n    exports.R2D = 57.29577951308232088;\r\n    exports.FORTPI = Math.PI / 4;\r\n    exports.TWO_PI = Math.PI * 2;\r\n    // SPI is slightly greater than Math.PI, so values that exceed the -180..180\r\n    // degree range by a tiny amount don't get wrapped. This prevents points that\r\n    // have drifted from their original location along the 180th meridian (due to\r\n    // floating point error) from changing their sign.\r\n    exports.SPI = 3.14159265359;\r\n}\r\n","/* proj4\\lib\\constants\\PrimeMeridian.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var exports$1 = {};\r\n    exports.default = exports$1;\r\n    exports$1.greenwich = 0.0; //\"0dE\",\r\n    exports$1.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\r\n    exports$1.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\r\n    exports$1.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\r\n    exports$1.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\r\n    exports$1.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\r\n    exports$1.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\r\n    exports$1.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\r\n    exports$1.ferro = -17.666666666667; //\"17d40'W\",\r\n    exports$1.brussels = 4.367975; //\"4d22'4.71\\\"E\",\r\n    exports$1.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\r\n    exports$1.athens = 23.7163375; //\"23d42'58.815\\\"E\",\r\n    exports$1.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\r\n}\r\n","/* proj4\\lib\\constants\\units.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = {\r\n        ft: { to_meter: 0.3048 },\r\n        'us-ft': { to_meter: 1200 / 3937 }\r\n    };\r\n}\r\n","/* proj4\\lib\\match.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\r\n    function match(obj, key) {\r\n        if (obj[key]) {\r\n            return obj[key];\r\n        }\r\n        var keys = Object.keys(obj);\r\n        var lkey = key.toLowerCase().replace(ignoredChar, '');\r\n        var i = -1;\r\n        var testkey, processedKey;\r\n        while (++i < keys.length) {\r\n            testkey = keys[i];\r\n            processedKey = testkey.toLowerCase().replace(ignoredChar, '');\r\n            if (processedKey === lkey) {\r\n                return obj[testkey];\r\n            }\r\n        }\r\n    }\r\n    exports.default = match;\r\n}\r\n","/* wkt-parser\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    var D2R = 0.01745329251994329577;\r\n    const parser_1 = tslib_1.__importDefault(require(49) /* ./parser */);\r\n    const process_1 = require(50) /* ./process */;\r\n    function rename(obj, params) {\r\n        var outName = params[0];\r\n        var inName = params[1];\r\n        if (!(outName in obj) && (inName in obj)) {\r\n            obj[outName] = obj[inName];\r\n            if (params.length === 3) {\r\n                obj[outName] = params[2](obj[outName]);\r\n            }\r\n        }\r\n    }\r\n    function d2r(input) {\r\n        return input * D2R;\r\n    }\r\n    function cleanWKT(wkt) {\r\n        if (wkt.type === 'GEOGCS') {\r\n            wkt.projName = 'longlat';\r\n        }\r\n        else if (wkt.type === 'LOCAL_CS') {\r\n            wkt.projName = 'identity';\r\n            wkt.local = true;\r\n        }\r\n        else {\r\n            if (typeof wkt.PROJECTION === 'object') {\r\n                wkt.projName = Object.keys(wkt.PROJECTION)[0];\r\n            }\r\n            else {\r\n                wkt.projName = wkt.PROJECTION;\r\n            }\r\n        }\r\n        if (wkt.AXIS) {\r\n            var axisOrder = '';\r\n            for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {\r\n                var axis = wkt.AXIS[i];\r\n                var descriptor = axis[0].toLowerCase();\r\n                if (descriptor.indexOf('north') !== -1) {\r\n                    axisOrder += 'n';\r\n                }\r\n                else if (descriptor.indexOf('south') !== -1) {\r\n                    axisOrder += 's';\r\n                }\r\n                else if (descriptor.indexOf('east') !== -1) {\r\n                    axisOrder += 'e';\r\n                }\r\n                else if (descriptor.indexOf('west') !== -1) {\r\n                    axisOrder += 'w';\r\n                }\r\n            }\r\n            if (axisOrder.length === 2) {\r\n                axisOrder += 'u';\r\n            }\r\n            if (axisOrder.length === 3) {\r\n                wkt.axis = axisOrder;\r\n            }\r\n        }\r\n        if (wkt.UNIT) {\r\n            wkt.units = wkt.UNIT.name.toLowerCase();\r\n            if (wkt.units === 'metre') {\r\n                wkt.units = 'meter';\r\n            }\r\n            if (wkt.UNIT.convert) {\r\n                if (wkt.type === 'GEOGCS') {\r\n                    if (wkt.DATUM && wkt.DATUM.SPHEROID) {\r\n                        wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;\r\n                    }\r\n                }\r\n                else {\r\n                    wkt.to_meter = wkt.UNIT.convert;\r\n                }\r\n            }\r\n        }\r\n        var geogcs = wkt.GEOGCS;\r\n        if (wkt.type === 'GEOGCS') {\r\n            geogcs = wkt;\r\n        }\r\n        if (geogcs) {\r\n            //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\r\n            //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\r\n            //}\r\n            if (geogcs.DATUM) {\r\n                wkt.datumCode = geogcs.DATUM.name.toLowerCase();\r\n            }\r\n            else {\r\n                wkt.datumCode = geogcs.name.toLowerCase();\r\n            }\r\n            if (wkt.datumCode.slice(0, 2) === 'd_') {\r\n                wkt.datumCode = wkt.datumCode.slice(2);\r\n            }\r\n            if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\r\n                wkt.datumCode = 'nzgd49';\r\n            }\r\n            if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {\r\n                if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\r\n                    wkt.sphere = true;\r\n                }\r\n                wkt.datumCode = 'wgs84';\r\n            }\r\n            if (wkt.datumCode.slice(-6) === '_ferro') {\r\n                wkt.datumCode = wkt.datumCode.slice(0, -6);\r\n            }\r\n            if (wkt.datumCode.slice(-8) === '_jakarta') {\r\n                wkt.datumCode = wkt.datumCode.slice(0, -8);\r\n            }\r\n            if (~wkt.datumCode.indexOf('belge')) {\r\n                wkt.datumCode = 'rnb72';\r\n            }\r\n            if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\r\n                wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\r\n                if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\r\n                    wkt.ellps = 'intl';\r\n                }\r\n                wkt.a = geogcs.DATUM.SPHEROID.a;\r\n                wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\r\n            }\r\n            if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\r\n                wkt.datum_params = geogcs.DATUM.TOWGS84;\r\n            }\r\n            if (~wkt.datumCode.indexOf('osgb_1936')) {\r\n                wkt.datumCode = 'osgb36';\r\n            }\r\n            if (~wkt.datumCode.indexOf('osni_1952')) {\r\n                wkt.datumCode = 'osni52';\r\n            }\r\n            if (~wkt.datumCode.indexOf('tm65')\r\n                || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\r\n                wkt.datumCode = 'ire65';\r\n            }\r\n            if (wkt.datumCode === 'ch1903+') {\r\n                wkt.datumCode = 'ch1903';\r\n            }\r\n            if (~wkt.datumCode.indexOf('israel')) {\r\n                wkt.datumCode = 'isr93';\r\n            }\r\n        }\r\n        if (wkt.b && !isFinite(wkt.b)) {\r\n            wkt.b = wkt.a;\r\n        }\r\n        function toMeter(input) {\r\n            var ratio = wkt.to_meter || 1;\r\n            return input * ratio;\r\n        }\r\n        var renamer = function (a) {\r\n            return rename(wkt, a);\r\n        };\r\n        var list = [\r\n            ['standard_parallel_1', 'Standard_Parallel_1'],\r\n            ['standard_parallel_2', 'Standard_Parallel_2'],\r\n            ['false_easting', 'False_Easting'],\r\n            ['false_northing', 'False_Northing'],\r\n            ['central_meridian', 'Central_Meridian'],\r\n            ['latitude_of_origin', 'Latitude_Of_Origin'],\r\n            ['latitude_of_origin', 'Central_Parallel'],\r\n            ['scale_factor', 'Scale_Factor'],\r\n            ['k0', 'scale_factor'],\r\n            ['latitude_of_center', 'Latitude_Of_Center'],\r\n            ['latitude_of_center', 'Latitude_of_center'],\r\n            ['lat0', 'latitude_of_center', d2r],\r\n            ['longitude_of_center', 'Longitude_Of_Center'],\r\n            ['longitude_of_center', 'Longitude_of_center'],\r\n            ['longc', 'longitude_of_center', d2r],\r\n            ['x0', 'false_easting', toMeter],\r\n            ['y0', 'false_northing', toMeter],\r\n            ['long0', 'central_meridian', d2r],\r\n            ['lat0', 'latitude_of_origin', d2r],\r\n            ['lat0', 'standard_parallel_1', d2r],\r\n            ['lat1', 'standard_parallel_1', d2r],\r\n            ['lat2', 'standard_parallel_2', d2r],\r\n            ['azimuth', 'Azimuth'],\r\n            ['alpha', 'azimuth', d2r],\r\n            ['srsCode', 'name']\r\n        ];\r\n        list.forEach(renamer);\r\n        if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\r\n            wkt.long0 = wkt.longc;\r\n        }\r\n        if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\r\n            wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\r\n            wkt.lat_ts = wkt.lat1;\r\n        }\r\n    }\r\n    function default_1(wkt) {\r\n        var lisp = parser_1.default(wkt);\r\n        var type = lisp.shift();\r\n        var name = lisp.shift();\r\n        lisp.unshift(['name', name]);\r\n        lisp.unshift(['type', type]);\r\n        var obj = {};\r\n        process_1.sExpr(lisp, obj);\r\n        cleanWKT(obj);\r\n        return obj;\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* wkt-parser\\parser.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = parseString;\r\n    var NEUTRAL = 1;\r\n    var KEYWORD = 2;\r\n    var NUMBER = 3;\r\n    var QUOTED = 4;\r\n    var AFTERQUOTE = 5;\r\n    var ENDED = -1;\r\n    var whitespace = /\\s/;\r\n    var latin = /[A-Za-z]/;\r\n    var keyword = /[A-Za-z84]/;\r\n    var endThings = /[,\\]]/;\r\n    var digets = /[\\d\\.E\\-\\+]/;\r\n    // const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\r\n    function Parser(text) {\r\n        if (typeof text !== 'string') {\r\n            throw new Error('not a string');\r\n        }\r\n        this.text = text.trim();\r\n        this.level = 0;\r\n        this.place = 0;\r\n        this.root = null;\r\n        this.stack = [];\r\n        this.currentObject = null;\r\n        this.state = NEUTRAL;\r\n    }\r\n    Parser.prototype.readCharicter = function () {\r\n        var char = this.text[this.place++];\r\n        if (this.state !== QUOTED) {\r\n            while (whitespace.test(char)) {\r\n                if (this.place >= this.text.length) {\r\n                    return;\r\n                }\r\n                char = this.text[this.place++];\r\n            }\r\n        }\r\n        switch (this.state) {\r\n            case NEUTRAL:\r\n                return this.neutral(char);\r\n            case KEYWORD:\r\n                return this.keyword(char);\r\n            case QUOTED:\r\n                return this.quoted(char);\r\n            case AFTERQUOTE:\r\n                return this.afterquote(char);\r\n            case NUMBER:\r\n                return this.number(char);\r\n            case ENDED:\r\n                return;\r\n        }\r\n    };\r\n    Parser.prototype.afterquote = function (char) {\r\n        if (char === '\"') {\r\n            this.word += '\"';\r\n            this.state = QUOTED;\r\n            return;\r\n        }\r\n        if (endThings.test(char)) {\r\n            this.word = this.word.trim();\r\n            this.afterItem(char);\r\n            return;\r\n        }\r\n        throw new Error('havn\\'t handled \"' + char + '\" in afterquote yet, index ' + this.place);\r\n    };\r\n    Parser.prototype.afterItem = function (char) {\r\n        if (char === ',') {\r\n            if (this.word !== null) {\r\n                this.currentObject.push(this.word);\r\n            }\r\n            this.word = null;\r\n            this.state = NEUTRAL;\r\n            return;\r\n        }\r\n        if (char === ']') {\r\n            this.level--;\r\n            if (this.word !== null) {\r\n                this.currentObject.push(this.word);\r\n                this.word = null;\r\n            }\r\n            this.state = NEUTRAL;\r\n            this.currentObject = this.stack.pop();\r\n            if (!this.currentObject) {\r\n                this.state = ENDED;\r\n            }\r\n            return;\r\n        }\r\n    };\r\n    Parser.prototype.number = function (char) {\r\n        if (digets.test(char)) {\r\n            this.word += char;\r\n            return;\r\n        }\r\n        if (endThings.test(char)) {\r\n            this.word = parseFloat(this.word);\r\n            this.afterItem(char);\r\n            return;\r\n        }\r\n        throw new Error('havn\\'t handled \"' + char + '\" in number yet, index ' + this.place);\r\n    };\r\n    Parser.prototype.quoted = function (char) {\r\n        if (char === '\"') {\r\n            this.state = AFTERQUOTE;\r\n            return;\r\n        }\r\n        this.word += char;\r\n        return;\r\n    };\r\n    Parser.prototype.keyword = function (char) {\r\n        if (keyword.test(char)) {\r\n            this.word += char;\r\n            return;\r\n        }\r\n        if (char === '[') {\r\n            var newObjects = [];\r\n            newObjects.push(this.word);\r\n            this.level++;\r\n            if (this.root === null) {\r\n                this.root = newObjects;\r\n            }\r\n            else {\r\n                this.currentObject.push(newObjects);\r\n            }\r\n            this.stack.push(this.currentObject);\r\n            this.currentObject = newObjects;\r\n            this.state = NEUTRAL;\r\n            return;\r\n        }\r\n        if (endThings.test(char)) {\r\n            this.afterItem(char);\r\n            return;\r\n        }\r\n        throw new Error('havn\\'t handled \"' + char + '\" in keyword yet, index ' + this.place);\r\n    };\r\n    Parser.prototype.neutral = function (char) {\r\n        if (latin.test(char)) {\r\n            this.word = char;\r\n            this.state = KEYWORD;\r\n            return;\r\n        }\r\n        if (char === '\"') {\r\n            this.word = '';\r\n            this.state = QUOTED;\r\n            return;\r\n        }\r\n        if (digets.test(char)) {\r\n            this.word = char;\r\n            this.state = NUMBER;\r\n            return;\r\n        }\r\n        if (endThings.test(char)) {\r\n            this.afterItem(char);\r\n            return;\r\n        }\r\n        throw new Error('havn\\'t handled \"' + char + '\" in neutral yet, index ' + this.place);\r\n    };\r\n    Parser.prototype.output = function () {\r\n        while (this.place < this.text.length) {\r\n            this.readCharicter();\r\n        }\r\n        if (this.state === ENDED) {\r\n            return this.root;\r\n        }\r\n        throw new Error('unable to parse string \"' + this.text + '\". State is ' + this.state);\r\n    };\r\n    function parseString(txt) {\r\n        var parser = new Parser(txt);\r\n        return parser.output();\r\n    }\r\n}\r\n","/* wkt-parser\\process.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function mapit(obj, key, value) {\r\n        if (Array.isArray(key)) {\r\n            value.unshift(key);\r\n            key = null;\r\n        }\r\n        var thing = key ? {} : obj;\r\n        var out = value.reduce(function (newObj, item) {\r\n            sExpr(item, newObj);\r\n            return newObj;\r\n        }, thing);\r\n        if (key) {\r\n            obj[key] = out;\r\n        }\r\n    }\r\n    function sExpr(v, obj) {\r\n        if (!Array.isArray(v)) {\r\n            obj[v] = true;\r\n            return;\r\n        }\r\n        var key = v.shift();\r\n        if (key === 'PARAMETER') {\r\n            key = v.shift();\r\n        }\r\n        if (v.length === 1) {\r\n            if (Array.isArray(v[0])) {\r\n                obj[key] = {};\r\n                sExpr(v[0], obj[key]);\r\n                return;\r\n            }\r\n            obj[key] = v[0];\r\n            return;\r\n        }\r\n        if (!v.length) {\r\n            obj[key] = true;\r\n            return;\r\n        }\r\n        if (key === 'TOWGS84') {\r\n            obj[key] = v;\r\n            return;\r\n        }\r\n        if (key === 'AXIS') {\r\n            if (!(key in obj)) {\r\n                obj[key] = [];\r\n            }\r\n            obj[key].push(v);\r\n            return;\r\n        }\r\n        if (!Array.isArray(key)) {\r\n            obj[key] = {};\r\n        }\r\n        var i;\r\n        switch (key) {\r\n            case 'UNIT':\r\n            case 'PRIMEM':\r\n            case 'VERT_DATUM':\r\n                obj[key] = {\r\n                    name: v[0].toLowerCase(),\r\n                    convert: v[1]\r\n                };\r\n                if (v.length === 3) {\r\n                    sExpr(v[2], obj[key]);\r\n                }\r\n                return;\r\n            case 'SPHEROID':\r\n            case 'ELLIPSOID':\r\n                obj[key] = {\r\n                    name: v[0],\r\n                    a: v[1],\r\n                    rf: v[2]\r\n                };\r\n                if (v.length === 4) {\r\n                    sExpr(v[3], obj[key]);\r\n                }\r\n                return;\r\n            case 'PROJECTEDCRS':\r\n            case 'PROJCRS':\r\n            case 'GEOGCS':\r\n            case 'GEOCCS':\r\n            case 'PROJCS':\r\n            case 'LOCAL_CS':\r\n            case 'GEODCRS':\r\n            case 'GEODETICCRS':\r\n            case 'GEODETICDATUM':\r\n            case 'EDATUM':\r\n            case 'ENGINEERINGDATUM':\r\n            case 'VERT_CS':\r\n            case 'VERTCRS':\r\n            case 'VERTICALCRS':\r\n            case 'COMPD_CS':\r\n            case 'COMPOUNDCRS':\r\n            case 'ENGINEERINGCRS':\r\n            case 'ENGCRS':\r\n            case 'FITTED_CS':\r\n            case 'LOCAL_DATUM':\r\n            case 'DATUM':\r\n                v[0] = ['name', v[0]];\r\n                mapit(obj, key, v);\r\n                return;\r\n            default:\r\n                i = -1;\r\n                while (++i < v.length) {\r\n                    if (!Array.isArray(v[i])) {\r\n                        return sExpr(v, obj[key]);\r\n                    }\r\n                }\r\n                return mapit(obj, key, v);\r\n        }\r\n    }\r\n    exports.sExpr = sExpr;\r\n}\r\n","/* proj4\\lib\\extend.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function default_1(destination, source) {\r\n        destination = destination || {};\r\n        var value, property;\r\n        if (!source) {\r\n            return destination;\r\n        }\r\n        for (property in source) {\r\n            value = source[property];\r\n            if (value !== undefined) {\r\n                destination[property] = value;\r\n            }\r\n        }\r\n        return destination;\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\projections.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const merc_1 = tslib_1.__importDefault(require(53) /* ./projections/merc */);\r\n    const longlat_1 = tslib_1.__importDefault(require(59) /* ./projections/longlat */);\r\n    var projs = [merc_1.default, longlat_1.default];\r\n    var names = {};\r\n    var projStore = [];\r\n    function add(proj, i) {\r\n        var len = projStore.length;\r\n        if (!proj.names) {\r\n            console.log(i);\r\n            return true;\r\n        }\r\n        projStore[len] = proj;\r\n        proj.names.forEach(function (n) {\r\n            names[n.toLowerCase()] = len;\r\n        });\r\n        return this;\r\n    }\r\n    exports.add = add;\r\n    function get(name) {\r\n        if (!name) {\r\n            return false;\r\n        }\r\n        var n = name.toLowerCase();\r\n        if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\r\n            return projStore[names[n]];\r\n        }\r\n    }\r\n    exports.get = get;\r\n    function start() {\r\n        projs.forEach(add);\r\n    }\r\n    exports.start = start;\r\n    exports.default = {\r\n        start: start,\r\n        add: add,\r\n        get: get\r\n    };\r\n}\r\n","/* proj4\\lib\\projections\\merc.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const msfnz_1 = tslib_1.__importDefault(require(54) /* ../common/msfnz */);\r\n    const adjust_lon_1 = tslib_1.__importDefault(require(55) /* ../common/adjust_lon */);\r\n    const tsfnz_1 = tslib_1.__importDefault(require(57) /* ../common/tsfnz */);\r\n    const phi2z_1 = tslib_1.__importDefault(require(58) /* ../common/phi2z */);\r\n    const values_1 = require(44) /* ../constants/values */;\r\n    function init() {\r\n        var con = this.b / this.a;\r\n        this.es = 1 - con * con;\r\n        if (!('x0' in this)) {\r\n            this.x0 = 0;\r\n        }\r\n        if (!('y0' in this)) {\r\n            this.y0 = 0;\r\n        }\r\n        this.e = Math.sqrt(this.es);\r\n        if (this.lat_ts) {\r\n            if (this.sphere) {\r\n                this.k0 = Math.cos(this.lat_ts);\r\n            }\r\n            else {\r\n                this.k0 = msfnz_1.default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\r\n            }\r\n        }\r\n        else {\r\n            if (!this.k0) {\r\n                if (this.k) {\r\n                    this.k0 = this.k;\r\n                }\r\n                else {\r\n                    this.k0 = 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.init = init;\r\n    /* Mercator forward equations--mapping lat,long to x,y\r\n      --------------------------------------------------*/\r\n    function forward(p) {\r\n        var lon = p.x;\r\n        var lat = p.y;\r\n        // convert to radians\r\n        if (lat * values_1.R2D > 90 && lat * values_1.R2D < -90 && lon * values_1.R2D > 180 && lon * values_1.R2D < -180) {\r\n            return null;\r\n        }\r\n        var x, y;\r\n        if (Math.abs(Math.abs(lat) - values_1.HALF_PI) <= values_1.EPSLN) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (this.sphere) {\r\n                x = this.x0 + this.a * this.k0 * adjust_lon_1.default(lon - this.long0);\r\n                y = this.y0 + this.a * this.k0 * Math.log(Math.tan(values_1.FORTPI + 0.5 * lat));\r\n            }\r\n            else {\r\n                var sinphi = Math.sin(lat);\r\n                var ts = tsfnz_1.default(this.e, lat, sinphi);\r\n                x = this.x0 + this.a * this.k0 * adjust_lon_1.default(lon - this.long0);\r\n                y = this.y0 - this.a * this.k0 * Math.log(ts);\r\n            }\r\n            p.x = x;\r\n            p.y = y;\r\n            return p;\r\n        }\r\n    }\r\n    exports.forward = forward;\r\n    /* Mercator inverse equations--mapping x,y to lat/long\r\n      --------------------------------------------------*/\r\n    function inverse(p) {\r\n        var x = p.x - this.x0;\r\n        var y = p.y - this.y0;\r\n        var lon, lat;\r\n        if (this.sphere) {\r\n            lat = values_1.HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\r\n        }\r\n        else {\r\n            var ts = Math.exp(-y / (this.a * this.k0));\r\n            lat = phi2z_1.default(this.e, ts);\r\n            if (lat === -9999) {\r\n                return null;\r\n            }\r\n        }\r\n        lon = adjust_lon_1.default(this.long0 + x / (this.a * this.k0));\r\n        p.x = lon;\r\n        p.y = lat;\r\n        return p;\r\n    }\r\n    exports.inverse = inverse;\r\n    exports.names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\r\n    exports.default = {\r\n        init: init,\r\n        forward: forward,\r\n        inverse: inverse,\r\n        names: exports.names\r\n    };\r\n}\r\n","/* proj4\\lib\\common\\msfnz.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function default_1(eccent, sinphi, cosphi) {\r\n        var con = eccent * sinphi;\r\n        return cosphi / (Math.sqrt(1 - con * con));\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\common\\adjust_lon.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const values_1 = require(44) /* ../constants/values */;\r\n    const sign_1 = tslib_1.__importDefault(require(56) /* ./sign */);\r\n    function default_1(x) {\r\n        return (Math.abs(x) <= values_1.SPI) ? x : (x - (sign_1.default(x) * values_1.TWO_PI));\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\common\\sign.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function default_1(x) {\r\n        return x < 0 ? -1 : 1;\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\common\\tsfnz.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const values_1 = require(44) /* ../constants/values */;\r\n    function default_1(eccent, phi, sinphi) {\r\n        var con = eccent * sinphi;\r\n        var com = 0.5 * eccent;\r\n        con = Math.pow(((1 - con) / (1 + con)), com);\r\n        return (Math.tan(0.5 * (values_1.HALF_PI - phi)) / con);\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\common\\phi2z.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const values_1 = require(44) /* ../constants/values */;\r\n    function default_1(eccent, ts) {\r\n        var eccnth = 0.5 * eccent;\r\n        var con, dphi;\r\n        var phi = values_1.HALF_PI - 2 * Math.atan(ts);\r\n        for (var i = 0; i <= 15; i++) {\r\n            con = eccent * Math.sin(phi);\r\n            dphi = values_1.HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\r\n            phi += dphi;\r\n            if (Math.abs(dphi) <= 0.0000000001) {\r\n                return phi;\r\n            }\r\n        }\r\n        //console.log(\"phi2z has NoConvergence\");\r\n        return -9999;\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\projections\\longlat.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function init() {\r\n        //no-op for longlat\r\n    }\r\n    exports.init = init;\r\n    function identity(pt) {\r\n        return pt;\r\n    }\r\n    exports.forward = identity;\r\n    exports.inverse = identity;\r\n    exports.names = [\"longlat\", \"identity\"];\r\n    exports.default = {\r\n        init: init,\r\n        forward: identity,\r\n        inverse: identity,\r\n        names: exports.names\r\n    };\r\n}\r\n","/* proj4\\lib\\deriveConstants.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const values_1 = require(44) /* ./constants/values */;\r\n    const Ellipsoid_1 = tslib_1.__importStar(require(61) /* ./constants/Ellipsoid */);\r\n    const match_1 = tslib_1.__importDefault(require(47) /* ./match */);\r\n    function eccentricity(a, b, rf, R_A) {\r\n        var a2 = a * a; // used in geocentric\r\n        var b2 = b * b; // used in geocentric\r\n        var es = (a2 - b2) / a2; // e ^ 2\r\n        var e = 0;\r\n        if (R_A) {\r\n            a *= 1 - es * (values_1.SIXTH + es * (values_1.RA4 + es * values_1.RA6));\r\n            a2 = a * a;\r\n            es = 0;\r\n        }\r\n        else {\r\n            e = Math.sqrt(es); // eccentricity\r\n        }\r\n        var ep2 = (a2 - b2) / b2; // used in geocentric\r\n        return {\r\n            es: es,\r\n            e: e,\r\n            ep2: ep2\r\n        };\r\n    }\r\n    exports.eccentricity = eccentricity;\r\n    function sphere(a, b, rf, ellps, sphere) {\r\n        if (!a) { // do we have an ellipsoid?\r\n            var ellipse = match_1.default(Ellipsoid_1.default, ellps);\r\n            if (!ellipse) {\r\n                ellipse = Ellipsoid_1.WGS84;\r\n            }\r\n            a = ellipse.a;\r\n            b = ellipse.b;\r\n            rf = ellipse.rf;\r\n        }\r\n        if (rf && !b) {\r\n            b = (1.0 - 1.0 / rf) * a;\r\n        }\r\n        if (rf === 0 || Math.abs(a - b) < values_1.EPSLN) {\r\n            sphere = true;\r\n            b = a;\r\n        }\r\n        return {\r\n            a: a,\r\n            b: b,\r\n            rf: rf,\r\n            sphere: sphere\r\n        };\r\n    }\r\n    exports.sphere = sphere;\r\n}\r\n","/* proj4\\lib\\constants\\Ellipsoid.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var exports$1 = {};\r\n    exports.default = exports$1;\r\n    exports$1.MERIT = {\r\n        a: 6378137.0,\r\n        rf: 298.257,\r\n        ellipseName: \"MERIT 1983\"\r\n    };\r\n    exports$1.SGS85 = {\r\n        a: 6378136.0,\r\n        rf: 298.257,\r\n        ellipseName: \"Soviet Geodetic System 85\"\r\n    };\r\n    exports$1.GRS80 = {\r\n        a: 6378137.0,\r\n        rf: 298.257222101,\r\n        ellipseName: \"GRS 1980(IUGG, 1980)\"\r\n    };\r\n    exports$1.IAU76 = {\r\n        a: 6378140.0,\r\n        rf: 298.257,\r\n        ellipseName: \"IAU 1976\"\r\n    };\r\n    exports$1.airy = {\r\n        a: 6377563.396,\r\n        b: 6356256.910,\r\n        ellipseName: \"Airy 1830\"\r\n    };\r\n    exports$1.APL4 = {\r\n        a: 6378137,\r\n        rf: 298.25,\r\n        ellipseName: \"Appl. Physics. 1965\"\r\n    };\r\n    exports$1.NWL9D = {\r\n        a: 6378145.0,\r\n        rf: 298.25,\r\n        ellipseName: \"Naval Weapons Lab., 1965\"\r\n    };\r\n    exports$1.mod_airy = {\r\n        a: 6377340.189,\r\n        b: 6356034.446,\r\n        ellipseName: \"Modified Airy\"\r\n    };\r\n    exports$1.andrae = {\r\n        a: 6377104.43,\r\n        rf: 300.0,\r\n        ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\r\n    };\r\n    exports$1.aust_SA = {\r\n        a: 6378160.0,\r\n        rf: 298.25,\r\n        ellipseName: \"Australian Natl & S. Amer. 1969\"\r\n    };\r\n    exports$1.GRS67 = {\r\n        a: 6378160.0,\r\n        rf: 298.2471674270,\r\n        ellipseName: \"GRS 67(IUGG 1967)\"\r\n    };\r\n    exports$1.bessel = {\r\n        a: 6377397.155,\r\n        rf: 299.1528128,\r\n        ellipseName: \"Bessel 1841\"\r\n    };\r\n    exports$1.bess_nam = {\r\n        a: 6377483.865,\r\n        rf: 299.1528128,\r\n        ellipseName: \"Bessel 1841 (Namibia)\"\r\n    };\r\n    exports$1.clrk66 = {\r\n        a: 6378206.4,\r\n        b: 6356583.8,\r\n        ellipseName: \"Clarke 1866\"\r\n    };\r\n    exports$1.clrk80 = {\r\n        a: 6378249.145,\r\n        rf: 293.4663,\r\n        ellipseName: \"Clarke 1880 mod.\"\r\n    };\r\n    exports$1.clrk58 = {\r\n        a: 6378293.645208759,\r\n        rf: 294.2606763692654,\r\n        ellipseName: \"Clarke 1858\"\r\n    };\r\n    exports$1.CPM = {\r\n        a: 6375738.7,\r\n        rf: 334.29,\r\n        ellipseName: \"Comm. des Poids et Mesures 1799\"\r\n    };\r\n    exports$1.delmbr = {\r\n        a: 6376428.0,\r\n        rf: 311.5,\r\n        ellipseName: \"Delambre 1810 (Belgium)\"\r\n    };\r\n    exports$1.engelis = {\r\n        a: 6378136.05,\r\n        rf: 298.2566,\r\n        ellipseName: \"Engelis 1985\"\r\n    };\r\n    exports$1.evrst30 = {\r\n        a: 6377276.345,\r\n        rf: 300.8017,\r\n        ellipseName: \"Everest 1830\"\r\n    };\r\n    exports$1.evrst48 = {\r\n        a: 6377304.063,\r\n        rf: 300.8017,\r\n        ellipseName: \"Everest 1948\"\r\n    };\r\n    exports$1.evrst56 = {\r\n        a: 6377301.243,\r\n        rf: 300.8017,\r\n        ellipseName: \"Everest 1956\"\r\n    };\r\n    exports$1.evrst69 = {\r\n        a: 6377295.664,\r\n        rf: 300.8017,\r\n        ellipseName: \"Everest 1969\"\r\n    };\r\n    exports$1.evrstSS = {\r\n        a: 6377298.556,\r\n        rf: 300.8017,\r\n        ellipseName: \"Everest (Sabah & Sarawak)\"\r\n    };\r\n    exports$1.fschr60 = {\r\n        a: 6378166.0,\r\n        rf: 298.3,\r\n        ellipseName: \"Fischer (Mercury Datum) 1960\"\r\n    };\r\n    exports$1.fschr60m = {\r\n        a: 6378155.0,\r\n        rf: 298.3,\r\n        ellipseName: \"Fischer 1960\"\r\n    };\r\n    exports$1.fschr68 = {\r\n        a: 6378150.0,\r\n        rf: 298.3,\r\n        ellipseName: \"Fischer 1968\"\r\n    };\r\n    exports$1.helmert = {\r\n        a: 6378200.0,\r\n        rf: 298.3,\r\n        ellipseName: \"Helmert 1906\"\r\n    };\r\n    exports$1.hough = {\r\n        a: 6378270.0,\r\n        rf: 297.0,\r\n        ellipseName: \"Hough\"\r\n    };\r\n    exports$1.intl = {\r\n        a: 6378388.0,\r\n        rf: 297.0,\r\n        ellipseName: \"International 1909 (Hayford)\"\r\n    };\r\n    exports$1.kaula = {\r\n        a: 6378163.0,\r\n        rf: 298.24,\r\n        ellipseName: \"Kaula 1961\"\r\n    };\r\n    exports$1.lerch = {\r\n        a: 6378139.0,\r\n        rf: 298.257,\r\n        ellipseName: \"Lerch 1979\"\r\n    };\r\n    exports$1.mprts = {\r\n        a: 6397300.0,\r\n        rf: 191.0,\r\n        ellipseName: \"Maupertius 1738\"\r\n    };\r\n    exports$1.new_intl = {\r\n        a: 6378157.5,\r\n        b: 6356772.2,\r\n        ellipseName: \"New International 1967\"\r\n    };\r\n    exports$1.plessis = {\r\n        a: 6376523.0,\r\n        rf: 6355863.0,\r\n        ellipseName: \"Plessis 1817 (France)\"\r\n    };\r\n    exports$1.krass = {\r\n        a: 6378245.0,\r\n        rf: 298.3,\r\n        ellipseName: \"Krassovsky, 1942\"\r\n    };\r\n    exports$1.SEasia = {\r\n        a: 6378155.0,\r\n        b: 6356773.3205,\r\n        ellipseName: \"Southeast Asia\"\r\n    };\r\n    exports$1.walbeck = {\r\n        a: 6376896.0,\r\n        b: 6355834.8467,\r\n        ellipseName: \"Walbeck\"\r\n    };\r\n    exports$1.WGS60 = {\r\n        a: 6378165.0,\r\n        rf: 298.3,\r\n        ellipseName: \"WGS 60\"\r\n    };\r\n    exports$1.WGS66 = {\r\n        a: 6378145.0,\r\n        rf: 298.25,\r\n        ellipseName: \"WGS 66\"\r\n    };\r\n    exports$1.WGS7 = {\r\n        a: 6378135.0,\r\n        rf: 298.26,\r\n        ellipseName: \"WGS 72\"\r\n    };\r\n    exports.WGS84 = exports$1.WGS84 = {\r\n        a: 6378137.0,\r\n        rf: 298.257223563,\r\n        ellipseName: \"WGS 84\"\r\n    };\r\n    exports$1.sphere = {\r\n        a: 6370997.0,\r\n        b: 6370997.0,\r\n        ellipseName: \"Normal Sphere (r=6370997)\"\r\n    };\r\n}\r\n","/* proj4\\lib\\constants\\Datum.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var exports$1 = {};\r\n    exports.default = exports$1;\r\n    exports$1.wgs84 = {\r\n        towgs84: \"0,0,0\",\r\n        ellipse: \"WGS84\",\r\n        datumName: \"WGS84\"\r\n    };\r\n    exports$1.ch1903 = {\r\n        towgs84: \"674.374,15.056,405.346\",\r\n        ellipse: \"bessel\",\r\n        datumName: \"swiss\"\r\n    };\r\n    exports$1.ggrs87 = {\r\n        towgs84: \"-199.87,74.79,246.62\",\r\n        ellipse: \"GRS80\",\r\n        datumName: \"Greek_Geodetic_Reference_System_1987\"\r\n    };\r\n    exports$1.nad83 = {\r\n        towgs84: \"0,0,0\",\r\n        ellipse: \"GRS80\",\r\n        datumName: \"North_American_Datum_1983\"\r\n    };\r\n    exports$1.nad27 = {\r\n        nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\r\n        ellipse: \"clrk66\",\r\n        datumName: \"North_American_Datum_1927\"\r\n    };\r\n    exports$1.potsdam = {\r\n        towgs84: \"606.0,23.0,413.0\",\r\n        ellipse: \"bessel\",\r\n        datumName: \"Potsdam Rauenberg 1950 DHDN\"\r\n    };\r\n    exports$1.carthage = {\r\n        towgs84: \"-263.0,6.0,431.0\",\r\n        ellipse: \"clark80\",\r\n        datumName: \"Carthage 1934 Tunisia\"\r\n    };\r\n    exports$1.hermannskogel = {\r\n        towgs84: \"653.0,-212.0,449.0\",\r\n        ellipse: \"bessel\",\r\n        datumName: \"Hermannskogel\"\r\n    };\r\n    exports$1.osni52 = {\r\n        towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\r\n        ellipse: \"airy\",\r\n        datumName: \"Irish National\"\r\n    };\r\n    exports$1.ire65 = {\r\n        towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\r\n        ellipse: \"mod_airy\",\r\n        datumName: \"Ireland 1965\"\r\n    };\r\n    exports$1.rassadiran = {\r\n        towgs84: \"-133.63,-157.5,-158.62\",\r\n        ellipse: \"intl\",\r\n        datumName: \"Rassadiran\"\r\n    };\r\n    exports$1.nzgd49 = {\r\n        towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\r\n        ellipse: \"intl\",\r\n        datumName: \"New Zealand Geodetic Datum 1949\"\r\n    };\r\n    exports$1.osgb36 = {\r\n        towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\r\n        ellipse: \"airy\",\r\n        datumName: \"Airy 1830\"\r\n    };\r\n    exports$1.s_jtsk = {\r\n        towgs84: \"589,76,480\",\r\n        ellipse: 'bessel',\r\n        datumName: 'S-JTSK (Ferro)'\r\n    };\r\n    exports$1.beduaram = {\r\n        towgs84: '-106,-87,188',\r\n        ellipse: 'clrk80',\r\n        datumName: 'Beduaram'\r\n    };\r\n    exports$1.gunung_segara = {\r\n        towgs84: '-403,684,41',\r\n        ellipse: 'bessel',\r\n        datumName: 'Gunung Segara Jakarta'\r\n    };\r\n    exports$1.rnb72 = {\r\n        towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\r\n        ellipse: \"intl\",\r\n        datumName: \"Reseau National Belge 1972\"\r\n    };\r\n}\r\n","/* proj4\\lib\\datum.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const values_1 = require(44) /* ./constants/values */;\r\n    function datum(datumCode, datum_params, a, b, es, ep2) {\r\n        var out = {};\r\n        if (datumCode === undefined || datumCode === 'none') {\r\n            out.datum_type = values_1.PJD_NODATUM;\r\n        }\r\n        else {\r\n            out.datum_type = values_1.PJD_WGS84;\r\n        }\r\n        if (datum_params) {\r\n            out.datum_params = datum_params.map(parseFloat);\r\n            if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\r\n                out.datum_type = values_1.PJD_3PARAM;\r\n            }\r\n            if (out.datum_params.length > 3) {\r\n                if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\r\n                    out.datum_type = values_1.PJD_7PARAM;\r\n                    out.datum_params[3] *= values_1.SEC_TO_RAD;\r\n                    out.datum_params[4] *= values_1.SEC_TO_RAD;\r\n                    out.datum_params[5] *= values_1.SEC_TO_RAD;\r\n                    out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\r\n                }\r\n            }\r\n        }\r\n        out.a = a; //datum object also uses these values\r\n        out.b = b;\r\n        out.es = es;\r\n        out.ep2 = ep2;\r\n        return out;\r\n    }\r\n    exports.default = datum;\r\n}\r\n","/* proj4\\lib\\transform.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const values_1 = require(44) /* ./constants/values */;\r\n    const datum_transform_1 = tslib_1.__importDefault(require(65) /* ./datum_transform */);\r\n    const adjust_axis_1 = tslib_1.__importDefault(require(67) /* ./adjust_axis */);\r\n    const Proj_1 = tslib_1.__importDefault(require(39) /* ./Proj */);\r\n    const toPoint_1 = tslib_1.__importDefault(require(68) /* ./common/toPoint */);\r\n    const checkSanity_1 = tslib_1.__importDefault(require(69) /* ./checkSanity */);\r\n    function checkNotWGS(source, dest) {\r\n        return ((source.datum.datum_type === values_1.PJD_3PARAM || source.datum.datum_type === values_1.PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === values_1.PJD_3PARAM || dest.datum.datum_type === values_1.PJD_7PARAM) && source.datumCode !== 'WGS84');\r\n    }\r\n    function transform(source, dest, point) {\r\n        var wgs84;\r\n        if (Array.isArray(point)) {\r\n            point = toPoint_1.default(point);\r\n        }\r\n        checkSanity_1.default(point);\r\n        // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\r\n        if (source.datum && dest.datum && checkNotWGS(source, dest)) {\r\n            wgs84 = new Proj_1.default('WGS84');\r\n            point = transform(source, wgs84, point);\r\n            source = wgs84;\r\n        }\r\n        // DGR, 2010/11/12\r\n        if (source.axis !== 'enu') {\r\n            point = adjust_axis_1.default(source, false, point);\r\n        }\r\n        // Transform source points to long/lat, if they aren't already.\r\n        if (source.projName === 'longlat') {\r\n            point = {\r\n                x: point.x * values_1.D2R,\r\n                y: point.y * values_1.D2R,\r\n                z: point.z || 0\r\n            };\r\n        }\r\n        else {\r\n            if (source.to_meter) {\r\n                point = {\r\n                    x: point.x * source.to_meter,\r\n                    y: point.y * source.to_meter,\r\n                    z: point.z || 0\r\n                };\r\n            }\r\n            point = source.inverse(point); // Convert Cartesian to longlat\r\n            if (!point) {\r\n                return;\r\n            }\r\n        }\r\n        // Adjust for the prime meridian if necessary\r\n        if (source.from_greenwich) {\r\n            point.x += source.from_greenwich;\r\n        }\r\n        // Convert datums if needed, and if possible.\r\n        point = datum_transform_1.default(source.datum, dest.datum, point);\r\n        // Adjust for the prime meridian if necessary\r\n        if (dest.from_greenwich) {\r\n            point = {\r\n                x: point.x - dest.from_greenwich,\r\n                y: point.y,\r\n                z: point.z || 0\r\n            };\r\n        }\r\n        if (dest.projName === 'longlat') {\r\n            // convert radians to decimal degrees\r\n            point = {\r\n                x: point.x * values_1.R2D,\r\n                y: point.y * values_1.R2D,\r\n                z: point.z || 0\r\n            };\r\n        }\r\n        else { // else project\r\n            point = dest.forward(point);\r\n            if (dest.to_meter) {\r\n                point = {\r\n                    x: point.x / dest.to_meter,\r\n                    y: point.y / dest.to_meter,\r\n                    z: point.z || 0\r\n                };\r\n            }\r\n        }\r\n        // DGR, 2010/11/12\r\n        if (dest.axis !== 'enu') {\r\n            return adjust_axis_1.default(dest, true, point);\r\n        }\r\n        return point;\r\n    }\r\n    exports.default = transform;\r\n}\r\n","/* proj4\\lib\\datum_transform.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const values_1 = require(44) /* ./constants/values */;\r\n    const datumUtils_1 = require(66) /* ./datumUtils */;\r\n    function checkParams(type) {\r\n        return (type === values_1.PJD_3PARAM || type === values_1.PJD_7PARAM);\r\n    }\r\n    function default_1(source, dest, point) {\r\n        // Short cut if the datums are identical.\r\n        if (datumUtils_1.compareDatums(source, dest)) {\r\n            return point; // in this case, zero is sucess,\r\n            // whereas cs_compare_datums returns 1 to indicate TRUE\r\n            // confusing, should fix this\r\n        }\r\n        // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\r\n        if (source.datum_type === values_1.PJD_NODATUM || dest.datum_type === values_1.PJD_NODATUM) {\r\n            return point;\r\n        }\r\n        // If this datum requires grid shifts, then apply it to geodetic coordinates.\r\n        // Do we need to go through geocentric coordinates?\r\n        if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\r\n            return point;\r\n        }\r\n        // Convert to geocentric coordinates.\r\n        point = datumUtils_1.geodeticToGeocentric(point, source.es, source.a);\r\n        // Convert between datums\r\n        if (checkParams(source.datum_type)) {\r\n            point = datumUtils_1.geocentricToWgs84(point, source.datum_type, source.datum_params);\r\n        }\r\n        if (checkParams(dest.datum_type)) {\r\n            point = datumUtils_1.geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\r\n        }\r\n        return datumUtils_1.geocentricToGeodetic(point, dest.es, dest.a, dest.b);\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\datumUtils.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const values_1 = require(44) /* ./constants/values */;\r\n    function compareDatums(source, dest) {\r\n        if (source.datum_type !== dest.datum_type) {\r\n            return false; // false, datums are not equal\r\n        }\r\n        else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\r\n            // the tolerance for es is to ensure that GRS80 and WGS84\r\n            // are considered identical\r\n            return false;\r\n        }\r\n        else if (source.datum_type === values_1.PJD_3PARAM) {\r\n            return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\r\n        }\r\n        else if (source.datum_type === values_1.PJD_7PARAM) {\r\n            return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\r\n        }\r\n        else {\r\n            return true; // datums are equal\r\n        }\r\n    } // cs_compare_datums()\r\n    exports.compareDatums = compareDatums;\r\n    /*\r\n     * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\r\n     * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\r\n     * according to the current ellipsoid parameters.\r\n     *\r\n     *    Latitude  : Geodetic latitude in radians                     (input)\r\n     *    Longitude : Geodetic longitude in radians                    (input)\r\n     *    Height    : Geodetic height, in meters                       (input)\r\n     *    X         : Calculated Geocentric X coordinate, in meters    (output)\r\n     *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\r\n     *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\r\n     *\r\n     */\r\n    function geodeticToGeocentric(p, es, a) {\r\n        var Longitude = p.x;\r\n        var Latitude = p.y;\r\n        var Height = p.z ? p.z : 0; //Z value not always supplied\r\n        var Rn; /*  Earth radius at location  */\r\n        var Sin_Lat; /*  Math.sin(Latitude)  */\r\n        var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\r\n        var Cos_Lat; /*  Math.cos(Latitude)  */\r\n        /*\r\n         ** Don't blow up if Latitude is just a little out of the value\r\n         ** range as it may just be a rounding issue.  Also removed longitude\r\n         ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\r\n         */\r\n        if (Latitude < -values_1.HALF_PI && Latitude > -1.001 * values_1.HALF_PI) {\r\n            Latitude = -values_1.HALF_PI;\r\n        }\r\n        else if (Latitude > values_1.HALF_PI && Latitude < 1.001 * values_1.HALF_PI) {\r\n            Latitude = values_1.HALF_PI;\r\n        }\r\n        else if (Latitude < -values_1.HALF_PI) {\r\n            /* Latitude out of range */\r\n            //..reportError('geocent:lat out of range:' + Latitude);\r\n            return { x: -Infinity, y: -Infinity, z: p.z };\r\n        }\r\n        else if (Latitude > values_1.HALF_PI) {\r\n            /* Latitude out of range */\r\n            return { x: Infinity, y: Infinity, z: p.z };\r\n        }\r\n        if (Longitude > Math.PI) {\r\n            Longitude -= (2 * Math.PI);\r\n        }\r\n        Sin_Lat = Math.sin(Latitude);\r\n        Cos_Lat = Math.cos(Latitude);\r\n        Sin2_Lat = Sin_Lat * Sin_Lat;\r\n        Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\r\n        return {\r\n            x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\r\n            y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\r\n            z: ((Rn * (1 - es)) + Height) * Sin_Lat\r\n        };\r\n    } // cs_geodetic_to_geocentric()\r\n    exports.geodeticToGeocentric = geodeticToGeocentric;\r\n    function geocentricToGeodetic(p, es, a, b) {\r\n        /* local defintions and variables */\r\n        /* end-criterium of loop, accuracy of sin(Latitude) */\r\n        var genau = 1e-12;\r\n        var genau2 = (genau * genau);\r\n        var maxiter = 30;\r\n        var P; /* distance between semi-minor axis and location */\r\n        var RR; /* distance between center and location */\r\n        var CT; /* sin of geocentric latitude */\r\n        var ST; /* cos of geocentric latitude */\r\n        var RX;\r\n        var RK;\r\n        var RN; /* Earth radius at location */\r\n        var CPHI0; /* cos of start or old geodetic latitude in iterations */\r\n        var SPHI0; /* sin of start or old geodetic latitude in iterations */\r\n        var CPHI; /* cos of searched geodetic latitude */\r\n        var SPHI; /* sin of searched geodetic latitude */\r\n        var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\r\n        var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\r\n        var X = p.x;\r\n        var Y = p.y;\r\n        var Z = p.z ? p.z : 0.0; //Z value not always supplied\r\n        var Longitude;\r\n        var Latitude;\r\n        var Height;\r\n        P = Math.sqrt(X * X + Y * Y);\r\n        RR = Math.sqrt(X * X + Y * Y + Z * Z);\r\n        /*      special cases for latitude and longitude */\r\n        if (P / a < genau) {\r\n            /*  special case, if P=0. (X=0., Y=0.) */\r\n            Longitude = 0.0;\r\n            /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\r\n             *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\r\n            if (RR / a < genau) {\r\n                Latitude = values_1.HALF_PI;\r\n                Height = -b;\r\n                return {\r\n                    x: p.x,\r\n                    y: p.y,\r\n                    z: p.z\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            /*  ellipsoidal (geodetic) longitude\r\n             *  interval: -PI < Longitude <= +PI */\r\n            Longitude = Math.atan2(Y, X);\r\n        }\r\n        /* --------------------------------------------------------------\r\n         * Following iterative algorithm was developped by\r\n         * \"Institut for Erdmessung\", University of Hannover, July 1988.\r\n         * Internet: www.ife.uni-hannover.de\r\n         * Iterative computation of CPHI,SPHI and Height.\r\n         * Iteration of CPHI and SPHI to 10**-12 radian resp.\r\n         * 2*10**-7 arcsec.\r\n         * --------------------------------------------------------------\r\n         */\r\n        CT = Z / RR;\r\n        ST = P / RR;\r\n        RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\r\n        CPHI0 = ST * (1.0 - es) * RX;\r\n        SPHI0 = CT * RX;\r\n        iter = 0;\r\n        /* loop to find sin(Latitude) resp. Latitude\r\n         * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\r\n        do {\r\n            iter++;\r\n            RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\r\n            /*  ellipsoidal (geodetic) height */\r\n            Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\r\n            RK = es * RN / (RN + Height);\r\n            RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\r\n            CPHI = ST * (1.0 - RK) * RX;\r\n            SPHI = CT * RX;\r\n            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\r\n            CPHI0 = CPHI;\r\n            SPHI0 = SPHI;\r\n        } while (SDPHI * SDPHI > genau2 && iter < maxiter);\r\n        /*      ellipsoidal (geodetic) latitude */\r\n        Latitude = Math.atan(SPHI / Math.abs(CPHI));\r\n        return {\r\n            x: Longitude,\r\n            y: Latitude,\r\n            z: Height\r\n        };\r\n    } // cs_geocentric_to_geodetic()\r\n    exports.geocentricToGeodetic = geocentricToGeodetic;\r\n    /****************************************************************/\r\n    // pj_geocentic_to_wgs84( p )\r\n    //  p = point to transform in geocentric coordinates (x,y,z)\r\n    /** point object, nothing fancy, just allows values to be\r\n        passed back and forth by reference rather than by value.\r\n        Other point classes may be used as long as they have\r\n        x and y properties, which will get modified in the transform method.\r\n    */\r\n    function geocentricToWgs84(p, datum_type, datum_params) {\r\n        if (datum_type === values_1.PJD_3PARAM) {\r\n            // if( x[io] === HUGE_VAL )\r\n            //    continue;\r\n            return {\r\n                x: p.x + datum_params[0],\r\n                y: p.y + datum_params[1],\r\n                z: p.z + datum_params[2],\r\n            };\r\n        }\r\n        else if (datum_type === values_1.PJD_7PARAM) {\r\n            var Dx_BF = datum_params[0];\r\n            var Dy_BF = datum_params[1];\r\n            var Dz_BF = datum_params[2];\r\n            var Rx_BF = datum_params[3];\r\n            var Ry_BF = datum_params[4];\r\n            var Rz_BF = datum_params[5];\r\n            var M_BF = datum_params[6];\r\n            // if( x[io] === HUGE_VAL )\r\n            //    continue;\r\n            return {\r\n                x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\r\n                y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\r\n                z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\r\n            };\r\n        }\r\n    } // cs_geocentric_to_wgs84\r\n    exports.geocentricToWgs84 = geocentricToWgs84;\r\n    /****************************************************************/\r\n    // pj_geocentic_from_wgs84()\r\n    //  coordinate system definition,\r\n    //  point to transform in geocentric coordinates (x,y,z)\r\n    function geocentricFromWgs84(p, datum_type, datum_params) {\r\n        if (datum_type === values_1.PJD_3PARAM) {\r\n            //if( x[io] === HUGE_VAL )\r\n            //    continue;\r\n            return {\r\n                x: p.x - datum_params[0],\r\n                y: p.y - datum_params[1],\r\n                z: p.z - datum_params[2],\r\n            };\r\n        }\r\n        else if (datum_type === values_1.PJD_7PARAM) {\r\n            var Dx_BF = datum_params[0];\r\n            var Dy_BF = datum_params[1];\r\n            var Dz_BF = datum_params[2];\r\n            var Rx_BF = datum_params[3];\r\n            var Ry_BF = datum_params[4];\r\n            var Rz_BF = datum_params[5];\r\n            var M_BF = datum_params[6];\r\n            var x_tmp = (p.x - Dx_BF) / M_BF;\r\n            var y_tmp = (p.y - Dy_BF) / M_BF;\r\n            var z_tmp = (p.z - Dz_BF) / M_BF;\r\n            //if( x[io] === HUGE_VAL )\r\n            //    continue;\r\n            return {\r\n                x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\r\n                y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\r\n                z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\r\n            };\r\n        } //cs_geocentric_from_wgs84()\r\n    }\r\n    exports.geocentricFromWgs84 = geocentricFromWgs84;\r\n}\r\n","/* proj4\\lib\\adjust_axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function default_1(crs, denorm, point) {\r\n        var xin = point.x, yin = point.y, zin = point.z || 0.0;\r\n        var v, t, i;\r\n        var out = {};\r\n        for (i = 0; i < 3; i++) {\r\n            if (denorm && i === 2 && point.z === undefined) {\r\n                continue;\r\n            }\r\n            if (i === 0) {\r\n                v = xin;\r\n                if (\"ew\".indexOf(crs.axis[i]) !== -1) {\r\n                    t = 'x';\r\n                }\r\n                else {\r\n                    t = 'y';\r\n                }\r\n            }\r\n            else if (i === 1) {\r\n                v = yin;\r\n                if (\"ns\".indexOf(crs.axis[i]) !== -1) {\r\n                    t = 'y';\r\n                }\r\n                else {\r\n                    t = 'x';\r\n                }\r\n            }\r\n            else {\r\n                v = zin;\r\n                t = 'z';\r\n            }\r\n            switch (crs.axis[i]) {\r\n                case 'e':\r\n                case 'w':\r\n                case 'n':\r\n                case 's':\r\n                    out[t] = v;\r\n                    break;\r\n                case 'u':\r\n                    if (point[t] !== undefined) {\r\n                        out.z = v;\r\n                    }\r\n                    break;\r\n                case 'd':\r\n                    if (point[t] !== undefined) {\r\n                        out.z = -v;\r\n                    }\r\n                    break;\r\n                default:\r\n                    //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\r\n                    return null;\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\common\\toPoint.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function default_1(array) {\r\n        var out = {\r\n            x: array[0],\r\n            y: array[1]\r\n        };\r\n        if (array.length > 2) {\r\n            out.z = array[2];\r\n        }\r\n        if (array.length > 3) {\r\n            out.m = array[3];\r\n        }\r\n        return out;\r\n    }\r\n    exports.default = default_1;\r\n}\r\n","/* proj4\\lib\\checkSanity.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function default_1(point) {\r\n        checkCoord(point.x);\r\n        checkCoord(point.y);\r\n    }\r\n    exports.default = default_1;\r\n    function checkCoord(num) {\r\n        if (typeof Number.isFinite === 'function') {\r\n            if (Number.isFinite(num)) {\r\n                return;\r\n            }\r\n            throw new TypeError('coordinates must be finite numbers');\r\n        }\r\n        if (typeof num !== 'number' || num !== num || !isFinite(num)) {\r\n            throw new TypeError('coordinates must be finite numbers');\r\n        }\r\n    }\r\n}\r\n","/* models\\renderers\\renderer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const view_1 = require(71) /* ../../core/view */;\r\n    const visuals = tslib_1.__importStar(require(74) /* ../../core/visuals */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const model_1 = require(81) /* ../../model */;\r\n    const coordinates_1 = require(82) /* ../canvas/coordinates */;\r\n    class RendererView extends view_1.View {\r\n        get coordinates() {\r\n            return this._coordinates;\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.visuals = new visuals.Visuals(this.model);\r\n            this.needs_webgl_blit = false;\r\n            this._initialize_coordinates();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            const { x_range_name, y_range_name } = this.model.properties;\r\n            this.on_change([x_range_name, y_range_name], () => this._initialize_coordinates());\r\n        }\r\n        _initialize_coordinates() {\r\n            const { x_range_name, y_range_name } = this.model;\r\n            const { frame } = this.plot_view;\r\n            const x_scale = frame.x_scales.get(x_range_name);\r\n            const y_scale = frame.y_scales.get(y_range_name);\r\n            this._coordinates = new coordinates_1.CoordinateTransform(x_scale, y_scale);\r\n        }\r\n        get plot_view() {\r\n            return this.parent;\r\n        }\r\n        get plot_model() {\r\n            return this.parent.model;\r\n        }\r\n        get layer() {\r\n            const { overlays, primary } = this.plot_view.canvas_view;\r\n            return this.model.level == \"overlay\" ? overlays : primary;\r\n        }\r\n        request_render() {\r\n            this.plot_view.request_render();\r\n        }\r\n        notify_finished() {\r\n            this.plot_view.notify_finished();\r\n        }\r\n        get needs_clip() {\r\n            return false;\r\n        }\r\n        get has_webgl() {\r\n            return false;\r\n        }\r\n        render() {\r\n            if (this.model.visible) {\r\n                this._render();\r\n            }\r\n            this._has_finished = true;\r\n        }\r\n    }\r\n    exports.RendererView = RendererView;\r\n    RendererView.__name__ = \"RendererView\";\r\n    class Renderer extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Renderer() {\r\n            this.define({\r\n                level: [p.RenderLevel],\r\n                visible: [p.Boolean, true],\r\n                x_range_name: [p.String, \"default\"],\r\n                y_range_name: [p.String, \"default\"],\r\n            });\r\n        }\r\n    }\r\n    exports.Renderer = Renderer;\r\n    Renderer.__name__ = \"Renderer\";\r\n    Renderer.init_Renderer();\r\n}\r\n","/* core\\view.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const signaling_1 = require(15) /* ./signaling */;\r\n    const dom_1 = require(72) /* ./dom */;\r\n    const types_1 = require(8) /* ./util/types */;\r\n    const root_css_1 = tslib_1.__importDefault(require(73) /* ../styles/root.css */);\r\n    class View {\r\n        constructor(options) {\r\n            this.removed = new signaling_1.Signal0(this, \"removed\");\r\n            this._ready = Promise.resolve(undefined);\r\n            if (options.model != null)\r\n                this.model = options.model;\r\n            else\r\n                throw new Error(\"model of a view wasn't configured\");\r\n            this._parent = options.parent;\r\n        }\r\n        get ready() {\r\n            return this._ready;\r\n        }\r\n        connect(signal, slot) {\r\n            const new_slot = (args, sender) => {\r\n                const promise = Promise.resolve(slot.call(this, args, sender));\r\n                this._ready = this._ready.then(() => promise);\r\n            };\r\n            return signal.connect(new_slot, this);\r\n        }\r\n        disconnect(signal, slot) {\r\n            return signal.disconnect(slot, this);\r\n        }\r\n        initialize() {\r\n            this._has_finished = false;\r\n            if (this.is_root) {\r\n                this._stylesheet = dom_1.stylesheet;\r\n            }\r\n            for (const style of this.styles()) {\r\n                this.stylesheet.append(style);\r\n            }\r\n        }\r\n        async lazy_initialize() { }\r\n        remove() {\r\n            this._parent = undefined;\r\n            this.disconnect_signals();\r\n            this.removed.emit();\r\n        }\r\n        toString() {\r\n            return `${this.model.type}View(${this.model.id})`;\r\n        }\r\n        serializable_state() {\r\n            return { type: this.model.type };\r\n        }\r\n        get parent() {\r\n            if (this._parent !== undefined)\r\n                return this._parent;\r\n            else\r\n                throw new Error(\"parent of a view wasn't configured\");\r\n        }\r\n        get is_root() {\r\n            return this.parent === null;\r\n        }\r\n        get root() {\r\n            return this.is_root ? this : this.parent.root;\r\n        }\r\n        assert_root() {\r\n            if (!this.is_root)\r\n                throw new Error(`${this.toString()} is not a root layout`);\r\n        }\r\n        has_finished() {\r\n            return this._has_finished;\r\n        }\r\n        get is_idle() {\r\n            return this.has_finished();\r\n        }\r\n        connect_signals() { }\r\n        disconnect_signals() {\r\n            signaling_1.Signal.disconnectReceiver(this);\r\n        }\r\n        on_change(properties, fn) {\r\n            for (const property of types_1.isArray(properties) ? properties : [properties]) {\r\n                this.connect(property.change, fn);\r\n            }\r\n        }\r\n        cursor(_sx, _sy) {\r\n            return null;\r\n        }\r\n        get stylesheet() {\r\n            if (this.is_root)\r\n                return this._stylesheet;\r\n            else\r\n                return this.root.stylesheet;\r\n        }\r\n        styles() {\r\n            return [root_css_1.default];\r\n        }\r\n    }\r\n    exports.View = View;\r\n    View.__name__ = \"View\";\r\n}\r\n","/* core\\dom.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(8) /* ./util/types */;\r\n    const object_1 = require(13) /* ./util/object */;\r\n    const _createElement = (tag) => {\r\n        return (attrs = {}, ...children) => {\r\n            const element = document.createElement(tag);\r\n            element.classList.add(\"bk\");\r\n            for (let [attr, value] of object_1.entries(attrs)) {\r\n                if (value == null || types_1.isBoolean(value) && !value)\r\n                    continue;\r\n                if (attr === \"class\") {\r\n                    if (types_1.isString(value))\r\n                        value = value.split(/\\s+/);\r\n                    if (types_1.isArray(value)) {\r\n                        for (const cls of value) {\r\n                            if (cls != null)\r\n                                element.classList.add(cls);\r\n                        }\r\n                        continue;\r\n                    }\r\n                }\r\n                if (attr === \"style\" && types_1.isPlainObject(value)) {\r\n                    for (const [prop, data] of object_1.entries(value)) {\r\n                        element.style[prop] = data;\r\n                    }\r\n                    continue;\r\n                }\r\n                if (attr === \"data\" && types_1.isPlainObject(value)) {\r\n                    for (const [key, data] of object_1.entries(value)) {\r\n                        element.dataset[key] = data; // XXX: attrs needs a better type\r\n                    }\r\n                    continue;\r\n                }\r\n                element.setAttribute(attr, value);\r\n            }\r\n            function append(child) {\r\n                if (types_1.isString(child))\r\n                    element.appendChild(document.createTextNode(child));\r\n                else if (child instanceof Node)\r\n                    element.appendChild(child);\r\n                else if (child instanceof NodeList || child instanceof HTMLCollection) {\r\n                    for (const el of child) {\r\n                        element.appendChild(el);\r\n                    }\r\n                }\r\n                else if (child != null && child !== false)\r\n                    throw new Error(`expected a DOM element, string, false or null, got ${JSON.stringify(child)}`);\r\n            }\r\n            for (const child of children) {\r\n                if (types_1.isArray(child)) {\r\n                    for (const _child of child)\r\n                        append(_child);\r\n                }\r\n                else\r\n                    append(child);\r\n            }\r\n            return element;\r\n        };\r\n    };\r\n    function createElement(tag, attrs, ...children) {\r\n        return _createElement(tag)(attrs, ...children);\r\n    }\r\n    exports.createElement = createElement;\r\n    exports.div = _createElement(\"div\"), exports.span = _createElement(\"span\"), exports.canvas = _createElement(\"canvas\"), exports.link = _createElement(\"link\"), exports.style = _createElement(\"style\"), exports.a = _createElement(\"a\"), exports.p = _createElement(\"p\"), exports.i = _createElement(\"i\"), exports.pre = _createElement(\"pre\"), exports.button = _createElement(\"button\"), exports.label = _createElement(\"label\"), exports.input = _createElement(\"input\"), exports.select = _createElement(\"select\"), exports.option = _createElement(\"option\"), exports.optgroup = _createElement(\"optgroup\"), exports.textarea = _createElement(\"textarea\");\r\n    function nbsp() {\r\n        return document.createTextNode(\"\\u00a0\");\r\n    }\r\n    exports.nbsp = nbsp;\r\n    function append(element, ...children) {\r\n        for (const child of children)\r\n            element.appendChild(child);\r\n    }\r\n    exports.append = append;\r\n    function remove(element) {\r\n        const parent = element.parentNode;\r\n        if (parent != null) {\r\n            parent.removeChild(element);\r\n        }\r\n    }\r\n    exports.remove = remove;\r\n    exports.removeElement = remove;\r\n    function replaceWith(element, replacement) {\r\n        const parent = element.parentNode;\r\n        if (parent != null) {\r\n            parent.replaceChild(replacement, element);\r\n        }\r\n    }\r\n    exports.replaceWith = replaceWith;\r\n    function prepend(element, ...nodes) {\r\n        const first = element.firstChild;\r\n        for (const node of nodes) {\r\n            element.insertBefore(node, first);\r\n        }\r\n    }\r\n    exports.prepend = prepend;\r\n    function empty(node, attrs = false) {\r\n        let child;\r\n        while (child = node.firstChild) {\r\n            node.removeChild(child);\r\n        }\r\n        if (attrs && node instanceof Element) {\r\n            for (const attr of node.attributes) {\r\n                node.removeAttributeNode(attr);\r\n            }\r\n        }\r\n    }\r\n    exports.empty = empty;\r\n    function display(element) {\r\n        element.style.display = \"\";\r\n    }\r\n    exports.display = display;\r\n    function undisplay(element) {\r\n        element.style.display = \"none\";\r\n    }\r\n    exports.undisplay = undisplay;\r\n    function show(element) {\r\n        element.style.visibility = \"\";\r\n    }\r\n    exports.show = show;\r\n    function hide(element) {\r\n        element.style.visibility = \"hidden\";\r\n    }\r\n    exports.hide = hide;\r\n    function offset(element) {\r\n        const rect = element.getBoundingClientRect();\r\n        return {\r\n            top: rect.top + window.pageYOffset - document.documentElement.clientTop,\r\n            left: rect.left + window.pageXOffset - document.documentElement.clientLeft,\r\n        };\r\n    }\r\n    exports.offset = offset;\r\n    function matches(el, selector) {\r\n        const p = Element.prototype;\r\n        const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector;\r\n        return f.call(el, selector);\r\n    }\r\n    exports.matches = matches;\r\n    function parent(el, selector) {\r\n        let node = el;\r\n        while (node = node.parentElement) {\r\n            if (matches(node, selector))\r\n                return node;\r\n        }\r\n        return null;\r\n    }\r\n    exports.parent = parent;\r\n    function num(value) {\r\n        return parseFloat(value) || 0;\r\n    }\r\n    function extents(el) {\r\n        const style = getComputedStyle(el);\r\n        return {\r\n            border: {\r\n                top: num(style.borderTopWidth),\r\n                bottom: num(style.borderBottomWidth),\r\n                left: num(style.borderLeftWidth),\r\n                right: num(style.borderRightWidth),\r\n            },\r\n            margin: {\r\n                top: num(style.marginTop),\r\n                bottom: num(style.marginBottom),\r\n                left: num(style.marginLeft),\r\n                right: num(style.marginRight),\r\n            },\r\n            padding: {\r\n                top: num(style.paddingTop),\r\n                bottom: num(style.paddingBottom),\r\n                left: num(style.paddingLeft),\r\n                right: num(style.paddingRight),\r\n            },\r\n        };\r\n    }\r\n    exports.extents = extents;\r\n    function size(el) {\r\n        const rect = el.getBoundingClientRect();\r\n        return {\r\n            width: Math.ceil(rect.width),\r\n            height: Math.ceil(rect.height),\r\n        };\r\n    }\r\n    exports.size = size;\r\n    function scroll_size(el) {\r\n        return {\r\n            width: Math.ceil(el.scrollWidth),\r\n            height: Math.ceil(el.scrollHeight),\r\n        };\r\n    }\r\n    exports.scroll_size = scroll_size;\r\n    function outer_size(el) {\r\n        const { margin: { left, right, top, bottom } } = extents(el);\r\n        const { width, height } = size(el);\r\n        return {\r\n            width: Math.ceil(width + left + right),\r\n            height: Math.ceil(height + top + bottom),\r\n        };\r\n    }\r\n    exports.outer_size = outer_size;\r\n    function content_size(el) {\r\n        const { left, top } = el.getBoundingClientRect();\r\n        const { padding } = extents(el);\r\n        let width = 0;\r\n        let height = 0;\r\n        for (const child of el.children) {\r\n            const rect = child.getBoundingClientRect();\r\n            width = Math.max(width, Math.ceil(rect.left - left - padding.left + rect.width));\r\n            height = Math.max(height, Math.ceil(rect.top - top - padding.top + rect.height));\r\n        }\r\n        return { width, height };\r\n    }\r\n    exports.content_size = content_size;\r\n    function position(el, box, margin) {\r\n        const { style } = el;\r\n        style.left = `${box.x}px`;\r\n        style.top = `${box.y}px`;\r\n        style.width = `${box.width}px`;\r\n        style.height = `${box.height}px`;\r\n        if (margin == null)\r\n            style.margin = \"\";\r\n        else {\r\n            const { top, right, bottom, left } = margin;\r\n            style.margin = `${top}px ${right}px ${bottom}px ${left}px`;\r\n        }\r\n    }\r\n    exports.position = position;\r\n    function children(el) {\r\n        return Array.from(el.children);\r\n    }\r\n    exports.children = children;\r\n    class ClassList {\r\n        constructor(el) {\r\n            this.el = el;\r\n            this.classList = el.classList;\r\n        }\r\n        get values() {\r\n            const values = [];\r\n            for (let i = 0; i < this.classList.length; i++) {\r\n                const item = this.classList.item(i);\r\n                if (item != null)\r\n                    values.push(item);\r\n            }\r\n            return values;\r\n        }\r\n        has(cls) {\r\n            return this.classList.contains(cls);\r\n        }\r\n        add(...classes) {\r\n            for (const cls of classes)\r\n                this.classList.add(cls);\r\n            return this;\r\n        }\r\n        remove(...classes) {\r\n            for (const cls of classes)\r\n                this.classList.remove(cls);\r\n            return this;\r\n        }\r\n        clear() {\r\n            for (const cls of this.values) {\r\n                if (cls != \"bk\")\r\n                    this.classList.remove(cls);\r\n            }\r\n            return this;\r\n        }\r\n        toggle(cls, activate) {\r\n            const add = activate != null ? activate : !this.has(cls);\r\n            if (add)\r\n                this.add(cls);\r\n            else\r\n                this.remove(cls);\r\n            return this;\r\n        }\r\n    }\r\n    exports.ClassList = ClassList;\r\n    ClassList.__name__ = \"ClassList\";\r\n    function classes(el) {\r\n        return new ClassList(el);\r\n    }\r\n    exports.classes = classes;\r\n    function toggle_attribute(el, attr, state) {\r\n        if (state == null) {\r\n            state = !el.hasAttribute(attr);\r\n        }\r\n        if (state)\r\n            el.setAttribute(attr, \"true\");\r\n        else\r\n            el.removeAttribute(attr);\r\n    }\r\n    exports.toggle_attribute = toggle_attribute;\r\n    (function (Keys) {\r\n        Keys[Keys[\"Backspace\"] = 8] = \"Backspace\";\r\n        Keys[Keys[\"Tab\"] = 9] = \"Tab\";\r\n        Keys[Keys[\"Enter\"] = 13] = \"Enter\";\r\n        Keys[Keys[\"Esc\"] = 27] = \"Esc\";\r\n        Keys[Keys[\"PageUp\"] = 33] = \"PageUp\";\r\n        Keys[Keys[\"PageDown\"] = 34] = \"PageDown\";\r\n        Keys[Keys[\"Left\"] = 37] = \"Left\";\r\n        Keys[Keys[\"Up\"] = 38] = \"Up\";\r\n        Keys[Keys[\"Right\"] = 39] = \"Right\";\r\n        Keys[Keys[\"Down\"] = 40] = \"Down\";\r\n        Keys[Keys[\"Delete\"] = 46] = \"Delete\";\r\n    })(exports.Keys || (exports.Keys = {}));\r\n    function undisplayed(el, fn) {\r\n        const { display } = el.style;\r\n        el.style.display = \"none\";\r\n        try {\r\n            return fn();\r\n        }\r\n        finally {\r\n            el.style.display = display;\r\n        }\r\n    }\r\n    exports.undisplayed = undisplayed;\r\n    function unsized(el, fn) {\r\n        return sized(el, {}, fn);\r\n    }\r\n    exports.unsized = unsized;\r\n    function sized(el, size, fn) {\r\n        const { width, height, position, display } = el.style;\r\n        el.style.position = \"absolute\";\r\n        el.style.display = \"\";\r\n        el.style.width = size.width != null && size.width != Infinity ? `${size.width}px` : \"auto\";\r\n        el.style.height = size.height != null && size.height != Infinity ? `${size.height}px` : \"auto\";\r\n        try {\r\n            return fn();\r\n        }\r\n        finally {\r\n            el.style.position = position;\r\n            el.style.display = display;\r\n            el.style.width = width;\r\n            el.style.height = height;\r\n        }\r\n    }\r\n    exports.sized = sized;\r\n    class StyleSheet {\r\n        constructor(root) {\r\n            this.root = root;\r\n            this.known = new Set();\r\n            this.style = exports.style({ type: \"text/css\" });\r\n            prepend(root, this.style);\r\n        }\r\n        append(css) {\r\n            if (!this.known.has(css)) {\r\n                this.style.appendChild(document.createTextNode(css));\r\n                this.known.add(css);\r\n            }\r\n        }\r\n    }\r\n    exports.StyleSheet = StyleSheet;\r\n    StyleSheet.__name__ = \"StyleSheet\";\r\n    exports.stylesheet = new StyleSheet(document.head);\r\n}\r\n","/* styles\\root.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root {\n  position: relative;\n  width: auto;\n  height: auto;\n  z-index: 0;\n  box-sizing: border-box;\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 13px;\n}\n.bk-root .bk,\n.bk-root .bk:before,\n.bk-root .bk:after {\n  box-sizing: inherit;\n  margin: 0;\n  border: 0;\n  padding: 0;\n  background-image: none;\n  font-family: inherit;\n  font-size: 100%;\n  line-height: 1.42857143;\n}\n.bk-root pre.bk {\n  font-family: Courier, monospace;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* core\\visuals.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ./property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ./properties */);\r\n    const color_1 = require(22) /* ./util/color */;\r\n    const types_1 = require(8) /* ./util/types */;\r\n    const svg_1 = require(75) /* ./util/svg */;\r\n    const canvas_1 = require(77) /* ../models/canvas/canvas */;\r\n    function color2css(color, alpha) {\r\n        const [r, g, b, a] = types_1.isString(color) ? color_1.color2rgba(color) : color_1.decode_rgba(color);\r\n        return `rgba(${r * 255}, ${g * 255}, ${b * 255}, ${a == 1.0 ? alpha : a})`;\r\n    }\r\n    function _horz(ctx, h, h2) {\r\n        ctx.moveTo(0, h2 + 0.5);\r\n        ctx.lineTo(h, h2 + 0.5);\r\n        ctx.stroke();\r\n    }\r\n    function _vert(ctx, h, h2) {\r\n        ctx.moveTo(h2 + 0.5, 0);\r\n        ctx.lineTo(h2 + 0.5, h);\r\n        ctx.stroke();\r\n    }\r\n    function _x(ctx, h) {\r\n        ctx.moveTo(0, h);\r\n        ctx.lineTo(h, 0);\r\n        ctx.stroke();\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(h, h);\r\n        ctx.stroke();\r\n    }\r\n    exports.hatch_aliases = {\r\n        \" \": \"blank\",\r\n        \".\": \"dot\",\r\n        o: \"ring\",\r\n        \"-\": \"horizontal_line\",\r\n        \"|\": \"vertical_line\",\r\n        \"+\": \"cross\",\r\n        \"\\\"\": \"horizontal_dash\",\r\n        \":\": \"vertical_dash\",\r\n        \"@\": \"spiral\",\r\n        \"/\": \"right_diagonal_line\",\r\n        \"\\\\\": \"left_diagonal_line\",\r\n        x: \"diagonal_cross\",\r\n        \",\": \"right_diagonal_dash\",\r\n        \"`\": \"left_diagonal_dash\",\r\n        v: \"horizontal_wave\",\r\n        \">\": \"vertical_wave\",\r\n        \"*\": \"criss_cross\",\r\n    };\r\n    function create_hatch_canvas(ctx, hatch_pattern, hatch_color, hatch_alpha, hatch_scale, hatch_weight) {\r\n        var _a;\r\n        const h = hatch_scale;\r\n        const h2 = h / 2;\r\n        const h4 = h2 / 2;\r\n        ctx.strokeStyle = color2css(hatch_color, hatch_alpha);\r\n        ctx.lineCap = \"square\";\r\n        ctx.fillStyle = hatch_color;\r\n        ctx.lineWidth = hatch_weight;\r\n        switch ((_a = exports.hatch_aliases[hatch_pattern]) !== null && _a !== void 0 ? _a : hatch_pattern) {\r\n            // we should not need these if code conditions on hatch.doit, but\r\n            // include them here just for completeness\r\n            case \"blank\":\r\n                break;\r\n            case \"dot\":\r\n                ctx.arc(h2, h2, h2 / 2, 0, 2 * Math.PI, true);\r\n                ctx.fill();\r\n                break;\r\n            case \"ring\":\r\n                ctx.arc(h2, h2, h2 / 2, 0, 2 * Math.PI, true);\r\n                ctx.stroke();\r\n                break;\r\n            case \"horizontal_line\":\r\n                _horz(ctx, h, h2);\r\n                break;\r\n            case \"vertical_line\":\r\n                _vert(ctx, h, h2);\r\n                break;\r\n            case \"cross\":\r\n                _horz(ctx, h, h2);\r\n                _vert(ctx, h, h2);\r\n                break;\r\n            case \"horizontal_dash\":\r\n                _horz(ctx, h2, h2);\r\n                break;\r\n            case \"vertical_dash\":\r\n                _vert(ctx, h2, h2);\r\n                break;\r\n            case \"spiral\": {\r\n                const h30 = h / 30;\r\n                ctx.moveTo(h2, h2);\r\n                for (let i = 0; i < 360; i++) {\r\n                    const angle = 0.1 * i;\r\n                    const x = h2 + (h30 * angle) * Math.cos(angle);\r\n                    const y = h2 + (h30 * angle) * Math.sin(angle);\r\n                    ctx.lineTo(x, y);\r\n                }\r\n                ctx.stroke();\r\n                break;\r\n            }\r\n            case \"right_diagonal_line\":\r\n                ctx.moveTo(-h4 + 0.5, h);\r\n                ctx.lineTo(h4 + 0.5, 0);\r\n                ctx.stroke();\r\n                ctx.moveTo(h4 + 0.5, h);\r\n                ctx.lineTo(3 * h4 + 0.5, 0);\r\n                ctx.stroke();\r\n                ctx.moveTo(3 * h4 + 0.5, h);\r\n                ctx.lineTo(5 * h4 + 0.5, 0);\r\n                ctx.stroke();\r\n                ctx.stroke();\r\n                break;\r\n            case \"left_diagonal_line\":\r\n                ctx.moveTo(h4 + 0.5, h);\r\n                ctx.lineTo(-h4 + 0.5, 0);\r\n                ctx.stroke();\r\n                ctx.moveTo(3 * h4 + 0.5, h);\r\n                ctx.lineTo(h4 + 0.5, 0);\r\n                ctx.stroke();\r\n                ctx.moveTo(5 * h4 + 0.5, h);\r\n                ctx.lineTo(3 * h4 + 0.5, 0);\r\n                ctx.stroke();\r\n                ctx.stroke();\r\n                break;\r\n            case \"diagonal_cross\":\r\n                _x(ctx, h);\r\n                break;\r\n            case \"right_diagonal_dash\":\r\n                ctx.moveTo(h4 + 0.5, 3 * h4 + 0.5);\r\n                ctx.lineTo(3 * h4 + 0.5, h4 + 0.5);\r\n                ctx.stroke();\r\n                break;\r\n            case \"left_diagonal_dash\":\r\n                ctx.moveTo(h4 + 0.5, h4 + 0.5);\r\n                ctx.lineTo(3 * h4 + 0.5, 3 * h4 + 0.5);\r\n                ctx.stroke();\r\n                break;\r\n            case \"horizontal_wave\":\r\n                ctx.moveTo(0, h4);\r\n                ctx.lineTo(h2, 3 * h4);\r\n                ctx.lineTo(h, h4);\r\n                ctx.stroke();\r\n                break;\r\n            case \"vertical_wave\":\r\n                ctx.moveTo(h4, 0);\r\n                ctx.lineTo(3 * h4, h2);\r\n                ctx.lineTo(h4, h);\r\n                ctx.stroke();\r\n                break;\r\n            case \"criss_cross\":\r\n                _x(ctx, h);\r\n                _horz(ctx, h, h2);\r\n                _vert(ctx, h, h2);\r\n                break;\r\n        }\r\n    }\r\n    class ContextProperties {\r\n        constructor(obj, prefix = \"\") {\r\n            this.obj = obj;\r\n            this.prefix = prefix;\r\n            this.cache = {};\r\n            for (const attr of this.attrs)\r\n                this[attr] = obj.properties[prefix + attr];\r\n        }\r\n        warm_cache(source, all_indices) {\r\n            for (const attr of this.attrs) {\r\n                const prop = this.obj.properties[this.prefix + attr];\r\n                if (prop.spec.value !== undefined) // TODO (bev) better test?\r\n                    this.cache[attr] = prop.spec.value;\r\n                else if (source != null && prop instanceof p.VectorSpec) {\r\n                    const array = prop.array(source);\r\n                    const subarray = all_indices != null ? all_indices.select(array) : array;\r\n                    this.cache[attr + \"_array\"] = subarray;\r\n                }\r\n                else\r\n                    throw new Error(\"source is required with a vectorized visual property\");\r\n            }\r\n        }\r\n        cache_select(attr, i) {\r\n            const prop = this.obj.properties[this.prefix + attr];\r\n            let value;\r\n            if (prop.spec.value !== undefined) // TODO (bev) better test?\r\n                this.cache[attr] = value = prop.spec.value;\r\n            else\r\n                this.cache[attr] = value = this.cache[attr + \"_array\"][i];\r\n            return value;\r\n        }\r\n        get_array(attr) {\r\n            return this.cache[attr + \"_array\"];\r\n        }\r\n        set_vectorize(ctx, i) {\r\n            this._set_vectorize(ctx, i);\r\n        }\r\n    }\r\n    exports.ContextProperties = ContextProperties;\r\n    ContextProperties.__name__ = \"ContextProperties\";\r\n    class Line extends ContextProperties {\r\n        set_value(ctx) {\r\n            const color = this.line_color.value();\r\n            const alpha = this.line_alpha.value();\r\n            ctx.strokeStyle = color2css(color, alpha);\r\n            ctx.lineWidth = this.line_width.value();\r\n            ctx.lineJoin = this.line_join.value();\r\n            ctx.lineCap = this.line_cap.value();\r\n            ctx.lineDash = this.line_dash.value();\r\n            ctx.lineDashOffset = this.line_dash_offset.value();\r\n        }\r\n        get doit() {\r\n            return !(this.line_color.spec.value === null ||\r\n                this.line_alpha.spec.value == 0 ||\r\n                this.line_width.spec.value == 0);\r\n        }\r\n        _set_vectorize(ctx, i) {\r\n            const color = this.cache_select(\"line_color\", i);\r\n            const alpha = this.cache_select(\"line_alpha\", i);\r\n            const width = this.cache_select(\"line_width\", i);\r\n            const join = this.cache_select(\"line_join\", i);\r\n            const cap = this.cache_select(\"line_cap\", i);\r\n            const dash = this.cache_select(\"line_dash\", i);\r\n            const offset = this.cache_select(\"line_dash_offset\", i);\r\n            ctx.strokeStyle = color2css(color, alpha);\r\n            ctx.lineWidth = width;\r\n            ctx.lineJoin = join;\r\n            ctx.lineCap = cap;\r\n            ctx.lineDash = dash;\r\n            ctx.lineDashOffset = offset;\r\n        }\r\n        color_value() {\r\n            return color2css(this.line_color.value(), this.line_alpha.value());\r\n        }\r\n    }\r\n    exports.Line = Line;\r\n    Line.__name__ = \"Line\";\r\n    Line.prototype.attrs = Object.keys(mixins.LineVector);\r\n    class Fill extends ContextProperties {\r\n        set_value(ctx) {\r\n            const color = this.fill_color.value();\r\n            const alpha = this.fill_alpha.value();\r\n            ctx.fillStyle = color2css(color, alpha);\r\n        }\r\n        get doit() {\r\n            return !(this.fill_color.spec.value === null ||\r\n                this.fill_alpha.spec.value == 0);\r\n        }\r\n        _set_vectorize(ctx, i) {\r\n            const color = this.cache_select(\"fill_color\", i);\r\n            const alpha = this.cache_select(\"fill_alpha\", i);\r\n            ctx.fillStyle = color2css(color, alpha);\r\n        }\r\n        color_value() {\r\n            return color2css(this.fill_color.value(), this.fill_alpha.value());\r\n        }\r\n    }\r\n    exports.Fill = Fill;\r\n    Fill.__name__ = \"Fill\";\r\n    Fill.prototype.attrs = Object.keys(mixins.FillVector);\r\n    class Hatch extends ContextProperties {\r\n        cache_select(name, i) {\r\n            let value;\r\n            if (name == \"pattern\") {\r\n                const color = this.cache_select(\"hatch_color\", i);\r\n                const alpha = this.cache_select(\"hatch_alpha\", i);\r\n                const scale = this.cache_select(\"hatch_scale\", i);\r\n                const pattern = this.cache_select(\"hatch_pattern\", i);\r\n                const weight = this.cache_select(\"hatch_weight\", i);\r\n                const { hatch_extra } = this.cache;\r\n                if (hatch_extra != null && hatch_extra.hasOwnProperty(pattern)) {\r\n                    const custom = hatch_extra[pattern];\r\n                    this.cache.pattern = custom.get_pattern(color, alpha, scale, weight);\r\n                }\r\n                else {\r\n                    this.cache.pattern = (ctx) => {\r\n                        // TODO: this needs a canvas provider instead of trying to guess what to use\r\n                        const output_backend = ctx instanceof svg_1.SVGRenderingContext2D ? \"svg\" : \"canvas\";\r\n                        const region = new canvas_1.CanvasLayer(output_backend, true);\r\n                        region.resize(scale, scale);\r\n                        region.prepare();\r\n                        create_hatch_canvas(region.ctx, pattern, color, alpha, scale, weight);\r\n                        return ctx.createPattern(region.canvas, \"repeat\");\r\n                    };\r\n                }\r\n            }\r\n            else\r\n                value = super.cache_select(name, i);\r\n            return value;\r\n        }\r\n        _try_defer(defer_func) {\r\n            const { hatch_pattern, hatch_extra } = this.cache;\r\n            if (hatch_extra != null && hatch_extra.hasOwnProperty(hatch_pattern)) {\r\n                const custom = hatch_extra[hatch_pattern];\r\n                custom.onload(defer_func);\r\n            }\r\n        }\r\n        get doit() {\r\n            return !(this.hatch_color.spec.value === null ||\r\n                this.hatch_alpha.spec.value == 0 ||\r\n                this.hatch_pattern.spec.value == \" \" ||\r\n                this.hatch_pattern.spec.value == \"blank\" ||\r\n                this.hatch_pattern.spec.value === null);\r\n        }\r\n        doit2(ctx, i, ready_func, defer_func) {\r\n            if (!this.doit) {\r\n                return;\r\n            }\r\n            this.cache_select(\"pattern\", i);\r\n            const pattern = this.cache.pattern(ctx);\r\n            if (pattern == null) {\r\n                this._try_defer(defer_func);\r\n            }\r\n            else {\r\n                this.set_vectorize(ctx, i);\r\n                ready_func();\r\n            }\r\n        }\r\n        _set_vectorize(ctx, i) {\r\n            this.cache_select(\"pattern\", i);\r\n            ctx.fillStyle = this.cache.pattern(ctx);\r\n        }\r\n        color_value() {\r\n            return color2css(this.hatch_color.value(), this.hatch_alpha.value());\r\n        }\r\n    }\r\n    exports.Hatch = Hatch;\r\n    Hatch.__name__ = \"Hatch\";\r\n    Hatch.prototype.attrs = Object.keys(mixins.HatchVector);\r\n    class Text extends ContextProperties {\r\n        color_value() {\r\n            return color2css(this.text_color.value(), this.text_alpha.value());\r\n        }\r\n        font_value() {\r\n            const text_font = this.text_font.value();\r\n            const text_font_size = this.text_font_size.value();\r\n            const text_font_style = this.text_font_style.value();\r\n            return `${text_font_style} ${text_font_size} ${text_font}`;\r\n        }\r\n        v_font_value(i) {\r\n            super.cache_select(\"text_font_style\", i);\r\n            super.cache_select(\"text_font_size\", i);\r\n            super.cache_select(\"text_font\", i);\r\n            const { text_font_style, text_font_size, text_font } = this.cache;\r\n            return `${text_font_style} ${text_font_size} ${text_font}`;\r\n        }\r\n        cache_select(name, i) {\r\n            let value;\r\n            if (name == \"font\") {\r\n                this.cache.font = value = this.v_font_value(i);\r\n            }\r\n            else\r\n                value = super.cache_select(name, i);\r\n            return value;\r\n        }\r\n        set_value(ctx) {\r\n            const color = this.text_color.value();\r\n            const alpha = this.text_alpha.value();\r\n            ctx.fillStyle = color2css(color, alpha);\r\n            ctx.font = this.font_value();\r\n            ctx.textAlign = this.text_align.value();\r\n            ctx.textBaseline = this.text_baseline.value();\r\n        }\r\n        get doit() {\r\n            return !(this.text_color.spec.value === null ||\r\n                this.text_alpha.spec.value == 0);\r\n        }\r\n        _set_vectorize(ctx, i) {\r\n            const color = this.cache_select(\"text_color\", i);\r\n            const alpha = this.cache_select(\"text_alpha\", i);\r\n            const font = this.cache_select(\"font\", i);\r\n            const align = this.cache_select(\"text_align\", i);\r\n            const baseline = this.cache_select(\"text_baseline\", i);\r\n            ctx.fillStyle = color2css(color, alpha);\r\n            ctx.font = font;\r\n            ctx.textAlign = align;\r\n            ctx.textBaseline = baseline;\r\n        }\r\n    }\r\n    exports.Text = Text;\r\n    Text.__name__ = \"Text\";\r\n    Text.prototype.attrs = Object.keys(mixins.TextVector);\r\n    class Visuals {\r\n        constructor(model) {\r\n            for (const mixin of model._mixins) {\r\n                const [name, prefix = \"\"] = mixin.split(\":\");\r\n                let cls;\r\n                switch (name) {\r\n                    case \"line\":\r\n                        cls = Line;\r\n                        break;\r\n                    case \"fill\":\r\n                        cls = Fill;\r\n                        break;\r\n                    case \"hatch\":\r\n                        cls = Hatch;\r\n                        break;\r\n                    case \"text\":\r\n                        cls = Text;\r\n                        break;\r\n                    default:\r\n                        throw new Error(`unknown visual: ${name}`);\r\n                }\r\n                this[prefix + name] = new cls(model, prefix);\r\n            }\r\n        }\r\n        warm_cache(source, all_indices) {\r\n            for (const name in this) {\r\n                if (this.hasOwnProperty(name)) {\r\n                    const prop = this[name];\r\n                    if (prop instanceof ContextProperties)\r\n                        prop.warm_cache(source, all_indices);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.Visuals = Visuals;\r\n    Visuals.__name__ = \"Visuals\";\r\n}\r\n","/* core\\util\\svg.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    /**\r\n     * Based on https://github.com/gliffy/canvas2svg\r\n     */\r\n    const affine_1 = require(76) /* ./affine */;\r\n    const types_1 = require(8) /* ./types */;\r\n    const dom_1 = require(72) /* ../dom */;\r\n    // helper function that generates a random string\r\n    function randomString(holder) {\r\n        if (!holder) {\r\n            throw new Error(\"cannot create a random attribute name for an undefined object\");\r\n        }\r\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\r\n        let randomstring = \"\";\r\n        do {\r\n            randomstring = \"\";\r\n            for (let i = 0; i < 12; i++) {\r\n                randomstring += chars[Math.floor(Math.random() * chars.length)];\r\n            }\r\n        } while (holder[randomstring]);\r\n        return randomstring;\r\n    }\r\n    // helper function to map named to numbered entities\r\n    function createNamedToNumberedLookup(input, radix) {\r\n        const lookup = new Map();\r\n        const items = input.split(',');\r\n        radix = radix || 10;\r\n        // Map from named to numbered entities.\r\n        for (let i = 0; i < items.length; i += 2) {\r\n            const entity = '&' + items[i + 1] + ';';\r\n            const base10 = parseInt(items[i], radix);\r\n            lookup.set(entity, '&#' + base10 + ';');\r\n        }\r\n        // FF and IE need to create a regex from hex values ie &nbsp; == \\xa0\r\n        lookup.set(\"\\\\xa0\", '&#160;');\r\n        return lookup;\r\n    }\r\n    // helper function to map canvas-textAlign to svg-textAnchor\r\n    function getTextAnchor(textAlign) {\r\n        // TODO: support rtl languages\r\n        const mapping = { left: \"start\", right: \"end\", center: \"middle\", start: \"start\", end: \"end\" };\r\n        return mapping[textAlign] || mapping.start;\r\n    }\r\n    // helper function to map canvas-textBaseline to svg-dominantBaseline\r\n    function getDominantBaseline(textBaseline) {\r\n        // INFO: not supported in all browsers\r\n        const mapping = { alphabetic: \"alphabetic\", hanging: \"hanging\", top: \"text-before-edge\", bottom: \"text-after-edge\", middle: \"central\" };\r\n        return mapping[textBaseline] || mapping.alphabetic;\r\n    }\r\n    // Unpack entities lookup where the numbers are in radix 32 to reduce the size\r\n    // entity mapping courtesy of tinymce\r\n    const namedEntities = createNamedToNumberedLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +\r\n        '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +\r\n        '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +\r\n        '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +\r\n        '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +\r\n        '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +\r\n        '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +\r\n        '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +\r\n        '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +\r\n        '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +\r\n        'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +\r\n        'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +\r\n        't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +\r\n        'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +\r\n        'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +\r\n        '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +\r\n        '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +\r\n        '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +\r\n        '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +\r\n        '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +\r\n        'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +\r\n        'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +\r\n        'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +\r\n        '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +\r\n        '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\r\n    // Some basic mappings for attributes and default values.\r\n    const STYLES = {\r\n        strokeStyle: {\r\n            svgAttr: \"stroke\",\r\n            canvas: \"#000000\",\r\n            svg: \"none\",\r\n            apply: \"stroke\",\r\n        },\r\n        fillStyle: {\r\n            svgAttr: \"fill\",\r\n            canvas: \"#000000\",\r\n            svg: null,\r\n            apply: \"fill\",\r\n        },\r\n        lineCap: {\r\n            svgAttr: \"stroke-linecap\",\r\n            canvas: \"butt\",\r\n            svg: \"butt\",\r\n            apply: \"stroke\",\r\n        },\r\n        lineJoin: {\r\n            svgAttr: \"stroke-linejoin\",\r\n            canvas: \"miter\",\r\n            svg: \"miter\",\r\n            apply: \"stroke\",\r\n        },\r\n        miterLimit: {\r\n            svgAttr: \"stroke-miterlimit\",\r\n            canvas: 10,\r\n            svg: 4,\r\n            apply: \"stroke\",\r\n        },\r\n        lineWidth: {\r\n            svgAttr: \"stroke-width\",\r\n            canvas: 1,\r\n            svg: 1,\r\n            apply: \"stroke\",\r\n        },\r\n        globalAlpha: {\r\n            svgAttr: \"opacity\",\r\n            canvas: 1,\r\n            svg: 1,\r\n            apply: \"fill stroke\",\r\n        },\r\n        font: {\r\n            // font converts to multiple svg attributes, there is custom logic for this\r\n            canvas: \"10px sans-serif\",\r\n        },\r\n        shadowColor: {\r\n            canvas: \"#000000\",\r\n        },\r\n        shadowOffsetX: {\r\n            canvas: 0,\r\n        },\r\n        shadowOffsetY: {\r\n            canvas: 0,\r\n        },\r\n        shadowBlur: {\r\n            canvas: 0,\r\n        },\r\n        textAlign: {\r\n            canvas: \"start\",\r\n        },\r\n        textBaseline: {\r\n            canvas: \"alphabetic\",\r\n        },\r\n        lineDash: {\r\n            svgAttr: \"stroke-dasharray\",\r\n            canvas: [],\r\n            svg: null,\r\n            apply: \"stroke\",\r\n        },\r\n    };\r\n    class CanvasGradient {\r\n        constructor(gradientNode, ctx) {\r\n            this.__root = gradientNode;\r\n            this.__ctx = ctx;\r\n        }\r\n        /**\r\n         * Adds a color stop to the gradient root\r\n         */\r\n        addColorStop(offset, color) {\r\n            const stop = this.__ctx.__createElement(\"stop\");\r\n            stop.setAttribute(\"offset\", `${offset}`);\r\n            if (color.indexOf(\"rgba\") !== -1) {\r\n                // separate alpha value, since webkit can't handle it\r\n                const regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\r\n                const matches = regex.exec(color);\r\n                const [, r, g, b, a] = matches;\r\n                stop.setAttribute(\"stop-color\", `rgb(${r},${g},${b})`);\r\n                stop.setAttribute(\"stop-opacity\", a);\r\n            }\r\n            else {\r\n                stop.setAttribute(\"stop-color\", color);\r\n            }\r\n            this.__root.appendChild(stop);\r\n        }\r\n    }\r\n    CanvasGradient.__name__ = \"CanvasGradient\";\r\n    class CanvasPattern {\r\n        constructor(pattern, ctx) {\r\n            this.__root = pattern;\r\n            this.__ctx = ctx;\r\n        }\r\n    }\r\n    CanvasPattern.__name__ = \"CanvasPattern\";\r\n    /**\r\n     * The mock canvas context\r\n     * @param o - options include:\r\n     * ctx - existing Context2D to wrap around\r\n     * width - width of your canvas (defaults to 500)\r\n     * height - height of your canvas (defaults to 500)\r\n     * document - the document object (defaults to the current document)\r\n     */\r\n    class SVGRenderingContext2D /*implements CanvasRenderingContext2D*/ {\r\n        constructor(options) {\r\n            var _a, _b, _c;\r\n            this.__currentPosition = null;\r\n            this.__currentElementsToStyle = null;\r\n            this._transform = new affine_1.AffineTransform();\r\n            this._clip_path = null;\r\n            this.__document = (_a = options === null || options === void 0 ? void 0 : options.document) !== null && _a !== void 0 ? _a : document;\r\n            // allow passing in an existing context to wrap around\r\n            // if a context is passed in, we know a canvas already exist\r\n            if (options === null || options === void 0 ? void 0 : options.ctx) {\r\n                this.__ctx = options.ctx;\r\n            }\r\n            else {\r\n                this.__canvas = this.__document.createElement(\"canvas\");\r\n                this.__ctx = this.__canvas.getContext(\"2d\");\r\n            }\r\n            this.__setDefaultStyles();\r\n            this.__stack = [];\r\n            // the root svg element\r\n            this.__root = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\r\n            this.__root.setAttribute(\"version\", \"1.1\");\r\n            this.__root.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\r\n            this.__root.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\r\n            this.width = (_b = options === null || options === void 0 ? void 0 : options.width) !== null && _b !== void 0 ? _b : 500;\r\n            this.height = (_c = options === null || options === void 0 ? void 0 : options.height) !== null && _c !== void 0 ? _c : 500;\r\n            // make sure we don't generate the same ids in defs\r\n            this.__ids = {};\r\n            // defs tag\r\n            this.__defs = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\r\n            this.__root.appendChild(this.__defs);\r\n        }\r\n        get canvas() {\r\n            // XXX: point back to this instance\r\n            return this;\r\n        }\r\n        get width() {\r\n            return this._width;\r\n        }\r\n        set width(width) {\r\n            this._width = width;\r\n            this.__root.setAttribute(\"width\", `${width}`);\r\n        }\r\n        get height() {\r\n            return this._height;\r\n        }\r\n        set height(height) {\r\n            this._height = height;\r\n            this.__root.setAttribute(\"height\", `${height}`);\r\n        }\r\n        /**\r\n         * Creates the specified svg element\r\n         */\r\n        __createElement(elementName, properties = {}, resetFill = false) {\r\n            const element = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", elementName);\r\n            if (resetFill) {\r\n                // if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.\r\n                element.setAttribute(\"fill\", \"none\");\r\n                element.setAttribute(\"stroke\", \"none\");\r\n            }\r\n            const keys = Object.keys(properties);\r\n            for (const key of keys) {\r\n                element.setAttribute(key, `${properties[key]}`);\r\n            }\r\n            return element;\r\n        }\r\n        /**\r\n         * Applies default canvas styles to the context\r\n         */\r\n        __setDefaultStyles() {\r\n            // default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/\r\n            const keys = Object.keys(STYLES);\r\n            const self = this;\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key = keys[i];\r\n                self[key] = STYLES[key].canvas;\r\n            }\r\n        }\r\n        /**\r\n         * Applies styles on restore\r\n         */\r\n        __applyStyleState(styleState) {\r\n            const keys = Object.keys(styleState);\r\n            const self = this;\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key = keys[i];\r\n                self[key] = styleState[key];\r\n            }\r\n        }\r\n        /**\r\n         * Gets the current style state\r\n         */\r\n        __getStyleState() {\r\n            const keys = Object.keys(STYLES);\r\n            const styleState = {};\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key = keys[i];\r\n                styleState[key] = this[key];\r\n            }\r\n            return styleState;\r\n        }\r\n        /**\r\n         * Apples the current styles to the current SVG element. On \"ctx.fill\" or \"ctx.stroke\"\r\n         */\r\n        __applyStyleToCurrentElement(type) {\r\n            let currentElement = this.__currentElement;\r\n            const currentStyleGroup = this.__currentElementsToStyle;\r\n            if (currentStyleGroup != null) {\r\n                currentElement.setAttribute(type, \"\");\r\n                currentElement = currentStyleGroup.element;\r\n                for (const node of currentStyleGroup.children) {\r\n                    node.setAttribute(type, \"\");\r\n                }\r\n            }\r\n            const keys = Object.keys(STYLES);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const style = STYLES[keys[i]];\r\n                const value = this[keys[i]];\r\n                if (style.apply) {\r\n                    if (value instanceof CanvasPattern) {\r\n                        for (const def of [...value.__ctx.__defs.childNodes]) {\r\n                            if (def instanceof Element) {\r\n                                const id = def.getAttribute(\"id\");\r\n                                this.__ids[id] = id;\r\n                                this.__defs.appendChild(def);\r\n                            }\r\n                        }\r\n                        const id = value.__root.getAttribute(\"id\");\r\n                        currentElement.setAttribute(style.apply, `url(#${id})`);\r\n                    }\r\n                    else if (value instanceof CanvasGradient) {\r\n                        const id = value.__root.getAttribute(\"id\");\r\n                        currentElement.setAttribute(style.apply, `url(#${id})`);\r\n                    }\r\n                    else if (style.apply.indexOf(type) !== -1 && style.svg !== value) {\r\n                        if ((style.svgAttr === \"stroke\" || style.svgAttr === \"fill\") && types_1.isString(value) && value.indexOf(\"rgba\") !== -1) {\r\n                            // separate alpha value, since illustrator can't handle it\r\n                            const regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\r\n                            const matches = regex.exec(value);\r\n                            const [, r, g, b, a] = matches;\r\n                            currentElement.setAttribute(style.svgAttr, `rgb(${r},${g},${b})`);\r\n                            // should take globalAlpha here\r\n                            let opacity = parseFloat(a);\r\n                            const globalAlpha = this.globalAlpha;\r\n                            if (globalAlpha != null) {\r\n                                opacity *= globalAlpha;\r\n                            }\r\n                            currentElement.setAttribute(style.svgAttr + \"-opacity\", `${opacity}`);\r\n                        }\r\n                        else {\r\n                            let attr = style.svgAttr;\r\n                            if (keys[i] === 'globalAlpha') {\r\n                                attr = type + '-' + style.svgAttr;\r\n                                if (currentElement.getAttribute(attr)) {\r\n                                    // fill-opacity or stroke-opacity has already been set by stroke or fill.\r\n                                    continue;\r\n                                }\r\n                            }\r\n                            // otherwise only update attribute if right type, and not svg default\r\n                            currentElement.setAttribute(attr, `${value}`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n          * Returns the serialized value of the svg so far\r\n          * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.\r\n          *                           If true, we attempt to find all named entities and encode it as a numeric entity.\r\n          * @return serialized svg\r\n          */\r\n        get_serialized_svg(fixNamedEntities = false) {\r\n            let serialized = new XMLSerializer().serializeToString(this.__root);\r\n            // IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly\r\n            const xmlns = /xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg\".+xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg/gi;\r\n            if (xmlns.test(serialized)) {\r\n                serialized = serialized.replace('xmlns=\"http://www.w3.org/2000/svg', 'xmlns:xlink=\"http://www.w3.org/1999/xlink');\r\n            }\r\n            if (fixNamedEntities) {\r\n                // loop over each named entity and replace with the proper equivalent.\r\n                for (const [key, value] of namedEntities) {\r\n                    const regexp = new RegExp(key, \"gi\");\r\n                    if (regexp.test(serialized)) {\r\n                        serialized = serialized.replace(regexp, value);\r\n                    }\r\n                }\r\n            }\r\n            return serialized;\r\n        }\r\n        get_svg() {\r\n            return this.__root;\r\n        }\r\n        /**\r\n          * Will generate a group tag.\r\n          */\r\n        save() {\r\n            this.__stack.push({\r\n                transform: this._transform,\r\n                clip_path: this._clip_path,\r\n                attributes: this.__getStyleState(),\r\n            });\r\n            this._transform = this._transform.clone();\r\n        }\r\n        /**\r\n          * Sets current element to parent, or just root if already root\r\n          */\r\n        restore() {\r\n            if (this.__stack.length == 0)\r\n                return;\r\n            const { transform, clip_path, attributes } = this.__stack.pop();\r\n            this._transform = transform;\r\n            this._clip_path = clip_path;\r\n            this.__applyStyleState(attributes);\r\n        }\r\n        _apply_transform(element, transform = this._transform) {\r\n            if (!transform.is_identity) {\r\n                element.setAttribute(\"transform\", transform.toString());\r\n            }\r\n        }\r\n        /**\r\n          *  scales the current element\r\n          */\r\n        scale(x, y) {\r\n            if (!isFinite(x) || (y != null && !isFinite(y)))\r\n                return;\r\n            this._transform.scale(x, y !== null && y !== void 0 ? y : x);\r\n        }\r\n        /**\r\n          * rotates the current element\r\n          */\r\n        rotate(angle) {\r\n            if (!isFinite(angle))\r\n                return;\r\n            this._transform.rotate(angle);\r\n        }\r\n        /**\r\n          * translates the current element\r\n          */\r\n        translate(x, y) {\r\n            if (!isFinite(x + y))\r\n                return;\r\n            this._transform.translate(x, y);\r\n        }\r\n        /**\r\n          * applies a transform to the current element\r\n          */\r\n        transform(a, b, c, d, e, f) {\r\n            if (!isFinite(a + b + c + d + e + f))\r\n                return;\r\n            this._transform.transform(a, b, c, d, e, f);\r\n        }\r\n        /**\r\n          * Create a new Path Element\r\n          */\r\n        beginPath() {\r\n            // Note that there is only one current default path, it is not part of the drawing state.\r\n            // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path\r\n            this.__currentDefaultPath = \"\";\r\n            this.__currentPosition = null;\r\n            const path = this.__createElement(\"path\", {}, true);\r\n            this.__root.appendChild(path);\r\n            this.__currentElement = path;\r\n        }\r\n        /**\r\n          * Helper function to apply currentDefaultPath to current path element\r\n          */\r\n        __applyCurrentDefaultPath() {\r\n            const currentElement = this.__currentElement;\r\n            if (currentElement.nodeName === \"path\") {\r\n                currentElement.setAttribute(\"d\", this.__currentDefaultPath);\r\n            }\r\n            else {\r\n                console.error(\"Attempted to apply path command to node\", currentElement.nodeName);\r\n            }\r\n        }\r\n        /**\r\n          * Helper function to add path command\r\n          */\r\n        __addPathCommand(x, y, path) {\r\n            const separator = !this.__currentDefaultPath ? \"\" : \" \";\r\n            this.__currentDefaultPath += separator + path;\r\n            this.__currentPosition = { x, y };\r\n        }\r\n        get _hasCurrentDefaultPath() {\r\n            return !!this.__currentDefaultPath;\r\n        }\r\n        /**\r\n          * Adds the move command to the current path element,\r\n          * if the currentPathElement is not empty create a new path element\r\n          */\r\n        moveTo(x, y) {\r\n            if (!isFinite(x + y))\r\n                return;\r\n            if (this.__currentElement.nodeName !== \"path\") {\r\n                this.beginPath();\r\n            }\r\n            // creates a new subpath with the given point\r\n            const [tx, ty] = this._transform.apply(x, y);\r\n            this.__addPathCommand(tx, ty, `M ${tx} ${ty}`);\r\n        }\r\n        /**\r\n          * Closes the current path\r\n          */\r\n        closePath() {\r\n            if (this._hasCurrentDefaultPath) {\r\n                this.__addPathCommand(NaN, NaN, \"Z\");\r\n            }\r\n        }\r\n        /**\r\n          * Adds a line to command\r\n          */\r\n        lineTo(x, y) {\r\n            if (!isFinite(x + y))\r\n                return;\r\n            if (!this._hasCurrentDefaultPath)\r\n                this.moveTo(x, y);\r\n            else {\r\n                const [tx, ty] = this._transform.apply(x, y);\r\n                this.__addPathCommand(tx, ty, `L ${tx} ${ty}`);\r\n            }\r\n        }\r\n        /**\r\n          * Add a bezier command\r\n          */\r\n        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\r\n            if (!isFinite(cp1x + cp1y + cp2x + cp2y + x + y))\r\n                return;\r\n            const [tx, ty] = this._transform.apply(x, y);\r\n            const [tcp1x, tcp1y] = this._transform.apply(cp1x, cp1y);\r\n            const [tcp2x, tcp2y] = this._transform.apply(cp2x, cp2y);\r\n            this.__addPathCommand(tx, ty, `C ${tcp1x} ${tcp1y} ${tcp2x} ${tcp2y} ${tx} ${ty}`);\r\n        }\r\n        /**\r\n          * Adds a quadratic curve to command\r\n          */\r\n        quadraticCurveTo(cpx, cpy, x, y) {\r\n            if (!isFinite(cpx + cpy + x + y))\r\n                return;\r\n            const [tx, ty] = this._transform.apply(x, y);\r\n            const [tcpx, tcpy] = this._transform.apply(cpx, cpy);\r\n            this.__addPathCommand(tx, ty, `Q ${tcpx} ${tcpy} ${tx} ${ty}`);\r\n        }\r\n        /**\r\n          * Adds the arcTo to the current path\r\n          *\r\n          * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto\r\n          */\r\n        arcTo(x1, y1, x2, y2, radius) {\r\n            if (!isFinite(x1 + y1 + x2 + y2 + radius))\r\n                return;\r\n            // Let the point (x0, y0) be the last point in the subpath.\r\n            if (this.__currentPosition == null)\r\n                return;\r\n            const x0 = this.__currentPosition.x;\r\n            const y0 = this.__currentPosition.y;\r\n            // Negative values for radius must cause the implementation to throw an IndexSizeError exception.\r\n            if (radius < 0) {\r\n                throw new Error(\"IndexSizeError: The radius provided (\" + radius + \") is negative.\");\r\n            }\r\n            // If the point (x0, y0) is equal to the point (x1, y1),\r\n            // or if the point (x1, y1) is equal to the point (x2, y2),\r\n            // or if the radius radius is zero,\r\n            // then the method must add the point (x1, y1) to the subpath,\r\n            // and connect that point to the previous point (x0, y0) by a straight line.\r\n            if (((x0 === x1) && (y0 === y1)) || ((x1 === x2) && (y1 === y2)) || (radius === 0)) {\r\n                this.lineTo(x1, y1);\r\n                return;\r\n            }\r\n            function normalize([x, y]) {\r\n                const len = Math.sqrt(x ** 2 + y ** 2);\r\n                return [x / len, y / len];\r\n            }\r\n            // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,\r\n            // then the method must add the point (x1, y1) to the subpath,\r\n            // and connect that point to the previous point (x0, y0) by a straight line.\r\n            const unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);\r\n            const unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);\r\n            if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {\r\n                this.lineTo(x1, y1);\r\n                return;\r\n            }\r\n            // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,\r\n            // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),\r\n            // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).\r\n            // The points at which this circle touches these two lines are called the start and end tangent points respectively.\r\n            // note that both vectors are unit vectors, so the length is 1\r\n            const cos = (unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1]);\r\n            const theta = Math.acos(Math.abs(cos));\r\n            // Calculate origin\r\n            const unit_vec_p1_origin = normalize([\r\n                unit_vec_p1_p0[0] + unit_vec_p1_p2[0],\r\n                unit_vec_p1_p0[1] + unit_vec_p1_p2[1],\r\n            ]);\r\n            const len_p1_origin = radius / Math.sin(theta / 2);\r\n            const x = x1 + len_p1_origin * unit_vec_p1_origin[0];\r\n            const y = y1 + len_p1_origin * unit_vec_p1_origin[1];\r\n            // Calculate start angle and end angle\r\n            // rotate 90deg clockwise (note that y axis points to its down)\r\n            const unit_vec_origin_start_tangent = [\r\n                -unit_vec_p1_p0[1],\r\n                unit_vec_p1_p0[0],\r\n            ];\r\n            // rotate 90deg counter clockwise (note that y axis points to its down)\r\n            const unit_vec_origin_end_tangent = [\r\n                unit_vec_p1_p2[1],\r\n                -unit_vec_p1_p2[0],\r\n            ];\r\n            function getAngle(vector) {\r\n                // get angle (clockwise) between vector and (1, 0)\r\n                const x = vector[0];\r\n                const y = vector[1];\r\n                if (y >= 0) { // note that y axis points to its down\r\n                    return Math.acos(x);\r\n                }\r\n                else {\r\n                    return -Math.acos(x);\r\n                }\r\n            }\r\n            const startAngle = getAngle(unit_vec_origin_start_tangent);\r\n            const endAngle = getAngle(unit_vec_origin_end_tangent);\r\n            // Connect the point (x0, y0) to the start tangent point by a straight line\r\n            this.lineTo(x + unit_vec_origin_start_tangent[0] * radius, y + unit_vec_origin_start_tangent[1] * radius);\r\n            // Connect the start tangent point to the end tangent point by arc\r\n            // and adding the end tangent point to the subpath.\r\n            this.arc(x, y, radius, startAngle, endAngle);\r\n        }\r\n        /**\r\n          * Sets the stroke property on the current element\r\n          */\r\n        stroke() {\r\n            if (this.__currentElement.nodeName === \"path\") {\r\n                this.__currentElement.setAttribute(\"paint-order\", \"fill\");\r\n            }\r\n            this.__applyCurrentDefaultPath();\r\n            this.__applyStyleToCurrentElement(\"stroke\");\r\n            if (this._clip_path != null) {\r\n                this.__currentElement.setAttribute(\"clip-path\", this._clip_path);\r\n            }\r\n        }\r\n        /**\r\n          * Sets fill properties on the current element\r\n          */\r\n        fill() {\r\n            if (this.__currentElement.nodeName === \"path\") {\r\n                this.__currentElement.setAttribute(\"paint-order\", \"stroke\");\r\n            }\r\n            this.__applyCurrentDefaultPath();\r\n            this.__applyStyleToCurrentElement(\"fill\");\r\n            if (this._clip_path != null) {\r\n                this.__currentElement.setAttribute(\"clip-path\", this._clip_path);\r\n            }\r\n        }\r\n        /**\r\n          *  Adds a rectangle to the path.\r\n          */\r\n        rect(x, y, width, height) {\r\n            if (!isFinite(x + y + width + height))\r\n                return;\r\n            if (this.__currentElement.nodeName !== \"path\") {\r\n                this.beginPath();\r\n            }\r\n            this.moveTo(x, y);\r\n            this.lineTo(x + width, y);\r\n            this.lineTo(x + width, y + height);\r\n            this.lineTo(x, y + height);\r\n            this.lineTo(x, y);\r\n        }\r\n        /**\r\n          * adds a rectangle element\r\n          */\r\n        fillRect(x, y, width, height) {\r\n            if (!isFinite(x + y + width + height))\r\n                return;\r\n            this.beginPath();\r\n            this.rect(x, y, width, height);\r\n            this.fill();\r\n        }\r\n        /**\r\n          * Draws a rectangle with no fill\r\n          * @param x\r\n          * @param y\r\n          * @param width\r\n          * @param height\r\n          */\r\n        strokeRect(x, y, width, height) {\r\n            if (!isFinite(x + y + width + height))\r\n                return;\r\n            this.beginPath();\r\n            this.rect(x, y, width, height);\r\n            this.stroke();\r\n        }\r\n        /**\r\n          * Clear entire canvas:\r\n          * 1. save current transforms\r\n          * 2. remove all the childNodes of the root g element\r\n          */\r\n        __clearCanvas() {\r\n            dom_1.empty(this.__defs);\r\n            dom_1.empty(this.__root);\r\n            this.__root.appendChild(this.__defs);\r\n            this.__currentElement = this.__root;\r\n        }\r\n        /**\r\n          * \"Clears\" a canvas by just drawing a white rectangle in the current group.\r\n          */\r\n        clearRect(x, y, width, height) {\r\n            if (!isFinite(x + y + width + height))\r\n                return;\r\n            if (x === 0 && y === 0 && width === this.width && height === this.height) {\r\n                this.__clearCanvas();\r\n                return;\r\n            }\r\n            const rect = this.__createElement(\"rect\", { x, y, width, height, fill: \"#FFFFFF\" }, true);\r\n            this._apply_transform(rect);\r\n            this.__root.appendChild(rect);\r\n        }\r\n        /**\r\n          * Adds a linear gradient to a defs tag.\r\n          * Returns a canvas gradient object that has a reference to it's parent def\r\n          */\r\n        createLinearGradient(x1, y1, x2, y2) {\r\n            if (!isFinite(x1 + y1 + x2 + y2))\r\n                throw new Error(\"The provided double value is non-finite\");\r\n            const [tx1, ty1] = this._transform.apply(x1, y1);\r\n            const [tx2, ty2] = this._transform.apply(x2, y2);\r\n            const grad = this.__createElement(\"linearGradient\", {\r\n                id: randomString(this.__ids),\r\n                x1: `${tx1}px`,\r\n                x2: `${tx2}px`,\r\n                y1: `${ty1}px`,\r\n                y2: `${ty2}px`,\r\n                gradientUnits: \"userSpaceOnUse\",\r\n            }, false);\r\n            this.__defs.appendChild(grad);\r\n            return new CanvasGradient(grad, this);\r\n        }\r\n        /**\r\n          * Adds a radial gradient to a defs tag.\r\n          * Returns a canvas gradient object that has a reference to it's parent def\r\n          */\r\n        createRadialGradient(x0, y0, _r0, x1, y1, r1) {\r\n            if (!isFinite(x0 + y0 + _r0 + x1 + y1 + r1))\r\n                throw new Error(\"The provided double value is non-finite\");\r\n            const [tx0, ty0] = this._transform.apply(x0, y0);\r\n            const [tx1, ty1] = this._transform.apply(x1, y1);\r\n            const grad = this.__createElement(\"radialGradient\", {\r\n                id: randomString(this.__ids),\r\n                cx: `${tx1}px`,\r\n                cy: `${ty1}px`,\r\n                r: `${r1}px`,\r\n                fx: `${tx0}px`,\r\n                fy: `${ty0}px`,\r\n                gradientUnits: \"userSpaceOnUse\",\r\n            }, false);\r\n            this.__defs.appendChild(grad);\r\n            return new CanvasGradient(grad, this);\r\n        }\r\n        /**\r\n          * Parses the font string and returns svg mapping\r\n          */\r\n        __parseFont() {\r\n            const regex = /^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))(?:\\s*\\/\\s*(normal|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])))?\\s*([-,\\'\\\"\\sa-z0-9]+?)\\s*$/i;\r\n            const fontPart = regex.exec(this.font);\r\n            const data = {\r\n                style: fontPart[1] || 'normal',\r\n                size: fontPart[4] || '10px',\r\n                family: fontPart[6] || 'sans-serif',\r\n                weight: fontPart[3] || 'normal',\r\n                decoration: fontPart[2] || 'normal',\r\n            };\r\n            // canvas doesn't support underline natively, but we can pass this attribute\r\n            if (this.__fontUnderline === \"underline\") {\r\n                data.decoration = \"underline\";\r\n            }\r\n            // canvas also doesn't support linking, but we can pass this as well\r\n            if (this.__fontHref != null) {\r\n                data.href = this.__fontHref;\r\n            }\r\n            return data;\r\n        }\r\n        /**\r\n          * Helper to link text fragments\r\n          */\r\n        __wrapTextLink(font, element) {\r\n            if (font.href) {\r\n                const a = this.__createElement(\"a\");\r\n                a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", font.href);\r\n                a.appendChild(element);\r\n                return a;\r\n            }\r\n            return element;\r\n        }\r\n        /**\r\n          * Fills or strokes text\r\n          */\r\n        __applyText(text, x, y, action) {\r\n            const font = this.__parseFont();\r\n            const textElement = this.__createElement(\"text\", {\r\n                \"font-family\": font.family,\r\n                \"font-size\": font.size,\r\n                \"font-style\": font.style,\r\n                \"font-weight\": font.weight,\r\n                \"text-decoration\": font.decoration,\r\n                x,\r\n                y,\r\n                \"text-anchor\": getTextAnchor(this.textAlign),\r\n                \"dominant-baseline\": getDominantBaseline(this.textBaseline),\r\n            }, true);\r\n            textElement.appendChild(this.__document.createTextNode(text));\r\n            this._apply_transform(textElement);\r\n            this.__currentElement = textElement;\r\n            this.__applyStyleToCurrentElement(action);\r\n            this.__root.appendChild(this.__wrapTextLink(font, textElement));\r\n        }\r\n        /**\r\n          * Creates a text element\r\n          */\r\n        fillText(text, x, y) {\r\n            if (text == null || !isFinite(x + y))\r\n                return;\r\n            this.__applyText(text, x, y, \"fill\");\r\n        }\r\n        /**\r\n          * Strokes text\r\n          */\r\n        strokeText(text, x, y) {\r\n            if (text == null || !isFinite(x + y))\r\n                return;\r\n            this.__applyText(text, x, y, \"stroke\");\r\n        }\r\n        /**\r\n          * No need to implement this for svg.\r\n          */\r\n        measureText(text) {\r\n            this.__ctx.font = this.font;\r\n            return this.__ctx.measureText(text);\r\n        }\r\n        arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {\r\n            if (!isFinite(x + y + radius + startAngle + endAngle))\r\n                return;\r\n            // in canvas no circle is drawn if no angle is provided.\r\n            if (startAngle === endAngle) {\r\n                return;\r\n            }\r\n            startAngle = startAngle % (2 * Math.PI);\r\n            endAngle = endAngle % (2 * Math.PI);\r\n            if (startAngle === endAngle) {\r\n                // circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)\r\n                endAngle = ((endAngle + (2 * Math.PI)) - 0.001 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);\r\n            }\r\n            const endX = x + radius * Math.cos(endAngle);\r\n            const endY = y + radius * Math.sin(endAngle);\r\n            const startX = x + radius * Math.cos(startAngle);\r\n            const startY = y + radius * Math.sin(startAngle);\r\n            const sweepFlag = counterClockwise ? 0 : 1;\r\n            let largeArcFlag = 0;\r\n            let diff = endAngle - startAngle;\r\n            // https://github.com/gliffy/canvas2svg/issues/4\r\n            if (diff < 0) {\r\n                diff += 2 * Math.PI;\r\n            }\r\n            if (counterClockwise) {\r\n                largeArcFlag = diff > Math.PI ? 0 : 1;\r\n            }\r\n            else {\r\n                largeArcFlag = diff > Math.PI ? 1 : 0;\r\n            }\r\n            this.lineTo(startX, startY);\r\n            const rx = radius;\r\n            const ry = radius;\r\n            const xAxisRotation = 0;\r\n            const [tendX, tendY] = this._transform.apply(endX, endY);\r\n            this.__addPathCommand(tendX, tendY, `A ${rx} ${ry} ${xAxisRotation} ${largeArcFlag} ${sweepFlag} ${tendX} ${tendY}`);\r\n        }\r\n        /**\r\n          * Generates a ClipPath from the clip command.\r\n          */\r\n        clip() {\r\n            const clip_path = this.__createElement(\"clipPath\");\r\n            const id = randomString(this.__ids);\r\n            this.__applyCurrentDefaultPath();\r\n            clip_path.setAttribute(\"id\", id);\r\n            clip_path.appendChild(this.__currentElement);\r\n            this.__defs.appendChild(clip_path);\r\n            this._clip_path = `url(#${id})`;\r\n        }\r\n        /**\r\n          * Draws a canvas, image or mock context to this canvas.\r\n          * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.\r\n          * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage\r\n          */\r\n        drawImage(image, ...args) {\r\n            let dx, dy;\r\n            let dw, dh;\r\n            let sx, sy;\r\n            let sw, sh;\r\n            if (args.length == 2) {\r\n                [dx, dy] = args;\r\n                if (!isFinite(dx + dy))\r\n                    return;\r\n                sx = 0;\r\n                sy = 0;\r\n                sw = image.width;\r\n                sh = image.height;\r\n                dw = sw;\r\n                dh = sh;\r\n            }\r\n            else if (args.length == 4) {\r\n                [dx, dy, dw, dh] = args;\r\n                if (!isFinite(dx + dy + dw + dh))\r\n                    return;\r\n                sx = 0;\r\n                sy = 0;\r\n                sw = image.width;\r\n                sh = image.height;\r\n            }\r\n            else if (args.length === 8) {\r\n                [sx, sy, sw, sh, dx, dy, dw, dh] = args;\r\n                if (!isFinite(sx + sy + sw + sh + dx + dy + dw + dh))\r\n                    return;\r\n            }\r\n            else {\r\n                throw new Error(`Inavlid number of arguments passed to drawImage: ${arguments.length}`);\r\n            }\r\n            // parent, svg, defs, group, currentElement, svgImage, canvas, context, id\r\n            const parent = this.__root;\r\n            const translateDirective = \"translate(\" + dx + \", \" + dy + \")\";\r\n            const transform = this._transform.clone().translate(dx, dy);\r\n            if (image instanceof SVGRenderingContext2D || image instanceof SVGSVGElement) {\r\n                // In the future we may want to clone nodes instead.\r\n                // also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.\r\n                const svg_node = image instanceof SVGSVGElement ? image : image.get_svg();\r\n                const svg = svg_node.cloneNode(true);\r\n                let scope;\r\n                if (transform.is_identity)\r\n                    scope = parent;\r\n                else {\r\n                    scope = this.__createElement(\"g\");\r\n                    this._apply_transform(scope, transform);\r\n                    parent.appendChild(scope);\r\n                }\r\n                for (const child of [...svg.childNodes]) {\r\n                    if (child instanceof SVGDefsElement) {\r\n                        for (const def of [...child.childNodes]) {\r\n                            if (def instanceof Element) {\r\n                                const id = def.getAttribute(\"id\");\r\n                                this.__ids[id] = id;\r\n                                this.__defs.appendChild(def);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        scope.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n            else if (image instanceof HTMLImageElement || image instanceof SVGImageElement) {\r\n                const svgImage = this.__createElement(\"image\");\r\n                svgImage.setAttribute(\"width\", `${dw}`);\r\n                svgImage.setAttribute(\"height\", `${dh}`);\r\n                svgImage.setAttribute(\"preserveAspectRatio\", \"none\");\r\n                if (sx || sy || sw !== image.width || sh !== image.height) {\r\n                    // crop the image using a temporary canvas\r\n                    const canvas = this.__document.createElement(\"canvas\");\r\n                    canvas.width = dw;\r\n                    canvas.height = dh;\r\n                    const context = canvas.getContext(\"2d\");\r\n                    context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);\r\n                    image = canvas;\r\n                }\r\n                svgImage.setAttribute(\"transform\", translateDirective);\r\n                const url = image instanceof HTMLCanvasElement ? image.toDataURL() : image.getAttribute(\"src\");\r\n                svgImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", url);\r\n                parent.appendChild(svgImage);\r\n            }\r\n            else if (image instanceof HTMLCanvasElement) {\r\n                const svgImage = this.__createElement(\"image\");\r\n                svgImage.setAttribute(\"width\", `${dw}`);\r\n                svgImage.setAttribute(\"height\", `${dh}`);\r\n                svgImage.setAttribute(\"preserveAspectRatio\", \"none\");\r\n                // draw canvas onto temporary canvas so that smoothing can be handled\r\n                const canvas = this.__document.createElement(\"canvas\");\r\n                canvas.width = dw;\r\n                canvas.height = dh;\r\n                const context = canvas.getContext(\"2d\");\r\n                context.imageSmoothingEnabled = false;\r\n                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);\r\n                image = canvas;\r\n                svgImage.setAttribute(\"transform\", translateDirective);\r\n                svgImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", image.toDataURL());\r\n                parent.appendChild(svgImage);\r\n            }\r\n        }\r\n        /**\r\n          * Generates a pattern tag\r\n          */\r\n        createPattern(image, _repetition) {\r\n            const pattern = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"pattern\");\r\n            const id = randomString(this.__ids);\r\n            pattern.setAttribute(\"id\", id);\r\n            pattern.setAttribute(\"width\", `${this._to_number(image.width)}`);\r\n            pattern.setAttribute(\"height\", `${this._to_number(image.height)}`);\r\n            pattern.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\r\n            if (image instanceof HTMLCanvasElement || image instanceof HTMLImageElement || image instanceof SVGImageElement) {\r\n                const img = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"image\");\r\n                const url = image instanceof HTMLCanvasElement ? image.toDataURL() : image.getAttribute(\"src\");\r\n                img.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", url);\r\n                pattern.appendChild(img);\r\n                this.__defs.appendChild(pattern);\r\n            }\r\n            else if (image instanceof SVGRenderingContext2D) {\r\n                for (const child of [...image.__root.childNodes]) {\r\n                    if (!(child instanceof SVGDefsElement)) {\r\n                        pattern.appendChild(child);\r\n                    }\r\n                }\r\n                //pattern.appendChild(image.__root.childNodes[1])\r\n                this.__defs.appendChild(pattern);\r\n            }\r\n            else if (image instanceof SVGSVGElement) {\r\n                for (const child of [...image.childNodes]) {\r\n                    if (!(child instanceof SVGDefsElement)) {\r\n                        pattern.appendChild(child);\r\n                    }\r\n                }\r\n                //pattern.appendChild(image.__root.childNodes[1])\r\n                this.__defs.appendChild(pattern);\r\n            }\r\n            else {\r\n                throw new Error(\"unsupported\");\r\n            }\r\n            return new CanvasPattern(pattern, this);\r\n        }\r\n        setLineDash(dashArray) {\r\n            if (dashArray && dashArray.length > 0) {\r\n                this.lineDash = dashArray.join(\",\");\r\n            }\r\n            else {\r\n                this.lineDash = null;\r\n            }\r\n        }\r\n        _to_number(val) {\r\n            return types_1.isNumber(val) ? val : val.baseVal.value;\r\n        }\r\n    }\r\n    exports.SVGRenderingContext2D = SVGRenderingContext2D;\r\n    SVGRenderingContext2D.__name__ = \"SVGRenderingContext2D\";\r\n}\r\n","/* core\\util\\affine.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const { sin, cos } = Math;\r\n    class AffineTransform {\r\n        constructor(a = 1, b = 0, c = 0, d = 1, e = 0, f = 0) {\r\n            this.a = a;\r\n            this.b = b;\r\n            this.c = c;\r\n            this.d = d;\r\n            this.e = e;\r\n            this.f = f;\r\n        }\r\n        toString() {\r\n            const { a, b, c, d, e, f } = this;\r\n            return `matrix(${a}, ${b}, ${c}, ${d}, ${e}, ${f})`;\r\n        }\r\n        clone() {\r\n            const { a, b, c, d, e, f } = this;\r\n            return new AffineTransform(a, b, c, d, e, f);\r\n        }\r\n        get is_identity() {\r\n            const { a, b, c, d, e, f } = this;\r\n            return a == 1 && b == 0 && c == 0 && d == 1 && e == 0 && f == 0;\r\n        }\r\n        apply(x, y) {\r\n            const { a, b, c, d, e, f } = this;\r\n            return [\r\n                a * x + c * y + e,\r\n                b * x + d * y + f,\r\n            ];\r\n        }\r\n        iv_apply(xs, ys) {\r\n            const { a, b, c, d, e, f } = this;\r\n            const n = xs.length;\r\n            for (let i = 0; i < n; i++) {\r\n                const x = xs[i];\r\n                const y = ys[i];\r\n                xs[i] = a * x + c * y + e;\r\n                ys[i] = b * x + d * y + f;\r\n            }\r\n        }\r\n        transform(A, B, C, D, E, F) {\r\n            const { a, b, c, d, e, f } = this;\r\n            this.a = a * A + c * B;\r\n            this.c = a * C + c * D;\r\n            this.e = a * E + c * F + e;\r\n            this.b = b * A + d * B;\r\n            this.d = b * C + d * D;\r\n            this.f = b * E + d * F + f;\r\n            return this;\r\n        }\r\n        translate(tx, ty) {\r\n            return this.transform(1, 0, 0, 1, tx, ty);\r\n        }\r\n        scale(cx, cy) {\r\n            return this.transform(cx, 0, 0, cy, 0, 0);\r\n        }\r\n        skew(sx, sy) {\r\n            return this.transform(1, sy, sx, 1, 0, 0);\r\n        }\r\n        rotate(angle) {\r\n            const s = sin(angle);\r\n            const c = cos(angle);\r\n            return this.transform(c, s, -s, c, 0, 0);\r\n        }\r\n        rotate_ccw(angle) {\r\n            return this.rotate(-angle);\r\n        }\r\n        translate_x(tx) {\r\n            return this.translate(tx, 0);\r\n        }\r\n        translate_y(ty) {\r\n            return this.translate(0, ty);\r\n        }\r\n        flip() {\r\n            return this.scale(-1, -1);\r\n        }\r\n        flip_x() {\r\n            return this.scale(1, -1);\r\n        }\r\n        flip_y() {\r\n            return this.scale(-1, 1);\r\n        }\r\n    }\r\n    exports.AffineTransform = AffineTransform;\r\n    AffineTransform.__name__ = \"AffineTransform\";\r\n}\r\n","/* models\\canvas\\canvas.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const has_props_1 = require(14) /* ../../core/has_props */;\r\n    const dom_view_1 = require(78) /* ../../core/dom_view */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\r\n    const canvas_1 = require(80) /* ../../core/util/canvas */;\r\n    const svg_1 = require(75) /* ../../core/util/svg */;\r\n    const global_webgl = (() => {\r\n        // We use a global invisible canvas and gl context. By having a global context,\r\n        // we avoid the limitation of max 16 contexts that most browsers have.\r\n        const canvas = document.createElement(\"canvas\");\r\n        const gl = canvas.getContext(\"webgl\", { premultipliedAlpha: true });\r\n        // If WebGL is available, we store a reference to the gl canvas on\r\n        // the ctx object, because that's what gets passed everywhere.\r\n        if (gl != null)\r\n            return { canvas, gl };\r\n        else {\r\n            logging_1.logger.trace(\"WebGL is not supported\");\r\n            return undefined;\r\n        }\r\n    })();\r\n    const style = {\r\n        position: \"absolute\",\r\n        top: \"0\",\r\n        left: \"0\",\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n    };\r\n    class CanvasLayer {\r\n        constructor(backend, hidpi) {\r\n            this.backend = backend;\r\n            this.hidpi = hidpi;\r\n            this.pixel_ratio = 1;\r\n            this.bbox = new bbox_1.BBox();\r\n            switch (backend) {\r\n                case \"webgl\":\r\n                case \"canvas\": {\r\n                    this._el = this._canvas = dom_1.canvas({ style });\r\n                    const ctx = this.canvas.getContext('2d');\r\n                    if (ctx == null)\r\n                        throw new Error(\"unable to obtain 2D rendering context\");\r\n                    this._ctx = ctx;\r\n                    if (hidpi) {\r\n                        this.pixel_ratio = devicePixelRatio;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"svg\": {\r\n                    const ctx = new svg_1.SVGRenderingContext2D();\r\n                    this._ctx = ctx;\r\n                    this._canvas = ctx.get_svg();\r\n                    this._el = dom_1.div({ style }, this._canvas);\r\n                    break;\r\n                }\r\n            }\r\n            canvas_1.fixup_ctx(this._ctx);\r\n        }\r\n        get canvas() {\r\n            return this._canvas;\r\n        }\r\n        get ctx() {\r\n            return this._ctx;\r\n        }\r\n        get el() {\r\n            return this._el;\r\n        }\r\n        resize(width, height) {\r\n            this.bbox = new bbox_1.BBox({ left: 0, top: 0, width, height });\r\n            const target = this._ctx instanceof svg_1.SVGRenderingContext2D ? this._ctx : this.canvas;\r\n            target.width = width * this.pixel_ratio;\r\n            target.height = height * this.pixel_ratio;\r\n        }\r\n        prepare() {\r\n            const { ctx, hidpi, pixel_ratio } = this;\r\n            ctx.save();\r\n            if (hidpi) {\r\n                ctx.scale(pixel_ratio, pixel_ratio);\r\n                ctx.translate(0.5, 0.5);\r\n            }\r\n            this.clear();\r\n        }\r\n        clear() {\r\n            const { x, y, width, height } = this.bbox;\r\n            this.ctx.clearRect(x, y, width, height);\r\n        }\r\n        finish() {\r\n            this.ctx.restore();\r\n        }\r\n        to_blob() {\r\n            const { _canvas } = this;\r\n            if (_canvas instanceof HTMLCanvasElement) {\r\n                if (_canvas.msToBlob != null) {\r\n                    return Promise.resolve(_canvas.msToBlob());\r\n                }\r\n                else {\r\n                    return new Promise((resolve, reject) => {\r\n                        _canvas.toBlob((blob) => blob != null ? resolve(blob) : reject(), \"image/png\");\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                const ctx = this._ctx;\r\n                const svg = ctx.get_serialized_svg(true);\r\n                const blob = new Blob([svg], { type: \"image/svg+xml\" });\r\n                return Promise.resolve(blob);\r\n            }\r\n        }\r\n    }\r\n    exports.CanvasLayer = CanvasLayer;\r\n    CanvasLayer.__name__ = \"CanvasLayer\";\r\n    class CanvasView extends dom_view_1.DOMView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.bbox = new bbox_1.BBox();\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            const { output_backend, hidpi } = this.model;\r\n            if (output_backend == \"webgl\") {\r\n                this.webgl = global_webgl;\r\n            }\r\n            this.underlays_el = dom_1.div({ style });\r\n            this.primary = new CanvasLayer(output_backend, hidpi);\r\n            this.overlays = new CanvasLayer(output_backend, hidpi);\r\n            this.overlays_el = dom_1.div({ style });\r\n            this.events_el = dom_1.div({ class: \"bk-canvas-events\", style });\r\n            const elements = [\r\n                this.underlays_el,\r\n                this.primary.el,\r\n                this.overlays.el,\r\n                this.overlays_el,\r\n                this.events_el,\r\n            ];\r\n            object_1.extend(this.el.style, style);\r\n            dom_1.append(this.el, ...elements);\r\n            logging_1.logger.debug(\"CanvasView initialized\");\r\n        }\r\n        add_underlay(el) {\r\n            this.underlays_el.appendChild(el);\r\n        }\r\n        add_overlay(el) {\r\n            this.overlays_el.appendChild(el);\r\n        }\r\n        add_event(el) {\r\n            this.events_el.appendChild(el);\r\n        }\r\n        get pixel_ratio() {\r\n            return this.primary.pixel_ratio; // XXX: primary\r\n        }\r\n        resize(width, height) {\r\n            this.bbox = new bbox_1.BBox({ left: 0, top: 0, width, height });\r\n            this.primary.resize(width, height);\r\n            this.overlays.resize(width, height);\r\n        }\r\n        prepare_webgl(frame_box) {\r\n            // Prepare WebGL for a drawing pass\r\n            const { webgl } = this;\r\n            if (webgl != null) {\r\n                // Sync canvas size\r\n                const { width, height } = this.bbox;\r\n                webgl.canvas.width = this.pixel_ratio * width;\r\n                webgl.canvas.height = this.pixel_ratio * height;\r\n                const { gl } = webgl;\r\n                // Clipping\r\n                gl.enable(gl.SCISSOR_TEST);\r\n                const [sx, sy, w, h] = frame_box;\r\n                const { xview, yview } = this.bbox;\r\n                const vx = xview.compute(sx);\r\n                const vy = yview.compute(sy + h);\r\n                const ratio = this.pixel_ratio;\r\n                gl.scissor(ratio * vx, ratio * vy, ratio * w, ratio * h); // lower left corner, width, height\r\n                // Setup blending\r\n                gl.enable(gl.BLEND);\r\n                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE); // premultipliedAlpha == true\r\n            }\r\n        }\r\n        clear_webgl() {\r\n            const { webgl } = this;\r\n            if (webgl != null) {\r\n                // Prepare GL for drawing\r\n                const { gl, canvas } = webgl;\r\n                gl.viewport(0, 0, canvas.width, canvas.height);\r\n                gl.clearColor(0, 0, 0, 0);\r\n                gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);\r\n            }\r\n        }\r\n        blit_webgl(ctx) {\r\n            // This should be called when the ctx has no state except the HIDPI transform\r\n            const { webgl } = this;\r\n            if (webgl != null) {\r\n                // Blit gl canvas into the 2D canvas. To do 1-on-1 blitting, we need\r\n                // to remove the hidpi transform, then blit, then restore.\r\n                // ctx.globalCompositeOperation = \"source-over\"  -> OK; is the default\r\n                logging_1.logger.debug('Blitting WebGL canvas');\r\n                ctx.restore();\r\n                ctx.drawImage(webgl.canvas, 0, 0);\r\n                // Set back hidpi transform\r\n                ctx.save();\r\n                if (this.model.hidpi) {\r\n                    const ratio = this.pixel_ratio;\r\n                    ctx.scale(ratio, ratio);\r\n                    ctx.translate(0.5, 0.5);\r\n                }\r\n            }\r\n        }\r\n        compose() {\r\n            const { output_backend, hidpi } = this.model;\r\n            const { width, height } = this.bbox;\r\n            const composite = new CanvasLayer(output_backend, hidpi);\r\n            composite.resize(width, height);\r\n            composite.ctx.drawImage(this.primary.canvas, 0, 0);\r\n            composite.ctx.drawImage(this.overlays.canvas, 0, 0);\r\n            return composite;\r\n        }\r\n        to_blob() {\r\n            return this.compose().to_blob();\r\n        }\r\n    }\r\n    exports.CanvasView = CanvasView;\r\n    CanvasView.__name__ = \"CanvasView\";\r\n    class Canvas extends has_props_1.HasProps {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Canvas() {\r\n            this.prototype.default_view = CanvasView;\r\n            this.internal({\r\n                hidpi: [p.Boolean, true],\r\n                output_backend: [p.OutputBackend, \"canvas\"],\r\n            });\r\n        }\r\n    }\r\n    exports.Canvas = Canvas;\r\n    Canvas.__name__ = \"Canvas\";\r\n    Canvas.init_Canvas();\r\n}\r\n","/* core\\dom_view.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const view_1 = require(71) /* ./view */;\r\n    const dom_1 = require(72) /* ./dom */;\r\n    class DOMView extends view_1.View {\r\n        initialize() {\r\n            super.initialize();\r\n            this.el = this._createElement();\r\n        }\r\n        remove() {\r\n            dom_1.remove(this.el);\r\n            super.remove();\r\n        }\r\n        css_classes() {\r\n            return [];\r\n        }\r\n        render() { }\r\n        renderTo(element) {\r\n            element.appendChild(this.el);\r\n            this.render();\r\n        }\r\n        _createElement() {\r\n            return dom_1.createElement(this.tagName, { class: this.css_classes() });\r\n        }\r\n    }\r\n    exports.DOMView = DOMView;\r\n    DOMView.__name__ = \"DOMView\";\r\n    DOMView.prototype.tagName = \"div\";\r\n}\r\n","/* core\\util\\bbox.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(24) /* ../types */;\r\n    const { min, max } = Math;\r\n    function empty() {\r\n        return {\r\n            x0: Infinity,\r\n            y0: Infinity,\r\n            x1: -Infinity,\r\n            y1: -Infinity,\r\n        };\r\n    }\r\n    exports.empty = empty;\r\n    function positive_x() {\r\n        return {\r\n            x0: Number.MIN_VALUE,\r\n            y0: -Infinity,\r\n            x1: Infinity,\r\n            y1: Infinity,\r\n        };\r\n    }\r\n    exports.positive_x = positive_x;\r\n    function positive_y() {\r\n        return {\r\n            x0: -Infinity,\r\n            y0: Number.MIN_VALUE,\r\n            x1: Infinity,\r\n            y1: Infinity,\r\n        };\r\n    }\r\n    exports.positive_y = positive_y;\r\n    function union(a, b) {\r\n        return {\r\n            x0: min(a.x0, b.x0),\r\n            x1: max(a.x1, b.x1),\r\n            y0: min(a.y0, b.y0),\r\n            y1: max(a.y1, b.y1),\r\n        };\r\n    }\r\n    exports.union = union;\r\n    class BBox {\r\n        constructor(box) {\r\n            if (box == null) {\r\n                this.x0 = 0;\r\n                this.y0 = 0;\r\n                this.x1 = 0;\r\n                this.y1 = 0;\r\n            }\r\n            else if ('x0' in box) {\r\n                const { x0, y0, x1, y1 } = box;\r\n                if (!(x0 <= x1 && y0 <= y1))\r\n                    throw new Error(`invalid bbox {x0: ${x0}, y0: ${y0}, x1: ${x1}, y1: ${y1}}`);\r\n                this.x0 = x0;\r\n                this.y0 = y0;\r\n                this.x1 = x1;\r\n                this.y1 = y1;\r\n            }\r\n            else if (\"x\" in box) {\r\n                const { x, y, width, height } = box;\r\n                if (!(width >= 0 && height >= 0))\r\n                    throw new Error(`invalid bbox {x: ${x}, y: ${y}, width: ${width}, height: ${height}}`);\r\n                this.x0 = x;\r\n                this.y0 = y;\r\n                this.x1 = x + width;\r\n                this.y1 = y + height;\r\n            }\r\n            else {\r\n                let left, right;\r\n                let top, bottom;\r\n                if (\"width\" in box) {\r\n                    if (\"left\" in box) {\r\n                        left = box.left;\r\n                        right = left + box.width;\r\n                    }\r\n                    else if (\"right\" in box) {\r\n                        right = box.right;\r\n                        left = right - box.width;\r\n                    }\r\n                    else {\r\n                        const w2 = box.width / 2;\r\n                        left = box.hcenter - w2;\r\n                        right = box.hcenter + w2;\r\n                    }\r\n                }\r\n                else {\r\n                    left = box.left;\r\n                    right = box.right;\r\n                }\r\n                if (\"height\" in box) {\r\n                    if (\"top\" in box) {\r\n                        top = box.top;\r\n                        bottom = top + box.height;\r\n                    }\r\n                    else if (\"bottom\" in box) {\r\n                        bottom = box.bottom;\r\n                        top = bottom - box.height;\r\n                    }\r\n                    else {\r\n                        const h2 = box.height / 2;\r\n                        top = box.vcenter - h2;\r\n                        bottom = box.vcenter + h2;\r\n                    }\r\n                }\r\n                else {\r\n                    top = box.top;\r\n                    bottom = box.bottom;\r\n                }\r\n                if (!(left <= right && top <= bottom))\r\n                    throw new Error(`invalid bbox {left: ${left}, top: ${top}, right: ${right}, bottom: ${bottom}}`);\r\n                this.x0 = left;\r\n                this.y0 = top;\r\n                this.x1 = right;\r\n                this.y1 = bottom;\r\n            }\r\n        }\r\n        toString() {\r\n            return `BBox({left: ${this.left}, top: ${this.top}, width: ${this.width}, height: ${this.height}})`;\r\n        }\r\n        get left() { return this.x0; }\r\n        get top() { return this.y0; }\r\n        get right() { return this.x1; }\r\n        get bottom() { return this.y1; }\r\n        get p0() { return [this.x0, this.y0]; }\r\n        get p1() { return [this.x1, this.y1]; }\r\n        get x() { return this.x0; }\r\n        get y() { return this.y0; }\r\n        get width() { return this.x1 - this.x0; }\r\n        get height() { return this.y1 - this.y0; }\r\n        get rect() { return { x0: this.x0, y0: this.y0, x1: this.x1, y1: this.y1 }; }\r\n        get box() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }\r\n        get h_range() { return { start: this.x0, end: this.x1 }; }\r\n        get v_range() { return { start: this.y0, end: this.y1 }; }\r\n        get ranges() { return [this.h_range, this.v_range]; }\r\n        get aspect() { return this.width / this.height; }\r\n        get hcenter() { return (this.left + this.right) / 2; }\r\n        get vcenter() { return (this.top + this.bottom) / 2; }\r\n        relativize() {\r\n            const { width, height } = this;\r\n            return new BBox({ x: 0, y: 0, width, height });\r\n        }\r\n        contains(x, y) {\r\n            return x >= this.x0 && x <= this.x1 && y >= this.y0 && y <= this.y1;\r\n        }\r\n        clip(x, y) {\r\n            if (x < this.x0)\r\n                x = this.x0;\r\n            else if (x > this.x1)\r\n                x = this.x1;\r\n            if (y < this.y0)\r\n                y = this.y0;\r\n            else if (y > this.y1)\r\n                y = this.y1;\r\n            return [x, y];\r\n        }\r\n        union(that) {\r\n            return new BBox({\r\n                x0: min(this.x0, that.x0),\r\n                y0: min(this.y0, that.y0),\r\n                x1: max(this.x1, that.x1),\r\n                y1: max(this.y1, that.y1),\r\n            });\r\n        }\r\n        equals(that) {\r\n            return this.x0 == that.x0 && this.y0 == that.y0 && this.x1 == that.x1 && this.y1 == that.y1;\r\n        }\r\n        get xview() {\r\n            return {\r\n                compute: (x) => {\r\n                    return this.left + x;\r\n                },\r\n                v_compute: (xx) => {\r\n                    const _xx = new types_1.NumberArray(xx.length);\r\n                    const left = this.left;\r\n                    for (let i = 0; i < xx.length; i++) {\r\n                        _xx[i] = left + xx[i];\r\n                    }\r\n                    return _xx;\r\n                },\r\n            };\r\n        }\r\n        get yview() {\r\n            return {\r\n                compute: (y) => {\r\n                    return this.bottom - y;\r\n                },\r\n                v_compute: (yy) => {\r\n                    const _yy = new types_1.NumberArray(yy.length);\r\n                    const bottom = this.bottom;\r\n                    for (let i = 0; i < yy.length; i++) {\r\n                        _yy[i] = bottom - yy[i];\r\n                    }\r\n                    return _yy;\r\n                },\r\n            };\r\n        }\r\n    }\r\n    exports.BBox = BBox;\r\n    BBox.__name__ = \"BBox\";\r\n}\r\n","/* core\\util\\canvas.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function fixup_line_dash(ctx) {\r\n        if (typeof ctx.lineDash === \"undefined\") {\r\n            Object.defineProperty(ctx, \"lineDash\", {\r\n                get: () => ctx.getLineDash(),\r\n                set: (segments) => ctx.setLineDash(segments),\r\n            });\r\n        }\r\n    }\r\n    function fixup_image_smoothing(ctx) {\r\n        ctx.setImageSmoothingEnabled = (value) => {\r\n            ctx.imageSmoothingEnabled = value;\r\n            ctx.mozImageSmoothingEnabled = value;\r\n            ctx.oImageSmoothingEnabled = value;\r\n            ctx.webkitImageSmoothingEnabled = value;\r\n            ctx.msImageSmoothingEnabled = value;\r\n        };\r\n        ctx.getImageSmoothingEnabled = () => {\r\n            const val = ctx.imageSmoothingEnabled;\r\n            return val != null ? val : true;\r\n        };\r\n    }\r\n    function fixup_measure_text(ctx) {\r\n        if (ctx.measureText && ctx.html5MeasureText == null) {\r\n            ctx.html5MeasureText = ctx.measureText;\r\n            ctx.measureText = (text) => {\r\n                const textMetrics = ctx.html5MeasureText(text);\r\n                // fake it til you make it\r\n                textMetrics.ascent = ctx.html5MeasureText(\"m\").width * 1.6;\r\n                return textMetrics;\r\n            };\r\n        }\r\n    }\r\n    function fixup_ellipse(ctx) {\r\n        // implementing the ctx.ellipse function with bezier curves\r\n        // we don't implement the startAngle, endAngle and anticlockwise arguments.\r\n        function ellipse_bezier(x, y, radiusX, radiusY, rotation, _startAngle, _endAngle, anticlockwise = false) {\r\n            const c = 0.551784; // see http://www.tinaja.com/glib/ellipse4.pdf\r\n            ctx.translate(x, y);\r\n            ctx.rotate(rotation);\r\n            let rx = radiusX;\r\n            let ry = radiusY;\r\n            if (anticlockwise) {\r\n                rx = -radiusX;\r\n                ry = -radiusY;\r\n            }\r\n            ctx.moveTo(-rx, 0); // start point of first curve\r\n            ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);\r\n            ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);\r\n            ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);\r\n            ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);\r\n            ctx.rotate(-rotation);\r\n            ctx.translate(-x, -y);\r\n        }\r\n        if (!ctx.ellipse)\r\n            ctx.ellipse = ellipse_bezier;\r\n    }\r\n    function fixup_ctx(ctx) {\r\n        fixup_line_dash(ctx);\r\n        fixup_image_smoothing(ctx);\r\n        fixup_measure_text(ctx);\r\n        fixup_ellipse(ctx);\r\n    }\r\n    exports.fixup_ctx = fixup_ctx;\r\n}\r\n","/* model.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const has_props_1 = require(14) /* ./core/has_props */;\r\n    const p = tslib_1.__importStar(require(18) /* ./core/properties */);\r\n    const types_1 = require(8) /* ./core/util/types */;\r\n    const object_1 = require(13) /* ./core/util/object */;\r\n    const logging_1 = require(19) /* ./core/logging */;\r\n    class Model extends has_props_1.HasProps {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Model() {\r\n            this.define({\r\n                tags: [p.Array, []],\r\n                name: [p.String],\r\n                js_property_callbacks: [p.Any, {}],\r\n                js_event_callbacks: [p.Any, {}],\r\n                subscribed_events: [p.Array, []],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._js_callbacks = new Map();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this._update_property_callbacks();\r\n            this.connect(this.properties.js_property_callbacks.change, () => this._update_property_callbacks());\r\n            this.connect(this.properties.js_event_callbacks.change, () => this._update_event_callbacks());\r\n            this.connect(this.properties.subscribed_events.change, () => this._update_event_callbacks());\r\n        }\r\n        /*protected*/ _process_event(event) {\r\n            for (const callback of this.js_event_callbacks[event.event_name] || [])\r\n                callback.execute(event);\r\n            if (this.document != null && this.subscribed_events.some((m) => m == event.event_name))\r\n                this.document.event_manager.send_event(event);\r\n        }\r\n        trigger_event(event) {\r\n            if (this.document != null) {\r\n                event.origin = this;\r\n                this.document.event_manager.trigger(event);\r\n            }\r\n        }\r\n        _update_event_callbacks() {\r\n            if (this.document == null) {\r\n                // File an issue: SidePanel in particular seems to have this issue\r\n                logging_1.logger.warn('WARNING: Document not defined for updating event callbacks');\r\n                return;\r\n            }\r\n            this.document.event_manager.subscribed_models.add(this);\r\n        }\r\n        _update_property_callbacks() {\r\n            const signal_for = (event) => {\r\n                const [evt, attr = null] = event.split(\":\");\r\n                return attr != null ? this.properties[attr][evt] : this[evt];\r\n            };\r\n            for (const [event, callbacks] of this._js_callbacks) {\r\n                const signal = signal_for(event);\r\n                for (const cb of callbacks)\r\n                    this.disconnect(signal, cb);\r\n            }\r\n            this._js_callbacks.clear();\r\n            for (const [event, callbacks] of object_1.entries(this.js_property_callbacks)) {\r\n                const wrappers = callbacks.map((cb) => () => cb.execute(this));\r\n                this._js_callbacks.set(event, wrappers);\r\n                const signal = signal_for(event);\r\n                for (const cb of wrappers)\r\n                    this.connect(signal, cb);\r\n            }\r\n        }\r\n        _doc_attached() {\r\n            if (!object_1.isEmpty(this.js_event_callbacks) || this.subscribed_events.length != 0)\r\n                this._update_event_callbacks();\r\n        }\r\n        _doc_detached() {\r\n            this.document.event_manager.subscribed_models.delete(this);\r\n        }\r\n        select(selector) {\r\n            if (types_1.isString(selector))\r\n                return [...this.references()].filter((ref) => ref instanceof Model && ref.name === selector);\r\n            else if (selector.prototype instanceof has_props_1.HasProps)\r\n                return [...this.references()].filter((ref) => ref instanceof selector);\r\n            else\r\n                throw new Error(\"invalid selector\");\r\n        }\r\n        select_one(selector) {\r\n            const result = this.select(selector);\r\n            switch (result.length) {\r\n                case 0:\r\n                    return null;\r\n                case 1:\r\n                    return result[0];\r\n                default:\r\n                    throw new Error(\"found more than one object matching given selector\");\r\n            }\r\n        }\r\n    }\r\n    exports.Model = Model;\r\n    Model.__name__ = \"Model\";\r\n    Model.init_Model();\r\n}\r\n","/* models\\canvas\\coordinates.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class CoordinateTransform {\r\n        constructor(x_scale, y_scale) {\r\n            this.x_scale = x_scale;\r\n            this.y_scale = y_scale;\r\n            this.x_range = this.x_scale.source_range;\r\n            this.y_range = this.y_scale.source_range;\r\n            this.ranges = [this.x_range, this.y_range];\r\n            this.scales = [this.x_scale, this.y_scale];\r\n        }\r\n        map_to_screen(xs, ys) {\r\n            const sxs = this.x_scale.v_compute(xs);\r\n            const sys = this.y_scale.v_compute(ys);\r\n            return [sxs, sys];\r\n        }\r\n        map_from_screen(sxs, sys) {\r\n            const xs = this.x_scale.v_invert(sxs);\r\n            const ys = this.y_scale.v_invert(sys);\r\n            return [xs, ys];\r\n        }\r\n    }\r\n    exports.CoordinateTransform = CoordinateTransform;\r\n    CoordinateTransform.__name__ = \"CoordinateTransform\";\r\n}\r\n","/* models\\annotations\\arrow.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const arrow_head_1 = require(84) /* ./arrow_head */;\r\n    const column_data_source_1 = require(85) /* ../sources/column_data_source */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const math_1 = require(10) /* ../../core/util/math */;\r\n    class ArrowView extends annotation_1.AnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n            if (this.model.source == null)\r\n                this.model.source = new column_data_source_1.ColumnDataSource();\r\n            this.set_data(this.model.source);\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.set_data(this.model.source));\r\n            this.connect(this.model.source.streaming, () => this.set_data(this.model.source));\r\n            this.connect(this.model.source.patching, () => this.set_data(this.model.source));\r\n            this.connect(this.model.source.change, () => this.set_data(this.model.source));\r\n        }\r\n        set_data(source) {\r\n            super.set_data(source);\r\n            this.visuals.warm_cache(source);\r\n            this.plot_view.request_render();\r\n        }\r\n        _map_data() {\r\n            const { frame } = this.plot_view;\r\n            let sx_start, sy_start;\r\n            if (this.model.start_units == 'data') {\r\n                sx_start = this.coordinates.x_scale.v_compute(this._x_start);\r\n                sy_start = this.coordinates.y_scale.v_compute(this._y_start);\r\n            }\r\n            else {\r\n                sx_start = frame.xview.v_compute(this._x_start);\r\n                sy_start = frame.yview.v_compute(this._y_start);\r\n            }\r\n            let sx_end, sy_end;\r\n            if (this.model.end_units == 'data') {\r\n                sx_end = this.coordinates.x_scale.v_compute(this._x_end);\r\n                sy_end = this.coordinates.y_scale.v_compute(this._y_end);\r\n            }\r\n            else {\r\n                sx_end = frame.xview.v_compute(this._x_end);\r\n                sy_end = frame.yview.v_compute(this._y_end);\r\n            }\r\n            return [[sx_start, sy_start], [sx_end, sy_end]];\r\n        }\r\n        _render() {\r\n            const { ctx } = this.layer;\r\n            ctx.save();\r\n            // Order in this function is important. First we draw all the arrow heads.\r\n            const [start, end] = this._map_data();\r\n            if (this.model.end != null)\r\n                this._arrow_head(ctx, \"render\", this.model.end, start, end);\r\n            if (this.model.start != null)\r\n                this._arrow_head(ctx, \"render\", this.model.start, end, start);\r\n            // Next we call .clip on all the arrow heads, inside an initial canvas sized\r\n            // rect, to create an \"inverted\" clip region for the arrow heads\r\n            ctx.beginPath();\r\n            const { x, y, width, height } = this.plot_view.frame.bbox;\r\n            ctx.rect(x, y, width, height);\r\n            if (this.model.end != null)\r\n                this._arrow_head(ctx, \"clip\", this.model.end, start, end);\r\n            if (this.model.start != null)\r\n                this._arrow_head(ctx, \"clip\", this.model.start, end, start);\r\n            ctx.closePath();\r\n            ctx.clip();\r\n            // Finally we draw the arrow body, with the clipping regions set up. This prevents\r\n            // \"fat\" arrows from overlapping the arrow head in a bad way.\r\n            this._arrow_body(ctx, start, end);\r\n            ctx.restore();\r\n        }\r\n        _arrow_head(ctx, action, head, start, end) {\r\n            for (let i = 0, _end = this._x_start.length; i < _end; i++) {\r\n                // arrow head runs orthogonal to arrow body\r\n                const angle = Math.PI / 2 + math_1.atan2([start[0][i], start[1][i]], [end[0][i], end[1][i]]);\r\n                ctx.save();\r\n                ctx.translate(end[0][i], end[1][i]);\r\n                ctx.rotate(angle);\r\n                if (action == \"render\")\r\n                    head.render(ctx, i);\r\n                else if (action == \"clip\")\r\n                    head.clip(ctx, i);\r\n                ctx.restore();\r\n            }\r\n        }\r\n        _arrow_body(ctx, start, end) {\r\n            if (!this.visuals.line.doit)\r\n                return;\r\n            for (let i = 0, n = this._x_start.length; i < n; i++) {\r\n                this.visuals.line.set_vectorize(ctx, i);\r\n                ctx.beginPath();\r\n                ctx.moveTo(start[0][i], start[1][i]);\r\n                ctx.lineTo(end[0][i], end[1][i]);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n    }\r\n    exports.ArrowView = ArrowView;\r\n    ArrowView.__name__ = \"ArrowView\";\r\n    class Arrow extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Arrow() {\r\n            this.prototype.default_view = ArrowView;\r\n            this.mixins(property_mixins_1.LineVector);\r\n            this.define({\r\n                x_start: [p.NumberSpec],\r\n                y_start: [p.NumberSpec],\r\n                start_units: [p.SpatialUnits, 'data'],\r\n                start: [p.Instance, null],\r\n                x_end: [p.NumberSpec],\r\n                y_end: [p.NumberSpec],\r\n                end_units: [p.SpatialUnits, 'data'],\r\n                end: [p.Instance, () => new arrow_head_1.OpenHead({})],\r\n                source: [p.Instance],\r\n            });\r\n        }\r\n    }\r\n    exports.Arrow = Arrow;\r\n    Arrow.__name__ = \"Arrow\";\r\n    Arrow.init_Arrow();\r\n}\r\n","/* models\\annotations\\arrow_head.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const visuals_1 = require(74) /* ../../core/visuals */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class ArrowHead extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ArrowHead() {\r\n            this.define({\r\n                size: [p.Number, 25],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.visuals = new visuals_1.Visuals(this);\r\n        }\r\n    }\r\n    exports.ArrowHead = ArrowHead;\r\n    ArrowHead.__name__ = \"ArrowHead\";\r\n    ArrowHead.init_ArrowHead();\r\n    class OpenHead extends ArrowHead {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_OpenHead() {\r\n            this.mixins(property_mixins_1.LineVector);\r\n        }\r\n        clip(ctx, i) {\r\n            // This method should not begin or close a path\r\n            this.visuals.line.set_vectorize(ctx, i);\r\n            ctx.moveTo(0.5 * this.size, this.size);\r\n            ctx.lineTo(0.5 * this.size, -2);\r\n            ctx.lineTo(-0.5 * this.size, -2);\r\n            ctx.lineTo(-0.5 * this.size, this.size);\r\n            ctx.lineTo(0, 0);\r\n            ctx.lineTo(0.5 * this.size, this.size);\r\n        }\r\n        render(ctx, i) {\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_vectorize(ctx, i);\r\n                ctx.beginPath();\r\n                ctx.moveTo(0.5 * this.size, this.size);\r\n                ctx.lineTo(0, 0);\r\n                ctx.lineTo(-0.5 * this.size, this.size);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n    }\r\n    exports.OpenHead = OpenHead;\r\n    OpenHead.__name__ = \"OpenHead\";\r\n    OpenHead.init_OpenHead();\r\n    class NormalHead extends ArrowHead {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_NormalHead() {\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.override({\r\n                fill_color: 'black',\r\n            });\r\n        }\r\n        clip(ctx, i) {\r\n            // This method should not begin or close a path\r\n            this.visuals.line.set_vectorize(ctx, i);\r\n            ctx.moveTo(0.5 * this.size, this.size);\r\n            ctx.lineTo(0.5 * this.size, -2);\r\n            ctx.lineTo(-0.5 * this.size, -2);\r\n            ctx.lineTo(-0.5 * this.size, this.size);\r\n            ctx.lineTo(0.5 * this.size, this.size);\r\n        }\r\n        render(ctx, i) {\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_vectorize(ctx, i);\r\n                this._normal(ctx, i);\r\n                ctx.fill();\r\n            }\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_vectorize(ctx, i);\r\n                this._normal(ctx, i);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        _normal(ctx, _i) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(0.5 * this.size, this.size);\r\n            ctx.lineTo(0, 0);\r\n            ctx.lineTo(-0.5 * this.size, this.size);\r\n            ctx.closePath();\r\n        }\r\n    }\r\n    exports.NormalHead = NormalHead;\r\n    NormalHead.__name__ = \"NormalHead\";\r\n    NormalHead.init_NormalHead();\r\n    class VeeHead extends ArrowHead {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_VeeHead() {\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.override({\r\n                fill_color: 'black',\r\n            });\r\n        }\r\n        clip(ctx, i) {\r\n            // This method should not begin or close a path\r\n            this.visuals.line.set_vectorize(ctx, i);\r\n            ctx.moveTo(0.5 * this.size, this.size);\r\n            ctx.lineTo(0.5 * this.size, -2);\r\n            ctx.lineTo(-0.5 * this.size, -2);\r\n            ctx.lineTo(-0.5 * this.size, this.size);\r\n            ctx.lineTo(0, 0.5 * this.size);\r\n            ctx.lineTo(0.5 * this.size, this.size);\r\n        }\r\n        render(ctx, i) {\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_vectorize(ctx, i);\r\n                this._vee(ctx, i);\r\n                ctx.fill();\r\n            }\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_vectorize(ctx, i);\r\n                this._vee(ctx, i);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        _vee(ctx, _i) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(0.5 * this.size, this.size);\r\n            ctx.lineTo(0, 0);\r\n            ctx.lineTo(-0.5 * this.size, this.size);\r\n            ctx.lineTo(0, 0.5 * this.size);\r\n            ctx.closePath();\r\n        }\r\n    }\r\n    exports.VeeHead = VeeHead;\r\n    VeeHead.__name__ = \"VeeHead\";\r\n    VeeHead.init_VeeHead();\r\n    class TeeHead extends ArrowHead {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_TeeHead() {\r\n            this.mixins(property_mixins_1.LineVector);\r\n        }\r\n        render(ctx, i) {\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_vectorize(ctx, i);\r\n                ctx.beginPath();\r\n                ctx.moveTo(0.5 * this.size, 0);\r\n                ctx.lineTo(-0.5 * this.size, 0);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        clip(_ctx, _i) { }\r\n    }\r\n    exports.TeeHead = TeeHead;\r\n    TeeHead.__name__ = \"TeeHead\";\r\n    TeeHead.init_TeeHead();\r\n}\r\n","/* models\\sources\\column_data_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const columnar_data_source_1 = require(86) /* ./columnar_data_source */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const typed_array = tslib_1.__importStar(require(119) /* ../../core/util/typed_array */);\r\n    const set_1 = require(120) /* ../../core/util/set */;\r\n    const events_1 = require(121) /* ../../document/events */;\r\n    //exported for testing\r\n    function stream_to_column(col, new_col, rollover) {\r\n        if (types_1.isArray(col)) {\r\n            const result = col.concat(new_col);\r\n            if (rollover != null && result.length > rollover)\r\n                return result.slice(-rollover);\r\n            else\r\n                return result;\r\n        }\r\n        else if (types_1.isTypedArray(col)) {\r\n            const total_len = col.length + new_col.length;\r\n            // handle rollover case for typed arrays\r\n            if (rollover != null && total_len > rollover) {\r\n                const start = total_len - rollover;\r\n                const end = col.length;\r\n                // resize col if it is shorter than the rollover length\r\n                let result;\r\n                if (col.length < rollover) {\r\n                    result = new col.constructor(rollover);\r\n                    result.set(col, 0);\r\n                }\r\n                else\r\n                    result = col;\r\n                // shift values in original col to accommodate new_col\r\n                for (let i = start, endi = end; i < endi; i++) {\r\n                    result[i - start] = result[i];\r\n                }\r\n                // update end values in col with new_col\r\n                for (let i = 0, endi = new_col.length; i < endi; i++) {\r\n                    result[i + (end - start)] = new_col[i];\r\n                }\r\n                return result;\r\n            }\r\n            else {\r\n                const tmp = new col.constructor(new_col);\r\n                return typed_array.concat(col, tmp);\r\n            }\r\n        }\r\n        else\r\n            throw new Error(\"unsupported array types\");\r\n    }\r\n    exports.stream_to_column = stream_to_column;\r\n    // exported for testing\r\n    function slice(ind, length) {\r\n        let start, step, stop;\r\n        if (types_1.isNumber(ind)) {\r\n            start = ind;\r\n            stop = ind + 1;\r\n            step = 1;\r\n        }\r\n        else {\r\n            start = ind.start != null ? ind.start : 0;\r\n            stop = ind.stop != null ? ind.stop : length;\r\n            step = ind.step != null ? ind.step : 1;\r\n        }\r\n        return [start, stop, step];\r\n    }\r\n    exports.slice = slice;\r\n    // exported for testing\r\n    function patch_to_column(col, patch) {\r\n        const patched = new Set();\r\n        let patched_range = false;\r\n        for (const [ind, val] of patch) {\r\n            // make the single index case look like the length-3 multi-index case\r\n            let shape;\r\n            let item;\r\n            let index;\r\n            let value;\r\n            if (types_1.isArray(ind)) {\r\n                const [i] = ind;\r\n                patched.add(i);\r\n                shape = col[i].shape;\r\n                item = col[i];\r\n                value = val;\r\n                // this is basically like NumPy's \"newaxis\", inserting an empty dimension\r\n                // makes length 2 and 3 multi-index cases uniform, so that the same code\r\n                // can handle both\r\n                if (ind.length === 2) {\r\n                    shape = [1, shape[0]];\r\n                    index = [ind[0], 0, ind[1]];\r\n                }\r\n                else\r\n                    index = ind;\r\n            }\r\n            else {\r\n                if (types_1.isNumber(ind)) {\r\n                    value = [val];\r\n                    patched.add(ind);\r\n                }\r\n                else {\r\n                    value = val;\r\n                    patched_range = true;\r\n                }\r\n                index = [0, 0, ind];\r\n                shape = [1, col.length];\r\n                item = col;\r\n            }\r\n            // now this one nested loop handles all cases\r\n            let flat_index = 0;\r\n            const [istart, istop, istep] = slice(index[1], shape[0]);\r\n            const [jstart, jstop, jstep] = slice(index[2], shape[1]);\r\n            for (let i = istart; i < istop; i += istep) {\r\n                for (let j = jstart; j < jstop; j += jstep) {\r\n                    if (patched_range) {\r\n                        patched.add(j);\r\n                    }\r\n                    item[i * shape[1] + j] = value[flat_index];\r\n                    flat_index++;\r\n                }\r\n            }\r\n        }\r\n        return patched;\r\n    }\r\n    exports.patch_to_column = patch_to_column;\r\n    class ColumnDataSource extends columnar_data_source_1.ColumnarDataSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ColumnDataSource() {\r\n            this.define({\r\n                data: [p.Any, {}],\r\n            });\r\n        }\r\n        stream(new_data, rollover, setter_id) {\r\n            const { data } = this;\r\n            for (const [name, new_column] of object_1.entries(new_data)) {\r\n                data[name] = stream_to_column(data[name], new_column, rollover);\r\n            }\r\n            this.setv({ data }, { silent: true });\r\n            this.streaming.emit();\r\n            if (this.document != null) {\r\n                const hint = new events_1.ColumnsStreamedEvent(this.document, this.ref(), new_data, rollover);\r\n                this.document._notify_change(this, 'data', null, null, { setter_id, hint });\r\n            }\r\n        }\r\n        patch(patches, setter_id) {\r\n            const { data } = this;\r\n            let patched = new Set();\r\n            for (const [column, patch] of object_1.entries(patches)) {\r\n                patched = set_1.union(patched, patch_to_column(data[column], patch)); // XXX\r\n            }\r\n            this.setv({ data }, { silent: true });\r\n            this.patching.emit([...patched]);\r\n            if (this.document != null) {\r\n                const hint = new events_1.ColumnsPatchedEvent(this.document, this.ref(), patches);\r\n                this.document._notify_change(this, 'data', null, null, { setter_id, hint });\r\n            }\r\n        }\r\n    }\r\n    exports.ColumnDataSource = ColumnDataSource;\r\n    ColumnDataSource.__name__ = \"ColumnDataSource\";\r\n    ColumnDataSource.init_ColumnDataSource();\r\n}\r\n","/* models\\sources\\columnar_data_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const data_source_1 = require(87) /* ./data_source */;\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const selection_manager_1 = require(89) /* ../../core/selection_manager */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    const interaction_policy_1 = require(118) /* ../selections/interaction_policy */;\r\n    class ColumnarDataSource extends data_source_1.DataSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        get_array(key) {\r\n            let column = this.data[key];\r\n            if (column == null)\r\n                this.data[key] = column = [];\r\n            else if (!types_1.isArray(column))\r\n                this.data[key] = column = Array.from(column);\r\n            return column;\r\n        }\r\n        static init_ColumnarDataSource() {\r\n            this.define({\r\n                selection_policy: [p.Instance, () => new interaction_policy_1.UnionRenderers()],\r\n            });\r\n            this.internal({\r\n                selection_manager: [p.Instance, (self) => new selection_manager_1.SelectionManager({ source: self })],\r\n                inspected: [p.Instance, () => new selection_1.Selection()],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._select = new signaling_1.Signal0(this, \"select\");\r\n            this.inspect = new signaling_1.Signal(this, \"inspect\"); // XXX: <[indices, tool, renderer-view, source, data], this>\r\n            this.streaming = new signaling_1.Signal0(this, \"streaming\");\r\n            this.patching = new signaling_1.Signal(this, \"patching\");\r\n        }\r\n        get_column(colname) {\r\n            const column = this.data[colname];\r\n            return column != null ? column : null;\r\n        }\r\n        columns() {\r\n            // return the column names in this data source\r\n            return object_1.keys(this.data);\r\n        }\r\n        get_length(soft = true) {\r\n            const lengths = array_1.uniq(object_1.values(this.data).map((v) => v.length));\r\n            switch (lengths.length) {\r\n                case 0: {\r\n                    return null; // XXX: don't guess, treat on case-by-case basis\r\n                }\r\n                case 1: {\r\n                    return lengths[0];\r\n                }\r\n                default: {\r\n                    const msg = \"data source has columns of inconsistent lengths\";\r\n                    if (soft) {\r\n                        logging_1.logger.warn(msg);\r\n                        return lengths.sort()[0];\r\n                    }\r\n                    else\r\n                        throw new Error(msg);\r\n                }\r\n            }\r\n        }\r\n        get length() {\r\n            var _a;\r\n            return (_a = this.get_length()) !== null && _a !== void 0 ? _a : 0;\r\n        }\r\n        clear() {\r\n            const empty = {};\r\n            for (const col of this.columns()) {\r\n                empty[col] = new this.data[col].constructor(0);\r\n            }\r\n            this.data = empty;\r\n        }\r\n    }\r\n    exports.ColumnarDataSource = ColumnarDataSource;\r\n    ColumnarDataSource.__name__ = \"ColumnarDataSource\";\r\n    ColumnarDataSource.init_ColumnarDataSource();\r\n}\r\n","/* models\\sources\\data_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class DataSource extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_DataSource() {\r\n            this.define({\r\n                selected: [p.Instance, () => new selection_1.Selection()],\r\n            });\r\n        }\r\n    }\r\n    exports.DataSource = DataSource;\r\n    DataSource.__name__ = \"DataSource\";\r\n    DataSource.init_DataSource();\r\n}\r\n","/* models\\selections\\selection.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    class Selection extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        get_view() {\r\n            return this.view;\r\n        }\r\n        static init_Selection() {\r\n            this.define({\r\n                indices: [p.Array, []],\r\n                line_indices: [p.Array, []],\r\n                multiline_indices: [p.Any, {}],\r\n            });\r\n            this.internal({\r\n                selected_glyphs: [p.Array, []],\r\n                view: [p.Any],\r\n                image_indices: [p.Array, []],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n        }\r\n        get selected_glyph() {\r\n            return this.selected_glyphs.length > 0 ? this.selected_glyphs[0] : null;\r\n        }\r\n        add_to_selected_glyphs(glyph) {\r\n            this.selected_glyphs.push(glyph);\r\n        }\r\n        update(selection, _final = true, mode = \"replace\") {\r\n            switch (mode) {\r\n                case \"replace\": {\r\n                    this.indices = selection.indices;\r\n                    this.line_indices = selection.line_indices;\r\n                    this.selected_glyphs = selection.selected_glyphs;\r\n                    this.view = selection.view;\r\n                    this.multiline_indices = selection.multiline_indices;\r\n                    this.image_indices = selection.image_indices;\r\n                    break;\r\n                }\r\n                case \"append\": {\r\n                    this.update_through_union(selection);\r\n                    break;\r\n                }\r\n                case \"intersect\": {\r\n                    this.update_through_intersection(selection);\r\n                    break;\r\n                }\r\n                case \"subtract\": {\r\n                    this.update_through_subtraction(selection);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        clear() {\r\n            this.indices = [];\r\n            this.line_indices = [];\r\n            this.multiline_indices = {};\r\n            this.view = null;\r\n            this.selected_glyphs = [];\r\n        }\r\n        is_empty() {\r\n            return this.indices.length == 0 && this.line_indices.length == 0 && this.image_indices.length == 0;\r\n        }\r\n        update_through_union(other) {\r\n            this.indices = array_1.union(this.indices, other.indices);\r\n            this.selected_glyphs = array_1.union(other.selected_glyphs, this.selected_glyphs);\r\n            this.line_indices = array_1.union(other.line_indices, this.line_indices);\r\n            this.view = other.view;\r\n            this.multiline_indices = object_1.merge(other.multiline_indices, this.multiline_indices);\r\n        }\r\n        update_through_intersection(other) {\r\n            this.indices = array_1.intersection(this.indices, other.indices);\r\n            // TODO: think through and fix any logic below\r\n            this.selected_glyphs = array_1.union(other.selected_glyphs, this.selected_glyphs);\r\n            this.line_indices = array_1.union(other.line_indices, this.line_indices);\r\n            this.view = other.view;\r\n            this.multiline_indices = object_1.merge(other.multiline_indices, this.multiline_indices);\r\n        }\r\n        update_through_subtraction(other) {\r\n            this.indices = array_1.difference(this.indices, other.indices);\r\n            // TODO: think through and fix any logic below\r\n            this.selected_glyphs = array_1.union(other.selected_glyphs, this.selected_glyphs);\r\n            this.line_indices = array_1.union(other.line_indices, this.line_indices);\r\n            this.view = other.view;\r\n            this.multiline_indices = object_1.merge(other.multiline_indices, this.multiline_indices);\r\n        }\r\n    }\r\n    exports.Selection = Selection;\r\n    Selection.__name__ = \"Selection\";\r\n    Selection.init_Selection();\r\n}\r\n","/* core\\selection_manager.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const has_props_1 = require(14) /* ./has_props */;\r\n    const selection_1 = require(88) /* ../models/selections/selection */;\r\n    const glyph_renderer_1 = require(90) /* ../models/renderers/glyph_renderer */;\r\n    const graph_renderer_1 = require(116) /* ../models/renderers/graph_renderer */;\r\n    const p = tslib_1.__importStar(require(18) /* ./properties */);\r\n    class SelectionManager extends has_props_1.HasProps {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.inspectors = new Map();\r\n        }\r\n        static init_SelectionManager() {\r\n            this.internal({\r\n                source: [p.Any],\r\n            });\r\n        }\r\n        select(renderer_views, geometry, final, mode = \"replace\") {\r\n            // divide renderers into glyph_renderers or graph_renderers\r\n            const glyph_renderer_views = [];\r\n            const graph_renderer_views = [];\r\n            for (const r of renderer_views) {\r\n                if (r instanceof glyph_renderer_1.GlyphRendererView)\r\n                    glyph_renderer_views.push(r);\r\n                else if (r instanceof graph_renderer_1.GraphRendererView)\r\n                    graph_renderer_views.push(r);\r\n            }\r\n            let did_hit = false;\r\n            // graph renderer case\r\n            for (const r of graph_renderer_views) {\r\n                const hit_test_result = r.model.selection_policy.hit_test(geometry, r);\r\n                did_hit = did_hit || r.model.selection_policy.do_selection(hit_test_result, r.model, final, mode);\r\n            }\r\n            // glyph renderers\r\n            if (glyph_renderer_views.length > 0) {\r\n                const hit_test_result = this.source.selection_policy.hit_test(geometry, glyph_renderer_views);\r\n                did_hit = did_hit || this.source.selection_policy.do_selection(hit_test_result, this.source, final, mode);\r\n            }\r\n            return did_hit;\r\n        }\r\n        inspect(renderer_view, geometry) {\r\n            let did_hit = false;\r\n            if (renderer_view instanceof glyph_renderer_1.GlyphRendererView) {\r\n                const hit_test_result = renderer_view.hit_test(geometry);\r\n                if (hit_test_result != null) {\r\n                    did_hit = !hit_test_result.is_empty();\r\n                    const inspection = this.get_or_create_inspector(renderer_view.model);\r\n                    inspection.update(hit_test_result, true, \"replace\");\r\n                    this.source.setv({ inspected: inspection }, { silent: true });\r\n                    this.source.inspect.emit([renderer_view, { geometry }]);\r\n                }\r\n            }\r\n            else if (renderer_view instanceof graph_renderer_1.GraphRendererView) {\r\n                const hit_test_result = renderer_view.model.inspection_policy.hit_test(geometry, renderer_view);\r\n                did_hit = did_hit || renderer_view.model.inspection_policy.do_inspection(hit_test_result, geometry, renderer_view, false, \"replace\");\r\n            }\r\n            return did_hit;\r\n        }\r\n        clear(rview) {\r\n            this.source.selected.clear();\r\n            if (rview != null)\r\n                this.get_or_create_inspector(rview.model).clear();\r\n        }\r\n        get_or_create_inspector(renderer) {\r\n            let selection = this.inspectors.get(renderer);\r\n            if (selection == null) {\r\n                selection = new selection_1.Selection();\r\n                this.inspectors.set(renderer, selection);\r\n            }\r\n            return selection;\r\n        }\r\n    }\r\n    exports.SelectionManager = SelectionManager;\r\n    SelectionManager.__name__ = \"SelectionManager\";\r\n    SelectionManager.init_SelectionManager();\r\n}\r\n","/* models\\renderers\\glyph_renderer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const data_renderer_1 = require(91) /* ./data_renderer */;\r\n    const line_1 = require(92) /* ../glyphs/line */;\r\n    const patch_1 = require(110) /* ../glyphs/patch */;\r\n    const harea_1 = require(111) /* ../glyphs/harea */;\r\n    const varea_1 = require(113) /* ../glyphs/varea */;\r\n    const cds_view_1 = require(114) /* ../sources/cds_view */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const build_views_1 = require(115) /* ../../core/build_views */;\r\n    const factor_range_1 = require(98) /* ../ranges/factor_range */;\r\n    const selection_defaults = {\r\n        fill: {},\r\n        line: {},\r\n    };\r\n    const decimated_defaults = {\r\n        fill: { fill_alpha: 0.3, fill_color: \"grey\" },\r\n        line: { line_alpha: 0.3, line_color: \"grey\" },\r\n    };\r\n    const nonselection_defaults = {\r\n        fill: { fill_alpha: 0.2 },\r\n        line: {},\r\n    };\r\n    class GlyphRendererView extends data_renderer_1.DataRendererView {\r\n        async lazy_initialize() {\r\n            await super.lazy_initialize();\r\n            const base_glyph = this.model.glyph;\r\n            const has_fill = array_1.includes(base_glyph._mixins, \"fill\");\r\n            const has_line = array_1.includes(base_glyph._mixins, \"line\");\r\n            const glyph_attrs = object_1.clone(base_glyph.attributes);\r\n            delete glyph_attrs.id;\r\n            function mk_glyph(defaults) {\r\n                const attrs = object_1.clone(glyph_attrs);\r\n                if (has_fill)\r\n                    object_1.extend(attrs, defaults.fill);\r\n                if (has_line)\r\n                    object_1.extend(attrs, defaults.line);\r\n                return new base_glyph.constructor(attrs);\r\n            }\r\n            this.glyph = await this.build_glyph_view(base_glyph);\r\n            let { selection_glyph } = this.model;\r\n            if (selection_glyph == null)\r\n                selection_glyph = mk_glyph({ fill: {}, line: {} });\r\n            else if (selection_glyph === \"auto\")\r\n                selection_glyph = mk_glyph(selection_defaults);\r\n            this.selection_glyph = await this.build_glyph_view(selection_glyph);\r\n            let { nonselection_glyph } = this.model;\r\n            if ((nonselection_glyph == null))\r\n                nonselection_glyph = mk_glyph({ fill: {}, line: {} });\r\n            else if (nonselection_glyph === \"auto\")\r\n                nonselection_glyph = mk_glyph(nonselection_defaults);\r\n            this.nonselection_glyph = await this.build_glyph_view(nonselection_glyph);\r\n            const { hover_glyph } = this.model;\r\n            if (hover_glyph != null)\r\n                this.hover_glyph = await this.build_glyph_view(hover_glyph);\r\n            const { muted_glyph } = this.model;\r\n            if (muted_glyph != null)\r\n                this.muted_glyph = await this.build_glyph_view(muted_glyph);\r\n            const decimated_glyph = mk_glyph(decimated_defaults);\r\n            this.decimated_glyph = await this.build_glyph_view(decimated_glyph);\r\n            this.set_data(false);\r\n        }\r\n        async build_glyph_view(glyph) {\r\n            return build_views_1.build_view(glyph, { parent: this });\r\n        }\r\n        remove() {\r\n            var _a, _b;\r\n            this.glyph.remove();\r\n            this.selection_glyph.remove();\r\n            this.nonselection_glyph.remove();\r\n            (_a = this.hover_glyph) === null || _a === void 0 ? void 0 : _a.remove();\r\n            (_b = this.muted_glyph) === null || _b === void 0 ? void 0 : _b.remove();\r\n            this.decimated_glyph.remove();\r\n            super.remove();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.request_render());\r\n            this.connect(this.model.glyph.change, () => this.set_data());\r\n            this.connect(this.model.data_source.change, () => this.set_data());\r\n            this.connect(this.model.data_source.streaming, () => this.set_data());\r\n            this.connect(this.model.data_source.patching, (indices /* XXX: WHY? */) => this.set_data(true, indices));\r\n            this.connect(this.model.data_source.selected.change, () => this.request_render());\r\n            this.connect(this.model.data_source._select, () => this.request_render());\r\n            if (this.hover_glyph != null)\r\n                this.connect(this.model.data_source.inspect, () => this.request_render());\r\n            this.connect(this.model.properties.view.change, () => this.set_data());\r\n            this.connect(this.model.view.properties.indices.change, () => this.set_data());\r\n            this.connect(this.model.view.properties.masked.change, () => this.set_visuals());\r\n            this.connect(this.model.properties.visible.change, () => this.plot_view.update_dataranges());\r\n            const { x_ranges, y_ranges } = this.plot_view.frame;\r\n            for (const [, range] of x_ranges) {\r\n                if (range instanceof factor_range_1.FactorRange)\r\n                    this.connect(range.change, () => this.set_data());\r\n            }\r\n            for (const [, range] of y_ranges) {\r\n                if (range instanceof factor_range_1.FactorRange)\r\n                    this.connect(range.change, () => this.set_data());\r\n            }\r\n            this.connect(this.model.glyph.transformchange, () => this.set_data());\r\n        }\r\n        _update_masked_indices() {\r\n            const masked = this.glyph.mask_data();\r\n            this.model.view.masked = masked;\r\n            return masked;\r\n        }\r\n        // in case of partial updates like patching, the list of indices that actually\r\n        // changed may be passed as the \"indices\" parameter to afford any optional optimizations\r\n        set_data(request_render = true, indices = null) {\r\n            const source = this.model.data_source;\r\n            this.all_indices = this.model.view.indices;\r\n            const { all_indices } = this;\r\n            this.glyph.set_data(source, all_indices, indices);\r\n            this.set_visuals();\r\n            this._update_masked_indices();\r\n            const { lod_factor } = this.plot_model;\r\n            const n = this.all_indices.count;\r\n            this.decimated = new types_1.Indices(n);\r\n            for (let i = 0; i < n; i += lod_factor) {\r\n                this.decimated.set(i);\r\n            }\r\n            this.set_data_timestamp = Date.now();\r\n            if (request_render) {\r\n                this.request_render();\r\n            }\r\n        }\r\n        set_visuals() {\r\n            var _a, _b, _c, _d;\r\n            const source = this.model.data_source;\r\n            const { all_indices } = this;\r\n            this.glyph.set_visuals(source, all_indices);\r\n            this.decimated_glyph.set_visuals(source, all_indices);\r\n            (_a = this.selection_glyph) === null || _a === void 0 ? void 0 : _a.set_visuals(source, all_indices);\r\n            (_b = this.nonselection_glyph) === null || _b === void 0 ? void 0 : _b.set_visuals(source, all_indices);\r\n            (_c = this.hover_glyph) === null || _c === void 0 ? void 0 : _c.set_visuals(source, all_indices);\r\n            (_d = this.muted_glyph) === null || _d === void 0 ? void 0 : _d.set_visuals(source, all_indices);\r\n        }\r\n        get has_webgl() {\r\n            return this.glyph.has_webgl;\r\n        }\r\n        _render() {\r\n            const glsupport = this.has_webgl;\r\n            this.glyph.map_data();\r\n            // all_indices is in full data space, indices is converted to subset space by mask_data (that may use the spatial index)\r\n            const all_indices = [...this.all_indices];\r\n            let indices = [...this._update_masked_indices()];\r\n            const { ctx } = this.layer;\r\n            ctx.save();\r\n            // selected is in full set space\r\n            const { selected } = this.model.data_source;\r\n            let selected_full_indices;\r\n            if (!selected || selected.is_empty())\r\n                selected_full_indices = [];\r\n            else {\r\n                if (this.glyph instanceof line_1.LineView && selected.selected_glyph === this.glyph.model)\r\n                    selected_full_indices = this.model.view.convert_indices_from_subset(indices);\r\n                else\r\n                    selected_full_indices = selected.indices;\r\n            }\r\n            // inspected is in full set space\r\n            const { inspected } = this.model.data_source;\r\n            const inspected_full_indices = new Set((() => {\r\n                if (!inspected || inspected.is_empty())\r\n                    return [];\r\n                else {\r\n                    if (inspected.selected_glyph)\r\n                        return this.model.view.convert_indices_from_subset(indices);\r\n                    else if (inspected.indices.length > 0)\r\n                        return inspected.indices;\r\n                    else {\r\n                        // TODO: return inspected.multiline_indices.keys()\r\n                        return Object.keys(inspected.multiline_indices).map((i) => parseInt(i));\r\n                    }\r\n                }\r\n            })());\r\n            // inspected is transformed to subset space\r\n            const inspected_subset_indices = arrayable_1.filter(indices, (i) => inspected_full_indices.has(all_indices[i]));\r\n            const { lod_threshold } = this.plot_model;\r\n            let glyph;\r\n            let nonselection_glyph;\r\n            let selection_glyph;\r\n            if ((this.model.document != null ? this.model.document.interactive_duration() > 0 : false)\r\n                && !glsupport && lod_threshold != null && all_indices.length > lod_threshold) {\r\n                // Render decimated during interaction if too many elements and not using GL\r\n                indices = [...this.decimated];\r\n                glyph = this.decimated_glyph;\r\n                nonselection_glyph = this.decimated_glyph;\r\n                selection_glyph = this.selection_glyph;\r\n            }\r\n            else {\r\n                glyph = this.model.muted && this.muted_glyph != null ? this.muted_glyph : this.glyph;\r\n                nonselection_glyph = this.nonselection_glyph;\r\n                selection_glyph = this.selection_glyph;\r\n            }\r\n            if (this.hover_glyph != null && inspected_subset_indices.length)\r\n                indices = array_1.difference(indices, inspected_subset_indices);\r\n            // Render with no selection\r\n            if (!selected_full_indices.length) {\r\n                if (this.glyph instanceof line_1.LineView) {\r\n                    if (this.hover_glyph && inspected_subset_indices.length)\r\n                        this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);\r\n                    else\r\n                        glyph.render(ctx, all_indices, this.glyph);\r\n                }\r\n                else if (this.glyph instanceof patch_1.PatchView || this.glyph instanceof harea_1.HAreaView || this.glyph instanceof varea_1.VAreaView) {\r\n                    if (inspected.selected_glyphs.length == 0 || this.hover_glyph == null) {\r\n                        glyph.render(ctx, all_indices, this.glyph);\r\n                    }\r\n                    else {\r\n                        for (const sglyph of inspected.selected_glyphs) {\r\n                            if (sglyph == this.glyph.model)\r\n                                this.hover_glyph.render(ctx, all_indices, this.glyph);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    glyph.render(ctx, indices, this.glyph);\r\n                    if (this.hover_glyph && inspected_subset_indices.length)\r\n                        this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\r\n                }\r\n                // Render with selection\r\n            }\r\n            else {\r\n                // reset the selection mask\r\n                const selected_mask = {};\r\n                for (const i of selected_full_indices) {\r\n                    selected_mask[i] = true;\r\n                }\r\n                // intersect/different selection with render mask\r\n                const selected_subset_indices = new Array();\r\n                const nonselected_subset_indices = new Array();\r\n                // now, selected is changed to subset space, except for Line glyph\r\n                if (this.glyph instanceof line_1.LineView) {\r\n                    for (const i of all_indices) {\r\n                        if (selected_mask[i] != null)\r\n                            selected_subset_indices.push(i);\r\n                        else\r\n                            nonselected_subset_indices.push(i);\r\n                    }\r\n                }\r\n                else {\r\n                    for (const i of indices) {\r\n                        if (selected_mask[all_indices[i]] != null)\r\n                            selected_subset_indices.push(i);\r\n                        else\r\n                            nonselected_subset_indices.push(i);\r\n                    }\r\n                }\r\n                nonselection_glyph.render(ctx, nonselected_subset_indices, this.glyph);\r\n                selection_glyph.render(ctx, selected_subset_indices, this.glyph);\r\n                if (this.hover_glyph != null) {\r\n                    if (this.glyph instanceof line_1.LineView)\r\n                        this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);\r\n                    else\r\n                        this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\r\n                }\r\n            }\r\n            ctx.restore();\r\n        }\r\n        draw_legend(ctx, x0, x1, y0, y1, field, label, index) {\r\n            if (index == null)\r\n                index = this.model.get_reference_point(field, label);\r\n            this.glyph.draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index);\r\n        }\r\n        hit_test(geometry) {\r\n            if (!this.model.visible)\r\n                return null;\r\n            const hit_test_result = this.glyph.hit_test(geometry);\r\n            // glyphs that don't have hit-testing implemented will return null\r\n            if (hit_test_result == null)\r\n                return null;\r\n            return this.model.view.convert_selection_from_subset(hit_test_result);\r\n        }\r\n    }\r\n    exports.GlyphRendererView = GlyphRendererView;\r\n    GlyphRendererView.__name__ = \"GlyphRendererView\";\r\n    class GlyphRenderer extends data_renderer_1.DataRenderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GlyphRenderer() {\r\n            this.prototype.default_view = GlyphRendererView;\r\n            this.define({\r\n                data_source: [p.Instance],\r\n                view: [p.Instance, () => new cds_view_1.CDSView()],\r\n                glyph: [p.Instance],\r\n                hover_glyph: [p.Instance],\r\n                nonselection_glyph: [p.Any, 'auto'],\r\n                selection_glyph: [p.Any, 'auto'],\r\n                muted_glyph: [p.Instance],\r\n                muted: [p.Boolean, false],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            if (this.view.source == null) {\r\n                this.view.source = this.data_source;\r\n                this.view.compute_indices();\r\n            }\r\n        }\r\n        get_reference_point(field, value) {\r\n            let index = 0;\r\n            if (field != null) {\r\n                const data = this.data_source.get_column(field);\r\n                if (data != null) {\r\n                    const i = arrayable_1.indexOf(data, value);\r\n                    if (i != -1)\r\n                        index = i;\r\n                }\r\n            }\r\n            return index;\r\n        }\r\n        get_selection_manager() {\r\n            return this.data_source.selection_manager;\r\n        }\r\n    }\r\n    exports.GlyphRenderer = GlyphRenderer;\r\n    GlyphRenderer.__name__ = \"GlyphRenderer\";\r\n    GlyphRenderer.init_GlyphRenderer();\r\n}\r\n","/* models\\renderers\\data_renderer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const renderer_1 = require(70) /* ./renderer */;\r\n    class DataRendererView extends renderer_1.RendererView {\r\n        get xscale() {\r\n            return this.coordinates.x_scale;\r\n        }\r\n        get yscale() {\r\n            return this.coordinates.y_scale;\r\n        }\r\n    }\r\n    exports.DataRendererView = DataRendererView;\r\n    DataRendererView.__name__ = \"DataRendererView\";\r\n    class DataRenderer extends renderer_1.Renderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_DataRenderer() {\r\n            this.override({\r\n                level: 'glyph',\r\n            });\r\n        }\r\n    }\r\n    exports.DataRenderer = DataRenderer;\r\n    DataRenderer.__name__ = \"DataRenderer\";\r\n    DataRenderer.init_DataRenderer();\r\n}\r\n","/* models\\glyphs\\line.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const line_1 = require(102) /* ./webgl/line */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class LineView extends xy_glyph_1.XYGlyphView {\r\n        initialize() {\r\n            super.initialize();\r\n            const { webgl } = this.renderer.plot_view.canvas_view;\r\n            if (webgl != null) {\r\n                this.glglyph = new line_1.LineGL(webgl.gl, this);\r\n            }\r\n        }\r\n        _render(ctx, indices, { sx, sy }) {\r\n            let drawing = false;\r\n            let last_index = null;\r\n            this.visuals.line.set_value(ctx);\r\n            for (const i of indices) {\r\n                if (drawing) {\r\n                    if (!isFinite(sx[i] + sy[i])) {\r\n                        ctx.stroke();\r\n                        ctx.beginPath();\r\n                        drawing = false;\r\n                        last_index = i;\r\n                        continue;\r\n                    }\r\n                    if (last_index != null && i - last_index > 1) {\r\n                        ctx.stroke();\r\n                        drawing = false;\r\n                    }\r\n                }\r\n                if (drawing)\r\n                    ctx.lineTo(sx[i], sy[i]);\r\n                else {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx[i], sy[i]);\r\n                    drawing = true;\r\n                }\r\n                last_index = i;\r\n            }\r\n            if (drawing)\r\n                ctx.stroke();\r\n        }\r\n        _hit_point(geometry) {\r\n            /* Check if the point geometry hits this line glyph and return an object\r\n            that describes the hit result:\r\n              Args:\r\n                * geometry (object): object with the following keys\r\n                  * sx (float): screen x coordinate of the point\r\n                  * sy (float): screen y coordinate of the point\r\n                  * type (str): type of geometry (in this case it's a point)\r\n            */\r\n            const result = new selection_1.Selection();\r\n            const point = { x: geometry.sx, y: geometry.sy };\r\n            let shortest = 9999;\r\n            const threshold = Math.max(2, this.visuals.line.line_width.value() / 2);\r\n            for (let i = 0, end = this.sx.length - 1; i < end; i++) {\r\n                const p0 = { x: this.sx[i], y: this.sy[i] };\r\n                const p1 = { x: this.sx[i + 1], y: this.sy[i + 1] };\r\n                const dist = hittest.dist_to_segment(point, p0, p1);\r\n                if (dist < threshold && dist < shortest) {\r\n                    shortest = dist;\r\n                    result.add_to_selected_glyphs(this.model);\r\n                    result.view = this;\r\n                    result.line_indices = [i];\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        _hit_span(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const result = new selection_1.Selection();\r\n            let val;\r\n            let values;\r\n            if (geometry.direction == 'v') {\r\n                val = this.renderer.yscale.invert(sy);\r\n                values = this._y;\r\n            }\r\n            else {\r\n                val = this.renderer.xscale.invert(sx);\r\n                values = this._x;\r\n            }\r\n            for (let i = 0, end = values.length - 1; i < end; i++) {\r\n                if ((values[i] <= val && val <= values[i + 1]) || (values[i + 1] <= val && val <= values[i])) {\r\n                    result.add_to_selected_glyphs(this.model);\r\n                    result.view = this;\r\n                    result.line_indices.push(i);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        get_interpolation_hit(i, geometry) {\r\n            const [x2, y2, x3, y3] = [this._x[i], this._y[i], this._x[i + 1], this._y[i + 1]];\r\n            return utils_1.line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.LineView = LineView;\r\n    LineView.__name__ = \"LineView\";\r\n    class Line extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Line() {\r\n            this.prototype.default_view = LineView;\r\n            this.mixins(mixins.Line /*Scalar*/);\r\n        }\r\n    }\r\n    exports.Line = Line;\r\n    Line.__name__ = \"Line\";\r\n    Line.init_Line();\r\n}\r\n","/* models\\glyphs\\xy_glyph.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    class XYGlyphView extends glyph_1.GlyphView {\r\n        _project_data() {\r\n            projections_1.inplace.project_xy(this._x, this._y);\r\n        }\r\n        _index_data(index) {\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const x = this._x[i];\r\n                const y = this._y[i];\r\n                if (isNaN(x + y) || !isFinite(x + y))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(x, y, x, y);\r\n            }\r\n        }\r\n        scenterxy(i) {\r\n            return [this.sx[i], this.sy[i]];\r\n        }\r\n    }\r\n    exports.XYGlyphView = XYGlyphView;\r\n    XYGlyphView.__name__ = \"XYGlyphView\";\r\n    class XYGlyph extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_XYGlyph() {\r\n            this.define({\r\n                x: [p.XCoordinateSpec, { field: \"x\" }],\r\n                y: [p.YCoordinateSpec, { field: \"y\" }],\r\n            });\r\n        }\r\n    }\r\n    exports.XYGlyph = XYGlyph;\r\n    XYGlyph.__name__ = \"XYGlyph\";\r\n    XYGlyph.init_XYGlyph();\r\n}\r\n","/* models\\glyphs\\glyph.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const bbox = tslib_1.__importStar(require(79) /* ../../core/util/bbox */);\r\n    const visuals = tslib_1.__importStar(require(74) /* ../../core/visuals */);\r\n    const view_1 = require(71) /* ../../core/view */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const spatial_1 = require(95) /* ../../core/util/spatial */;\r\n    const factor_range_1 = require(98) /* ../ranges/factor_range */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class GlyphView extends view_1.View {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._index = null;\r\n            this._data_size = null;\r\n            this._nohit_warned = new Set();\r\n        }\r\n        get renderer() {\r\n            return this.parent;\r\n        }\r\n        get has_webgl() {\r\n            return this.glglyph != null;\r\n        }\r\n        get index() {\r\n            const { _index } = this;\r\n            if (_index != null)\r\n                return _index;\r\n            else\r\n                throw new Error(`${this}.index_data() wasn't called`);\r\n        }\r\n        get data_size() {\r\n            const { _data_size } = this;\r\n            if (_data_size != null)\r\n                return _data_size;\r\n            else\r\n                throw new Error(`${this}.set_data() wasn't called`);\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.visuals = new visuals.Visuals(this.model);\r\n        }\r\n        set_visuals(source, indices) {\r\n            this.visuals.warm_cache(source, indices);\r\n            if (this.glglyph != null)\r\n                this.glglyph.set_visuals_changed();\r\n        }\r\n        render(ctx, indices, data) {\r\n            ctx.beginPath();\r\n            if (this.glglyph != null) {\r\n                this.renderer.needs_webgl_blit = this.glglyph.render(ctx, indices, data);\r\n                if (this.renderer.needs_webgl_blit)\r\n                    return;\r\n            }\r\n            this._render(ctx, indices, data);\r\n        }\r\n        has_finished() {\r\n            return true;\r\n        }\r\n        notify_finished() {\r\n            this.renderer.notify_finished();\r\n        }\r\n        _bounds(bounds) {\r\n            return bounds;\r\n        }\r\n        bounds() {\r\n            return this._bounds(this.index.bbox);\r\n        }\r\n        log_bounds() {\r\n            const { x0, x1 } = this.index.bounds(bbox.positive_x());\r\n            const { y0, y1 } = this.index.bounds(bbox.positive_y());\r\n            return this._bounds({ x0, y0, x1, y1 });\r\n        }\r\n        get_anchor_point(anchor, i, [sx, sy]) {\r\n            switch (anchor) {\r\n                case \"center\": {\r\n                    const [x, y] = this.scenterxy(i, sx, sy);\r\n                    return { x, y };\r\n                }\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n        /** @deprecated */\r\n        scenterx(i, sx, sy) {\r\n            return this.scenterxy(i, sx, sy)[0];\r\n        }\r\n        /** @deprecated */\r\n        scentery(i, sx, sy) {\r\n            return this.scenterxy(i, sx, sy)[1];\r\n        }\r\n        sdist(scale, pts, spans, pts_location = \"edge\", dilate = false) {\r\n            let pt0;\r\n            let pt1;\r\n            const n = pts.length;\r\n            if (pts_location == 'center') {\r\n                const halfspan = arrayable_1.map(spans, (d) => d / 2);\r\n                pt0 = new Float64Array(n);\r\n                for (let i = 0; i < n; i++) {\r\n                    pt0[i] = pts[i] - halfspan[i];\r\n                }\r\n                pt1 = new Float64Array(n);\r\n                for (let i = 0; i < n; i++) {\r\n                    pt1[i] = pts[i] + halfspan[i];\r\n                }\r\n            }\r\n            else {\r\n                pt0 = pts;\r\n                pt1 = new Float64Array(n);\r\n                for (let i = 0; i < n; i++) {\r\n                    pt1[i] = pt0[i] + spans[i];\r\n                }\r\n            }\r\n            const spt0 = scale.v_compute(pt0);\r\n            const spt1 = scale.v_compute(pt1);\r\n            if (dilate)\r\n                return arrayable_1.map(spt0, (_, i) => Math.ceil(Math.abs(spt1[i] - spt0[i])));\r\n            else\r\n                return arrayable_1.map(spt0, (_, i) => Math.abs(spt1[i] - spt0[i]));\r\n        }\r\n        draw_legend_for_index(_ctx, _bbox, _index) { }\r\n        hit_test(geometry) {\r\n            switch (geometry.type) {\r\n                case \"point\":\r\n                    if (this._hit_point != null)\r\n                        return this._hit_point(geometry);\r\n                    break;\r\n                case \"span\":\r\n                    if (this._hit_span != null)\r\n                        return this._hit_span(geometry);\r\n                    break;\r\n                case \"rect\":\r\n                    if (this._hit_rect != null)\r\n                        return this._hit_rect(geometry);\r\n                    break;\r\n                case \"poly\":\r\n                    if (this._hit_poly != null)\r\n                        return this._hit_poly(geometry);\r\n                    break;\r\n            }\r\n            if (!this._nohit_warned.has(geometry.type)) {\r\n                logging_1.logger.debug(`'${geometry.type}' selection not available for ${this.model.type}`);\r\n                this._nohit_warned.add(geometry.type);\r\n            }\r\n            return null;\r\n        }\r\n        _hit_rect_against_index(geometry) {\r\n            const { sx0, sx1, sy0, sy1 } = geometry;\r\n            const [x0, x1] = this.renderer.coordinates.x_scale.r_invert(sx0, sx1);\r\n            const [y0, y1] = this.renderer.coordinates.y_scale.r_invert(sy0, sy1);\r\n            const indices = [...this.index.indices({ x0, x1, y0, y1 })];\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _project_data() { }\r\n        set_data(source, indices, indices_to_update) {\r\n            var _a, _b;\r\n            const { x_range, y_range } = this.renderer.coordinates;\r\n            this._data_size = (_a = source.get_length()) !== null && _a !== void 0 ? _a : 1;\r\n            for (const prop of this.model) {\r\n                if (!(prop instanceof p.VectorSpec))\r\n                    continue;\r\n                // this skips optional properties like radius for circles\r\n                if (prop.optional && prop.spec.value == null && !prop.dirty)\r\n                    continue;\r\n                const name = prop.attr;\r\n                const base_array = prop.array(source);\r\n                let array = indices.select(base_array);\r\n                if (prop instanceof p.BaseCoordinateSpec) {\r\n                    const range = prop.dimension == \"x\" ? x_range : y_range;\r\n                    if (range instanceof factor_range_1.FactorRange) {\r\n                        if (prop instanceof p.CoordinateSpec) {\r\n                            array = range.v_synthetic(array);\r\n                        }\r\n                        else if (prop instanceof p.CoordinateSeqSpec) {\r\n                            for (let i = 0; i < array.length; i++) {\r\n                                array[i] = range.v_synthetic(array[i]);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (prop instanceof p.CoordinateSeqSpec) {\r\n                        array = types_1.RaggedArray.from(array);\r\n                    }\r\n                }\r\n                else if (prop instanceof p.DistanceSpec) {\r\n                    this[`max_${name}`] = arrayable_1.max(array);\r\n                }\r\n                this[`_${name}`] = array;\r\n            }\r\n            if (this.renderer.plot_view.model.use_map) {\r\n                this._project_data();\r\n            }\r\n            this._set_data(indices_to_update); // TODO doesn't take subset indices into account\r\n            (_b = this.glglyph) === null || _b === void 0 ? void 0 : _b.set_data_changed();\r\n            this.index_data();\r\n        }\r\n        _set_data(_indices) { }\r\n        get _index_size() {\r\n            return this.data_size;\r\n        }\r\n        index_data() {\r\n            const index = new spatial_1.SpatialIndex(this._index_size);\r\n            this._index_data(index);\r\n            index.finish();\r\n            this._index = index;\r\n        }\r\n        mask_data() {\r\n            // WebGL can do the clipping much more efficiently\r\n            if (this.glglyph != null || this._mask_data == null)\r\n                return types_1.Indices.all_set(this.data_size);\r\n            else\r\n                return this._mask_data();\r\n        }\r\n        map_data() {\r\n            var _a;\r\n            const self = this;\r\n            const { x_scale, y_scale } = this.renderer.coordinates;\r\n            for (const prop of this.model) {\r\n                if (prop instanceof p.BaseCoordinateSpec) {\r\n                    const scale = prop.dimension == \"x\" ? x_scale : y_scale;\r\n                    let array = self[`_${prop.attr}`];\r\n                    if (array instanceof types_1.RaggedArray) {\r\n                        const screen = scale.v_compute(array.array);\r\n                        array = new types_1.RaggedArray(array.offsets, screen);\r\n                    }\r\n                    else {\r\n                        array = scale.v_compute(array);\r\n                    }\r\n                    this[`s${prop.attr}`] = array;\r\n                }\r\n            }\r\n            this._map_data();\r\n            (_a = this.glglyph) === null || _a === void 0 ? void 0 : _a.set_data_changed();\r\n        }\r\n        // This is where specs not included in coords are computed, e.g. radius.\r\n        _map_data() { }\r\n    }\r\n    exports.GlyphView = GlyphView;\r\n    GlyphView.__name__ = \"GlyphView\";\r\n    class Glyph extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Glyph() { }\r\n    }\r\n    exports.Glyph = Glyph;\r\n    Glyph.__name__ = \"Glyph\";\r\n    Glyph.init_Glyph();\r\n}\r\n","/* core\\util\\spatial.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const flatbush_1 = tslib_1.__importDefault(require(96) /* flatbush */);\r\n    const types_1 = require(24) /* ../types */;\r\n    const bbox_1 = require(79) /* ./bbox */;\r\n    function upperBound(value, arr) {\r\n        let i = 0;\r\n        let j = arr.length - 1;\r\n        while (i < j) {\r\n            const m = (i + j) >> 1;\r\n            if (arr[m] > value) {\r\n                j = m;\r\n            }\r\n            else {\r\n                i = m + 1;\r\n            }\r\n        }\r\n        return arr[i];\r\n    }\r\n    class _FlatBush extends flatbush_1.default {\r\n        search_indices(minX, minY, maxX, maxY) {\r\n            if (this._pos !== this._boxes.length) {\r\n                throw new Error('Data not yet indexed - call index.finish().');\r\n            }\r\n            let nodeIndex = this._boxes.length - 4;\r\n            const queue = [];\r\n            const results = new types_1.Indices(this.numItems);\r\n            while (nodeIndex !== undefined) {\r\n                // find the end index of the node\r\n                const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\r\n                // search through child nodes\r\n                for (let pos = nodeIndex; pos < end; pos += 4) {\r\n                    const index = this._indices[pos >> 2] | 0;\r\n                    // check if node bbox intersects with query bbox\r\n                    if (maxX < this._boxes[pos + 0])\r\n                        continue; // maxX < nodeMinX\r\n                    if (maxY < this._boxes[pos + 1])\r\n                        continue; // maxY < nodeMinY\r\n                    if (minX > this._boxes[pos + 2])\r\n                        continue; // minX > nodeMaxX\r\n                    if (minY > this._boxes[pos + 3])\r\n                        continue; // minY > nodeMaxY\r\n                    if (nodeIndex < this.numItems * 4) {\r\n                        results.set(index); // leaf item\r\n                    }\r\n                    else {\r\n                        queue.push(index); // node; add it to the search queue\r\n                    }\r\n                }\r\n                nodeIndex = queue.pop();\r\n            }\r\n            return results;\r\n        }\r\n    }\r\n    _FlatBush.__name__ = \"_FlatBush\";\r\n    class SpatialIndex {\r\n        constructor(size) {\r\n            this.index = null;\r\n            if (size > 0) {\r\n                this.index = new _FlatBush(size);\r\n            }\r\n        }\r\n        add(x0, y0, x1, y1) {\r\n            var _a;\r\n            (_a = this.index) === null || _a === void 0 ? void 0 : _a.add(x0, y0, x1, y1);\r\n        }\r\n        add_empty() {\r\n            var _a;\r\n            (_a = this.index) === null || _a === void 0 ? void 0 : _a.add(Infinity, Infinity, -Infinity, -Infinity);\r\n        }\r\n        finish() {\r\n            var _a;\r\n            (_a = this.index) === null || _a === void 0 ? void 0 : _a.finish();\r\n        }\r\n        _normalize(rect) {\r\n            let { x0, y0, x1, y1 } = rect;\r\n            if (x0 > x1)\r\n                [x0, x1] = [x1, x0];\r\n            if (y0 > y1)\r\n                [y0, y1] = [y1, y0];\r\n            return { x0, y0, x1, y1 };\r\n        }\r\n        get bbox() {\r\n            if (this.index == null)\r\n                return bbox_1.empty();\r\n            else {\r\n                const { minX, minY, maxX, maxY } = this.index;\r\n                return { x0: minX, y0: minY, x1: maxX, y1: maxY };\r\n            }\r\n        }\r\n        indices(rect) {\r\n            if (this.index == null)\r\n                return new types_1.Indices(0);\r\n            else {\r\n                const { x0, y0, x1, y1 } = this._normalize(rect);\r\n                return this.index.search_indices(x0, y0, x1, y1);\r\n            }\r\n        }\r\n        bounds(rect) {\r\n            const bounds = bbox_1.empty();\r\n            for (const i of this.indices(rect)) {\r\n                const boxes = this.index._boxes;\r\n                const x1 = boxes[4 * i + 0];\r\n                const y1 = boxes[4 * i + 1];\r\n                const x0 = boxes[4 * i + 2];\r\n                const y0 = boxes[4 * i + 3];\r\n                if (x0 < bounds.x0)\r\n                    bounds.x0 = x0;\r\n                if (x1 > bounds.x1)\r\n                    bounds.x1 = x1;\r\n                if (y0 < bounds.y0)\r\n                    bounds.y0 = y0;\r\n                if (y1 > bounds.y1)\r\n                    bounds.y1 = y1;\r\n            }\r\n            return bounds;\r\n        }\r\n    }\r\n    exports.SpatialIndex = SpatialIndex;\r\n    SpatialIndex.__name__ = \"SpatialIndex\";\r\n}\r\n","/* flatbush\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const flatqueue_1 = tslib_1.__importDefault(require(97) /* flatqueue */);\r\n    const ARRAY_TYPES = [\r\n        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\r\n        Int32Array, Uint32Array, Float32Array, Float64Array\r\n    ];\r\n    const VERSION = 3; // serialized format version\r\n    class Flatbush {\r\n        static from(data) {\r\n            if (!(data instanceof ArrayBuffer)) {\r\n                throw new Error('Data must be an instance of ArrayBuffer.');\r\n            }\r\n            const [magic, versionAndType] = new Uint8Array(data, 0, 2);\r\n            if (magic !== 0xfb) {\r\n                throw new Error('Data does not appear to be in a Flatbush format.');\r\n            }\r\n            if (versionAndType >> 4 !== VERSION) {\r\n                throw new Error(`Got v${versionAndType >> 4} data when expected v${VERSION}.`);\r\n            }\r\n            const [nodeSize] = new Uint16Array(data, 2, 1);\r\n            const [numItems] = new Uint32Array(data, 4, 1);\r\n            return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);\r\n        }\r\n        constructor(numItems, nodeSize = 16, ArrayType = Float64Array, data) {\r\n            if (numItems === undefined)\r\n                throw new Error('Missing required argument: numItems.');\r\n            if (isNaN(numItems) || numItems <= 0)\r\n                throw new Error(`Unpexpected numItems value: ${numItems}.`);\r\n            this.numItems = +numItems;\r\n            this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\r\n            // calculate the total number of nodes in the R-tree to allocate space for\r\n            // and the index of each tree level (used in search later)\r\n            let n = numItems;\r\n            let numNodes = n;\r\n            this._levelBounds = [n * 4];\r\n            do {\r\n                n = Math.ceil(n / this.nodeSize);\r\n                numNodes += n;\r\n                this._levelBounds.push(numNodes * 4);\r\n            } while (n !== 1);\r\n            this.ArrayType = ArrayType || Float64Array;\r\n            this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\r\n            const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\r\n            const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;\r\n            if (arrayTypeIndex < 0) {\r\n                throw new Error(`Unexpected typed array class: ${ArrayType}.`);\r\n            }\r\n            if (data && (data instanceof ArrayBuffer)) {\r\n                this.data = data;\r\n                this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\r\n                this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\r\n                this._pos = numNodes * 4;\r\n                this.minX = this._boxes[this._pos - 4];\r\n                this.minY = this._boxes[this._pos - 3];\r\n                this.maxX = this._boxes[this._pos - 2];\r\n                this.maxY = this._boxes[this._pos - 1];\r\n            }\r\n            else {\r\n                this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\r\n                this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\r\n                this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\r\n                this._pos = 0;\r\n                this.minX = Infinity;\r\n                this.minY = Infinity;\r\n                this.maxX = -Infinity;\r\n                this.maxY = -Infinity;\r\n                new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\r\n                new Uint16Array(this.data, 2, 1)[0] = nodeSize;\r\n                new Uint32Array(this.data, 4, 1)[0] = numItems;\r\n            }\r\n            // a priority queue for k-nearest-neighbors queries\r\n            this._queue = new flatqueue_1.default();\r\n        }\r\n        add(minX, minY, maxX, maxY) {\r\n            const index = this._pos >> 2;\r\n            this._indices[index] = index;\r\n            this._boxes[this._pos++] = minX;\r\n            this._boxes[this._pos++] = minY;\r\n            this._boxes[this._pos++] = maxX;\r\n            this._boxes[this._pos++] = maxY;\r\n            if (minX < this.minX)\r\n                this.minX = minX;\r\n            if (minY < this.minY)\r\n                this.minY = minY;\r\n            if (maxX > this.maxX)\r\n                this.maxX = maxX;\r\n            if (maxY > this.maxY)\r\n                this.maxY = maxY;\r\n            return index;\r\n        }\r\n        finish() {\r\n            if (this._pos >> 2 !== this.numItems) {\r\n                throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\r\n            }\r\n            if (this.numItems <= this.nodeSize) {\r\n                // only one node, skip sorting and just fill the root box\r\n                this._boxes[this._pos++] = this.minX;\r\n                this._boxes[this._pos++] = this.minY;\r\n                this._boxes[this._pos++] = this.maxX;\r\n                this._boxes[this._pos++] = this.maxY;\r\n                return;\r\n            }\r\n            const width = this.maxX - this.minX;\r\n            const height = this.maxY - this.minY;\r\n            const hilbertValues = new Uint32Array(this.numItems);\r\n            const hilbertMax = (1 << 16) - 1;\r\n            // map item centers into Hilbert coordinate space and calculate Hilbert values\r\n            for (let i = 0; i < this.numItems; i++) {\r\n                let pos = 4 * i;\r\n                const minX = this._boxes[pos++];\r\n                const minY = this._boxes[pos++];\r\n                const maxX = this._boxes[pos++];\r\n                const maxY = this._boxes[pos++];\r\n                const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\r\n                const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\r\n                hilbertValues[i] = hilbert(x, y);\r\n            }\r\n            // sort items by their Hilbert value (for packing later)\r\n            sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1, this.nodeSize);\r\n            // generate nodes at each tree level, bottom-up\r\n            for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\r\n                const end = this._levelBounds[i];\r\n                // generate a parent node for each block of consecutive <nodeSize> nodes\r\n                while (pos < end) {\r\n                    const nodeIndex = pos;\r\n                    // calculate bbox for the new node\r\n                    let nodeMinX = Infinity;\r\n                    let nodeMinY = Infinity;\r\n                    let nodeMaxX = -Infinity;\r\n                    let nodeMaxY = -Infinity;\r\n                    for (let i = 0; i < this.nodeSize && pos < end; i++) {\r\n                        nodeMinX = Math.min(nodeMinX, this._boxes[pos++]);\r\n                        nodeMinY = Math.min(nodeMinY, this._boxes[pos++]);\r\n                        nodeMaxX = Math.max(nodeMaxX, this._boxes[pos++]);\r\n                        nodeMaxY = Math.max(nodeMaxY, this._boxes[pos++]);\r\n                    }\r\n                    // add the new node to the tree data\r\n                    this._indices[this._pos >> 2] = nodeIndex;\r\n                    this._boxes[this._pos++] = nodeMinX;\r\n                    this._boxes[this._pos++] = nodeMinY;\r\n                    this._boxes[this._pos++] = nodeMaxX;\r\n                    this._boxes[this._pos++] = nodeMaxY;\r\n                }\r\n            }\r\n        }\r\n        search(minX, minY, maxX, maxY, filterFn) {\r\n            if (this._pos !== this._boxes.length) {\r\n                throw new Error('Data not yet indexed - call index.finish().');\r\n            }\r\n            let nodeIndex = this._boxes.length - 4;\r\n            const queue = [];\r\n            const results = [];\r\n            while (nodeIndex !== undefined) {\r\n                // find the end index of the node\r\n                const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\r\n                // search through child nodes\r\n                for (let pos = nodeIndex; pos < end; pos += 4) {\r\n                    const index = this._indices[pos >> 2] | 0;\r\n                    // check if node bbox intersects with query bbox\r\n                    if (maxX < this._boxes[pos])\r\n                        continue; // maxX < nodeMinX\r\n                    if (maxY < this._boxes[pos + 1])\r\n                        continue; // maxY < nodeMinY\r\n                    if (minX > this._boxes[pos + 2])\r\n                        continue; // minX > nodeMaxX\r\n                    if (minY > this._boxes[pos + 3])\r\n                        continue; // minY > nodeMaxY\r\n                    if (nodeIndex < this.numItems * 4) {\r\n                        if (filterFn === undefined || filterFn(index)) {\r\n                            results.push(index); // leaf item\r\n                        }\r\n                    }\r\n                    else {\r\n                        queue.push(index); // node; add it to the search queue\r\n                    }\r\n                }\r\n                nodeIndex = queue.pop();\r\n            }\r\n            return results;\r\n        }\r\n        neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {\r\n            if (this._pos !== this._boxes.length) {\r\n                throw new Error('Data not yet indexed - call index.finish().');\r\n            }\r\n            let nodeIndex = this._boxes.length - 4;\r\n            const q = this._queue;\r\n            const results = [];\r\n            const maxDistSquared = maxDistance * maxDistance;\r\n            while (nodeIndex !== undefined) {\r\n                // find the end index of the node\r\n                const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\r\n                // add child nodes to the queue\r\n                for (let pos = nodeIndex; pos < end; pos += 4) {\r\n                    const index = this._indices[pos >> 2] | 0;\r\n                    const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);\r\n                    const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);\r\n                    const dist = dx * dx + dy * dy;\r\n                    if (nodeIndex < this.numItems * 4) { // leaf node\r\n                        if (filterFn === undefined || filterFn(index)) {\r\n                            // put a negative index if it's an item rather than a node, to recognize later\r\n                            q.push(-index - 1, dist);\r\n                        }\r\n                    }\r\n                    else {\r\n                        q.push(index, dist);\r\n                    }\r\n                }\r\n                // pop items from the queue\r\n                while (q.length && q.peek() < 0) {\r\n                    const dist = q.peekValue();\r\n                    if (dist > maxDistSquared) {\r\n                        q.clear();\r\n                        return results;\r\n                    }\r\n                    results.push(-q.pop() - 1);\r\n                    if (results.length === maxResults) {\r\n                        q.clear();\r\n                        return results;\r\n                    }\r\n                }\r\n                nodeIndex = q.pop();\r\n            }\r\n            q.clear();\r\n            return results;\r\n        }\r\n    }\r\n    exports.default = Flatbush;\r\n    function axisDist(k, min, max) {\r\n        return k < min ? min - k : k <= max ? 0 : k - max;\r\n    }\r\n    // binary search for the first value in the array bigger than the given\r\n    function upperBound(value, arr) {\r\n        let i = 0;\r\n        let j = arr.length - 1;\r\n        while (i < j) {\r\n            const m = (i + j) >> 1;\r\n            if (arr[m] > value) {\r\n                j = m;\r\n            }\r\n            else {\r\n                i = m + 1;\r\n            }\r\n        }\r\n        return arr[i];\r\n    }\r\n    // custom quicksort that partially sorts bbox data alongside the hilbert values\r\n    function sort(values, boxes, indices, left, right, nodeSize) {\r\n        if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize))\r\n            return;\r\n        const pivot = values[(left + right) >> 1];\r\n        let i = left - 1;\r\n        let j = right + 1;\r\n        while (true) {\r\n            do\r\n                i++;\r\n            while (values[i] < pivot);\r\n            do\r\n                j--;\r\n            while (values[j] > pivot);\r\n            if (i >= j)\r\n                break;\r\n            swap(values, boxes, indices, i, j);\r\n        }\r\n        sort(values, boxes, indices, left, j, nodeSize);\r\n        sort(values, boxes, indices, j + 1, right, nodeSize);\r\n    }\r\n    // swap two values and two corresponding boxes\r\n    function swap(values, boxes, indices, i, j) {\r\n        const temp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = temp;\r\n        const k = 4 * i;\r\n        const m = 4 * j;\r\n        const a = boxes[k];\r\n        const b = boxes[k + 1];\r\n        const c = boxes[k + 2];\r\n        const d = boxes[k + 3];\r\n        boxes[k] = boxes[m];\r\n        boxes[k + 1] = boxes[m + 1];\r\n        boxes[k + 2] = boxes[m + 2];\r\n        boxes[k + 3] = boxes[m + 3];\r\n        boxes[m] = a;\r\n        boxes[m + 1] = b;\r\n        boxes[m + 2] = c;\r\n        boxes[m + 3] = d;\r\n        const e = indices[i];\r\n        indices[i] = indices[j];\r\n        indices[j] = e;\r\n    }\r\n    // Fast Hilbert curve algorithm by http://threadlocalmutex.com/\r\n    // Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\r\n    function hilbert(x, y) {\r\n        let a = x ^ y;\r\n        let b = 0xFFFF ^ a;\r\n        let c = 0xFFFF ^ (x | y);\r\n        let d = x & (y ^ 0xFFFF);\r\n        let A = a | (b >> 1);\r\n        let B = (a >> 1) ^ a;\r\n        let C = ((c >> 1) ^ (b & (d >> 1))) ^ c;\r\n        let D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;\r\n        a = A;\r\n        b = B;\r\n        c = C;\r\n        d = D;\r\n        A = ((a & (a >> 2)) ^ (b & (b >> 2)));\r\n        B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));\r\n        C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));\r\n        D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));\r\n        a = A;\r\n        b = B;\r\n        c = C;\r\n        d = D;\r\n        A = ((a & (a >> 4)) ^ (b & (b >> 4)));\r\n        B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));\r\n        C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));\r\n        D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));\r\n        a = A;\r\n        b = B;\r\n        c = C;\r\n        d = D;\r\n        C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));\r\n        D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));\r\n        a = C ^ (C >> 1);\r\n        b = D ^ (D >> 1);\r\n        let i0 = x ^ y;\r\n        let i1 = b | (0xFFFF ^ (i0 | a));\r\n        i0 = (i0 | (i0 << 8)) & 0x00FF00FF;\r\n        i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;\r\n        i0 = (i0 | (i0 << 2)) & 0x33333333;\r\n        i0 = (i0 | (i0 << 1)) & 0x55555555;\r\n        i1 = (i1 | (i1 << 8)) & 0x00FF00FF;\r\n        i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;\r\n        i1 = (i1 | (i1 << 2)) & 0x33333333;\r\n        i1 = (i1 | (i1 << 1)) & 0x55555555;\r\n        return ((i1 << 1) | i0) >>> 0;\r\n    }\r\n}\r\n","/* flatqueue\\index.mjs */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class FlatQueue {\r\n        constructor() {\r\n            this.ids = [];\r\n            this.values = [];\r\n            this.length = 0;\r\n        }\r\n        clear() {\r\n            this.length = 0;\r\n        }\r\n        push(id, value) {\r\n            let pos = this.length++;\r\n            this.ids[pos] = id;\r\n            this.values[pos] = value;\r\n            while (pos > 0) {\r\n                const parent = (pos - 1) >> 1;\r\n                const parentValue = this.values[parent];\r\n                if (value >= parentValue)\r\n                    break;\r\n                this.ids[pos] = this.ids[parent];\r\n                this.values[pos] = parentValue;\r\n                pos = parent;\r\n            }\r\n            this.ids[pos] = id;\r\n            this.values[pos] = value;\r\n        }\r\n        pop() {\r\n            if (this.length === 0)\r\n                return undefined;\r\n            const top = this.ids[0];\r\n            this.length--;\r\n            if (this.length > 0) {\r\n                const id = this.ids[0] = this.ids[this.length];\r\n                const value = this.values[0] = this.values[this.length];\r\n                const halfLength = this.length >> 1;\r\n                let pos = 0;\r\n                while (pos < halfLength) {\r\n                    let left = (pos << 1) + 1;\r\n                    const right = left + 1;\r\n                    let bestIndex = this.ids[left];\r\n                    let bestValue = this.values[left];\r\n                    const rightValue = this.values[right];\r\n                    if (right < this.length && rightValue < bestValue) {\r\n                        left = right;\r\n                        bestIndex = this.ids[right];\r\n                        bestValue = rightValue;\r\n                    }\r\n                    if (bestValue >= value)\r\n                        break;\r\n                    this.ids[pos] = bestIndex;\r\n                    this.values[pos] = bestValue;\r\n                    pos = left;\r\n                }\r\n                this.ids[pos] = id;\r\n                this.values[pos] = value;\r\n            }\r\n            return top;\r\n        }\r\n        peek() {\r\n            if (this.length === 0)\r\n                return undefined;\r\n            return this.ids[0];\r\n        }\r\n        peekValue() {\r\n            if (this.length === 0)\r\n                return undefined;\r\n            return this.values[0];\r\n        }\r\n    }\r\n    exports.default = FlatQueue;\r\n}\r\n","/* models\\ranges\\factor_range.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const range_1 = require(99) /* ./range */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const types_2 = require(8) /* ../../core/util/types */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    function map_one_level(factors, padding, offset = 0) {\r\n        const mapping = new Map();\r\n        for (let i = 0; i < factors.length; i++) {\r\n            const factor = factors[i];\r\n            if (!mapping.has(factor))\r\n                mapping.set(factor, { value: 0.5 + i * (1 + padding) + offset });\r\n            else\r\n                throw new Error(`duplicate factor or subfactor: ${factor}`);\r\n        }\r\n        return [mapping, (factors.length - 1) * padding];\r\n    }\r\n    exports.map_one_level = map_one_level;\r\n    function map_two_levels(factors, outer_pad, factor_pad, offset = 0) {\r\n        var _a;\r\n        const mapping = new Map();\r\n        const tops = new Map();\r\n        for (const [f0, f1] of factors) {\r\n            const top = (_a = tops.get(f0)) !== null && _a !== void 0 ? _a : [];\r\n            tops.set(f0, [...top, f1]);\r\n        }\r\n        let suboffset = offset;\r\n        let total_subpad = 0;\r\n        for (const [f0, top] of tops) {\r\n            const n = top.length;\r\n            const [submap, subpad] = map_one_level(top, factor_pad, suboffset);\r\n            total_subpad += subpad;\r\n            const subtot = array_1.sum(top.map((f1) => submap.get(f1).value));\r\n            mapping.set(f0, { value: subtot / n, mapping: submap });\r\n            suboffset += n + outer_pad + subpad;\r\n        }\r\n        return [mapping, (tops.size - 1) * outer_pad + total_subpad];\r\n    }\r\n    exports.map_two_levels = map_two_levels;\r\n    function map_three_levels(factors, outer_pad, inner_pad, factor_pad, offset = 0) {\r\n        var _a;\r\n        const mapping = new Map();\r\n        const tops = new Map();\r\n        for (const [f0, f1, f2] of factors) {\r\n            const top = (_a = tops.get(f0)) !== null && _a !== void 0 ? _a : [];\r\n            tops.set(f0, [...top, [f1, f2]]);\r\n        }\r\n        let suboffset = offset;\r\n        let total_subpad = 0;\r\n        for (const [f0, top] of tops) {\r\n            const n = top.length;\r\n            const [submap, subpad] = map_two_levels(top, inner_pad, factor_pad, suboffset);\r\n            total_subpad += subpad;\r\n            const subtot = array_1.sum(top.map(([f1]) => submap.get(f1).value));\r\n            mapping.set(f0, { value: subtot / n, mapping: submap });\r\n            suboffset += n + outer_pad + subpad;\r\n        }\r\n        return [mapping, (tops.size - 1) * outer_pad + total_subpad];\r\n    }\r\n    exports.map_three_levels = map_three_levels;\r\n    class FactorRange extends range_1.Range {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_FactorRange() {\r\n            this.define({\r\n                factors: [p.Array, []],\r\n                factor_padding: [p.Number, 0],\r\n                subgroup_padding: [p.Number, 0.8],\r\n                group_padding: [p.Number, 1.4],\r\n                range_padding: [p.Number, 0],\r\n                range_padding_units: [p.PaddingUnits, \"percent\"],\r\n                start: [p.Number],\r\n                end: [p.Number],\r\n            });\r\n            this.internal({\r\n                levels: [p.Number],\r\n                mids: [p.Array, null],\r\n                tops: [p.Array, null],\r\n            });\r\n        }\r\n        get min() {\r\n            return this.start;\r\n        }\r\n        get max() {\r\n            return this.end;\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._init(true);\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.properties.factors.change, () => this.reset());\r\n            this.connect(this.properties.factor_padding.change, () => this.reset());\r\n            this.connect(this.properties.group_padding.change, () => this.reset());\r\n            this.connect(this.properties.subgroup_padding.change, () => this.reset());\r\n            this.connect(this.properties.range_padding.change, () => this.reset());\r\n            this.connect(this.properties.range_padding_units.change, () => this.reset());\r\n        }\r\n        reset() {\r\n            this._init(false);\r\n            this.change.emit();\r\n        }\r\n        _lookup(x) {\r\n            switch (x.length) {\r\n                case 1: {\r\n                    const [f0] = x;\r\n                    const mapping = this._mapping;\r\n                    const y0 = mapping.get(f0);\r\n                    return y0 != null ? y0.value : NaN;\r\n                }\r\n                case 2: {\r\n                    const [f0, f1] = x;\r\n                    const mapping = this._mapping;\r\n                    const y0 = mapping.get(f0);\r\n                    if (y0 != null) {\r\n                        const y1 = y0.mapping.get(f1);\r\n                        if (y1 != null)\r\n                            return y1.value;\r\n                    }\r\n                    return NaN;\r\n                }\r\n                case 3: {\r\n                    const [f0, f1, f2] = x;\r\n                    const mapping = this._mapping;\r\n                    const y0 = mapping.get(f0);\r\n                    if (y0 != null) {\r\n                        const y1 = y0.mapping.get(f1);\r\n                        if (y1 != null) {\r\n                            const y2 = y1.mapping.get(f2);\r\n                            if (y2 != null)\r\n                                return y2.value;\r\n                        }\r\n                    }\r\n                    return NaN;\r\n                }\r\n                default:\r\n                    assert_1.unreachable();\r\n            }\r\n        }\r\n        // convert a string factor into a synthetic coordinate\r\n        synthetic(x) {\r\n            if (types_2.isNumber(x))\r\n                return x;\r\n            if (types_2.isString(x))\r\n                return this._lookup([x]);\r\n            let offset = 0;\r\n            const off = x[x.length - 1];\r\n            if (types_2.isNumber(off)) {\r\n                offset = off;\r\n                x = x.slice(0, -1);\r\n            }\r\n            return this._lookup(x) + offset;\r\n        }\r\n        // convert an array of string factors into synthetic coordinates\r\n        v_synthetic(xs) {\r\n            const n = xs.length;\r\n            const array = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                array[i] = this.synthetic(xs[i]);\r\n            }\r\n            return array;\r\n        }\r\n        _init(silent) {\r\n            const { levels, mapping, tops, mids, inside_padding } = (() => {\r\n                if (array_1.every(this.factors, types_2.isString)) {\r\n                    const factors = this.factors;\r\n                    const [mapping, inside_padding] = map_one_level(factors, this.factor_padding);\r\n                    const tops = null;\r\n                    const mids = null;\r\n                    return { levels: 1, mapping, tops, mids, inside_padding };\r\n                }\r\n                else if (array_1.every(this.factors, (x) => types_2.isArray(x) && x.length == 2 && types_2.isString(x[0]) && types_2.isString(x[1]))) {\r\n                    const factors = this.factors;\r\n                    const [mapping, inside_padding] = map_two_levels(factors, this.group_padding, this.factor_padding);\r\n                    const tops = [...mapping.keys()];\r\n                    const mids = null;\r\n                    return { levels: 2, mapping, tops, mids, inside_padding };\r\n                }\r\n                else if (array_1.every(this.factors, (x) => types_2.isArray(x) && x.length == 3 && types_2.isString(x[0]) && types_2.isString(x[1]) && types_2.isString(x[2]))) {\r\n                    const factors = this.factors;\r\n                    const [mapping, inside_padding] = map_three_levels(factors, this.group_padding, this.subgroup_padding, this.factor_padding);\r\n                    const tops = [...mapping.keys()];\r\n                    const mids = [];\r\n                    for (const [f0, L2] of mapping) {\r\n                        for (const f1 of L2.mapping.keys()) {\r\n                            mids.push([f0, f1]);\r\n                        }\r\n                    }\r\n                    return { levels: 3, mapping, tops, mids, inside_padding };\r\n                }\r\n                else\r\n                    assert_1.unreachable();\r\n            })();\r\n            this._mapping = mapping;\r\n            this.tops = tops;\r\n            this.mids = mids;\r\n            let start = 0;\r\n            let end = this.factors.length + inside_padding;\r\n            if (this.range_padding_units == \"percent\") {\r\n                const half_span = (end - start) * this.range_padding / 2;\r\n                start -= half_span;\r\n                end += half_span;\r\n            }\r\n            else {\r\n                start -= this.range_padding;\r\n                end += this.range_padding;\r\n            }\r\n            this.setv({ start, end, levels }, { silent });\r\n            if (this.bounds == \"auto\")\r\n                this.setv({ bounds: [start, end] }, { silent: true });\r\n        }\r\n    }\r\n    exports.FactorRange = FactorRange;\r\n    FactorRange.__name__ = \"FactorRange\";\r\n    FactorRange.init_FactorRange();\r\n}\r\n","/* models\\ranges\\range.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class Range extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.have_updated_interactively = false;\r\n        }\r\n        static init_Range() {\r\n            this.define({\r\n                bounds: [p.Any],\r\n                min_interval: [p.Any],\r\n                max_interval: [p.Any],\r\n            });\r\n            this.internal({\r\n                plots: [p.Array, []],\r\n            });\r\n        }\r\n        get is_reversed() {\r\n            return this.start > this.end;\r\n        }\r\n        get is_valid() {\r\n            return !isNaN(this.min) && !isNaN(this.max);\r\n        }\r\n    }\r\n    exports.Range = Range;\r\n    Range.__name__ = \"Range\";\r\n    Range.init_Range();\r\n}\r\n","/* models\\glyphs\\utils.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    function generic_line_legend(visuals, ctx, { x0, x1, y0, y1 }, index) {\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.moveTo(x0, (y0 + y1) / 2);\r\n        ctx.lineTo(x1, (y0 + y1) / 2);\r\n        if (visuals.line.doit) {\r\n            visuals.line.set_vectorize(ctx, index);\r\n            ctx.stroke();\r\n        }\r\n        ctx.restore();\r\n    }\r\n    exports.generic_line_legend = generic_line_legend;\r\n    function generic_area_legend(visuals, ctx, { x0, x1, y0, y1 }, index) {\r\n        const w = Math.abs(x1 - x0);\r\n        const dw = w * 0.1;\r\n        const h = Math.abs(y1 - y0);\r\n        const dh = h * 0.1;\r\n        const sx0 = x0 + dw;\r\n        const sx1 = x1 - dw;\r\n        const sy0 = y0 + dh;\r\n        const sy1 = y1 - dh;\r\n        if (visuals.fill.doit) {\r\n            visuals.fill.set_vectorize(ctx, index);\r\n            ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\r\n        }\r\n        if (visuals.hatch != null && visuals.hatch.doit) {\r\n            visuals.hatch.set_vectorize(ctx, index);\r\n            ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\r\n        }\r\n        if (visuals.line && visuals.line.doit) {\r\n            ctx.beginPath();\r\n            ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);\r\n            visuals.line.set_vectorize(ctx, index);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    exports.generic_area_legend = generic_area_legend;\r\n    function line_interpolation(renderer, geometry, x2, y2, x3, y3) {\r\n        const { sx, sy } = geometry;\r\n        let x0, x1;\r\n        let y0, y1;\r\n        if (geometry.type == 'point') {\r\n            // The +/- adjustments here are to dilate the hit point into a virtual \"segment\" to use below\r\n            [y0, y1] = renderer.yscale.r_invert(sy - 1, sy + 1);\r\n            [x0, x1] = renderer.xscale.r_invert(sx - 1, sx + 1);\r\n        }\r\n        else {\r\n            // The +/- adjustments here are to handle cases such as purely horizontal or vertical lines\r\n            if (geometry.direction == 'v') {\r\n                [y0, y1] = renderer.yscale.r_invert(sy, sy);\r\n                [x0, x1] = [Math.min(x2 - 1, x3 - 1), Math.max(x2 + 1, x3 + 1)];\r\n            }\r\n            else {\r\n                [x0, x1] = renderer.xscale.r_invert(sx, sx);\r\n                [y0, y1] = [Math.min(y2 - 1, y3 - 1), Math.max(y2 + 1, y3 + 1)];\r\n            }\r\n        }\r\n        const { x, y } = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\r\n        return [x, y]; // XXX: null is not handled at use sites\r\n    }\r\n    exports.line_interpolation = line_interpolation;\r\n}\r\n","/* core\\hittest.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function point_in_poly(x, y, px, py) {\r\n        let inside = false;\r\n        let x1 = px[px.length - 1];\r\n        let y1 = py[py.length - 1];\r\n        for (let i = 0; i < px.length; i++) {\r\n            const x2 = px[i];\r\n            const y2 = py[i];\r\n            if ((y1 < y) != (y2 < y)) {\r\n                if ((x1 + (y - y1) / (y2 - y1) * (x2 - x1)) < x)\r\n                    inside = !inside;\r\n            }\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n        return inside;\r\n    }\r\n    exports.point_in_poly = point_in_poly;\r\n    function point_in_ellipse(x, y, angle, b, a, x0, y0) {\r\n        const A = ((Math.cos(angle) / a) ** 2 + (Math.sin(angle) / b) ** 2);\r\n        const B = 2 * Math.cos(angle) * Math.sin(angle) * ((1 / a) ** 2 - (1 / b) ** 2);\r\n        const C = ((Math.cos(angle) / b) ** 2 + (Math.sin(angle) / a) ** 2);\r\n        const eqn = A * (x - x0) ** 2 + B * (x - x0) * (y - y0) + C * (y - y0) ** 2;\r\n        const inside = eqn <= 1;\r\n        return inside;\r\n    }\r\n    exports.point_in_ellipse = point_in_ellipse;\r\n    function dist_2_pts(p0, p1) {\r\n        return (p0.x - p1.x) ** 2 + (p0.y - p1.y) ** 2;\r\n    }\r\n    exports.dist_2_pts = dist_2_pts;\r\n    function dist_to_segment_squared(p, v, w) {\r\n        const l2 = dist_2_pts(v, w);\r\n        if (l2 == 0)\r\n            return dist_2_pts(p, v);\r\n        const t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\r\n        if (t < 0)\r\n            return dist_2_pts(p, v);\r\n        if (t > 1)\r\n            return dist_2_pts(p, w);\r\n        const q = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };\r\n        return dist_2_pts(p, q);\r\n    }\r\n    exports.dist_to_segment_squared = dist_to_segment_squared;\r\n    function dist_to_segment(p, v, w) {\r\n        return Math.sqrt(dist_to_segment_squared(p, v, w));\r\n    }\r\n    exports.dist_to_segment = dist_to_segment;\r\n    function check_2_segments_intersect(l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {\r\n        /*\r\n         *  Check if 2 segments (l0 and l1) intersect. Returns a structure with\r\n         *  the following attributes:\r\n         *   * hit (boolean): whether the 2 segments intersect\r\n         *   * x (float): x coordinate of the intersection point\r\n         *   * y (float): y coordinate of the intersection point\r\n         */\r\n        const den = ((l1_y1 - l1_y0) * (l0_x1 - l0_x0)) - ((l1_x1 - l1_x0) * (l0_y1 - l0_y0));\r\n        if (den == 0) {\r\n            return { hit: false, x: null, y: null };\r\n        }\r\n        else {\r\n            let a = l0_y0 - l1_y0;\r\n            let b = l0_x0 - l1_x0;\r\n            const num1 = ((l1_x1 - l1_x0) * a) - ((l1_y1 - l1_y0) * b);\r\n            const num2 = ((l0_x1 - l0_x0) * a) - ((l0_y1 - l0_y0) * b);\r\n            a = num1 / den;\r\n            b = num2 / den;\r\n            const x = l0_x0 + (a * (l0_x1 - l0_x0));\r\n            const y = l0_y0 + (a * (l0_y1 - l0_y0));\r\n            return { hit: (a > 0 && a < 1) && (b > 0 && b < 1), x, y };\r\n        }\r\n    }\r\n    exports.check_2_segments_intersect = check_2_segments_intersect;\r\n}\r\n","/* models\\glyphs\\webgl\\line.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const utils_1 = require(103) /* ./utils */;\r\n    const base_1 = require(107) /* ./base */;\r\n    const line_vert_1 = require(108) /* ./line.vert */;\r\n    const line_frag_1 = require(109) /* ./line.frag */;\r\n    const color_1 = require(22) /* ../../../core/util/color */;\r\n    class DashAtlas {\r\n        constructor(gl) {\r\n            this._atlas = new Map();\r\n            this._width = 256;\r\n            this._height = 256;\r\n            // Init texture\r\n            this.tex = new utils_1.Texture2d(gl);\r\n            this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\r\n            this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\r\n            this.tex.set_size([this._width, this._height], gl.RGBA);\r\n            this.tex.set_data([0, 0], [this._width, this._height], new Uint8Array(4 * this._width * this._height));\r\n            // Init with solid line (index 0 is reserved for this)\r\n            this.get_atlas_data([1]);\r\n        }\r\n        get_atlas_data(pattern) {\r\n            const key = pattern.join(\"-\");\r\n            let atlas_data = this._atlas.get(key);\r\n            if (atlas_data == null) {\r\n                const [data, period] = this.make_pattern(pattern);\r\n                const index = this._atlas.size;\r\n                this.tex.set_data([0, index], [this._width, 1], new Uint8Array(data.map((x) => x + 10)));\r\n                atlas_data = [index / this._height, period];\r\n                this._atlas.set(key, atlas_data);\r\n            }\r\n            return atlas_data;\r\n        }\r\n        make_pattern(pattern) {\r\n            // A pattern is defined as on/off sequence of segments\r\n            // It must be a multiple of 2\r\n            if (pattern.length > 1 && pattern.length % 2) {\r\n                pattern = pattern.concat(pattern);\r\n            }\r\n            // Period is sum of elements\r\n            let period = 0;\r\n            for (const v of pattern) {\r\n                period += v;\r\n            }\r\n            // Find all start and end of on-segment only\r\n            const C = [];\r\n            let c = 0;\r\n            for (let i = 0, end = pattern.length + 2; i < end; i += 2) {\r\n                const a = Math.max(0.0001, pattern[i % pattern.length]);\r\n                const b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\r\n                C.push(c, c + a);\r\n                c += a + b;\r\n            }\r\n            // Build pattern\r\n            const n = this._width;\r\n            const Z = new Float32Array(n * 4);\r\n            for (let i = 0, end = n; i < end; i++) {\r\n                let dash_end, dash_start, dash_type;\r\n                const x = (period * i) / (n - 1);\r\n                // get index at min - index = np.argmin(abs(C-(x)))\r\n                let index = 0;\r\n                let val_at_index = 1e16;\r\n                for (let j = 0, endj = C.length; j < endj; j++) {\r\n                    const val = Math.abs(C[j] - x);\r\n                    if (val < val_at_index) {\r\n                        index = j;\r\n                        val_at_index = val;\r\n                    }\r\n                }\r\n                if ((index % 2) === 0) {\r\n                    dash_type = (x <= C[index]) ? +1 : 0;\r\n                    dash_start = C[index];\r\n                    dash_end = C[index + 1];\r\n                }\r\n                else {\r\n                    dash_type = (x > C[index]) ? -1 : 0;\r\n                    dash_start = C[index - 1];\r\n                    dash_end = C[index];\r\n                }\r\n                Z[(i * 4) + 0] = C[index];\r\n                Z[(i * 4) + 1] = dash_type;\r\n                Z[(i * 4) + 2] = dash_start;\r\n                Z[(i * 4) + 3] = dash_end;\r\n            }\r\n            return [Z, period];\r\n        }\r\n    }\r\n    DashAtlas.__name__ = \"DashAtlas\";\r\n    const joins = { miter: 0, round: 1, bevel: 2 };\r\n    const caps = {\r\n        '': 0, none: 0, '.': 0,\r\n        round: 1, ')': 1, '(': 1, o: 1,\r\n        'triangle in': 2, '<': 2,\r\n        'triangle out': 3, '>': 3,\r\n        square: 4, '[': 4, ']': 4, '=': 4,\r\n        butt: 5, '|': 5,\r\n    };\r\n    class LineGL extends base_1.BaseGLGlyph {\r\n        init() {\r\n            const { gl } = this;\r\n            this._scale_aspect = 0; // keep track, so we know when we need to update segment data\r\n            const vert = line_vert_1.vertex_shader;\r\n            const frag = line_frag_1.fragment_shader;\r\n            // The program\r\n            this.prog = new utils_1.Program(gl);\r\n            this.prog.set_shaders(vert, frag);\r\n            this.index_buffer = new utils_1.IndexBuffer(gl);\r\n            // Buffers\r\n            this.vbo_position = new utils_1.VertexBuffer(gl);\r\n            this.vbo_tangents = new utils_1.VertexBuffer(gl);\r\n            this.vbo_segment = new utils_1.VertexBuffer(gl);\r\n            this.vbo_angles = new utils_1.VertexBuffer(gl);\r\n            this.vbo_texcoord = new utils_1.VertexBuffer(gl);\r\n            // Dash atlas\r\n            this.dash_atlas = new DashAtlas(gl);\r\n        }\r\n        draw(indices, mainGlyph, trans) {\r\n            const mainGlGlyph = mainGlyph.glglyph;\r\n            if (mainGlGlyph.data_changed) {\r\n                mainGlGlyph._set_data();\r\n                mainGlGlyph.data_changed = false;\r\n            }\r\n            if (this.visuals_changed) {\r\n                this._set_visuals();\r\n                this.visuals_changed = false;\r\n            }\r\n            mainGlGlyph._update_scale(1, 1);\r\n            this._scale_aspect = 1;\r\n            // Select buffers from main glyph\r\n            // (which may be this glyph but maybe not if this is a (non)selection glyph)\r\n            this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\r\n            this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\r\n            this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\r\n            this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\r\n            this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\r\n            //\r\n            this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\r\n            this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\r\n            // Handle transformation to device coordinates\r\n            this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\r\n            this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\r\n            this.prog.set_uniform('u_scale_aspect', 'vec2', [1, 1]);\r\n            this.prog.set_uniform('u_scale_length', 'float', [Math.sqrt(2)]);\r\n            this.I_triangles = mainGlGlyph.I_triangles;\r\n            if (this.I_triangles.length < 65535) {\r\n                // Data is small enough to draw in one pass\r\n                this.index_buffer.set_size(this.I_triangles.length * 2);\r\n                this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\r\n                this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\r\n                // @prog.draw(@gl.LINE_STRIP, @index_buffer)  # Use this to draw the line skeleton\r\n            }\r\n            else {\r\n                // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\r\n                // First collect indices in chunks\r\n                indices = Array.from(this.I_triangles);\r\n                const nvertices = this.I_triangles.length;\r\n                const chunksize = 64008; // 65536 max. 64008 is divisible by 12\r\n                const chunks = [];\r\n                for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\r\n                    chunks.push([]);\r\n                }\r\n                for (let i = 0, end = indices.length; i < end; i++) {\r\n                    const uint16_index = indices[i] % chunksize;\r\n                    const chunk = Math.floor(indices[i] / chunksize);\r\n                    chunks[chunk].push(uint16_index);\r\n                }\r\n                // Then draw each chunk\r\n                for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\r\n                    const these_indices = new Uint16Array(chunks[chunk]);\r\n                    const offset = chunk * chunksize * 4;\r\n                    if (these_indices.length === 0) {\r\n                        continue;\r\n                    }\r\n                    this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\r\n                    this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\r\n                    this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\r\n                    this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\r\n                    this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\r\n                    // The actual drawing\r\n                    this.index_buffer.set_size(these_indices.length * 2);\r\n                    this.index_buffer.set_data(0, these_indices);\r\n                    this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\r\n                }\r\n            }\r\n        }\r\n        _set_data() {\r\n            this._bake();\r\n            this.vbo_position.set_size(this.V_position.length * 4);\r\n            this.vbo_position.set_data(0, this.V_position);\r\n            this.vbo_tangents.set_size(this.V_tangents.length * 4);\r\n            this.vbo_tangents.set_data(0, this.V_tangents);\r\n            this.vbo_angles.set_size(this.V_angles.length * 4);\r\n            this.vbo_angles.set_data(0, this.V_angles);\r\n            this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\r\n            this.vbo_texcoord.set_data(0, this.V_texcoord);\r\n        }\r\n        _set_visuals() {\r\n            const color = color_1.color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\r\n            const cap = caps[this.glyph.visuals.line.line_cap.value()];\r\n            const join = joins[this.glyph.visuals.line.line_join.value()];\r\n            this.prog.set_uniform('u_color', 'vec4', color);\r\n            this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\r\n            this.prog.set_uniform('u_antialias', 'float', [0.9]); // Smaller aa-region to obtain crisper images\r\n            this.prog.set_uniform('u_linecaps', 'vec2', [cap, cap]);\r\n            this.prog.set_uniform('u_linejoin', 'float', [join]);\r\n            this.prog.set_uniform('u_miter_limit', 'float', [10.0]); // 10 should be a good value\r\n            // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\r\n            const dash_pattern = this.glyph.visuals.line.line_dash.value();\r\n            let dash_index = 0;\r\n            let dash_period = 1;\r\n            if (dash_pattern.length) {\r\n                [dash_index, dash_period] = this.dash_atlas.get_atlas_data(dash_pattern);\r\n            }\r\n            this.prog.set_uniform('u_dash_index', 'float', [dash_index]); // 0 means solid line\r\n            this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\r\n            this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\r\n            this.prog.set_uniform('u_dash_caps', 'vec2', [cap, cap]);\r\n            this.prog.set_uniform('u_closed', 'float', [0]); // We dont do closed lines\r\n        }\r\n        _bake() {\r\n            // This is what you get if you port 50 lines of numpy code to JS.\r\n            // V_segment is handled in another method, because it depends on the aspect\r\n            // ratio of the scale (The original paper/code assumed isotropic scaling).\r\n            //\r\n            // Buffer dtype from the Python implementation:\r\n            //\r\n            // self.vtype = np.dtype( [('a_position', 'f4', 2),\r\n            //                         ('a_segment',  'f4', 2),\r\n            //                         ('a_angles',   'f4', 2),\r\n            //                         ('a_tangents', 'f4', 4),\r\n            //                         ('a_texcoord', 'f4', 2) ])\r\n            // Init array of implicit shape nx2\r\n            let I, T, V_angles2, V_position2, V_tangents2, V_texcoord2, Vp, Vt;\r\n            const n = this.nvertices;\r\n            const sx = this.glyph.sx;\r\n            const sy = this.glyph.sy;\r\n            // Init vertex data\r\n            const V_position = (Vp = new Float32Array(n * 2));\r\n            //V_segment = new Float32Array(n*2)  # Done later\r\n            const V_angles = new Float32Array(n * 2);\r\n            const V_tangents = (Vt = new Float32Array(n * 4)); // mind the 4!\r\n            // Position\r\n            for (let i = 0, end = n; i < end; i++) {\r\n                V_position[(i * 2) + 0] = sx[i];\r\n                V_position[(i * 2) + 1] = sy[i];\r\n            }\r\n            // Tangents & norms (need tangents to calculate segments based on scale)\r\n            this.tangents = (T = new Float32Array((n * 2) - 2));\r\n            for (let i = 0, end = n - 1; i < end; i++) {\r\n                T[(i * 2) + 0] = Vp[((i + 1) * 2) + 0] - Vp[(i * 2) + 0];\r\n                T[(i * 2) + 1] = Vp[((i + 1) * 2) + 1] - Vp[(i * 2) + 1];\r\n            }\r\n            for (let i = 0, end = n - 1; i < end; i++) {\r\n                // V['a_tangents'][+1:, :2] = T\r\n                V_tangents[((i + 1) * 4) + 0] = T[(i * 2) + 0];\r\n                V_tangents[((i + 1) * 4) + 1] = T[(i * 2) + 1];\r\n                // V['a_tangents'][:-1, 2:] = T\r\n                V_tangents[(i * 4) + 2] = T[(i * 2) + 0];\r\n                V_tangents[(i * 4) + 3] = T[(i * 2) + 1];\r\n            }\r\n            // V['a_tangents'][0  , :2] = T[0]\r\n            V_tangents[(0 * 4) + 0] = T[0];\r\n            V_tangents[(0 * 4) + 1] = T[1];\r\n            // V['a_tangents'][ -1, 2:] = T[-1]\r\n            V_tangents[((n - 1) * 4) + 2] = T[((n - 2) * 2) + 0];\r\n            V_tangents[((n - 1) * 4) + 3] = T[((n - 2) * 2) + 1];\r\n            // Angles\r\n            const A = new Float32Array(n);\r\n            for (let i = 0, end = n; i < end; i++) {\r\n                A[i] = Math.atan2((Vt[(i * 4) + 0] * Vt[(i * 4) + 3]) - (Vt[(i * 4) + 1] * Vt[(i * 4) + 2]), (Vt[(i * 4) + 0] * Vt[(i * 4) + 2]) + (Vt[(i * 4) + 1] * Vt[(i * 4) + 3]));\r\n            }\r\n            for (let i = 0, end = n - 1; i < end; i++) {\r\n                V_angles[(i * 2) + 0] = A[i];\r\n                V_angles[(i * 2) + 1] = A[i + 1];\r\n            }\r\n            // Step 1: A -- B -- C  =>  A -- B, B' -- C\r\n            // Repeat our array 4 times\r\n            const m = (4 * n) - 4;\r\n            this.V_position = (V_position2 = new Float32Array(m * 2));\r\n            this.V_angles = (V_angles2 = new Float32Array(m * 2));\r\n            this.V_tangents = (V_tangents2 = new Float32Array(m * 4)); // mind the 4!\r\n            this.V_texcoord = (V_texcoord2 = new Float32Array(m * 2));\r\n            const o = 2;\r\n            //\r\n            // Arg, we really need an ndarray thing in JS :/\r\n            for (let i = 0, end = n; i < end; i++) { // all nodes on the line\r\n                for (let j = 0; j < 4; j++) { // the four quad vertices\r\n                    for (let k = 0; k < 2; k++) { // xy\r\n                        V_position2[((((i * 4) + j) - o) * 2) + k] = V_position[(i * 2) + k];\r\n                        V_angles2[(((i * 4) + j) * 2) + k] = V_angles[(i * 2) + k];\r\n                    } // no offset\r\n                    for (let k = 0; k < 4; k++) {\r\n                        V_tangents2[((((i * 4) + j) - o) * 4) + k] = V_tangents[(i * 4) + k];\r\n                    }\r\n                }\r\n            }\r\n            for (let i = 0, end = n; i < end; i++) {\r\n                V_texcoord2[(((i * 4) + 0) * 2) + 0] = -1;\r\n                V_texcoord2[(((i * 4) + 1) * 2) + 0] = -1;\r\n                V_texcoord2[(((i * 4) + 2) * 2) + 0] = +1;\r\n                V_texcoord2[(((i * 4) + 3) * 2) + 0] = +1;\r\n                //\r\n                V_texcoord2[(((i * 4) + 0) * 2) + 1] = -1;\r\n                V_texcoord2[(((i * 4) + 1) * 2) + 1] = +1;\r\n                V_texcoord2[(((i * 4) + 2) * 2) + 1] = -1;\r\n                V_texcoord2[(((i * 4) + 3) * 2) + 1] = +1;\r\n            }\r\n            // Indices\r\n            //I = np.resize( np.array([0,1,2,1,2,3], dtype=np.uint32), (n-1)*(2*3))\r\n            //I += np.repeat( 4*np.arange(n-1), 6)\r\n            const ni = (n - 1) * 6;\r\n            this.I_triangles = (I = new Uint32Array(ni));\r\n            // Order of indices is such that drawing as line_strip reveals the line skeleton\r\n            // Might have implications on culling, if we ever turn that on.\r\n            // Order in paper was: 0 1 2 1 2 3\r\n            for (let i = 0, end = n; i < end; i++) {\r\n                I[(i * 6) + 0] = 0 + (4 * i);\r\n                I[(i * 6) + 1] = 1 + (4 * i);\r\n                I[(i * 6) + 2] = 3 + (4 * i);\r\n                I[(i * 6) + 3] = 2 + (4 * i);\r\n                I[(i * 6) + 4] = 0 + (4 * i);\r\n                I[(i * 6) + 5] = 3 + (4 * i);\r\n            }\r\n        }\r\n        _update_scale(sx, sy) {\r\n            // Update segment data and cumsum so the length along the line has the\r\n            // scale aspect ratio in it. In the vertex shader we multiply with the\r\n            // \"isotropic part\" of the scale.\r\n            let V_segment2;\r\n            const n = this.nvertices;\r\n            const m = (4 * n) - 4;\r\n            // Prepare arrays\r\n            const T = this.tangents;\r\n            const N = new Float32Array(n - 1);\r\n            const V_segment = new Float32Array(n * 2); // Elements are initialized with 0\r\n            this.V_segment = (V_segment2 = new Float32Array(m * 2));\r\n            // Calculate vector lengths - with scale aspect ratio taken into account\r\n            for (let i = 0, end = n - 1; i < end; i++) {\r\n                N[i] = Math.sqrt((T[(i * 2) + 0] * sx) ** 2 + (T[(i * 2) + 1] * sy) ** 2);\r\n            }\r\n            // Calculate Segments\r\n            let cumsum = 0;\r\n            for (let i = 0, end = n - 1; i < end; i++) {\r\n                cumsum += N[i];\r\n                V_segment[((i + 1) * 2) + 0] = cumsum;\r\n                V_segment[(i * 2) + 1] = cumsum;\r\n            }\r\n            // Upscale (same loop as in _bake())\r\n            for (let i = 0, end = n; i < end; i++) {\r\n                for (let j = 0; j < 4; j++) {\r\n                    for (let k = 0; k < 2; k++) {\r\n                        V_segment2[(((i * 4) + j) * 2) + k] = V_segment[(i * 2) + k];\r\n                    }\r\n                }\r\n            }\r\n            // Update\r\n            this.cumsum = cumsum; // L[-1] in Nico's code\r\n            this.vbo_segment.set_size(this.V_segment.length * 4);\r\n            this.vbo_segment.set_data(0, this.V_segment);\r\n        }\r\n    }\r\n    exports.LineGL = LineGL;\r\n    LineGL.__name__ = \"LineGL\";\r\n}\r\n","/* models\\glyphs\\webgl\\utils\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var program_1 = require(104) /* ./program */;\r\n    exports.Program = program_1.Program;\r\n    var texture_1 = require(106) /* ./texture */;\r\n    exports.Texture2d = texture_1.Texture2d;\r\n    var buffer_1 = require(105) /* ./buffer */;\r\n    exports.IndexBuffer = buffer_1.IndexBuffer;\r\n    exports.VertexBuffer = buffer_1.VertexBuffer;\r\n}\r\n","/* models\\glyphs\\webgl\\utils\\program.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const buffer_1 = require(105) /* ./buffer */;\r\n    class Program {\r\n        constructor(gl) {\r\n            this.gl = gl;\r\n            this.UTYPEMAP = {\r\n                float: \"uniform1fv\",\r\n                vec2: \"uniform2fv\",\r\n                vec3: \"uniform3fv\",\r\n                vec4: \"uniform4fv\",\r\n                int: \"uniform1iv\",\r\n                ivec2: \"uniform2iv\",\r\n                ivec3: \"uniform3iv\",\r\n                ivec4: \"uniform4iv\",\r\n                bool: \"uniform1iv\",\r\n                bvec2: \"uniform2iv\",\r\n                bvec3: \"uniform3iv\",\r\n                bvec4: \"uniform4iv\",\r\n                mat2: \"uniformMatrix2fv\",\r\n                mat3: \"uniformMatrix3fv\",\r\n                mat4: \"uniformMatrix4fv\",\r\n                sampler1D: \"uniform1i\",\r\n                sampler2D: \"uniform1i\",\r\n                sampler3D: \"uniform1i\",\r\n            };\r\n            this.ATYPEMAP = {\r\n                float: \"vertexAttrib1f\",\r\n                vec2: \"vertexAttrib2f\",\r\n                vec3: \"vertexAttrib3f\",\r\n                vec4: \"vertexAttrib4f\",\r\n            };\r\n            this.ATYPEINFO = {\r\n                float: [1, 5126],\r\n                vec2: [2, 5126],\r\n                vec3: [3, 5126],\r\n                vec4: [4, 5126],\r\n            };\r\n            this._linked = false;\r\n            this._validated = false;\r\n            this._unset_variables = new Set();\r\n            this._known_invalid = new Set();\r\n            this._locations = new Map();\r\n            this._samplers = new Map();\r\n            this._attributes = new Map();\r\n            this.handle = this.gl.createProgram();\r\n        }\r\n        delete() {\r\n            this.gl.deleteProgram(this.handle);\r\n        }\r\n        activate() {\r\n            this.gl.useProgram(this.handle);\r\n        }\r\n        deactivate() {\r\n            this.gl.useProgram(0);\r\n        }\r\n        set_shaders(vert, frag) {\r\n            // Set GLSL code for the vertex and fragment shader.\r\n            //\r\n            // This function takes care of setting the shading code and\r\n            // compiling+linking it into a working program object that is ready\r\n            // to use.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // vert : str\r\n            //     GLSL code for the vertex shader.\r\n            // frag : str\r\n            //     GLSL code for the fragment shader.\r\n            const gl = this.gl;\r\n            this._linked = false;\r\n            const vert_handle = gl.createShader(gl.VERTEX_SHADER);\r\n            const frag_handle = gl.createShader(gl.FRAGMENT_SHADER);\r\n            const tmp = [\r\n                [vert, vert_handle, \"vertex\"],\r\n                [frag, frag_handle, \"fragment\"],\r\n            ];\r\n            for (const [code, handle, type] of tmp) {\r\n                gl.shaderSource(handle, code);\r\n                gl.compileShader(handle);\r\n                const status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);\r\n                if (!status) {\r\n                    const errors = gl.getShaderInfoLog(handle);\r\n                    throw new Error(`errors in ${type} shader:\\n${errors}`);\r\n                }\r\n            }\r\n            gl.attachShader(this.handle, vert_handle);\r\n            gl.attachShader(this.handle, frag_handle);\r\n            gl.linkProgram(this.handle);\r\n            if (!gl.getProgramParameter(this.handle, gl.LINK_STATUS)) {\r\n                const logs = gl.getProgramInfoLog(this.handle);\r\n                throw new Error(`Program link error:\\n${logs}`);\r\n            }\r\n            this._unset_variables = this._get_active_attributes_and_uniforms();\r\n            gl.detachShader(this.handle, vert_handle);\r\n            gl.detachShader(this.handle, frag_handle);\r\n            gl.deleteShader(vert_handle);\r\n            gl.deleteShader(frag_handle);\r\n            this._known_invalid.clear();\r\n            this._linked = true;\r\n        }\r\n        _get_active_attributes_and_uniforms() {\r\n            // Retrieve active attributes and uniforms to be able to check that\r\n            // all uniforms/attributes are set by the user.\r\n            const gl = this.gl;\r\n            this._locations.clear();\r\n            const regex = new RegExp(\"(\\\\w+)\\\\s*(\\\\[(\\\\d+)\\\\])\\\\s*\");\r\n            const cu = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\r\n            const ca = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\r\n            const attributes = [];\r\n            const uniforms = [];\r\n            const stub5_seq = [\r\n                [attributes, ca, gl.getActiveAttrib, gl.getAttribLocation],\r\n                [uniforms, cu, gl.getActiveUniform, gl.getUniformLocation],\r\n            ];\r\n            for (const [container, count, getActive, getLocation] of stub5_seq) {\r\n                for (let i = 0; i < count; i += 1) {\r\n                    const info = getActive.call(gl, this.handle, i);\r\n                    const name = info.name;\r\n                    const m = name.match(regex);\r\n                    if (m != null) {\r\n                        const name = m[1];\r\n                        for (let j = 0; j < info.size; j += 1) {\r\n                            container.push([`${name}[${j}]`, info.type]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        container.push([name, info.type]);\r\n                    }\r\n                    this._locations.set(name, getLocation.call(gl, this.handle, name));\r\n                }\r\n            }\r\n            const attrs_and_uniforms = new Set();\r\n            for (const [name] of attributes) {\r\n                attrs_and_uniforms.add(name);\r\n            }\r\n            for (const [name] of uniforms) {\r\n                attrs_and_uniforms.add(name);\r\n            }\r\n            return attrs_and_uniforms;\r\n        }\r\n        set_texture(name, value) {\r\n            var _a;\r\n            // Set a texture sampler.\r\n            //\r\n            // A texture is a 2 dimensional grid of colors/intensities that\r\n            // can be applied to a face (or used for other means by providing\r\n            // a regular grid of data).\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // name : str\r\n            //     The name by which the texture is known in the GLSL code.\r\n            // value : Texture2d\r\n            //     The Texture2d object to bind.\r\n            if (!this._linked) {\r\n                throw new Error(\"Cannot set uniform when program has no code\");\r\n            }\r\n            const handle = (_a = this._locations.get(name)) !== null && _a !== void 0 ? _a : -1;\r\n            if (handle < 0) {\r\n                if (!this._known_invalid.has(name)) {\r\n                    this._known_invalid.add(name);\r\n                    console.log(`\"Variable ${name} is not an active texture`);\r\n                }\r\n                return;\r\n            }\r\n            if (this._unset_variables.has(name)) {\r\n                this._unset_variables.delete(name);\r\n            }\r\n            this.activate();\r\n            if (true) {\r\n                let unit = this._samplers.size;\r\n                if (this._samplers.has(name)) {\r\n                    unit = this._samplers.get(name)[2];\r\n                }\r\n                this._samplers.set(name, [value._target, value.handle, unit]);\r\n                this.gl.uniform1i(handle, unit);\r\n            }\r\n        }\r\n        set_uniform(name, type_, value) {\r\n            var _a;\r\n            // Set a uniform value.\r\n            //\r\n            // A uniform is a value that is global to both the vertex and\r\n            // fragment shader.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // name : str\r\n            //     The name by which the uniform is known in the GLSL code.\r\n            // type_ : str\r\n            //     The type of the uniform, e.g. 'float', 'vec2', etc.\r\n            // value : list of scalars\r\n            //     The value for the uniform. Should be a list even for type float.\r\n            if (!this._linked) {\r\n                throw new Error(\"Cannot set uniform when program has no code\");\r\n            }\r\n            const handle = (_a = this._locations.get(name)) !== null && _a !== void 0 ? _a : -1;\r\n            if (handle < 0) {\r\n                if (!this._known_invalid.has(name)) {\r\n                    this._known_invalid.add(name);\r\n                    console.log(`Variable ${name} is not an active uniform`);\r\n                }\r\n                return;\r\n            }\r\n            if (this._unset_variables.has(name)) {\r\n                this._unset_variables.delete(name);\r\n            }\r\n            let count = 1;\r\n            if (!type_.startsWith(\"mat\")) {\r\n                const a_type = type_ == \"int\" || type_ == \"bool\" ? \"float\" : type_.replace(/^ib/, \"\");\r\n                count = Math.floor(value.length / (this.ATYPEINFO[a_type][0]));\r\n            }\r\n            if (count > 1) {\r\n                for (let j = 0; j < count; j += 1) {\r\n                    if (this._unset_variables.has(`${name}[${j}]`)) {\r\n                        const name_ = `${name}[${j}]`;\r\n                        if (this._unset_variables.has(name_)) {\r\n                            this._unset_variables.delete(name_);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const funcname = this.UTYPEMAP[type_];\r\n            this.activate();\r\n            if (type_.startsWith(\"mat\")) {\r\n                this.gl[funcname](handle, false, value);\r\n            }\r\n            else {\r\n                this.gl[funcname](handle, value);\r\n            }\r\n        }\r\n        set_attribute(name, type_, value, stride = 0, offset = 0) {\r\n            var _a;\r\n            // Set an attribute value.\r\n            //\r\n            // An attribute represents per-vertex data and can only be used\r\n            // in the vertex shader.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // name : str\r\n            //     The name by which the attribute is known in the GLSL code.\r\n            // type_ : str\r\n            //     The type of the attribute, e.g. 'float', 'vec2', etc.\r\n            // value : VertexBuffer, array\r\n            //     If value is a VertexBuffer, it is used (with stride and offset)\r\n            //     for the vertex data. If value is an array, its used to set\r\n            //     the value of all vertices (similar to a uniform).\r\n            // stide : int, default 0\r\n            //     The stride to \"sample\" the vertex data inside the buffer. Unless\r\n            //     multiple vertex data are packed into a single buffer, this should\r\n            //     be zero.\r\n            // offset : int, default 0\r\n            //     The offset to \"sample\" the vertex data inside the buffer. Unless\r\n            //     multiple vertex data are packed into a single buffer, or only\r\n            //     a part of the data must be used, this should probably be zero.\r\n            if (!this._linked) {\r\n                throw new Error(\"Cannot set attribute when program has no code\");\r\n            }\r\n            const handle = (_a = this._locations.get(name)) !== null && _a !== void 0 ? _a : -1;\r\n            if (handle < 0) {\r\n                if (!this._known_invalid.has(name)) {\r\n                    this._known_invalid.add(name);\r\n                    if (value instanceof buffer_1.VertexBuffer && offset > 0) {\r\n                    }\r\n                    else {\r\n                        console.log(`Variable ${name} is not an active attribute`);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            if (this._unset_variables.has(name)) {\r\n                this._unset_variables.delete(name);\r\n            }\r\n            this.activate();\r\n            if (!(value instanceof buffer_1.VertexBuffer)) {\r\n                const funcname = this.ATYPEMAP[type_];\r\n                this._attributes.set(name, [null, handle, funcname, value]);\r\n            }\r\n            else {\r\n                const [size, gtype] = this.ATYPEINFO[type_];\r\n                const funcname = \"vertexAttribPointer\";\r\n                const args = [size, gtype, false, stride, offset];\r\n                this._attributes.set(name, [value.handle, handle, funcname, args]);\r\n            }\r\n        }\r\n        _pre_draw() {\r\n            this.activate();\r\n            for (const [tex_target, tex_handle, unit] of this._samplers.values()) {\r\n                this.gl.activeTexture(this.gl.TEXTURE0 + unit);\r\n                this.gl.bindTexture(tex_target, tex_handle);\r\n            }\r\n            for (const [vbo_handle, attr_handle, funcname, args] of this._attributes.values()) {\r\n                if (vbo_handle != null) {\r\n                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo_handle);\r\n                    this.gl.enableVertexAttribArray(attr_handle);\r\n                    this.gl[funcname].apply(this.gl, [attr_handle, ...args]);\r\n                }\r\n                else {\r\n                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n                    this.gl.disableVertexAttribArray(attr_handle);\r\n                    this.gl[funcname].apply(this.gl, [attr_handle, ...args]);\r\n                }\r\n            }\r\n            if (!this._validated) {\r\n                this._validated = true;\r\n                this._validate();\r\n            }\r\n        }\r\n        _validate() {\r\n            if (this._unset_variables.size) {\r\n                console.log(`Program has unset variables: ${this._unset_variables}`);\r\n            }\r\n            this.gl.validateProgram(this.handle);\r\n            if (!this.gl.getProgramParameter(this.handle, this.gl.VALIDATE_STATUS)) {\r\n                console.log(this.gl.getProgramInfoLog(this.handle));\r\n                throw new Error(\"Program validation error\");\r\n            }\r\n        }\r\n        draw(mode, selection) {\r\n            // Draw the current visualization defined by the program.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // mode : GL enum\r\n            //     Can be POINTS, LINES, LINE_LOOP, LINE_STRIP, LINE_FAN, TRIANGLES\r\n            // selection : 2-element tuple or IndexBuffer\r\n            //     The selection to draw, specified either as (first, count) or an\r\n            //     IndexBuffer object.\r\n            if (!this._linked) {\r\n                throw new Error(\"Cannot draw program if code has not been set\");\r\n            }\r\n            if (selection instanceof buffer_1.IndexBuffer) {\r\n                this._pre_draw();\r\n                selection.activate();\r\n                const count = selection.buffer_size / 2;\r\n                const gtype = this.gl.UNSIGNED_SHORT;\r\n                this.gl.drawElements(mode, count, gtype, 0);\r\n                selection.deactivate();\r\n            }\r\n            else {\r\n                const [first, count] = selection;\r\n                if (count != 0) {\r\n                    this._pre_draw();\r\n                    this.gl.drawArrays(mode, first, count);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.Program = Program;\r\n    Program.__name__ = \"Program\";\r\n}\r\n","/* models\\glyphs\\webgl\\utils\\buffer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class Buffer {\r\n        constructor(gl) {\r\n            this.gl = gl;\r\n            this._usage = 35048;\r\n            this.buffer_size = 0;\r\n            this.handle = this.gl.createBuffer();\r\n        }\r\n        delete() {\r\n            this.gl.deleteBuffer(this.handle);\r\n        }\r\n        activate() {\r\n            this.gl.bindBuffer(this._target, this.handle);\r\n        }\r\n        deactivate() {\r\n            this.gl.bindBuffer(this._target, null);\r\n        }\r\n        set_size(nbytes) {\r\n            // Set the size of the buffer in bytes.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // nbytes : int\r\n            //     The number of bytes that the buffer needs to hold.\r\n            if (nbytes != this.buffer_size) {\r\n                this.activate();\r\n                this.gl.bufferData(this._target, nbytes, this._usage);\r\n                this.buffer_size = nbytes;\r\n            }\r\n        }\r\n        set_data(offset, data) {\r\n            // Set the buffer data.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // offset : int\r\n            //     The offset in bytes for the new data.\r\n            // data : typed array\r\n            //     The data to upload.\r\n            this.activate();\r\n            this.gl.bufferSubData(this._target, offset, data);\r\n        }\r\n    }\r\n    exports.Buffer = Buffer;\r\n    Buffer.__name__ = \"Buffer\";\r\n    class VertexBuffer extends Buffer {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._target = 34962;\r\n        }\r\n    }\r\n    exports.VertexBuffer = VertexBuffer;\r\n    VertexBuffer.__name__ = \"VertexBuffer\";\r\n    class IndexBuffer extends Buffer {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._target = 34963;\r\n        }\r\n    }\r\n    exports.IndexBuffer = IndexBuffer;\r\n    IndexBuffer.__name__ = \"IndexBuffer\";\r\n}\r\n","/* models\\glyphs\\webgl\\utils\\texture.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const assert_1 = require(11) /* ../../../../core/util/assert */;\r\n    class Texture2d {\r\n        constructor(gl) {\r\n            this.gl = gl;\r\n            this._target = 3553;\r\n            this._types = {\r\n                Int8Array: 5120,\r\n                Uint8Array: 5121,\r\n                Int16Array: 5122,\r\n                Uint16Array: 5123,\r\n                Int32Array: 5124,\r\n                Uint32Array: 5125,\r\n                Float32Array: 5126,\r\n            };\r\n            this.handle = this.gl.createTexture();\r\n        }\r\n        delete() {\r\n            this.gl.deleteTexture(this.handle);\r\n        }\r\n        activate() {\r\n            this.gl.bindTexture(this._target, this.handle);\r\n        }\r\n        deactivate() {\r\n            this.gl.bindTexture(this._target, 0);\r\n        }\r\n        _get_alignment(width) {\r\n            // Determines a textures byte alignment. If the width isn't a\r\n            // power of 2 we need to adjust the byte alignment of the image.\r\n            // The image height is unimportant.\r\n            //\r\n            // www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\r\n            const alignments = [4, 8, 2, 1];\r\n            for (const alignment of alignments) {\r\n                if (width % alignment == 0) {\r\n                    return alignment;\r\n                }\r\n            }\r\n            assert_1.unreachable();\r\n        }\r\n        set_wrapping(wrap_s, wrap_t) {\r\n            // Set the texture wrapping mode.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // wrap_s : GL enum\r\n            //     The mode to wrap the x dimension. Valid values are REPEAT\r\n            //     CLAMP_TO_EDGE MIRRORED_REPEAT\r\n            // wrap_t : GL enum\r\n            //     The mode to wrap the y dimension. Same options as for wrap_s.\r\n            this.activate();\r\n            this.gl.texParameterf(this._target, this.gl.TEXTURE_WRAP_S, wrap_s);\r\n            this.gl.texParameterf(this._target, this.gl.TEXTURE_WRAP_T, wrap_t);\r\n        }\r\n        set_interpolation(min, mag) {\r\n            // Set the texture interpolation mode\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // min : GL enum\r\n            //     The interpolation mode when minifying (i.e. zoomed out). Valid\r\n            //     values are LINEAR and NEAREST.\r\n            // max : GL enum\r\n            //     The interpolation mode when magnifying (i.e. zoomed in). Valid\r\n            //     values are LINEAR, NEAREST, NEAREST_MIPMAP_NEAREST,\r\n            //     LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR.\r\n            this.activate();\r\n            this.gl.texParameterf(this._target, this.gl.TEXTURE_MIN_FILTER, min);\r\n            this.gl.texParameterf(this._target, this.gl.TEXTURE_MAG_FILTER, mag);\r\n        }\r\n        set_size([width, height], format) {\r\n            var _a, _b, _c;\r\n            // Set the size of the 2D texture.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // shape : tuple of ints\r\n            //     The shape of the data to upload\r\n            // format : GL enum\r\n            //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\r\n            //     RGB, and RGBA.\r\n            if (width != ((_a = this._shape_format) === null || _a === void 0 ? void 0 : _a.width) || height != ((_b = this._shape_format) === null || _b === void 0 ? void 0 : _b.height) || format != ((_c = this._shape_format) === null || _c === void 0 ? void 0 : _c.format)) {\r\n                this._shape_format = { width, height, format };\r\n                this.activate();\r\n                this.gl.texImage2D(this._target, 0, format, width, height, 0, format, this.gl.UNSIGNED_BYTE, null);\r\n            }\r\n        }\r\n        set_data(offset, [width, height], data) {\r\n            // Set the 2D texture data.\r\n            //\r\n            // Parameters\r\n            // ----------\r\n            // offset : tuple of ints\r\n            //     Offset in pixels for each dimension.\r\n            // shape : tuple of ints\r\n            //     The shape of the data to upload\r\n            // data : typed array\r\n            //     The actual pixel data. Can be of any type, but on the GPU the\r\n            //     dat is stored in 8 bit precision.\r\n            this.activate();\r\n            const { format } = this._shape_format;\r\n            const [x, y] = offset;\r\n            const gtype = this._types[data.constructor.name];\r\n            if (gtype == null) {\r\n                throw new Error(`Type ${data.constructor.name} not allowed for texture`);\r\n            }\r\n            const alignment = this._get_alignment(width);\r\n            if (alignment != 4) {\r\n                this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, alignment);\r\n            }\r\n            this.gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);\r\n            if (alignment != 4) {\r\n                this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 4);\r\n            }\r\n        }\r\n    }\r\n    exports.Texture2d = Texture2d;\r\n    Texture2d.__name__ = \"Texture2d\";\r\n}\r\n","/* models\\glyphs\\webgl\\base.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    class BaseGLGlyph {\r\n        constructor(gl, glyph) {\r\n            this.gl = gl;\r\n            this.glyph = glyph;\r\n            this.nvertices = 0;\r\n            this.size_changed = false;\r\n            this.data_changed = false;\r\n            this.visuals_changed = false;\r\n            this.init();\r\n        }\r\n        set_data_changed() {\r\n            const { data_size } = this.glyph;\r\n            if (data_size != this.nvertices) {\r\n                this.nvertices = data_size;\r\n                this.size_changed = true;\r\n            }\r\n            this.data_changed = true;\r\n        }\r\n        set_visuals_changed() {\r\n            this.visuals_changed = true;\r\n        }\r\n        render(_ctx, indices, mainglyph) {\r\n            if (indices.length == 0) {\r\n                return true;\r\n            }\r\n            const { width, height } = this.glyph.renderer.plot_view.canvas_view.webgl.canvas;\r\n            const trans = {\r\n                pixel_ratio: this.glyph.renderer.plot_view.canvas_view.pixel_ratio,\r\n                width,\r\n                height,\r\n            };\r\n            this.draw(indices, mainglyph, trans);\r\n            return true;\r\n        }\r\n    }\r\n    exports.BaseGLGlyph = BaseGLGlyph;\r\n    BaseGLGlyph.__name__ = \"BaseGLGlyph\";\r\n}\r\n","/* models\\glyphs\\webgl\\line.vert.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.vertex_shader = `\r\nprecision mediump float;\r\n\r\nconst float PI = 3.14159265358979323846264;\r\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\r\n\r\nuniform float u_pixel_ratio;\r\nuniform vec2 u_canvas_size, u_offset;\r\nuniform vec2 u_scale_aspect;\r\nuniform float u_scale_length;\r\n\r\nuniform vec4 u_color;\r\nuniform float u_antialias;\r\nuniform float u_length;\r\nuniform float u_linewidth;\r\nuniform float u_dash_index;\r\nuniform float u_closed;\r\n\r\nattribute vec2 a_position;\r\nattribute vec4 a_tangents;\r\nattribute vec2 a_segment;\r\nattribute vec2 a_angles;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4  v_color;\r\nvarying vec2  v_segment;\r\nvarying vec2  v_angles;\r\nvarying vec2  v_texcoord;\r\nvarying vec2  v_miter;\r\nvarying float v_length;\r\nvarying float v_linewidth;\r\n\r\nfloat cross(in vec2 v1, in vec2 v2)\r\n{\r\n    return v1.x*v2.y - v1.y*v2.x;\r\n}\r\n\r\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\r\n{\r\n    return cross(v2-v1,v1-v3) / length(v2-v1);\r\n}\r\n\r\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\r\n{\r\n    float c = cos(alpha);\r\n    float s = sin(alpha);\r\n    result = vec2( c*v.x - s*v.y,\r\n                   s*v.x + c*v.y );\r\n}\r\n\r\nvoid main()\r\n{\r\n    bool closed = (u_closed > 0.0);\r\n\r\n    // Attributes and uniforms to varyings\r\n    v_color = u_color;\r\n    v_linewidth = u_linewidth;\r\n    v_segment = a_segment * u_scale_length;\r\n    v_length = u_length * u_scale_length;\r\n\r\n    // Scale to map to pixel coordinates. The original algorithm from the paper\r\n    // assumed isotropic scale. We obviously do not have this.\r\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\r\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\r\n\r\n    // Correct angles for aspect ratio\r\n    vec2 av;\r\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\r\n    v_angles.x = atan(av.y, av.x);\r\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\r\n    v_angles.y = atan(av.y, av.x);\r\n\r\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\r\n    // and a modified alpha\r\n    v_color.a = min(v_linewidth, v_color.a);\r\n    v_linewidth = max(v_linewidth, 1.0);\r\n\r\n    // If color is fully transparent we just will discard the fragment anyway\r\n    if( v_color.a <= 0.0 ) {\r\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\r\n        return;\r\n    }\r\n\r\n    // This is the actual half width of the line\r\n    float w = ceil(u_antialias+v_linewidth)/2.0;\r\n\r\n    vec2 position = a_position;\r\n\r\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\r\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\r\n    float u = a_texcoord.x;\r\n    float v = a_texcoord.y;\r\n    vec2 o1 = vec2( +t1.y, -t1.x);\r\n    vec2 o2 = vec2( +t2.y, -t2.x);\r\n\r\n    // This is a join\r\n    // ----------------------------------------------------------------\r\n    if( t1 != t2 ) {\r\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\r\n        vec2 t  = normalize(t1+t2);\r\n        vec2 o  = vec2( + t.y, - t.x);\r\n\r\n        if ( u_dash_index > 0.0 )\r\n        {\r\n            // Broken angle\r\n            // ----------------------------------------------------------------\r\n            if( (abs(angle) > THETA) ) {\r\n                position += v * w * o / cos(angle/2.0);\r\n                float s = sign(angle);\r\n                if( angle < 0.0 ) {\r\n                    if( u == +1.0 ) {\r\n                        u = v_segment.y + v * w * tan(angle/2.0);\r\n                        if( v == 1.0 ) {\r\n                            position -= 2.0 * w * t1 / sin(angle);\r\n                            u -= 2.0 * w / sin(angle);\r\n                        }\r\n                    } else {\r\n                        u = v_segment.x - v * w * tan(angle/2.0);\r\n                        if( v == 1.0 ) {\r\n                            position += 2.0 * w * t2 / sin(angle);\r\n                            u += 2.0*w / sin(angle);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if( u == +1.0 ) {\r\n                        u = v_segment.y + v * w * tan(angle/2.0);\r\n                        if( v == -1.0 ) {\r\n                            position += 2.0 * w * t1 / sin(angle);\r\n                            u += 2.0 * w / sin(angle);\r\n                        }\r\n                    } else {\r\n                        u = v_segment.x - v * w * tan(angle/2.0);\r\n                        if( v == -1.0 ) {\r\n                            position -= 2.0 * w * t2 / sin(angle);\r\n                            u -= 2.0*w / sin(angle);\r\n                        }\r\n                    }\r\n                }\r\n                // Continuous angle\r\n                // ------------------------------------------------------------\r\n            } else {\r\n                position += v * w * o / cos(angle/2.0);\r\n                if( u == +1.0 ) u = v_segment.y;\r\n                else            u = v_segment.x;\r\n            }\r\n        }\r\n\r\n        // Solid line\r\n        // --------------------------------------------------------------------\r\n        else\r\n        {\r\n            position.xy += v * w * o / cos(angle/2.0);\r\n            if( angle < 0.0 ) {\r\n                if( u == +1.0 ) {\r\n                    u = v_segment.y + v * w * tan(angle/2.0);\r\n                } else {\r\n                    u = v_segment.x - v * w * tan(angle/2.0);\r\n                }\r\n            } else {\r\n                if( u == +1.0 ) {\r\n                    u = v_segment.y + v * w * tan(angle/2.0);\r\n                } else {\r\n                    u = v_segment.x - v * w * tan(angle/2.0);\r\n                }\r\n            }\r\n        }\r\n\r\n    // This is a line start or end (t1 == t2)\r\n    // ------------------------------------------------------------------------\r\n    } else {\r\n        position += v * w * o1;\r\n        if( u == -1.0 ) {\r\n            u = v_segment.x - w;\r\n            position -= w * t1;\r\n        } else {\r\n            u = v_segment.y + w;\r\n            position += w * t2;\r\n        }\r\n    }\r\n\r\n    // Miter distance\r\n    // ------------------------------------------------------------------------\r\n    vec2 t;\r\n    vec2 curr = a_position * abs_scale;\r\n    if( a_texcoord.x < 0.0 ) {\r\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\r\n\r\n        rotate( t1, +v_angles.x/2.0, t);\r\n        v_miter.x = signed_distance(curr, curr+t, position);\r\n\r\n        rotate( t2, +v_angles.y/2.0, t);\r\n        v_miter.y = signed_distance(next, next+t, position);\r\n    } else {\r\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\r\n\r\n        rotate( t1, -v_angles.x/2.0,t);\r\n        v_miter.x = signed_distance(prev, prev+t, position);\r\n\r\n        rotate( t2, -v_angles.y/2.0,t);\r\n        v_miter.y = signed_distance(curr, curr+t, position);\r\n    }\r\n\r\n    if (!closed && v_segment.x <= 0.0) {\r\n        v_miter.x = 1e10;\r\n    }\r\n    if (!closed && v_segment.y >= v_length)\r\n    {\r\n        v_miter.y = 1e10;\r\n    }\r\n\r\n    v_texcoord = vec2( u, v*w );\r\n\r\n    // Calculate position in device coordinates. Note that we\r\n    // already scaled with abs scale above.\r\n    vec2 normpos = position * sign(u_scale_aspect);\r\n    normpos += 0.5;  // make up for Bokeh's offset\r\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\r\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\r\n    gl_Position.y *= -1.0;\r\n}\r\n`;\r\n}\r\n","/* models\\glyphs\\webgl\\line.frag.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.fragment_shader = `\r\nprecision mediump float;\r\n\r\nconst float PI = 3.14159265358979323846264;\r\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\r\n\r\nuniform sampler2D u_dash_atlas;\r\n\r\nuniform vec2 u_linecaps;\r\nuniform float u_miter_limit;\r\nuniform float u_linejoin;\r\nuniform float u_antialias;\r\nuniform float u_dash_phase;\r\nuniform float u_dash_period;\r\nuniform float u_dash_index;\r\nuniform vec2 u_dash_caps;\r\nuniform float u_closed;\r\n\r\nvarying vec4  v_color;\r\nvarying vec2  v_segment;\r\nvarying vec2  v_angles;\r\nvarying vec2  v_texcoord;\r\nvarying vec2  v_miter;\r\nvarying float v_length;\r\nvarying float v_linewidth;\r\n\r\n// Compute distance to cap ----------------------------------------------------\r\nfloat cap( int type, float dx, float dy, float t, float linewidth )\r\n{\r\n    float d = 0.0;\r\n    dx = abs(dx);\r\n    dy = abs(dy);\r\n    if      (type == 0)  discard;  // None\r\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\r\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\r\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\r\n    else if (type == 4)  d = max(dx,dy);  // Square\r\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\r\n    return d;\r\n}\r\n\r\n// Compute distance to join -------------------------------------------------\r\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\r\n           in float linewidth )\r\n{\r\n    // texcoord.x is distance from start\r\n    // texcoord.y is distance from centerline\r\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\r\n\r\n    float dx = texcoord.x;\r\n\r\n    // Round join\r\n    if( type == 1 ) {\r\n        if (dx < segment.x) {\r\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\r\n            //d = length( texcoord - vec2(segment.x,0.0));\r\n        } else if (dx > segment.y) {\r\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\r\n            //d = length( texcoord - vec2(segment.y,0.0));\r\n        }\r\n    }\r\n    // Bevel join\r\n    else if ( type == 2 ) {\r\n        if (dx < segment.x) {\r\n            vec2 x = texcoord - vec2(segment.x,0.0);\r\n            d = max(d, max(abs(x.x), abs(x.y)));\r\n\r\n        } else if (dx > segment.y) {\r\n            vec2 x = texcoord - vec2(segment.y,0.0);\r\n            d = max(d, max(abs(x.x), abs(x.y)));\r\n        }\r\n        /*  Original code for bevel which does not work for us\r\n        if( (dx < segment.x) ||  (dx > segment.y) )\r\n            d = max(d, min(abs(x.x),abs(x.y)));\r\n        */\r\n    }\r\n\r\n    return d;\r\n}\r\n\r\nvoid main()\r\n{\r\n    // If color is fully transparent we just discard the fragment\r\n    if( v_color.a <= 0.0 ) {\r\n        discard;\r\n    }\r\n\r\n    // Test if dash pattern is the solid one (0)\r\n    bool solid =  (u_dash_index == 0.0);\r\n\r\n    // Test if path is closed\r\n    bool closed = (u_closed > 0.0);\r\n\r\n    vec4 color = v_color;\r\n    float dx = v_texcoord.x;\r\n    float dy = v_texcoord.y;\r\n    float t = v_linewidth/2.0-u_antialias;\r\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\r\n    float d = 0.0;\r\n\r\n    vec2 linecaps = u_linecaps;\r\n    vec2 dash_caps = u_dash_caps;\r\n    float line_start = 0.0;\r\n    float line_stop = v_length;\r\n\r\n    // Apply miter limit; fragments too far into the miter are simply discarded\r\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\r\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\r\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\r\n          discard;\r\n    }\r\n\r\n    // Solid line --------------------------------------------------------------\r\n    if( solid ) {\r\n        d = abs(dy);\r\n        if( (!closed) && (dx < line_start) ) {\r\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\r\n        }\r\n        else if( (!closed) &&  (dx > line_stop) ) {\r\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\r\n        }\r\n        else {\r\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\r\n        }\r\n\r\n    // Dash line --------------------------------------------------------------\r\n    } else {\r\n        float segment_start = v_segment.x;\r\n        float segment_stop  = v_segment.y;\r\n        float segment_center= (segment_start+segment_stop)/2.0;\r\n        float freq          = u_dash_period*width;\r\n        float u = mod( dx + u_dash_phase*width, freq);\r\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\r\n        float dash_center= tex.x * width;\r\n        float dash_type  = tex.y;\r\n        float _start = tex.z * width;\r\n        float _stop  = tex.a * width;\r\n        float dash_start = dx - u + _start;\r\n        float dash_stop  = dx - u + _stop;\r\n\r\n        // Compute extents of the first dash (the one relative to v_segment.x)\r\n        // Note: this could be computed in the vertex shader\r\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\r\n            float u = mod(segment_start + u_dash_phase*width, freq);\r\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\r\n            dash_center= tex.x * width;\r\n            //dash_type  = tex.y;\r\n            float _start = tex.z * width;\r\n            float _stop  = tex.a * width;\r\n            dash_start = segment_start - u + _start;\r\n            dash_stop = segment_start - u + _stop;\r\n        }\r\n\r\n        // Compute extents of the last dash (the one relatives to v_segment.y)\r\n        // Note: This could be computed in the vertex shader\r\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\r\n            float u = mod(segment_stop + u_dash_phase*width, freq);\r\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\r\n            dash_center= tex.x * width;\r\n            //dash_type  = tex.y;\r\n            float _start = tex.z * width;\r\n            float _stop  = tex.a * width;\r\n            dash_start = segment_stop - u + _start;\r\n            dash_stop  = segment_stop - u + _stop;\r\n        }\r\n\r\n        // This test if the we are dealing with a discontinuous angle\r\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\r\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\r\n        //if( dx < line_start) discontinuous = false;\r\n        //if( dx > line_stop)  discontinuous = false;\r\n\r\n        float d_join = join( int(u_linejoin), abs(dy),\r\n                            v_segment, v_texcoord, v_miter, v_linewidth );\r\n\r\n        // When path is closed, we do not have room for linecaps, so we make room\r\n        // by shortening the total length\r\n        if (closed) {\r\n             line_start += v_linewidth/2.0;\r\n             line_stop  -= v_linewidth/2.0;\r\n        }\r\n\r\n        // We also need to take antialias area into account\r\n        //line_start += u_antialias;\r\n        //line_stop  -= u_antialias;\r\n\r\n        // Check is dash stop is before line start\r\n        if( dash_stop <= line_start ) {\r\n            discard;\r\n        }\r\n        // Check is dash start is beyond line stop\r\n        if( dash_start >= line_stop ) {\r\n            discard;\r\n        }\r\n\r\n        // Check if current dash start is beyond segment stop\r\n        if( discontinuous ) {\r\n            // Dash start is beyond segment, we discard\r\n            if( (dash_start > segment_stop) ) {\r\n                discard;\r\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\r\n            }\r\n\r\n            // Dash stop is before segment, we discard\r\n            if( (dash_stop < segment_start) ) {\r\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\r\n            }\r\n\r\n            // Special case for round caps (nicer with this)\r\n            if( dash_caps.x == 1.0 ) {\r\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\r\n                    discard;\r\n                }\r\n            }\r\n\r\n            // Special case for round caps  (nicer with this)\r\n            if( dash_caps.y == 1.0 ) {\r\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\r\n                    discard;\r\n                }\r\n            }\r\n\r\n            // Special case for triangle caps (in & out) and square\r\n            // We make sure the cap stop at crossing frontier\r\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\r\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\r\n                    float a = v_angles.x/2.0;\r\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\r\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\r\n                    if( x > 0.0 ) discard;\r\n                    // We transform the cap into square to avoid holes\r\n                    dash_caps.x = 4.0;\r\n                }\r\n            }\r\n\r\n            // Special case for triangle caps (in & out) and square\r\n            // We make sure the cap stop at crossing frontier\r\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\r\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\r\n                    float a = v_angles.y/2.0;\r\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\r\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\r\n                    if( x > 0.0 ) discard;\r\n                    // We transform the caps into square to avoid holes\r\n                    dash_caps.y = 4.0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Line cap at start\r\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\r\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\r\n        }\r\n        // Line cap at stop\r\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\r\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\r\n        }\r\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\r\n        else if( dash_type < -0.5 ) {\r\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\r\n            if( (dx > line_start) && (dx < line_stop) )\r\n                d = max(d,d_join);\r\n        }\r\n        // Dash cap right\r\n        else if( dash_type > 0.5 ) {\r\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\r\n            if( (dx > line_start) && (dx < line_stop) )\r\n                d = max(d,d_join);\r\n        }\r\n        // Dash body (plain)\r\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\r\n            d = abs(dy);\r\n        }\r\n\r\n        // Line join\r\n        if( (dx > line_start) && (dx < line_stop)) {\r\n            if( (dx <= segment_start) && (dash_start <= segment_start)\r\n                && (dash_stop >= segment_start) ) {\r\n                d = d_join;\r\n                // Antialias at outer border\r\n                float angle = PI/2.+v_angles.x;\r\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\r\n                d = max(f,d);\r\n            }\r\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\r\n                     && (dash_stop >= segment_stop) ) {\r\n                d = d_join;\r\n                // Antialias at outer border\r\n                float angle = PI/2.+v_angles.y;\r\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\r\n                d = max(f,d);\r\n            }\r\n            else if( dx < (segment_start - v_linewidth/2.)) {\r\n                discard;\r\n            }\r\n            else if( dx > (segment_stop + v_linewidth/2.)) {\r\n                discard;\r\n            }\r\n        }\r\n        else if( dx < (segment_start - v_linewidth/2.)) {\r\n            discard;\r\n        }\r\n        else if( dx > (segment_stop + v_linewidth/2.)) {\r\n            discard;\r\n        }\r\n    }\r\n\r\n    // Distance to border ------------------------------------------------------\r\n    d = d - t;\r\n    if( d < 0.0 ) {\r\n        gl_FragColor = color;\r\n    } else {\r\n        d /= u_antialias;\r\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\r\n    }\r\n}\r\n`;\r\n}\r\n","/* models\\glyphs\\patch.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class PatchView extends xy_glyph_1.XYGlyphView {\r\n        _inner_loop(ctx, indices, sx, sy, func) {\r\n            for (const i of indices) {\r\n                if (i == 0) {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx[i], sy[i]);\r\n                    continue;\r\n                }\r\n                else if (isNaN(sx[i] + sy[i])) {\r\n                    ctx.closePath();\r\n                    func.apply(ctx);\r\n                    ctx.beginPath();\r\n                    continue;\r\n                }\r\n                else\r\n                    ctx.lineTo(sx[i], sy[i]);\r\n            }\r\n            ctx.closePath();\r\n            func.call(ctx);\r\n        }\r\n        _render(ctx, indices, { sx, sy }) {\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_value(ctx);\r\n                this._inner_loop(ctx, indices, sx, sy, ctx.fill);\r\n            }\r\n            this.visuals.hatch.doit2(ctx, 0, () => this._inner_loop(ctx, indices, sx, sy, ctx.fill), () => this.renderer.request_render());\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_value(ctx);\r\n                this._inner_loop(ctx, indices, sx, sy, ctx.stroke);\r\n            }\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n        _hit_point(geometry) {\r\n            const result = new selection_1.Selection();\r\n            if (hittest.point_in_poly(geometry.sx, geometry.sy, this.sx, this.sy)) {\r\n                result.add_to_selected_glyphs(this.model);\r\n                result.view = this;\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.PatchView = PatchView;\r\n    PatchView.__name__ = \"PatchView\";\r\n    class Patch extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Patch() {\r\n            this.prototype.default_view = PatchView;\r\n            this.mixins([mixins.Line /*Scalar*/, mixins.Fill /*Scalar*/, mixins.Hatch /*Scalar*/]);\r\n        }\r\n    }\r\n    exports.Patch = Patch;\r\n    Patch.__name__ = \"Patch\";\r\n    Patch.init_Patch();\r\n}\r\n","/* models\\glyphs\\harea.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const area_1 = require(112) /* ./area */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class HAreaView extends area_1.AreaView {\r\n        _index_data(index) {\r\n            const { min, max } = Math;\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const x1 = this._x1[i];\r\n                const x2 = this._x2[i];\r\n                const y = this._y[i];\r\n                if (isNaN(x1 + x2 + y) || !isFinite(x1 + x2 + y))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(min(x1, x2), y, max(x1, x2), y);\r\n            }\r\n        }\r\n        _inner(ctx, sx1, sx2, sy, func) {\r\n            ctx.beginPath();\r\n            for (let i = 0, end = sx1.length; i < end; i++) {\r\n                ctx.lineTo(sx1[i], sy[i]);\r\n            }\r\n            // iterate backwards so that the upper end is below the lower start\r\n            for (let i = sx2.length - 1; i >= 0; i--) {\r\n                ctx.lineTo(sx2[i], sy[i]);\r\n            }\r\n            ctx.closePath();\r\n            func.call(ctx);\r\n        }\r\n        _render(ctx, _indices, { sx1, sx2, sy }) {\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_value(ctx);\r\n                this._inner(ctx, sx1, sx2, sy, ctx.fill);\r\n            }\r\n            this.visuals.hatch.doit2(ctx, 0, () => this._inner(ctx, sx1, sx2, sy, ctx.fill), () => this.renderer.request_render());\r\n        }\r\n        _hit_point(geometry) {\r\n            const L = this.sy.length;\r\n            const sx = new types_1.NumberArray(2 * L);\r\n            const sy = new types_1.NumberArray(2 * L);\r\n            for (let i = 0, end = L; i < end; i++) {\r\n                sx[i] = this.sx1[i];\r\n                sy[i] = this.sy[i];\r\n                sx[L + i] = this.sx2[L - i - 1];\r\n                sy[L + i] = this.sy[L - i - 1];\r\n            }\r\n            const result = new selection_1.Selection();\r\n            if (hittest.point_in_poly(geometry.sx, geometry.sy, sx, sy)) {\r\n                result.add_to_selected_glyphs(this.model);\r\n                result.view = this;\r\n            }\r\n            return result;\r\n        }\r\n        scenterxy(i) {\r\n            const scx = (this.sx1[i] + this.sx2[i]) / 2;\r\n            const scy = this.sy[i];\r\n            return [scx, scy];\r\n        }\r\n        _map_data() {\r\n            this.sx1 = this.renderer.xscale.v_compute(this._x1);\r\n            this.sx2 = this.renderer.xscale.v_compute(this._x2);\r\n            this.sy = this.renderer.yscale.v_compute(this._y);\r\n        }\r\n    }\r\n    exports.HAreaView = HAreaView;\r\n    HAreaView.__name__ = \"HAreaView\";\r\n    class HArea extends area_1.Area {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_HArea() {\r\n            this.prototype.default_view = HAreaView;\r\n            this.define({\r\n                x1: [p.XCoordinateSpec, { field: \"x1\" }],\r\n                x2: [p.XCoordinateSpec, { field: \"x2\" }],\r\n                y: [p.YCoordinateSpec, { field: \"y\" }],\r\n            });\r\n        }\r\n    }\r\n    exports.HArea = HArea;\r\n    HArea.__name__ = \"HArea\";\r\n    HArea.init_HArea();\r\n}\r\n","/* models\\glyphs\\area.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    class AreaView extends glyph_1.GlyphView {\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.AreaView = AreaView;\r\n    AreaView.__name__ = \"AreaView\";\r\n    class Area extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Area() {\r\n            this.mixins([mixins.Fill /*Scalar*/, mixins.HatchVector]);\r\n        }\r\n    }\r\n    exports.Area = Area;\r\n    Area.__name__ = \"Area\";\r\n    Area.init_Area();\r\n}\r\n","/* models\\glyphs\\varea.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const area_1 = require(112) /* ./area */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class VAreaView extends area_1.AreaView {\r\n        _index_data(index) {\r\n            const { min, max } = Math;\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const x = this._x[i];\r\n                const y1 = this._y1[i];\r\n                const y2 = this._y2[i];\r\n                if (isNaN(x + y1 + y2) || !isFinite(x + y1 + y2))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(x, min(y1, y2), x, max(y1, y2));\r\n            }\r\n        }\r\n        _inner(ctx, sx, sy1, sy2, func) {\r\n            ctx.beginPath();\r\n            for (let i = 0, end = sy1.length; i < end; i++) {\r\n                ctx.lineTo(sx[i], sy1[i]);\r\n            }\r\n            // iterate backwards so that the upper end is below the lower start\r\n            for (let i = sy2.length - 1; i >= 0; i--) {\r\n                ctx.lineTo(sx[i], sy2[i]);\r\n            }\r\n            ctx.closePath();\r\n            func.call(ctx);\r\n        }\r\n        _render(ctx, _indices, { sx, sy1, sy2 }) {\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_value(ctx);\r\n                this._inner(ctx, sx, sy1, sy2, ctx.fill);\r\n            }\r\n            this.visuals.hatch.doit2(ctx, 0, () => this._inner(ctx, sx, sy1, sy2, ctx.fill), () => this.renderer.request_render());\r\n        }\r\n        scenterxy(i) {\r\n            const scx = this.sx[i];\r\n            const scy = (this.sy1[i] + this.sy2[i]) / 2;\r\n            return [scx, scy];\r\n        }\r\n        _hit_point(geometry) {\r\n            const L = this.sx.length;\r\n            const sx = new types_1.NumberArray(2 * L);\r\n            const sy = new types_1.NumberArray(2 * L);\r\n            for (let i = 0, end = L; i < end; i++) {\r\n                sx[i] = this.sx[i];\r\n                sy[i] = this.sy1[i];\r\n                sx[L + i] = this.sx[L - i - 1];\r\n                sy[L + i] = this.sy2[L - i - 1];\r\n            }\r\n            const result = new selection_1.Selection();\r\n            if (hittest.point_in_poly(geometry.sx, geometry.sy, sx, sy)) {\r\n                result.add_to_selected_glyphs(this.model);\r\n                result.view = this;\r\n            }\r\n            return result;\r\n        }\r\n        _map_data() {\r\n            this.sx = this.renderer.xscale.v_compute(this._x);\r\n            this.sy1 = this.renderer.yscale.v_compute(this._y1);\r\n            this.sy2 = this.renderer.yscale.v_compute(this._y2);\r\n        }\r\n    }\r\n    exports.VAreaView = VAreaView;\r\n    VAreaView.__name__ = \"VAreaView\";\r\n    class VArea extends area_1.Area {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_VArea() {\r\n            this.prototype.default_view = VAreaView;\r\n            this.define({\r\n                x: [p.XCoordinateSpec, { field: \"x\" }],\r\n                y1: [p.YCoordinateSpec, { field: \"y1\" }],\r\n                y2: [p.YCoordinateSpec, { field: \"y2\" }],\r\n            });\r\n        }\r\n    }\r\n    exports.VArea = VArea;\r\n    VArea.__name__ = \"VArea\";\r\n    VArea.init_VArea();\r\n}\r\n","/* models\\sources\\cds_view.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const columnar_data_source_1 = require(86) /* ./columnar_data_source */;\r\n    class CDSView extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CDSView() {\r\n            this.define({\r\n                filters: [p.Array, []],\r\n                source: [p.Instance],\r\n            });\r\n            this.internal({\r\n                indices: [p.Any],\r\n                indices_map: [p.Any, {}],\r\n                masked: [p.Any, null],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.compute_indices();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.properties.filters.change, () => this.compute_indices());\r\n            const connect_listeners = () => {\r\n                const fn = () => this.compute_indices();\r\n                if (this.source != null) {\r\n                    this.connect(this.source.change, fn);\r\n                    if (this.source instanceof columnar_data_source_1.ColumnarDataSource) {\r\n                        this.connect(this.source.streaming, fn);\r\n                        this.connect(this.source.patching, fn);\r\n                    }\r\n                }\r\n            };\r\n            let initialized = this.source != null;\r\n            if (initialized)\r\n                connect_listeners();\r\n            else {\r\n                this.connect(this.properties.source.change, () => {\r\n                    if (!initialized) {\r\n                        connect_listeners();\r\n                        initialized = true;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        compute_indices() {\r\n            var _a;\r\n            const { source } = this;\r\n            if (source == null)\r\n                return;\r\n            // XXX: if the data source is empty, there still may be one\r\n            // index originating from glyph's scalar values.\r\n            const size = (_a = source.get_length()) !== null && _a !== void 0 ? _a : 1;\r\n            const indices = types_1.Indices.all_set(size);\r\n            for (const filter of this.filters) {\r\n                indices.intersect(filter.compute_indices(source));\r\n            }\r\n            this.indices = indices;\r\n            this._indices = [...indices];\r\n            this.indices_map_to_subset();\r\n        }\r\n        indices_map_to_subset() {\r\n            this.indices_map = {};\r\n            for (let i = 0; i < this._indices.length; i++) {\r\n                this.indices_map[this._indices[i]] = i;\r\n            }\r\n        }\r\n        convert_selection_from_subset(selection_subset) {\r\n            const indices = selection_subset.indices.map((i) => this._indices[i]);\r\n            return new selection_1.Selection(Object.assign(Object.assign({}, selection_subset.attributes), { indices }));\r\n        }\r\n        convert_selection_to_subset(selection_full) {\r\n            const indices = selection_full.indices.map((i) => this.indices_map[i]);\r\n            return new selection_1.Selection(Object.assign(Object.assign({}, selection_full.attributes), { indices }));\r\n        }\r\n        convert_indices_from_subset(indices) {\r\n            return indices.map((i) => this._indices[i]);\r\n        }\r\n    }\r\n    exports.CDSView = CDSView;\r\n    CDSView.__name__ = \"CDSView\";\r\n    CDSView.init_CDSView();\r\n}\r\n","/* core\\build_views.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const array_1 = require(9) /* ./util/array */;\r\n    async function _build_view(view_cls, model, options) {\r\n        const view = new view_cls(Object.assign(Object.assign({}, options), { model }));\r\n        view.initialize();\r\n        await view.lazy_initialize();\r\n        return view;\r\n    }\r\n    async function build_view(model, options = { parent: null }, cls = (model) => model.default_view) {\r\n        const view = await _build_view(cls(model), model, options);\r\n        view.connect_signals();\r\n        return view;\r\n    }\r\n    exports.build_view = build_view;\r\n    async function build_views(view_storage, models, options = { parent: null }, cls = (model) => model.default_view) {\r\n        const to_remove = array_1.difference([...view_storage.keys()], models);\r\n        for (const model of to_remove) {\r\n            view_storage.get(model).remove();\r\n            view_storage.delete(model);\r\n        }\r\n        const created_views = [];\r\n        const new_models = models.filter((model) => !view_storage.has(model));\r\n        for (const model of new_models) {\r\n            const view = await _build_view(cls(model), model, options);\r\n            view_storage.set(model, view);\r\n            created_views.push(view);\r\n        }\r\n        for (const view of created_views)\r\n            view.connect_signals();\r\n        return created_views;\r\n    }\r\n    exports.build_views = build_views;\r\n    function remove_views(view_storage) {\r\n        for (const [model, view] of view_storage) {\r\n            view.remove();\r\n            view_storage.delete(model);\r\n        }\r\n    }\r\n    exports.remove_views = remove_views;\r\n}\r\n","/* models\\renderers\\graph_renderer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const data_renderer_1 = require(91) /* ./data_renderer */;\r\n    const graph_hit_test_policy_1 = require(117) /* ../graphs/graph_hit_test_policy */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const build_views_1 = require(115) /* ../../core/build_views */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    class GraphRendererView extends data_renderer_1.DataRendererView {\r\n        async lazy_initialize() {\r\n            await super.lazy_initialize();\r\n            const graph = this.model;\r\n            // TODO: replace this with bi-variate transforms\r\n            let xs_ys = null;\r\n            let x_y = null;\r\n            const xs_expr = {\r\n                v_compute(source) {\r\n                    assert_1.assert(xs_ys == null);\r\n                    const [xs] = xs_ys = graph.layout_provider.get_edge_coordinates(source);\r\n                    return xs;\r\n                },\r\n            };\r\n            const ys_expr = {\r\n                v_compute(_source) {\r\n                    assert_1.assert(xs_ys != null);\r\n                    const [, ys] = xs_ys;\r\n                    xs_ys = null;\r\n                    return ys;\r\n                },\r\n            };\r\n            const x_expr = {\r\n                v_compute(source) {\r\n                    assert_1.assert(x_y == null);\r\n                    const [x] = x_y = graph.layout_provider.get_node_coordinates(source);\r\n                    return x;\r\n                },\r\n            };\r\n            const y_expr = {\r\n                v_compute(_source) {\r\n                    assert_1.assert(x_y != null);\r\n                    const [, y] = x_y;\r\n                    x_y = null;\r\n                    return y;\r\n                },\r\n            };\r\n            const { edge_renderer, node_renderer } = this.model;\r\n            edge_renderer.glyph.properties.xs.internal = true;\r\n            edge_renderer.glyph.properties.ys.internal = true;\r\n            node_renderer.glyph.properties.x.internal = true;\r\n            node_renderer.glyph.properties.y.internal = true;\r\n            edge_renderer.glyph.xs = { expr: xs_expr };\r\n            edge_renderer.glyph.ys = { expr: ys_expr };\r\n            node_renderer.glyph.x = { expr: x_expr };\r\n            node_renderer.glyph.y = { expr: y_expr };\r\n            const { parent } = this;\r\n            this.edge_view = await build_views_1.build_view(edge_renderer, { parent });\r\n            this.node_view = await build_views_1.build_view(node_renderer, { parent });\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.layout_provider.change, () => {\r\n                this.edge_view.set_data(false);\r\n                this.node_view.set_data(false);\r\n                this.request_render();\r\n            });\r\n        }\r\n        remove() {\r\n            this.edge_view.remove();\r\n            this.node_view.remove();\r\n            super.remove();\r\n        }\r\n        _render() {\r\n            this.edge_view.render();\r\n            this.node_view.render();\r\n        }\r\n    }\r\n    exports.GraphRendererView = GraphRendererView;\r\n    GraphRendererView.__name__ = \"GraphRendererView\";\r\n    class GraphRenderer extends data_renderer_1.DataRenderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GraphRenderer() {\r\n            this.prototype.default_view = GraphRendererView;\r\n            this.define({\r\n                layout_provider: [p.Instance],\r\n                node_renderer: [p.Instance],\r\n                edge_renderer: [p.Instance],\r\n                selection_policy: [p.Instance, () => new graph_hit_test_policy_1.NodesOnly()],\r\n                inspection_policy: [p.Instance, () => new graph_hit_test_policy_1.NodesOnly()],\r\n            });\r\n        }\r\n        get_selection_manager() {\r\n            return this.node_renderer.data_source.selection_manager;\r\n        }\r\n    }\r\n    exports.GraphRenderer = GraphRenderer;\r\n    GraphRenderer.__name__ = \"GraphRenderer\";\r\n    GraphRenderer.init_GraphRenderer();\r\n}\r\n","/* models\\graphs\\graph_hit_test_policy.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class GraphHitTestPolicy extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        _hit_test_nodes(geometry, graph_view) {\r\n            if (!graph_view.model.visible)\r\n                return null;\r\n            const hit_test_result = graph_view.node_view.glyph.hit_test(geometry);\r\n            if (hit_test_result == null)\r\n                return null;\r\n            else\r\n                return graph_view.node_view.model.view.convert_selection_from_subset(hit_test_result);\r\n        }\r\n        _hit_test_edges(geometry, graph_view) {\r\n            if (!graph_view.model.visible)\r\n                return null;\r\n            const hit_test_result = graph_view.edge_view.glyph.hit_test(geometry);\r\n            if (hit_test_result == null)\r\n                return null;\r\n            else\r\n                return graph_view.edge_view.model.view.convert_selection_from_subset(hit_test_result);\r\n        }\r\n    }\r\n    exports.GraphHitTestPolicy = GraphHitTestPolicy;\r\n    GraphHitTestPolicy.__name__ = \"GraphHitTestPolicy\";\r\n    class NodesOnly extends GraphHitTestPolicy {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        hit_test(geometry, graph_view) {\r\n            return this._hit_test_nodes(geometry, graph_view);\r\n        }\r\n        do_selection(hit_test_result, graph, final, mode) {\r\n            if (hit_test_result == null)\r\n                return false;\r\n            const node_selection = graph.node_renderer.data_source.selected;\r\n            node_selection.update(hit_test_result, final, mode);\r\n            graph.node_renderer.data_source._select.emit();\r\n            return !node_selection.is_empty();\r\n        }\r\n        do_inspection(hit_test_result, geometry, graph_view, final, mode) {\r\n            if (hit_test_result == null)\r\n                return false;\r\n            const node_inspection = graph_view.model.get_selection_manager().get_or_create_inspector(graph_view.node_view.model);\r\n            node_inspection.update(hit_test_result, final, mode);\r\n            // silently set inspected attr to avoid triggering data_source.change event and rerender\r\n            graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\r\n            graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, { geometry }]);\r\n            return !node_inspection.is_empty();\r\n        }\r\n    }\r\n    exports.NodesOnly = NodesOnly;\r\n    NodesOnly.__name__ = \"NodesOnly\";\r\n    class NodesAndLinkedEdges extends GraphHitTestPolicy {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        hit_test(geometry, graph_view) {\r\n            return this._hit_test_nodes(geometry, graph_view);\r\n        }\r\n        get_linked_edges(node_source, edge_source, mode) {\r\n            let node_indices = [];\r\n            if (mode == 'selection') {\r\n                node_indices = node_source.selected.indices.map((i) => node_source.data.index[i]);\r\n            }\r\n            else if (mode == 'inspection') {\r\n                node_indices = node_source.inspected.indices.map((i) => node_source.data.index[i]);\r\n            }\r\n            const edge_indices = [];\r\n            for (let i = 0; i < edge_source.data.start.length; i++) {\r\n                if (array_1.contains(node_indices, edge_source.data.start[i]) || array_1.contains(node_indices, edge_source.data.end[i]))\r\n                    edge_indices.push(i);\r\n            }\r\n            const linked_edges = new selection_1.Selection();\r\n            for (const i of edge_indices) {\r\n                linked_edges.multiline_indices[i] = [0]; //currently only supports 2-element multilines, so this is all of it\r\n            }\r\n            linked_edges.indices = edge_indices;\r\n            return linked_edges;\r\n        }\r\n        do_selection(hit_test_result, graph, final, mode) {\r\n            if (hit_test_result == null)\r\n                return false;\r\n            const node_selection = graph.node_renderer.data_source.selected;\r\n            node_selection.update(hit_test_result, final, mode);\r\n            const edge_selection = graph.edge_renderer.data_source.selected;\r\n            const linked_edges_selection = this.get_linked_edges(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\r\n            edge_selection.update(linked_edges_selection, final, mode);\r\n            graph.node_renderer.data_source._select.emit();\r\n            return !node_selection.is_empty();\r\n        }\r\n        do_inspection(hit_test_result, geometry, graph_view, final, mode) {\r\n            if (hit_test_result == null)\r\n                return false;\r\n            const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\r\n            node_inspection.update(hit_test_result, final, mode);\r\n            graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\r\n            const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\r\n            const linked_edges = this.get_linked_edges(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\r\n            edge_inspection.update(linked_edges, final, mode);\r\n            //silently set inspected attr to avoid triggering data_source.change event and rerender\r\n            graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });\r\n            graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, { geometry }]);\r\n            return !node_inspection.is_empty();\r\n        }\r\n    }\r\n    exports.NodesAndLinkedEdges = NodesAndLinkedEdges;\r\n    NodesAndLinkedEdges.__name__ = \"NodesAndLinkedEdges\";\r\n    class EdgesAndLinkedNodes extends GraphHitTestPolicy {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        hit_test(geometry, graph_view) {\r\n            return this._hit_test_edges(geometry, graph_view);\r\n        }\r\n        get_linked_nodes(node_source, edge_source, mode) {\r\n            let edge_indices = [];\r\n            if (mode == 'selection')\r\n                edge_indices = edge_source.selected.indices;\r\n            else if (mode == 'inspection')\r\n                edge_indices = edge_source.inspected.indices;\r\n            const nodes = [];\r\n            for (const i of edge_indices) {\r\n                nodes.push(edge_source.data.start[i]);\r\n                nodes.push(edge_source.data.end[i]);\r\n            }\r\n            const node_indices = array_1.uniq(nodes).map((i) => arrayable_1.indexOf(node_source.data.index, i));\r\n            return new selection_1.Selection({ indices: node_indices });\r\n        }\r\n        do_selection(hit_test_result, graph, final, mode) {\r\n            if (hit_test_result == null)\r\n                return false;\r\n            const edge_selection = graph.edge_renderer.data_source.selected;\r\n            edge_selection.update(hit_test_result, final, mode);\r\n            const node_selection = graph.node_renderer.data_source.selected;\r\n            const linked_nodes = this.get_linked_nodes(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\r\n            node_selection.update(linked_nodes, final, mode);\r\n            graph.edge_renderer.data_source._select.emit();\r\n            return !edge_selection.is_empty();\r\n        }\r\n        do_inspection(hit_test_result, geometry, graph_view, final, mode) {\r\n            if (hit_test_result == null)\r\n                return false;\r\n            const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\r\n            edge_inspection.update(hit_test_result, final, mode);\r\n            graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });\r\n            const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\r\n            const linked_nodes = this.get_linked_nodes(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\r\n            node_inspection.update(linked_nodes, final, mode);\r\n            // silently set inspected attr to avoid triggering data_source.change event and rerender\r\n            graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\r\n            graph_view.edge_view.model.data_source.inspect.emit([graph_view.edge_view, { geometry }]);\r\n            return !edge_inspection.is_empty();\r\n        }\r\n    }\r\n    exports.EdgesAndLinkedNodes = EdgesAndLinkedNodes;\r\n    EdgesAndLinkedNodes.__name__ = \"EdgesAndLinkedNodes\";\r\n}\r\n","/* models\\selections\\interaction_policy.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class SelectionPolicy extends model_1.Model {\r\n        do_selection(hit_test_result, source, final, mode) {\r\n            if (hit_test_result === null) {\r\n                return false;\r\n            }\r\n            else {\r\n                source.selected.update(hit_test_result, final, mode);\r\n                source._select.emit();\r\n                return !source.selected.is_empty();\r\n            }\r\n        }\r\n    }\r\n    exports.SelectionPolicy = SelectionPolicy;\r\n    SelectionPolicy.__name__ = \"SelectionPolicy\";\r\n    class IntersectRenderers extends SelectionPolicy {\r\n        hit_test(geometry, renderer_views) {\r\n            const hit_test_result_renderers = [];\r\n            for (const r of renderer_views) {\r\n                const result = r.hit_test(geometry);\r\n                if (result !== null)\r\n                    hit_test_result_renderers.push(result);\r\n            }\r\n            if (hit_test_result_renderers.length > 0) {\r\n                const hit_test_result = hit_test_result_renderers[0];\r\n                for (const hit_test_result_other of hit_test_result_renderers) {\r\n                    hit_test_result.update_through_intersection(hit_test_result_other);\r\n                }\r\n                return hit_test_result;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    exports.IntersectRenderers = IntersectRenderers;\r\n    IntersectRenderers.__name__ = \"IntersectRenderers\";\r\n    class UnionRenderers extends SelectionPolicy {\r\n        hit_test(geometry, renderer_views) {\r\n            const hit_test_result_renderers = [];\r\n            for (const r of renderer_views) {\r\n                const result = r.hit_test(geometry);\r\n                if (result !== null)\r\n                    hit_test_result_renderers.push(result);\r\n            }\r\n            if (hit_test_result_renderers.length > 0) {\r\n                const hit_test_result = hit_test_result_renderers[0];\r\n                for (const hit_test_result_other of hit_test_result_renderers) {\r\n                    hit_test_result.update_through_union(hit_test_result_other);\r\n                }\r\n                return hit_test_result;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    exports.UnionRenderers = UnionRenderers;\r\n    UnionRenderers.__name__ = \"UnionRenderers\";\r\n}\r\n","/* core\\util\\typed_array.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function concat(array0, ...arrays) {\r\n        let n = array0.length;\r\n        for (const array of arrays)\r\n            n += array.length;\r\n        const result = new array0.constructor(n);\r\n        result.set(array0, 0);\r\n        let i = array0.length;\r\n        for (const array of arrays) {\r\n            result.set(array, i);\r\n            i += array.length;\r\n        }\r\n        return result;\r\n    }\r\n    exports.concat = concat;\r\n}\r\n","/* core\\util\\set.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function union(...sets) {\r\n        const result = new Set();\r\n        for (const set of sets) {\r\n            for (const item of set) {\r\n                result.add(item);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    exports.union = union;\r\n    function intersection(set, ...sets) {\r\n        const result = new Set();\r\n        top: for (const item of set) {\r\n            for (const other of sets) {\r\n                if (!other.has(item))\r\n                    continue top;\r\n            }\r\n            result.add(item);\r\n        }\r\n        return result;\r\n    }\r\n    exports.intersection = intersection;\r\n    function difference(set, ...sets) {\r\n        const result = new Set(set);\r\n        for (const item of union(...sets)) {\r\n            result.delete(item);\r\n        }\r\n        return result;\r\n    }\r\n    exports.difference = difference;\r\n}\r\n","/* document\\events.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const has_props_1 = require(14) /* ../core/has_props */;\r\n    class DocumentEvent {\r\n        constructor(document) {\r\n            this.document = document;\r\n        }\r\n    }\r\n    exports.DocumentEvent = DocumentEvent;\r\n    DocumentEvent.__name__ = \"DocumentEvent\";\r\n    class DocumentEventBatch extends DocumentEvent {\r\n        constructor(document, events, setter_id) {\r\n            super(document);\r\n            this.events = events;\r\n            this.setter_id = setter_id;\r\n        }\r\n    }\r\n    exports.DocumentEventBatch = DocumentEventBatch;\r\n    DocumentEventBatch.__name__ = \"DocumentEventBatch\";\r\n    class DocumentChangedEvent extends DocumentEvent {\r\n    }\r\n    exports.DocumentChangedEvent = DocumentChangedEvent;\r\n    DocumentChangedEvent.__name__ = \"DocumentChangedEvent\";\r\n    class MessageSentEvent extends DocumentChangedEvent {\r\n        constructor(document, msg_type, msg_data) {\r\n            super(document);\r\n            this.msg_type = msg_type;\r\n            this.msg_data = msg_data;\r\n        }\r\n        json(_references) {\r\n            const value = this.msg_data;\r\n            const value_json = has_props_1.HasProps._value_to_json(value);\r\n            const value_refs = new Set();\r\n            has_props_1.HasProps._value_record_references(value, value_refs, { recursive: true });\r\n            /* XXX: this will cause all referenced models to be reinitialized\r\n            for (const id in value_refs) {\r\n              references[id] = value_refs[id]\r\n            }\r\n            */\r\n            return {\r\n                kind: \"MessageSent\",\r\n                msg_type: this.msg_type,\r\n                msg_data: value_json,\r\n            };\r\n        }\r\n    }\r\n    exports.MessageSentEvent = MessageSentEvent;\r\n    MessageSentEvent.__name__ = \"MessageSentEvent\";\r\n    class ModelChangedEvent extends DocumentChangedEvent {\r\n        constructor(document, model, attr, old, new_, setter_id, hint) {\r\n            super(document);\r\n            this.model = model;\r\n            this.attr = attr;\r\n            this.old = old;\r\n            this.new_ = new_;\r\n            this.setter_id = setter_id;\r\n            this.hint = hint;\r\n        }\r\n        json(references) {\r\n            if (this.attr === \"id\") {\r\n                throw new Error(\"'id' field should never change, whatever code just set it is wrong\");\r\n            }\r\n            if (this.hint != null)\r\n                return this.hint.json(references);\r\n            const value = this.new_;\r\n            const value_json = has_props_1.HasProps._value_to_json(value);\r\n            const value_refs = new Set();\r\n            has_props_1.HasProps._value_record_references(value, value_refs, { recursive: true });\r\n            if (value_refs.has(this.model) && this.model !== value) {\r\n                // we know we don't want a whole new copy of the obj we're\r\n                // patching unless it's also the value itself\r\n                value_refs.delete(this.model);\r\n            }\r\n            for (const ref of value_refs) {\r\n                references.add(ref);\r\n            }\r\n            return {\r\n                kind: \"ModelChanged\",\r\n                model: this.model.ref(),\r\n                attr: this.attr,\r\n                new: value_json,\r\n            };\r\n        }\r\n    }\r\n    exports.ModelChangedEvent = ModelChangedEvent;\r\n    ModelChangedEvent.__name__ = \"ModelChangedEvent\";\r\n    class ColumnsPatchedEvent extends DocumentChangedEvent {\r\n        constructor(document, column_source, patches) {\r\n            super(document);\r\n            this.column_source = column_source;\r\n            this.patches = patches;\r\n        }\r\n        json(_references) {\r\n            return {\r\n                kind: \"ColumnsPatched\",\r\n                column_source: this.column_source,\r\n                patches: this.patches,\r\n            };\r\n        }\r\n    }\r\n    exports.ColumnsPatchedEvent = ColumnsPatchedEvent;\r\n    ColumnsPatchedEvent.__name__ = \"ColumnsPatchedEvent\";\r\n    class ColumnsStreamedEvent extends DocumentChangedEvent {\r\n        constructor(document, column_source, data, rollover) {\r\n            super(document);\r\n            this.column_source = column_source;\r\n            this.data = data;\r\n            this.rollover = rollover;\r\n        }\r\n        json(_references) {\r\n            return {\r\n                kind: \"ColumnsStreamed\",\r\n                column_source: this.column_source,\r\n                data: this.data,\r\n                rollover: this.rollover,\r\n            };\r\n        }\r\n    }\r\n    exports.ColumnsStreamedEvent = ColumnsStreamedEvent;\r\n    ColumnsStreamedEvent.__name__ = \"ColumnsStreamedEvent\";\r\n    class TitleChangedEvent extends DocumentChangedEvent {\r\n        constructor(document, title, setter_id) {\r\n            super(document);\r\n            this.title = title;\r\n            this.setter_id = setter_id;\r\n        }\r\n        json(_references) {\r\n            return {\r\n                kind: \"TitleChanged\",\r\n                title: this.title,\r\n            };\r\n        }\r\n    }\r\n    exports.TitleChangedEvent = TitleChangedEvent;\r\n    TitleChangedEvent.__name__ = \"TitleChangedEvent\";\r\n    class RootAddedEvent extends DocumentChangedEvent {\r\n        constructor(document, model, setter_id) {\r\n            super(document);\r\n            this.model = model;\r\n            this.setter_id = setter_id;\r\n        }\r\n        json(references) {\r\n            has_props_1.HasProps._value_record_references(this.model, references, { recursive: true });\r\n            return {\r\n                kind: \"RootAdded\",\r\n                model: this.model.ref(),\r\n            };\r\n        }\r\n    }\r\n    exports.RootAddedEvent = RootAddedEvent;\r\n    RootAddedEvent.__name__ = \"RootAddedEvent\";\r\n    class RootRemovedEvent extends DocumentChangedEvent {\r\n        constructor(document, model, setter_id) {\r\n            super(document);\r\n            this.model = model;\r\n            this.setter_id = setter_id;\r\n        }\r\n        json(_references) {\r\n            return {\r\n                kind: \"RootRemoved\",\r\n                model: this.model.ref(),\r\n            };\r\n        }\r\n    }\r\n    exports.RootRemovedEvent = RootRemovedEvent;\r\n    RootRemovedEvent.__name__ = \"RootRemovedEvent\";\r\n}\r\n","/* models\\annotations\\band.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const upper_lower_1 = require(123) /* ./upper_lower */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    class BandView extends upper_lower_1.UpperLowerView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            const update = () => this.set_data(this.model.source);\r\n            this.connect(this.model.change, update);\r\n            this.connect(this.model.source.streaming, update);\r\n            this.connect(this.model.source.patching, update);\r\n            this.connect(this.model.source.change, update);\r\n        }\r\n        _render() {\r\n            this._map_data();\r\n            const { ctx } = this.layer;\r\n            // Draw the band body\r\n            ctx.beginPath();\r\n            ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);\r\n            for (let i = 0, end = this._lower_sx.length; i < end; i++) {\r\n                ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);\r\n            }\r\n            // iterate backwards so that the upper end is below the lower start\r\n            for (let i = this._upper_sx.length - 1; i >= 0; i--) {\r\n                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\r\n            }\r\n            ctx.closePath();\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_value(ctx);\r\n                ctx.fill();\r\n            }\r\n            // Draw the lower band edge\r\n            ctx.beginPath();\r\n            ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);\r\n            for (let i = 0, end = this._lower_sx.length; i < end; i++) {\r\n                ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);\r\n            }\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_value(ctx);\r\n                ctx.stroke();\r\n            }\r\n            // Draw the upper band edge\r\n            ctx.beginPath();\r\n            ctx.moveTo(this._upper_sx[0], this._upper_sy[0]);\r\n            for (let i = 0, end = this._upper_sx.length; i < end; i++) {\r\n                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\r\n            }\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_value(ctx);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n    }\r\n    exports.BandView = BandView;\r\n    BandView.__name__ = \"BandView\";\r\n    class Band extends upper_lower_1.UpperLower {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Band() {\r\n            this.prototype.default_view = BandView;\r\n            this.mixins([mixins.Line /*Scalar*/, mixins.Fill /*Scalar*/]);\r\n            this.override({\r\n                fill_color: \"#fff9ba\",\r\n                fill_alpha: 0.4,\r\n                line_color: \"#cccccc\",\r\n                line_alpha: 0.3,\r\n            });\r\n        }\r\n    }\r\n    exports.Band = Band;\r\n    Band.__name__ = \"Band\";\r\n    Band.init_Band();\r\n}\r\n","/* models\\annotations\\upper_lower.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const column_data_source_1 = require(85) /* ../sources/column_data_source */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class UpperLowerView extends annotation_1.AnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.set_data(this.model.source);\r\n        }\r\n        set_data(source) {\r\n            super.set_data(source);\r\n            this.visuals.warm_cache(source);\r\n            this.plot_view.request_render();\r\n        }\r\n        _map_data() {\r\n            const { frame } = this.plot_view;\r\n            const dim = this.model.dimension;\r\n            const xscale = this.coordinates.x_scale;\r\n            const yscale = this.coordinates.y_scale;\r\n            const limit_scale = dim == \"height\" ? yscale : xscale;\r\n            const base_scale = dim == \"height\" ? xscale : yscale;\r\n            const limit_view = dim == \"height\" ? frame.yview : frame.xview;\r\n            const base_view = dim == \"height\" ? frame.xview : frame.yview;\r\n            let _lower_sx;\r\n            if (this.model.properties.lower.units == \"data\")\r\n                _lower_sx = limit_scale.v_compute(this._lower);\r\n            else\r\n                _lower_sx = limit_view.v_compute(this._lower);\r\n            let _upper_sx;\r\n            if (this.model.properties.upper.units == \"data\")\r\n                _upper_sx = limit_scale.v_compute(this._upper);\r\n            else\r\n                _upper_sx = limit_view.v_compute(this._upper);\r\n            let _base_sx;\r\n            if (this.model.properties.base.units == \"data\")\r\n                _base_sx = base_scale.v_compute(this._base);\r\n            else\r\n                _base_sx = base_view.v_compute(this._base);\r\n            const [i, j] = dim == 'height' ? [1, 0] : [0, 1];\r\n            const _lower = [_lower_sx, _base_sx];\r\n            const _upper = [_upper_sx, _base_sx];\r\n            this._lower_sx = _lower[i];\r\n            this._lower_sy = _lower[j];\r\n            this._upper_sx = _upper[i];\r\n            this._upper_sy = _upper[j];\r\n        }\r\n    }\r\n    exports.UpperLowerView = UpperLowerView;\r\n    UpperLowerView.__name__ = \"UpperLowerView\";\r\n    class UpperLower extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_UpperLower() {\r\n            this.define({\r\n                lower: [p.DistanceSpec],\r\n                upper: [p.DistanceSpec],\r\n                base: [p.DistanceSpec],\r\n                dimension: [p.Dimension, 'height'],\r\n                source: [p.Instance, () => new column_data_source_1.ColumnDataSource()],\r\n            });\r\n        }\r\n    }\r\n    exports.UpperLower = UpperLower;\r\n    UpperLower.__name__ = \"UpperLower\";\r\n    UpperLower.init_UpperLower();\r\n}\r\n","/* models\\annotations\\box_annotation.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\r\n    exports.EDGE_TOLERANCE = 2.5;\r\n    class BoxAnnotationView extends annotation_1.AnnotationView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.plot_view.request_paint(this));\r\n            this.connect(this.model.data_update, () => this.plot_view.request_paint(this));\r\n        }\r\n        _render() {\r\n            // don't render if *all* position are null\r\n            if (this.model.left == null && this.model.right == null && this.model.top == null && this.model.bottom == null) {\r\n                return;\r\n            }\r\n            const { frame } = this.plot_view;\r\n            const xscale = this.coordinates.x_scale;\r\n            const yscale = this.coordinates.y_scale;\r\n            const _calc_dim = (dim, dim_units, scale, view, frame_extrema) => {\r\n                let sdim;\r\n                if (dim != null) {\r\n                    if (this.model.screen)\r\n                        sdim = dim;\r\n                    else {\r\n                        if (dim_units == 'data')\r\n                            sdim = scale.compute(dim);\r\n                        else\r\n                            sdim = view.compute(dim);\r\n                    }\r\n                }\r\n                else\r\n                    sdim = frame_extrema;\r\n                return sdim;\r\n            };\r\n            this.sleft = _calc_dim(this.model.left, this.model.left_units, xscale, frame.xview, frame.bbox.left);\r\n            this.sright = _calc_dim(this.model.right, this.model.right_units, xscale, frame.xview, frame.bbox.right);\r\n            this.stop = _calc_dim(this.model.top, this.model.top_units, yscale, frame.yview, frame.bbox.top);\r\n            this.sbottom = _calc_dim(this.model.bottom, this.model.bottom_units, yscale, frame.yview, frame.bbox.bottom);\r\n            this._paint_box(this.sleft, this.sright, this.sbottom, this.stop);\r\n        }\r\n        _paint_box(sleft, sright, sbottom, stop) {\r\n            const { ctx } = this.layer;\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.rect(sleft, stop, sright - sleft, sbottom - stop);\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_value(ctx);\r\n                ctx.fill();\r\n            }\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_value(ctx);\r\n                ctx.stroke();\r\n            }\r\n            ctx.restore();\r\n        }\r\n        interactive_bbox() {\r\n            const tol = this.model.properties.line_width.value() + exports.EDGE_TOLERANCE;\r\n            return new bbox_1.BBox({\r\n                x0: this.sleft - tol,\r\n                y0: this.stop - tol,\r\n                x1: this.sright + tol,\r\n                y1: this.sbottom + tol,\r\n            });\r\n        }\r\n        interactive_hit(sx, sy) {\r\n            if (this.model.in_cursor == null)\r\n                return false;\r\n            const bbox = this.interactive_bbox();\r\n            return bbox.contains(sx, sy);\r\n        }\r\n        cursor(sx, sy) {\r\n            const tol = 3;\r\n            if (Math.abs(sx - this.sleft) < tol || Math.abs(sx - this.sright) < tol)\r\n                return this.model.ew_cursor;\r\n            else if (Math.abs(sy - this.sbottom) < tol || Math.abs(sy - this.stop) < tol)\r\n                return this.model.ns_cursor;\r\n            else if (sx > this.sleft && sx < this.sright && sy > this.stop && sy < this.sbottom)\r\n                return this.model.in_cursor;\r\n            else\r\n                return null;\r\n        }\r\n    }\r\n    exports.BoxAnnotationView = BoxAnnotationView;\r\n    BoxAnnotationView.__name__ = \"BoxAnnotationView\";\r\n    class BoxAnnotation extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_BoxAnnotation() {\r\n            this.prototype.default_view = BoxAnnotationView;\r\n            this.mixins([mixins.Line /*Scalar*/, mixins.Fill /*Scalar*/]);\r\n            this.define({\r\n                render_mode: [p.RenderMode, 'canvas'],\r\n                top: [p.Number, null],\r\n                top_units: [p.SpatialUnits, 'data'],\r\n                bottom: [p.Number, null],\r\n                bottom_units: [p.SpatialUnits, 'data'],\r\n                left: [p.Number, null],\r\n                left_units: [p.SpatialUnits, 'data'],\r\n                right: [p.Number, null],\r\n                right_units: [p.SpatialUnits, 'data'],\r\n            });\r\n            this.internal({\r\n                screen: [p.Boolean, false],\r\n                ew_cursor: [p.String, null],\r\n                ns_cursor: [p.String, null],\r\n                in_cursor: [p.String, null],\r\n            });\r\n            this.override({\r\n                fill_color: '#fff9ba',\r\n                fill_alpha: 0.4,\r\n                line_color: '#cccccc',\r\n                line_alpha: 0.3,\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.data_update = new signaling_1.Signal0(this, \"data_update\");\r\n        }\r\n        update({ left, right, top, bottom }) {\r\n            this.setv({ left, right, top, bottom, screen: true }, { silent: true });\r\n            this.data_update.emit();\r\n        }\r\n    }\r\n    exports.BoxAnnotation = BoxAnnotation;\r\n    BoxAnnotation.__name__ = \"BoxAnnotation\";\r\n    BoxAnnotation.init_BoxAnnotation();\r\n}\r\n","/* models\\annotations\\color_bar.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const basic_ticker_1 = require(126) /* ../tickers/basic_ticker */;\r\n    const basic_tick_formatter_1 = require(130) /* ../formatters/basic_tick_formatter */;\r\n    const mappers_1 = require(132) /* ../mappers */;\r\n    const linear_scale_1 = require(145) /* ../scales/linear_scale */;\r\n    const linear_interpolation_scale_1 = require(156) /* ../scales/linear_interpolation_scale */;\r\n    const log_scale_1 = require(157) /* ../scales/log_scale */;\r\n    const range1d_1 = require(158) /* ../ranges/range1d */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const text_util = tslib_1.__importStar(require(159) /* ../../core/util/text */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    const SHORT_DIM = 25;\r\n    const LONG_DIM_MIN_SCALAR = 0.3;\r\n    const LONG_DIM_MAX_SCALAR = 0.8;\r\n    class ColorBarView extends annotation_1.AnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n            this._set_canvas_image();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.ticker.change, () => this.plot_view.request_render());\r\n            this.connect(this.model.formatter.change, () => this.plot_view.request_render());\r\n            if (this.model.color_mapper != null) {\r\n                this.connect(this.model.color_mapper.change, () => {\r\n                    this._set_canvas_image();\r\n                    this.plot_view.request_render();\r\n                });\r\n            }\r\n        }\r\n        _get_size() {\r\n            if (this.model.color_mapper == null)\r\n                return { width: 0, height: 0 };\r\n            else {\r\n                const { width, height } = this.compute_legend_dimensions();\r\n                return { width, height };\r\n            }\r\n        }\r\n        _set_canvas_image() {\r\n            if (this.model.color_mapper == null)\r\n                return;\r\n            let { palette } = this.model.color_mapper;\r\n            if (this.model.orientation == 'vertical')\r\n                palette = array_1.reversed(palette);\r\n            let w, h;\r\n            switch (this.model.orientation) {\r\n                case \"vertical\": {\r\n                    [w, h] = [1, palette.length];\r\n                    break;\r\n                }\r\n                case \"horizontal\": {\r\n                    [w, h] = [palette.length, 1];\r\n                    break;\r\n                }\r\n            }\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = w;\r\n            canvas.height = h;\r\n            const image_ctx = canvas.getContext('2d');\r\n            const image_data = image_ctx.getImageData(0, 0, w, h);\r\n            // We always want to draw the entire palette linearly, so we create a new\r\n            // LinearColorMapper instance and map a monotonic range of values with\r\n            // length = palette.length to get each palette color in order.\r\n            const cmap = new mappers_1.LinearColorMapper({ palette }).rgba_mapper;\r\n            const buf8 = cmap.v_compute(array_1.range(0, palette.length));\r\n            image_data.data.set(buf8);\r\n            image_ctx.putImageData(image_data, 0, 0);\r\n            this.image = canvas;\r\n        }\r\n        compute_legend_dimensions() {\r\n            const image_dimensions = this._computed_image_dimensions();\r\n            const [image_height, image_width] = [image_dimensions.height, image_dimensions.width];\r\n            const label_extent = this._get_label_extent();\r\n            const title_extent = this._title_extent();\r\n            const tick_extent = this._tick_extent();\r\n            const { padding } = this.model;\r\n            let legend_height, legend_width;\r\n            switch (this.model.orientation) {\r\n                case \"vertical\":\r\n                    legend_height = image_height + title_extent + 2 * padding;\r\n                    legend_width = image_width + tick_extent + label_extent + 2 * padding;\r\n                    break;\r\n                case \"horizontal\":\r\n                    legend_height = image_height + title_extent + tick_extent + label_extent + 2 * padding;\r\n                    legend_width = image_width + 2 * padding;\r\n                    break;\r\n            }\r\n            return { width: legend_width, height: legend_height };\r\n        }\r\n        compute_legend_location() {\r\n            const legend_dimensions = this.compute_legend_dimensions();\r\n            const [legend_height, legend_width] = [legend_dimensions.height, legend_dimensions.width];\r\n            const legend_margin = this.model.margin;\r\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\r\n            const [hr, vr] = panel.bbox.ranges;\r\n            const { location } = this.model;\r\n            let sx, sy;\r\n            if (types_1.isString(location)) {\r\n                switch (location) {\r\n                    case 'top_left':\r\n                        sx = hr.start + legend_margin;\r\n                        sy = vr.start + legend_margin;\r\n                        break;\r\n                    case 'top_center':\r\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\r\n                        sy = vr.start + legend_margin;\r\n                        break;\r\n                    case 'top_right':\r\n                        sx = hr.end - legend_margin - legend_width;\r\n                        sy = vr.start + legend_margin;\r\n                        break;\r\n                    case 'bottom_right':\r\n                        sx = hr.end - legend_margin - legend_width;\r\n                        sy = vr.end - legend_margin - legend_height;\r\n                        break;\r\n                    case 'bottom_center':\r\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\r\n                        sy = vr.end - legend_margin - legend_height;\r\n                        break;\r\n                    case 'bottom_left':\r\n                        sx = hr.start + legend_margin;\r\n                        sy = vr.end - legend_margin - legend_height;\r\n                        break;\r\n                    case 'center_left':\r\n                        sx = hr.start + legend_margin;\r\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\r\n                        break;\r\n                    case 'center':\r\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\r\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\r\n                        break;\r\n                    case 'center_right':\r\n                        sx = hr.end - legend_margin - legend_width;\r\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\r\n                        break;\r\n                }\r\n            }\r\n            else if (types_1.isArray(location) && location.length == 2) {\r\n                const [vx, vy] = location;\r\n                sx = panel.xview.compute(vx);\r\n                sy = panel.yview.compute(vy) - legend_height;\r\n            }\r\n            else\r\n                assert_1.unreachable();\r\n            return { sx, sy };\r\n        }\r\n        _render() {\r\n            if (this.model.color_mapper == null)\r\n                return;\r\n            const { ctx } = this.layer;\r\n            ctx.save();\r\n            const { sx, sy } = this.compute_legend_location();\r\n            ctx.translate(sx, sy);\r\n            this._draw_bbox(ctx);\r\n            const image_offset = this._get_image_offset();\r\n            ctx.translate(image_offset.x, image_offset.y);\r\n            this._draw_image(ctx);\r\n            const tick_info = this.tick_info();\r\n            this._draw_major_ticks(ctx, tick_info);\r\n            this._draw_minor_ticks(ctx, tick_info);\r\n            this._draw_major_labels(ctx, tick_info);\r\n            if (this.model.title)\r\n                this._draw_title(ctx);\r\n            ctx.restore();\r\n        }\r\n        _draw_bbox(ctx) {\r\n            const bbox = this.compute_legend_dimensions();\r\n            ctx.save();\r\n            if (this.visuals.background_fill.doit) {\r\n                this.visuals.background_fill.set_value(ctx);\r\n                ctx.fillRect(0, 0, bbox.width, bbox.height);\r\n            }\r\n            if (this.visuals.border_line.doit) {\r\n                this.visuals.border_line.set_value(ctx);\r\n                ctx.strokeRect(0, 0, bbox.width, bbox.height);\r\n            }\r\n            ctx.restore();\r\n        }\r\n        _draw_image(ctx) {\r\n            const image = this._computed_image_dimensions();\r\n            ctx.save();\r\n            ctx.setImageSmoothingEnabled(false);\r\n            ctx.globalAlpha = this.model.scale_alpha;\r\n            ctx.drawImage(this.image, 0, 0, image.width, image.height);\r\n            if (this.visuals.bar_line.doit) {\r\n                this.visuals.bar_line.set_value(ctx);\r\n                ctx.strokeRect(0, 0, image.width, image.height);\r\n            }\r\n            ctx.restore();\r\n        }\r\n        _draw_major_ticks(ctx, tick_info) {\r\n            if (!this.visuals.major_tick_line.doit)\r\n                return;\r\n            const [nx, ny] = this._normals();\r\n            const image = this._computed_image_dimensions();\r\n            const [x_offset, y_offset] = [image.width * nx, image.height * ny];\r\n            const [sx, sy] = tick_info.coords.major;\r\n            const tin = this.model.major_tick_in;\r\n            const tout = this.model.major_tick_out;\r\n            ctx.save();\r\n            ctx.translate(x_offset, y_offset);\r\n            this.visuals.major_tick_line.set_value(ctx);\r\n            for (let i = 0, end = sx.length; i < end; i++) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\r\n                ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\r\n                ctx.stroke();\r\n            }\r\n            ctx.restore();\r\n        }\r\n        _draw_minor_ticks(ctx, tick_info) {\r\n            if (!this.visuals.minor_tick_line.doit)\r\n                return;\r\n            const [nx, ny] = this._normals();\r\n            const image = this._computed_image_dimensions();\r\n            const [x_offset, y_offset] = [image.width * nx, image.height * ny];\r\n            const [sx, sy] = tick_info.coords.minor;\r\n            const tin = this.model.minor_tick_in;\r\n            const tout = this.model.minor_tick_out;\r\n            ctx.save();\r\n            ctx.translate(x_offset, y_offset);\r\n            this.visuals.minor_tick_line.set_value(ctx);\r\n            for (let i = 0, end = sx.length; i < end; i++) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\r\n                ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\r\n                ctx.stroke();\r\n            }\r\n            ctx.restore();\r\n        }\r\n        _draw_major_labels(ctx, tick_info) {\r\n            if (!this.visuals.major_label_text.doit)\r\n                return;\r\n            const [nx, ny] = this._normals();\r\n            const image = this._computed_image_dimensions();\r\n            const [x_offset, y_offset] = [image.width * nx, image.height * ny];\r\n            const standoff = (this.model.label_standoff + this._tick_extent());\r\n            const [x_standoff, y_standoff] = [standoff * nx, standoff * ny];\r\n            const [sx, sy] = tick_info.coords.major;\r\n            const formatted_labels = tick_info.labels.major;\r\n            this.visuals.major_label_text.set_value(ctx);\r\n            ctx.save();\r\n            ctx.translate(x_offset + x_standoff, y_offset + y_standoff);\r\n            for (let i = 0, end = sx.length; i < end; i++) {\r\n                ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));\r\n            }\r\n            ctx.restore();\r\n        }\r\n        _draw_title(ctx) {\r\n            if (!this.visuals.title_text.doit)\r\n                return;\r\n            ctx.save();\r\n            this.visuals.title_text.set_value(ctx);\r\n            ctx.fillText(this.model.title, 0, -this.model.title_standoff);\r\n            ctx.restore();\r\n        }\r\n        /*protected*/ _get_label_extent() {\r\n            const major_labels = this.tick_info().labels.major;\r\n            let label_extent;\r\n            if (!array_1.is_empty(major_labels)) {\r\n                const { ctx } = this.layer;\r\n                ctx.save();\r\n                this.visuals.major_label_text.set_value(ctx);\r\n                switch (this.model.orientation) {\r\n                    case \"vertical\":\r\n                        label_extent = array_1.max((major_labels.map((label) => ctx.measureText(label.toString()).width)));\r\n                        break;\r\n                    case \"horizontal\":\r\n                        label_extent = text_util.measure_font(this.visuals.major_label_text.font_value()).height;\r\n                        break;\r\n                }\r\n                label_extent += this.model.label_standoff;\r\n                ctx.restore();\r\n            }\r\n            else\r\n                label_extent = 0;\r\n            return label_extent;\r\n        }\r\n        /*protected*/ _get_image_offset() {\r\n            // Returns image offset relative to legend bounding box\r\n            const x = this.model.padding;\r\n            const y = this.model.padding + this._title_extent();\r\n            return { x, y };\r\n        }\r\n        // {{{ TODO: state\r\n        _normals() {\r\n            return this.model.orientation == 'vertical' ? [1, 0] : [0, 1];\r\n        }\r\n        _title_extent() {\r\n            const font_value = this.model.title_text_font + \" \" + this.model.title_text_font_size + \" \" + this.model.title_text_font_style;\r\n            const title_extent = this.model.title ? text_util.measure_font(font_value).height + this.model.title_standoff : 0;\r\n            return title_extent;\r\n        }\r\n        _tick_extent() {\r\n            return array_1.max([this.model.major_tick_out, this.model.minor_tick_out]);\r\n        }\r\n        _computed_image_dimensions() {\r\n            /*\r\n            Heuristics to determine ColorBar image dimensions if set to \"auto\"\r\n        \r\n            Note: Returns the height/width values for the ColorBar's scale image, not\r\n            the dimensions of the entire ColorBar.\r\n        \r\n            If the short dimension (the width of a vertical bar or height of a\r\n            horizontal bar) is set to \"auto\", the resulting dimension will be set to\r\n            25 px.\r\n        \r\n            For a ColorBar in a side panel with the long dimension (the height of a\r\n            vertical bar or width of a horizontal bar) set to \"auto\", the\r\n            resulting dimension will be as long as the adjacent frame edge, so that the\r\n            bar \"fits\" to the plot.\r\n        \r\n            For a ColorBar in the plot frame with the long dimension set to \"auto\", the\r\n            resulting dimension will be the greater of:\r\n              * The length of the color palette * 25px\r\n              * The parallel frame dimension * 0.30\r\n                (i.e the frame height for a vertical ColorBar)\r\n            But not greater than:\r\n              * The parallel frame dimension * 0.80\r\n            */\r\n            const frame_height = this.plot_view.frame.bbox.height;\r\n            const frame_width = this.plot_view.frame.bbox.width;\r\n            const title_extent = this._title_extent();\r\n            let height, width;\r\n            switch (this.model.orientation) {\r\n                case \"vertical\": {\r\n                    if (this.model.height == 'auto') {\r\n                        if (this.panel != null)\r\n                            height = frame_height - 2 * this.model.padding - title_extent;\r\n                        else {\r\n                            height = array_1.max([this.model.color_mapper.palette.length * SHORT_DIM, frame_height * LONG_DIM_MIN_SCALAR]);\r\n                            height = array_1.min([height, frame_height * LONG_DIM_MAX_SCALAR - 2 * this.model.padding - title_extent]);\r\n                        }\r\n                    }\r\n                    else\r\n                        height = this.model.height;\r\n                    width = this.model.width == 'auto' ? SHORT_DIM : this.model.width;\r\n                    break;\r\n                }\r\n                case \"horizontal\": {\r\n                    height = this.model.height == 'auto' ? SHORT_DIM : this.model.height;\r\n                    if (this.model.width == 'auto') {\r\n                        if (this.panel != null)\r\n                            width = frame_width - 2 * this.model.padding;\r\n                        else {\r\n                            width = array_1.max([this.model.color_mapper.palette.length * SHORT_DIM, frame_width * LONG_DIM_MIN_SCALAR]);\r\n                            width = array_1.min([width, frame_width * LONG_DIM_MAX_SCALAR - 2 * this.model.padding]);\r\n                        }\r\n                    }\r\n                    else\r\n                        width = this.model.width;\r\n                    break;\r\n                }\r\n            }\r\n            return { width, height };\r\n        }\r\n        /*protected*/ _tick_coordinate_scale(scale_length) {\r\n            /*\r\n            Creates and returns a scale instance that maps the `color_mapper` range\r\n            (low to high) to a screen space range equal to the length of the ColorBar's\r\n            scale image. The scale is used to calculate the tick coordinates in screen\r\n            coordinates for plotting purposes.\r\n        \r\n            Note: the type of color_mapper has to match the type of scale (i.e.\r\n            a LinearColorMapper will require a corresponding LinearScale instance).\r\n            */\r\n            const ranges = {\r\n                source_range: new range1d_1.Range1d({\r\n                    start: this.model.color_mapper.metrics.min,\r\n                    end: this.model.color_mapper.metrics.max,\r\n                }),\r\n                target_range: new range1d_1.Range1d({\r\n                    start: 0,\r\n                    end: scale_length,\r\n                }),\r\n            };\r\n            const { color_mapper } = this.model;\r\n            if (color_mapper instanceof mappers_1.LinearColorMapper)\r\n                return new linear_scale_1.LinearScale(ranges);\r\n            else if (color_mapper instanceof mappers_1.LogColorMapper)\r\n                return new log_scale_1.LogScale(ranges);\r\n            else if (color_mapper instanceof mappers_1.ScanningColorMapper) {\r\n                const { binning } = color_mapper.metrics;\r\n                return new linear_interpolation_scale_1.LinearInterpolationScale(Object.assign(Object.assign({}, ranges), { binning }));\r\n            }\r\n            else {\r\n                // TODO: Categorical*Mapper needs painters\r\n                assert_1.unreachable();\r\n            }\r\n        }\r\n        _format_major_labels(initial_labels, major_ticks) {\r\n            // XXX: passing null as cross_loc probably means MercatorTickFormatters, etc\r\n            // will not function properly in conjunction with colorbars\r\n            const formatted_labels = this.model.formatter.doFormat(initial_labels, null);\r\n            for (let i = 0, end = major_ticks.length; i < end; i++) {\r\n                if (major_ticks[i] in this.model.major_label_overrides)\r\n                    formatted_labels[i] = this.model.major_label_overrides[major_ticks[i]];\r\n            }\r\n            return formatted_labels;\r\n        }\r\n        tick_info() {\r\n            const image_dimensions = this._computed_image_dimensions();\r\n            let scale_length;\r\n            switch (this.model.orientation) {\r\n                case \"vertical\": {\r\n                    scale_length = image_dimensions.height;\r\n                    break;\r\n                }\r\n                case \"horizontal\": {\r\n                    scale_length = image_dimensions.width;\r\n                    break;\r\n                }\r\n            }\r\n            const scale = this._tick_coordinate_scale(scale_length);\r\n            const [i, j] = this._normals();\r\n            const [start, end] = [this.model.color_mapper.metrics.min, this.model.color_mapper.metrics.max];\r\n            // XXX: passing null as cross_loc probably means MercatorTickers, etc\r\n            // will not function properly in conjunction with colorbars\r\n            const ticks = this.model.ticker.get_ticks(start, end, null, null, this.model.ticker.desired_num_ticks);\r\n            const majors = ticks.major;\r\n            const minors = ticks.minor;\r\n            const major_coords = [[], []];\r\n            const minor_coords = [[], []];\r\n            for (let ii = 0, _end = majors.length; ii < _end; ii++) {\r\n                if (majors[ii] < start || majors[ii] > end)\r\n                    continue;\r\n                major_coords[i].push(majors[ii]);\r\n                major_coords[j].push(0);\r\n            }\r\n            for (let ii = 0, _end = minors.length; ii < _end; ii++) {\r\n                if (minors[ii] < start || minors[ii] > end)\r\n                    continue;\r\n                minor_coords[i].push(minors[ii]);\r\n                minor_coords[j].push(0);\r\n            }\r\n            const labels = { major: this._format_major_labels(major_coords[i], majors) };\r\n            const coords = {\r\n                major: [[], []],\r\n                minor: [[], []],\r\n            };\r\n            coords.major[i] = scale.v_compute(major_coords[i]);\r\n            coords.minor[i] = scale.v_compute(minor_coords[i]);\r\n            coords.major[j] = major_coords[j];\r\n            coords.minor[j] = minor_coords[j];\r\n            // Because we want the scale to be reversed\r\n            if (this.model.orientation == 'vertical') {\r\n                coords.major[i] = arrayable_1.map(coords.major[i], (coord) => scale_length - coord);\r\n                coords.minor[i] = arrayable_1.map(coords.minor[i], (coord) => scale_length - coord);\r\n            }\r\n            return { coords, labels };\r\n        }\r\n    }\r\n    exports.ColorBarView = ColorBarView;\r\n    ColorBarView.__name__ = \"ColorBarView\";\r\n    class ColorBar extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ColorBar() {\r\n            this.prototype.default_view = ColorBarView;\r\n            this.mixins([\r\n                [\"major_label_\", mixins.Text],\r\n                [\"title_\", mixins.Text],\r\n                [\"major_tick_\", mixins.Line],\r\n                [\"minor_tick_\", mixins.Line],\r\n                [\"border_\", mixins.Line],\r\n                [\"bar_\", mixins.Line],\r\n                [\"background_\", mixins.Fill],\r\n            ]);\r\n            this.define({\r\n                location: [p.Any, 'top_right'],\r\n                orientation: [p.Orientation, 'vertical'],\r\n                title: [p.String],\r\n                title_standoff: [p.Number, 2],\r\n                width: [p.Any, 'auto'],\r\n                height: [p.Any, 'auto'],\r\n                scale_alpha: [p.Number, 1.0],\r\n                ticker: [p.Instance, () => new basic_ticker_1.BasicTicker()],\r\n                formatter: [p.Instance, () => new basic_tick_formatter_1.BasicTickFormatter()],\r\n                major_label_overrides: [p.Any, {}],\r\n                color_mapper: [p.Instance],\r\n                label_standoff: [p.Number, 5],\r\n                margin: [p.Number, 30],\r\n                padding: [p.Number, 10],\r\n                major_tick_in: [p.Number, 5],\r\n                major_tick_out: [p.Number, 0],\r\n                minor_tick_in: [p.Number, 0],\r\n                minor_tick_out: [p.Number, 0],\r\n            });\r\n            this.override({\r\n                background_fill_color: \"#ffffff\",\r\n                background_fill_alpha: 0.95,\r\n                bar_line_color: null,\r\n                border_line_color: null,\r\n                major_label_text_align: \"center\",\r\n                major_label_text_baseline: \"middle\",\r\n                major_label_text_font_size: \"11px\",\r\n                major_tick_line_color: \"#ffffff\",\r\n                minor_tick_line_color: null,\r\n                title_text_font_size: \"13px\",\r\n                title_text_font_style: \"italic\",\r\n            });\r\n        }\r\n    }\r\n    exports.ColorBar = ColorBar;\r\n    ColorBar.__name__ = \"ColorBar\";\r\n    ColorBar.init_ColorBar();\r\n}\r\n","/* models\\tickers\\basic_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const adaptive_ticker_1 = require(127) /* ./adaptive_ticker */;\r\n    class BasicTicker extends adaptive_ticker_1.AdaptiveTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.BasicTicker = BasicTicker;\r\n    BasicTicker.__name__ = \"BasicTicker\";\r\n}\r\n","/* models\\tickers\\adaptive_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const continuous_ticker_1 = require(128) /* ./continuous_ticker */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    // Forces a number x into a specified range [min_val, max_val].\r\n    function clamp(x, min_val, max_val) {\r\n        return Math.max(min_val, Math.min(max_val, x));\r\n    }\r\n    // A log function with an optional base.\r\n    function log(x, base = Math.E) {\r\n        return Math.log(x) / Math.log(base);\r\n    }\r\n    class AdaptiveTicker extends continuous_ticker_1.ContinuousTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_AdaptiveTicker() {\r\n            this.define({\r\n                base: [p.Number, 10.0],\r\n                mantissas: [p.Array, [1, 2, 5]],\r\n                min_interval: [p.Number, 0.0],\r\n                max_interval: [p.Number],\r\n            });\r\n        }\r\n        // These arguments control the range of possible intervals.  The interval I\r\n        // returned by get_interval() will be the one that most closely matches the\r\n        // desired number of ticks, subject to the following constraints:\r\n        // I = (M * B^N), where\r\n        // M is a member of mantissas,\r\n        // B is base,\r\n        // and N is an integer;\r\n        // and min_interval <= I <= max_interval.\r\n        initialize() {\r\n            super.initialize();\r\n            const prefix_mantissa = array_1.nth(this.mantissas, -1) / this.base;\r\n            const suffix_mantissa = array_1.nth(this.mantissas, 0) * this.base;\r\n            this.extended_mantissas = [prefix_mantissa, ...this.mantissas, suffix_mantissa];\r\n            this.base_factor = this.get_min_interval() === 0.0 ? 1.0 : this.get_min_interval();\r\n        }\r\n        get_interval(data_low, data_high, desired_n_ticks) {\r\n            const data_range = data_high - data_low;\r\n            const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\r\n            const interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));\r\n            const ideal_magnitude = this.base ** interval_exponent * this.base_factor;\r\n            // An untested optimization.\r\n            //   const ideal_mantissa = ideal_interval / ideal_magnitude\r\n            //   index = sorted_index(this.extended_mantissas, ideal_mantissa)\r\n            //   candidate_mantissas = this.extended_mantissas[index..index + 1]\r\n            const candidate_mantissas = this.extended_mantissas;\r\n            const errors = candidate_mantissas.map((mantissa) => {\r\n                return Math.abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)));\r\n            });\r\n            const best_mantissa = candidate_mantissas[array_1.argmin(errors)];\r\n            const interval = best_mantissa * ideal_magnitude;\r\n            return clamp(interval, this.get_min_interval(), this.get_max_interval());\r\n        }\r\n    }\r\n    exports.AdaptiveTicker = AdaptiveTicker;\r\n    AdaptiveTicker.__name__ = \"AdaptiveTicker\";\r\n    AdaptiveTicker.init_AdaptiveTicker();\r\n}\r\n","/* models\\tickers\\continuous_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const ticker_1 = require(129) /* ./ticker */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    class ContinuousTicker extends ticker_1.Ticker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ContinuousTicker() {\r\n            this.define({\r\n                num_minor_ticks: [p.Number, 5],\r\n                desired_num_ticks: [p.Number, 6],\r\n            });\r\n        }\r\n        get_ticks(data_low, data_high, _range, cross_loc, _) {\r\n            return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);\r\n        }\r\n        // The version of get_ticks() that does the work (and the version that\r\n        // should be overridden in subclasses).\r\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\r\n            const interval = this.get_interval(data_low, data_high, desired_n_ticks);\r\n            const start_factor = Math.floor(data_low / interval);\r\n            const end_factor = Math.ceil(data_high / interval);\r\n            let factors;\r\n            if (!isFinite(start_factor) || !isFinite(end_factor))\r\n                factors = [];\r\n            else\r\n                factors = array_1.range(start_factor, end_factor + 1);\r\n            const ticks = factors\r\n                .map((factor) => factor * interval)\r\n                .filter((tick) => data_low <= tick && tick <= data_high);\r\n            const num_minor_ticks = this.num_minor_ticks;\r\n            const minor_ticks = [];\r\n            if (num_minor_ticks > 0 && ticks.length > 0) {\r\n                const minor_interval = interval / num_minor_ticks;\r\n                const minor_offsets = array_1.range(0, num_minor_ticks).map((i) => i * minor_interval);\r\n                for (const x of minor_offsets.slice(1)) {\r\n                    const mt = ticks[0] - x;\r\n                    if (data_low <= mt && mt <= data_high) {\r\n                        minor_ticks.push(mt);\r\n                    }\r\n                }\r\n                for (const tick of ticks) {\r\n                    for (const x of minor_offsets) {\r\n                        const mt = tick + x;\r\n                        if (data_low <= mt && mt <= data_high) {\r\n                            minor_ticks.push(mt);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                major: ticks,\r\n                minor: minor_ticks,\r\n            };\r\n        }\r\n        // Returns the smallest interval that can be returned by get_interval().\r\n        get_min_interval() {\r\n            return this.min_interval;\r\n        }\r\n        // Returns the largest interval that can be returned by get_interval().\r\n        get_max_interval() {\r\n            return this.max_interval != null ? this.max_interval : Infinity;\r\n        }\r\n        // Returns the interval size that would produce exactly the number of\r\n        // desired ticks.  (In general we won't use exactly this interval, because\r\n        // we want the ticks to be round numbers.)\r\n        get_ideal_interval(data_low, data_high, desired_n_ticks) {\r\n            const data_range = data_high - data_low;\r\n            return data_range / desired_n_ticks;\r\n        }\r\n    }\r\n    exports.ContinuousTicker = ContinuousTicker;\r\n    ContinuousTicker.__name__ = \"ContinuousTicker\";\r\n    ContinuousTicker.init_ContinuousTicker();\r\n}\r\n","/* models\\tickers\\ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class Ticker extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.Ticker = Ticker;\r\n    Ticker.__name__ = \"Ticker\";\r\n}\r\n","/* models\\formatters\\basic_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class BasicTickFormatter extends tick_formatter_1.TickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.last_precision = 3;\r\n        }\r\n        static init_BasicTickFormatter() {\r\n            this.define({\r\n                precision: [p.Any, 'auto'],\r\n                use_scientific: [p.Boolean, true],\r\n                power_limit_high: [p.Number, 5],\r\n                power_limit_low: [p.Number, -3],\r\n            });\r\n        }\r\n        get scientific_limit_low() {\r\n            return 10.0 ** this.power_limit_low;\r\n        }\r\n        get scientific_limit_high() {\r\n            return 10.0 ** this.power_limit_high;\r\n        }\r\n        _need_sci(ticks) {\r\n            if (!this.use_scientific)\r\n                return false;\r\n            const { scientific_limit_high } = this;\r\n            const { scientific_limit_low } = this;\r\n            const zeroish = ticks.length < 2 ? 0 : Math.abs(ticks[1] - ticks[0]) / 10000;\r\n            for (const tick of ticks) {\r\n                const tick_abs = Math.abs(tick);\r\n                if (tick_abs <= zeroish)\r\n                    continue;\r\n                if (tick_abs >= scientific_limit_high || tick_abs <= scientific_limit_low) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        _format_with_precision(ticks, need_sci, precision) {\r\n            const labels = new Array(ticks.length);\r\n            if (need_sci) {\r\n                for (let i = 0, end = ticks.length; i < end; i++) {\r\n                    labels[i] = ticks[i].toExponential(precision);\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0, end = ticks.length; i < end; i++) {\r\n                    // strip trailing zeros\r\n                    labels[i] = ticks[i].toFixed(precision).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\r\n                }\r\n            }\r\n            return labels;\r\n        }\r\n        _auto_precision(ticks, need_sci) {\r\n            const labels = new Array(ticks.length);\r\n            const asc = this.last_precision <= 15;\r\n            outer: for (let x = this.last_precision; asc ? x <= 15 : x >= 1; asc ? x++ : x--) {\r\n                if (need_sci) {\r\n                    labels[0] = ticks[0].toExponential(x);\r\n                    for (let i = 1; i < ticks.length; i++) {\r\n                        if (labels[i] == labels[i - 1]) {\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    this.last_precision = x;\r\n                    break;\r\n                }\r\n                else {\r\n                    labels[0] = ticks[0].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\r\n                    for (let i = 1; i < ticks.length; i++) {\r\n                        labels[i] = ticks[i].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\r\n                        if (labels[i] == labels[i - 1]) {\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    this.last_precision = x;\r\n                    break;\r\n                }\r\n            }\r\n            return this.last_precision;\r\n        }\r\n        doFormat(ticks, _opts) {\r\n            if (ticks.length == 0)\r\n                return [];\r\n            const need_sci = this._need_sci(ticks);\r\n            const precision = this.precision == \"auto\" ? this._auto_precision(ticks, need_sci) : this.precision;\r\n            return this._format_with_precision(ticks, need_sci, precision);\r\n        }\r\n    }\r\n    exports.BasicTickFormatter = BasicTickFormatter;\r\n    BasicTickFormatter.__name__ = \"BasicTickFormatter\";\r\n    BasicTickFormatter.init_BasicTickFormatter();\r\n}\r\n","/* models\\formatters\\tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class TickFormatter extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.TickFormatter = TickFormatter;\r\n    TickFormatter.__name__ = \"TickFormatter\";\r\n}\r\n","/* models\\mappers\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var categorical_color_mapper_1 = require(133) /* ./categorical_color_mapper */;\r\n    exports.CategoricalColorMapper = categorical_color_mapper_1.CategoricalColorMapper;\r\n    var categorical_marker_mapper_1 = require(138) /* ./categorical_marker_mapper */;\r\n    exports.CategoricalMarkerMapper = categorical_marker_mapper_1.CategoricalMarkerMapper;\r\n    var categorical_pattern_mapper_1 = require(139) /* ./categorical_pattern_mapper */;\r\n    exports.CategoricalPatternMapper = categorical_pattern_mapper_1.CategoricalPatternMapper;\r\n    var continuous_color_mapper_1 = require(140) /* ./continuous_color_mapper */;\r\n    exports.ContinuousColorMapper = continuous_color_mapper_1.ContinuousColorMapper;\r\n    var color_mapper_1 = require(135) /* ./color_mapper */;\r\n    exports.ColorMapper = color_mapper_1.ColorMapper;\r\n    var linear_color_mapper_1 = require(141) /* ./linear_color_mapper */;\r\n    exports.LinearColorMapper = linear_color_mapper_1.LinearColorMapper;\r\n    var log_color_mapper_1 = require(142) /* ./log_color_mapper */;\r\n    exports.LogColorMapper = log_color_mapper_1.LogColorMapper;\r\n    var scanning_color_mapper_1 = require(143) /* ./scanning_color_mapper */;\r\n    exports.ScanningColorMapper = scanning_color_mapper_1.ScanningColorMapper;\r\n    var eqhist_color_mapper_1 = require(144) /* ./eqhist_color_mapper */;\r\n    exports.EqHistColorMapper = eqhist_color_mapper_1.EqHistColorMapper;\r\n}\r\n","/* models\\mappers\\categorical_color_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const categorical_mapper_1 = require(134) /* ./categorical_mapper */;\r\n    const color_mapper_1 = require(135) /* ./color_mapper */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class CategoricalColorMapper extends color_mapper_1.ColorMapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CategoricalColorMapper() {\r\n            this.define({\r\n                factors: [p.Array],\r\n                start: [p.Number, 0],\r\n                end: [p.Number],\r\n            });\r\n        }\r\n        _v_compute(data, values, palette, { nan_color }) {\r\n            categorical_mapper_1.cat_v_compute(data, this.factors, palette, values, this.start, this.end, nan_color);\r\n        }\r\n    }\r\n    exports.CategoricalColorMapper = CategoricalColorMapper;\r\n    CategoricalColorMapper.__name__ = \"CategoricalColorMapper\";\r\n    CategoricalColorMapper.init_CategoricalColorMapper();\r\n}\r\n","/* models\\mappers\\categorical_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    function _cat_equals(a, b) {\r\n        if (a.length != b.length)\r\n            return false;\r\n        for (let i = 0, end = a.length; i < end; i++) {\r\n            if (a[i] !== b[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    exports._cat_equals = _cat_equals;\r\n    function cat_v_compute(data, factors, targets, values, start, end, extra_value) {\r\n        for (let i = 0, N = data.length; i < N; i++) {\r\n            let d = data[i];\r\n            let key;\r\n            if (types_1.isString(d))\r\n                key = arrayable_1.index_of(factors, d);\r\n            else {\r\n                if (start != null) {\r\n                    if (end != null)\r\n                        d = d.slice(start, end);\r\n                    else\r\n                        d = d.slice(start);\r\n                }\r\n                else if (end != null)\r\n                    d = d.slice(0, end);\r\n                if (d.length == 1)\r\n                    key = arrayable_1.index_of(factors, d[0]);\r\n                else\r\n                    key = arrayable_1.find_index(factors, (x) => _cat_equals(x, d));\r\n            }\r\n            let value;\r\n            if (key < 0 || key >= targets.length)\r\n                value = extra_value;\r\n            else\r\n                value = targets[key];\r\n            values[i] = value;\r\n        }\r\n    }\r\n    exports.cat_v_compute = cat_v_compute;\r\n}\r\n","/* models\\mappers\\color_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const mapper_1 = require(136) /* ./mapper */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const color_1 = require(22) /* ../../core/util/color */;\r\n    const compat_1 = require(32) /* ../../core/util/compat */;\r\n    function _convert_color(color) {\r\n        if (types_1.isNumber(color))\r\n            return color;\r\n        if (color[0] != \"#\")\r\n            color = color_1.color2hex(color);\r\n        if (color.length != 9)\r\n            color = color + 'ff';\r\n        return parseInt(color.slice(1), 16);\r\n    }\r\n    exports._convert_color = _convert_color;\r\n    function _convert_palette(palette) {\r\n        const new_palette = new Uint32Array(palette.length);\r\n        for (let i = 0, end = palette.length; i < end; i++)\r\n            new_palette[i] = _convert_color(palette[i]);\r\n        return new_palette;\r\n    }\r\n    exports._convert_palette = _convert_palette;\r\n    function _uint32_to_rgba(values) {\r\n        if (compat_1.is_little_endian) {\r\n            const view = new DataView(values.buffer);\r\n            for (let i = 0, end = values.length; i < end; i++)\r\n                view.setUint32(i * 4, values[i]);\r\n        }\r\n        return new Uint8Array(values.buffer);\r\n    }\r\n    exports._uint32_to_rgba = _uint32_to_rgba;\r\n    class ColorMapper extends mapper_1.Mapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ColorMapper() {\r\n            this.define({\r\n                palette: [p.Any],\r\n                nan_color: [p.Color, \"gray\"],\r\n            });\r\n        }\r\n        v_compute(xs) {\r\n            const values = new Array(xs.length);\r\n            this._v_compute(xs, values, this.palette, this._colors((c) => c));\r\n            return values;\r\n        }\r\n        get rgba_mapper() {\r\n            const self = this;\r\n            const palette = _convert_palette(this.palette);\r\n            const colors = this._colors(_convert_color);\r\n            return {\r\n                v_compute(xs) {\r\n                    const values = new Uint32Array(xs.length);\r\n                    self._v_compute(xs, values, palette, colors);\r\n                    return _uint32_to_rgba(values);\r\n                },\r\n            };\r\n        }\r\n        _colors(conv) {\r\n            return { nan_color: conv(this.nan_color) };\r\n        }\r\n    }\r\n    exports.ColorMapper = ColorMapper;\r\n    ColorMapper.__name__ = \"ColorMapper\";\r\n    ColorMapper.init_ColorMapper();\r\n}\r\n","/* models\\mappers\\mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const transform_1 = require(137) /* ../transforms/transform */;\r\n    class Mapper extends transform_1.Transform {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        compute(_x) {\r\n            // If it's just a single value, then a mapper doesn't really make sense.\r\n            throw new Error(\"mapping single values is not supported\");\r\n        }\r\n    }\r\n    exports.Mapper = Mapper;\r\n    Mapper.__name__ = \"Mapper\";\r\n}\r\n","/* models\\transforms\\transform.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class Transform extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.Transform = Transform;\r\n    Transform.__name__ = \"Transform\";\r\n}\r\n","/* models\\mappers\\categorical_marker_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const categorical_mapper_1 = require(134) /* ./categorical_mapper */;\r\n    const mapper_1 = require(136) /* ./mapper */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class CategoricalMarkerMapper extends mapper_1.Mapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CategoricalMarkerMapper() {\r\n            this.define({\r\n                factors: [p.Array],\r\n                markers: [p.Array],\r\n                start: [p.Number, 0],\r\n                end: [p.Number],\r\n                default_value: [p.MarkerType, \"circle\"],\r\n            });\r\n        }\r\n        v_compute(xs) {\r\n            const values = new Array(xs.length);\r\n            categorical_mapper_1.cat_v_compute(xs, this.factors, this.markers, values, this.start, this.end, this.default_value);\r\n            return values;\r\n        }\r\n    }\r\n    exports.CategoricalMarkerMapper = CategoricalMarkerMapper;\r\n    CategoricalMarkerMapper.__name__ = \"CategoricalMarkerMapper\";\r\n    CategoricalMarkerMapper.init_CategoricalMarkerMapper();\r\n}\r\n","/* models\\mappers\\categorical_pattern_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const categorical_mapper_1 = require(134) /* ./categorical_mapper */;\r\n    const mapper_1 = require(136) /* ./mapper */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class CategoricalPatternMapper extends mapper_1.Mapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CategoricalPatternMapper() {\r\n            this.define({\r\n                factors: [p.Array],\r\n                patterns: [p.Array],\r\n                start: [p.Number, 0],\r\n                end: [p.Number],\r\n                default_value: [p.HatchPatternType, \" \"],\r\n            });\r\n        }\r\n        v_compute(xs) {\r\n            const values = new Array(xs.length);\r\n            categorical_mapper_1.cat_v_compute(xs, this.factors, this.patterns, values, this.start, this.end, this.default_value);\r\n            return values;\r\n        }\r\n    }\r\n    exports.CategoricalPatternMapper = CategoricalPatternMapper;\r\n    CategoricalPatternMapper.__name__ = \"CategoricalPatternMapper\";\r\n    CategoricalPatternMapper.init_CategoricalPatternMapper();\r\n}\r\n","/* models\\mappers\\continuous_color_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const color_mapper_1 = require(135) /* ./color_mapper */;\r\n    const glyph_renderer_1 = require(90) /* ../renderers/glyph_renderer */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    class ContinuousColorMapper extends color_mapper_1.ColorMapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this._scan_data = null;\r\n        }\r\n        static init_ContinuousColorMapper() {\r\n            this.define(({ Number, String, Null, Ref, Color, Or, Tuple, Array }) => {\r\n                return {\r\n                    high: [Or(Number, Null), null],\r\n                    low: [Or(Number, Null), null],\r\n                    high_color: [Or(Color, Null), null],\r\n                    low_color: [Or(Color, Null), null],\r\n                    domain: [Array(Tuple(Ref(glyph_renderer_1.GlyphRenderer), Or(String, Array(String)))), []],\r\n                };\r\n            });\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            const connect_renderers = () => {\r\n                // TODO: if already connected this will bail. However, it won't remove old connections.\r\n                for (const [renderer] of this.domain) {\r\n                    this.connect(renderer.view.change, () => this.update_data());\r\n                    this.connect(renderer.data_source.selected.change, () => this.update_data());\r\n                }\r\n            };\r\n            this.connect(this.properties.domain.change, () => connect_renderers());\r\n            connect_renderers();\r\n        }\r\n        update_data() {\r\n            const { domain, palette } = this;\r\n            const all_data = [...this._collect(domain)];\r\n            this._scan_data = this.scan(all_data, palette.length);\r\n            this.change.emit();\r\n        }\r\n        get metrics() {\r\n            if (this._scan_data == null) {\r\n                this.update_data();\r\n            }\r\n            return this._scan_data;\r\n        }\r\n        *_collect(domain) {\r\n            for (const [renderer, fields] of domain) {\r\n                for (const field of types_1.isArray(fields) ? fields : [fields]) {\r\n                    let array = renderer.data_source.get_column(field);\r\n                    array = renderer.view.indices.select(array);\r\n                    const masked = renderer.view.masked;\r\n                    const selected = renderer.data_source.selected.indices;\r\n                    let subset;\r\n                    if (masked != null && selected.length > 0)\r\n                        subset = array_1.intersection([...masked], selected);\r\n                    else if (masked != null)\r\n                        subset = [...masked];\r\n                    else if (selected.length > 0)\r\n                        subset = selected;\r\n                    if (subset != null) {\r\n                        array = array_1.map(subset, (i) => array[i]);\r\n                    }\r\n                    if (array.length > 0 && !types_1.isNumber(array[0])) {\r\n                        for (const subarray of array) {\r\n                            yield* subarray;\r\n                        }\r\n                    }\r\n                    else {\r\n                        yield* array;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _v_compute(data, values, palette, colors) {\r\n            const { nan_color } = colors;\r\n            let { low_color, high_color } = colors;\r\n            if (low_color == null)\r\n                low_color = palette[0];\r\n            if (high_color == null)\r\n                high_color = palette[palette.length - 1];\r\n            const { domain } = this;\r\n            const all_data = !array_1.is_empty(domain) ? [...this._collect(domain)] : data;\r\n            this._scan_data = this.scan(all_data, palette.length);\r\n            for (let i = 0, end = data.length; i < end; i++) {\r\n                const d = data[i];\r\n                if (isNaN(d))\r\n                    values[i] = nan_color;\r\n                else\r\n                    values[i] = this.cmap(d, palette, low_color, high_color, this._scan_data);\r\n            }\r\n        }\r\n        _colors(conv) {\r\n            return Object.assign(Object.assign({}, super._colors(conv)), { low_color: this.low_color != null ? conv(this.low_color) : undefined, high_color: this.high_color != null ? conv(this.high_color) : undefined });\r\n        }\r\n    }\r\n    exports.ContinuousColorMapper = ContinuousColorMapper;\r\n    ContinuousColorMapper.__name__ = \"ContinuousColorMapper\";\r\n    ContinuousColorMapper.init_ContinuousColorMapper();\r\n}\r\n","/* models\\mappers\\linear_color_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const continuous_color_mapper_1 = require(140) /* ./continuous_color_mapper */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    class LinearColorMapper extends continuous_color_mapper_1.ContinuousColorMapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        scan(data, n) {\r\n            const low = this.low != null ? this.low : arrayable_1.min(data);\r\n            const high = this.high != null ? this.high : arrayable_1.max(data);\r\n            const norm_factor = 1 / (high - low);\r\n            const normed_interval = 1 / n;\r\n            return { max: high, min: low, norm_factor, normed_interval };\r\n        }\r\n        cmap(d, palette, low_color, high_color, scan_data) {\r\n            // This handles the edge case where d == high, since the code below maps\r\n            // values exactly equal to high to palette.length, which is greater than\r\n            // max_key\r\n            const max_key = palette.length - 1;\r\n            if (d == scan_data.max) {\r\n                return palette[max_key];\r\n            }\r\n            const normed_d = (d - scan_data.min) * scan_data.norm_factor;\r\n            const key = Math.floor(normed_d / scan_data.normed_interval);\r\n            if (key < 0)\r\n                return low_color;\r\n            else if (key > max_key)\r\n                return high_color;\r\n            else\r\n                return palette[key];\r\n        }\r\n    }\r\n    exports.LinearColorMapper = LinearColorMapper;\r\n    LinearColorMapper.__name__ = \"LinearColorMapper\";\r\n}\r\n","/* models\\mappers\\log_color_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const continuous_color_mapper_1 = require(140) /* ./continuous_color_mapper */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    class LogColorMapper extends continuous_color_mapper_1.ContinuousColorMapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        scan(data, n) {\r\n            const low = this.low != null ? this.low : arrayable_1.min(data);\r\n            const high = this.high != null ? this.high : arrayable_1.max(data);\r\n            const scale = n / (Math.log(high) - Math.log(low)); // subtract the low offset\r\n            return { max: high, min: low, scale };\r\n        }\r\n        cmap(d, palette, low_color, high_color, scan_data) {\r\n            const max_key = palette.length - 1;\r\n            if (d > scan_data.max) {\r\n                return high_color;\r\n            }\r\n            // This handles the edge case where d == high, since the code below maps\r\n            // values exactly equal to high to palette.length, which is greater than\r\n            // max_key\r\n            if (d == scan_data.max)\r\n                return palette[max_key];\r\n            else if (d < scan_data.min)\r\n                return low_color;\r\n            // Get the key\r\n            const log = Math.log(d) - Math.log(scan_data.min); // subtract the low offset\r\n            let key = Math.floor(log * scan_data.scale);\r\n            // Deal with upper bound\r\n            if (key > max_key) {\r\n                key = max_key;\r\n            }\r\n            return palette[key];\r\n        }\r\n    }\r\n    exports.LogColorMapper = LogColorMapper;\r\n    LogColorMapper.__name__ = \"LogColorMapper\";\r\n}\r\n","/* models\\mappers\\scanning_color_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const continuous_color_mapper_1 = require(140) /* ./continuous_color_mapper */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    class ScanningColorMapper extends continuous_color_mapper_1.ContinuousColorMapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        cmap(d, palette, low_color, high_color, edges) {\r\n            if (d < edges.binning[0])\r\n                return low_color;\r\n            if (d > edges.binning[edges.binning.length - 1])\r\n                return high_color;\r\n            const key = arrayable_1.left_edge_index(d, edges.binning);\r\n            return palette[key];\r\n        }\r\n    }\r\n    exports.ScanningColorMapper = ScanningColorMapper;\r\n    ScanningColorMapper.__name__ = \"ScanningColorMapper\";\r\n}\r\n","/* models\\mappers\\eqhist_color_mapper.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const scanning_color_mapper_1 = require(143) /* ./scanning_color_mapper */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    class EqHistColorMapper extends scanning_color_mapper_1.ScanningColorMapper {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_EqHistColorMapper() {\r\n            this.define({\r\n                bins: [p.Int, 256 * 256],\r\n            });\r\n        }\r\n        scan(data, n) {\r\n            const low = this.low != null ? this.low : arrayable_1.min(data);\r\n            const high = this.high != null ? this.high : arrayable_1.max(data);\r\n            const nbins = this.bins;\r\n            const eq_bin_edges = array_1.linspace(low, high, nbins + 1);\r\n            const hist = arrayable_1.bin_counts(data, eq_bin_edges);\r\n            const eq_bin_centers = new Array(nbins);\r\n            for (let i = 0, length = eq_bin_edges.length; i < length - 1; i++) {\r\n                const left = eq_bin_edges[i];\r\n                const right = eq_bin_edges[i + 1];\r\n                eq_bin_centers[i] = (left + right) / 2;\r\n            }\r\n            // CDFs\r\n            const cdf = array_1.cumsum(hist);\r\n            const cdf_max = cdf[cdf.length - 1];\r\n            const norm_cdf = arrayable_1.map(cdf, (x) => x / cdf_max);\r\n            // Iteratively find as many finite bins as there are colors\r\n            let finite_bins = n - 1;\r\n            let binning = [];\r\n            let iterations = 0;\r\n            let guess = n * 2;\r\n            while ((finite_bins != n) && (iterations < 4) && (finite_bins != 0)) {\r\n                const ratio = guess / finite_bins;\r\n                if (ratio > 1000) {\r\n                    // Abort if distribution is extremely skewed\r\n                    break;\r\n                }\r\n                guess = Math.round(Math.max(n * ratio, n));\r\n                // Interpolate\r\n                const palette_edges = array_1.range(0, guess);\r\n                const palette_cdf = arrayable_1.map(norm_cdf, (x) => x * (guess - 1));\r\n                binning = arrayable_1.interpolate(palette_edges, palette_cdf, eq_bin_centers);\r\n                // Evaluate binning\r\n                const uniq_bins = array_1.uniq(binning);\r\n                finite_bins = uniq_bins.length - 1;\r\n                iterations++;\r\n            }\r\n            if (finite_bins == 0) {\r\n                binning = [low, high];\r\n                for (let j = 0; j < n - 1; j++)\r\n                    binning.push(high);\r\n            }\r\n            else {\r\n                binning = binning.slice(binning.length - n - 1);\r\n                if (finite_bins != n)\r\n                    logging_1.logger.warn(\"EqHistColorMapper warning: Histogram equalization did not converge.\");\r\n            }\r\n            return { min: low, max: high, binning };\r\n        }\r\n    }\r\n    exports.EqHistColorMapper = EqHistColorMapper;\r\n    EqHistColorMapper.__name__ = \"EqHistColorMapper\";\r\n    EqHistColorMapper.init_EqHistColorMapper();\r\n}\r\n","/* models\\scales\\linear_scale.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const continuous_scale_1 = require(146) /* ./continuous_scale */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class LinearScale extends continuous_scale_1.ContinuousScale {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LinearScale() {\r\n            this.internal({ scan_result: [p.Any] });\r\n        }\r\n        compute(x) {\r\n            return this._linear_compute(x);\r\n        }\r\n        v_compute(xs) {\r\n            return this._linear_v_compute(xs);\r\n        }\r\n        invert(xprime) {\r\n            return this._linear_invert(xprime);\r\n        }\r\n        v_invert(xprimes) {\r\n            return this._linear_v_invert(xprimes);\r\n        }\r\n    }\r\n    exports.LinearScale = LinearScale;\r\n    LinearScale.__name__ = \"LinearScale\";\r\n    LinearScale.init_LinearScale();\r\n}\r\n","/* models\\scales\\continuous_scale.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const scale_1 = require(147) /* ./scale */;\r\n    class ContinuousScale extends scale_1.Scale {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.ContinuousScale = ContinuousScale;\r\n    ContinuousScale.__name__ = \"ContinuousScale\";\r\n}\r\n","/* models\\scales\\scale.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const transforms_1 = require(148) /* ../transforms */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class Scale extends transforms_1.Transform {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Scale() {\r\n            this.internal({\r\n                source_range: [p.Any],\r\n                target_range: [p.Any],\r\n            });\r\n        }\r\n        r_compute(x0, x1) {\r\n            if (this.target_range.is_reversed)\r\n                return [this.compute(x1), this.compute(x0)];\r\n            else\r\n                return [this.compute(x0), this.compute(x1)];\r\n        }\r\n        r_invert(sx0, sx1) {\r\n            if (this.target_range.is_reversed)\r\n                return [this.invert(sx1), this.invert(sx0)];\r\n            else\r\n                return [this.invert(sx0), this.invert(sx1)];\r\n        }\r\n        // These are needed by both LinearScale and CategoricalScale and this is the\r\n        // only common ancestor. TODO: Proper MI/Mixin would be better.\r\n        _linear_compute(x) {\r\n            const [factor, offset] = this._linear_compute_state();\r\n            return factor * x + offset;\r\n        }\r\n        _linear_v_compute(xs) {\r\n            const [factor, offset] = this._linear_compute_state();\r\n            const result = new types_1.NumberArray(xs.length);\r\n            for (let i = 0; i < xs.length; i++)\r\n                result[i] = factor * xs[i] + offset;\r\n            return result;\r\n        }\r\n        _linear_invert(xprime) {\r\n            const [factor, offset] = this._linear_compute_state();\r\n            return (xprime - offset) / factor;\r\n        }\r\n        _linear_v_invert(xprimes) {\r\n            const [factor, offset] = this._linear_compute_state();\r\n            const result = new types_1.NumberArray(xprimes.length);\r\n            for (let i = 0; i < xprimes.length; i++)\r\n                result[i] = (xprimes[i] - offset) / factor;\r\n            return result;\r\n        }\r\n        /*protected*/ _linear_compute_state() {\r\n            //\r\n            //  (t1 - t0)       (t1 - t0)\r\n            //  --------- * x - --------- * s0 + t0\r\n            //  (s1 - s0)       (s1 - s0)\r\n            //\r\n            // [  factor  ]     [    offset    ]\r\n            //\r\n            const source_start = this.source_range.start;\r\n            const source_end = this.source_range.end;\r\n            const target_start = this.target_range.start;\r\n            const target_end = this.target_range.end;\r\n            const factor = (target_end - target_start) / (source_end - source_start);\r\n            const offset = -(factor * source_start) + target_start;\r\n            return [factor, offset];\r\n        }\r\n    }\r\n    exports.Scale = Scale;\r\n    Scale.__name__ = \"Scale\";\r\n    Scale.init_Scale();\r\n}\r\n","/* models\\transforms\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var customjs_transform_1 = require(149) /* ./customjs_transform */;\r\n    exports.CustomJSTransform = customjs_transform_1.CustomJSTransform;\r\n    var dodge_1 = require(150) /* ./dodge */;\r\n    exports.Dodge = dodge_1.Dodge;\r\n    var interpolator_1 = require(152) /* ./interpolator */;\r\n    exports.Interpolator = interpolator_1.Interpolator;\r\n    var jitter_1 = require(153) /* ./jitter */;\r\n    exports.Jitter = jitter_1.Jitter;\r\n    var linear_interpolator_1 = require(154) /* ./linear_interpolator */;\r\n    exports.LinearInterpolator = linear_interpolator_1.LinearInterpolator;\r\n    var step_interpolator_1 = require(155) /* ./step_interpolator */;\r\n    exports.StepInterpolator = step_interpolator_1.StepInterpolator;\r\n    var transform_1 = require(137) /* ./transform */;\r\n    exports.Transform = transform_1.Transform;\r\n}\r\n","/* models\\transforms\\customjs_transform.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const transform_1 = require(137) /* ./transform */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const string_1 = require(29) /* ../../core/util/string */;\r\n    class CustomJSTransform extends transform_1.Transform {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CustomJSTransform() {\r\n            this.define({\r\n                args: [p.Any, {}],\r\n                func: [p.String, \"\"],\r\n                v_func: [p.String, \"\"],\r\n            });\r\n        }\r\n        get names() {\r\n            return object_1.keys(this.args);\r\n        }\r\n        get values() {\r\n            return object_1.values(this.args);\r\n        }\r\n        _make_transform(name, func) {\r\n            return new Function(...this.names, name, string_1.use_strict(func));\r\n        }\r\n        get scalar_transform() {\r\n            return this._make_transform(\"x\", this.func);\r\n        }\r\n        get vector_transform() {\r\n            return this._make_transform(\"xs\", this.v_func);\r\n        }\r\n        compute(x) {\r\n            return this.scalar_transform(...this.values, x);\r\n        }\r\n        v_compute(xs) {\r\n            return this.vector_transform(...this.values, xs);\r\n        }\r\n    }\r\n    exports.CustomJSTransform = CustomJSTransform;\r\n    CustomJSTransform.__name__ = \"CustomJSTransform\";\r\n    CustomJSTransform.init_CustomJSTransform();\r\n}\r\n","/* models\\transforms\\dodge.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const range_transform_1 = require(151) /* ./range_transform */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class Dodge extends range_transform_1.RangeTransform {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Dodge() {\r\n            this.define({\r\n                value: [p.Number, 0],\r\n            });\r\n        }\r\n        _compute(x) {\r\n            return x + this.value;\r\n        }\r\n    }\r\n    exports.Dodge = Dodge;\r\n    Dodge.__name__ = \"Dodge\";\r\n    Dodge.init_Dodge();\r\n}\r\n","/* models\\transforms\\range_transform.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const transform_1 = require(137) /* ./transform */;\r\n    const factor_range_1 = require(98) /* ../ranges/factor_range */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const types_2 = require(8) /* ../../core/util/types */;\r\n    class RangeTransform extends transform_1.Transform {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_RangeTransform() {\r\n            this.define({\r\n                range: [p.Instance],\r\n            });\r\n        }\r\n        v_compute(xs0) {\r\n            let xs;\r\n            if (this.range instanceof factor_range_1.FactorRange)\r\n                xs = this.range.v_synthetic(xs0);\r\n            else if (types_2.isArrayableOf(xs0, types_2.isNumber))\r\n                xs = xs0;\r\n            else\r\n                throw new Error(\"unexpected\");\r\n            const result = new types_1.NumberArray(xs.length);\r\n            for (let i = 0; i < xs.length; i++) {\r\n                const x = xs[i];\r\n                result[i] = this._compute(x);\r\n            }\r\n            return result;\r\n        }\r\n        compute(x) {\r\n            if (this.range instanceof factor_range_1.FactorRange)\r\n                return this._compute(this.range.synthetic(x));\r\n            else if (types_2.isNumber(x))\r\n                return this._compute(x);\r\n            else\r\n                throw new Error(\"unexpected\");\r\n        }\r\n    }\r\n    exports.RangeTransform = RangeTransform;\r\n    RangeTransform.__name__ = \"RangeTransform\";\r\n    RangeTransform.init_RangeTransform();\r\n}\r\n","/* models\\transforms\\interpolator.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const transform_1 = require(137) /* ./transform */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const types_2 = require(8) /* ../../core/util/types */;\r\n    class Interpolator extends transform_1.Transform {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this._sorted_dirty = true;\r\n        }\r\n        static init_Interpolator() {\r\n            this.define({\r\n                x: [p.Any],\r\n                y: [p.Any],\r\n                data: [p.Any],\r\n                clip: [p.Boolean, true],\r\n            });\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.change, () => this._sorted_dirty = true);\r\n        }\r\n        v_compute(xs) {\r\n            const result = new types_1.NumberArray(xs.length);\r\n            for (let i = 0; i < xs.length; i++) {\r\n                const x = xs[i];\r\n                result[i] = this.compute(x);\r\n            }\r\n            return result;\r\n        }\r\n        sort(descending = false) {\r\n            if (!this._sorted_dirty)\r\n                return;\r\n            let tsx;\r\n            let tsy;\r\n            if (types_2.isString(this.x) && types_2.isString(this.y) && this.data != null) {\r\n                const column_names = this.data.columns();\r\n                if (!array_1.includes(column_names, this.x))\r\n                    throw new Error(\"The x parameter does not correspond to a valid column name defined in the data parameter\");\r\n                if (!array_1.includes(column_names, this.y))\r\n                    throw new Error(\"The y parameter does not correspond to a valid column name defined in the data parameter\");\r\n                tsx = this.data.get_column(this.x);\r\n                tsy = this.data.get_column(this.y);\r\n            }\r\n            else if (types_2.isArray(this.x) && types_2.isArray(this.y)) {\r\n                tsx = this.x;\r\n                tsy = this.y;\r\n            }\r\n            else {\r\n                throw new Error(\"parameters 'x' and 'y' must be both either string fields or arrays\");\r\n            }\r\n            if (tsx.length !== tsy.length)\r\n                throw new Error(\"The length for x and y do not match\");\r\n            if (tsx.length < 2)\r\n                throw new Error(\"x and y must have at least two elements to support interpolation\");\r\n            const n = tsx.length;\r\n            const index = new Uint32Array(n);\r\n            for (let i = 0; i < n; i++) {\r\n                index[i] = i;\r\n            }\r\n            const sign = descending ? -1 : 1;\r\n            index.sort((i, j) => sign * (tsx[i] - tsx[j]));\r\n            this._x_sorted = new types_1.NumberArray(n);\r\n            this._y_sorted = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                this._x_sorted[i] = tsx[index[i]];\r\n                this._y_sorted[i] = tsy[index[i]];\r\n            }\r\n            this._sorted_dirty = false;\r\n        }\r\n    }\r\n    exports.Interpolator = Interpolator;\r\n    Interpolator.__name__ = \"Interpolator\";\r\n    Interpolator.init_Interpolator();\r\n}\r\n","/* models\\transforms\\jitter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const range_transform_1 = require(151) /* ./range_transform */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const bokeh_math = tslib_1.__importStar(require(10) /* ../../core/util/math */);\r\n    class Jitter extends range_transform_1.RangeTransform {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Jitter() {\r\n            this.define({\r\n                mean: [p.Number, 0],\r\n                width: [p.Number, 1],\r\n                distribution: [p.Distribution, 'uniform'],\r\n            });\r\n        }\r\n        v_compute(xs0) {\r\n            if (this.previous_values != null && this.previous_values.length == xs0.length)\r\n                return this.previous_values;\r\n            this.previous_values = super.v_compute(xs0);\r\n            return this.previous_values;\r\n        }\r\n        _compute(x) {\r\n            switch (this.distribution) {\r\n                case \"uniform\":\r\n                    return x + this.mean + (bokeh_math.random() - 0.5) * this.width;\r\n                case \"normal\":\r\n                    return x + bokeh_math.rnorm(this.mean, this.width);\r\n            }\r\n        }\r\n    }\r\n    exports.Jitter = Jitter;\r\n    Jitter.__name__ = \"Jitter\";\r\n    Jitter.init_Jitter();\r\n}\r\n","/* models\\transforms\\linear_interpolator.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const interpolator_1 = require(152) /* ./interpolator */;\r\n    class LinearInterpolator extends interpolator_1.Interpolator {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        compute(x) {\r\n            this.sort(false);\r\n            if (this.clip) {\r\n                if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1])\r\n                    return NaN;\r\n            }\r\n            else {\r\n                if (x < this._x_sorted[0])\r\n                    return this._y_sorted[0];\r\n                if (x > this._x_sorted[this._x_sorted.length - 1])\r\n                    return this._y_sorted[this._y_sorted.length - 1];\r\n            }\r\n            if (x == this._x_sorted[0])\r\n                return this._y_sorted[0];\r\n            const ind = array_1.find_last_index(this._x_sorted, num => num < x);\r\n            const x1 = this._x_sorted[ind];\r\n            const x2 = this._x_sorted[ind + 1];\r\n            const y1 = this._y_sorted[ind];\r\n            const y2 = this._y_sorted[ind + 1];\r\n            return y1 + (((x - x1) / (x2 - x1)) * (y2 - y1));\r\n        }\r\n    }\r\n    exports.LinearInterpolator = LinearInterpolator;\r\n    LinearInterpolator.__name__ = \"LinearInterpolator\";\r\n}\r\n","/* models\\transforms\\step_interpolator.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const interpolator_1 = require(152) /* ./interpolator */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    class StepInterpolator extends interpolator_1.Interpolator {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_StepInterpolator() {\r\n            this.define({\r\n                mode: [p.StepMode, \"after\"],\r\n            });\r\n        }\r\n        compute(x) {\r\n            this.sort(false);\r\n            if (this.clip) {\r\n                if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1])\r\n                    return NaN;\r\n            }\r\n            else {\r\n                if (x < this._x_sorted[0])\r\n                    return this._y_sorted[0];\r\n                if (x > this._x_sorted[this._x_sorted.length - 1])\r\n                    return this._y_sorted[this._y_sorted.length - 1];\r\n            }\r\n            let ind;\r\n            switch (this.mode) {\r\n                case \"after\": {\r\n                    ind = array_1.find_last_index(this._x_sorted, num => x >= num);\r\n                    break;\r\n                }\r\n                case \"before\": {\r\n                    ind = array_1.find_index(this._x_sorted, num => x <= num);\r\n                    break;\r\n                }\r\n                case \"center\": {\r\n                    const diffs = this._x_sorted.map((tx) => Math.abs(tx - x));\r\n                    const mdiff = array_1.min(diffs);\r\n                    ind = array_1.find_index(diffs, num => mdiff === num);\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new Error(`unknown mode: ${this.mode}`);\r\n            }\r\n            return ind != -1 ? this._y_sorted[ind] : NaN;\r\n        }\r\n    }\r\n    exports.StepInterpolator = StepInterpolator;\r\n    StepInterpolator.__name__ = \"StepInterpolator\";\r\n    StepInterpolator.init_StepInterpolator();\r\n}\r\n","/* models\\scales\\linear_interpolation_scale.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const scale_1 = require(147) /* ./scale */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class LinearInterpolationScale extends scale_1.Scale {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LinearInterpolationScale() {\r\n            this.internal({ binning: [p.Array] });\r\n        }\r\n        compute(x) {\r\n            return x;\r\n        }\r\n        v_compute(xs) {\r\n            const norm_xs = arrayable_1.norm(xs, this.source_range.start, this.source_range.end);\r\n            const edges_norm = array_1.linspace(0, 1, this.binning.length);\r\n            const interpolated = arrayable_1.interpolate(norm_xs, edges_norm, this.binning);\r\n            const norm_interp = arrayable_1.norm(interpolated, this.source_range.start, this.source_range.end);\r\n            const target_span = this.target_range.end - this.target_range.start;\r\n            const sxs = arrayable_1.map(norm_interp, (x) => this.target_range.start + x * target_span);\r\n            return new types_1.NumberArray(sxs);\r\n        }\r\n        invert(xprime) {\r\n            return xprime;\r\n        }\r\n        v_invert(xprimes) {\r\n            return new types_1.NumberArray(xprimes);\r\n        }\r\n    }\r\n    exports.LinearInterpolationScale = LinearInterpolationScale;\r\n    LinearInterpolationScale.__name__ = \"LinearInterpolationScale\";\r\n    LinearInterpolationScale.init_LinearInterpolationScale();\r\n}\r\n","/* models\\scales\\log_scale.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const continuous_scale_1 = require(146) /* ./continuous_scale */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    class LogScale extends continuous_scale_1.ContinuousScale {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        compute(x) {\r\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\r\n            let value;\r\n            if (inter_factor == 0)\r\n                value = 0;\r\n            else {\r\n                const _x = (Math.log(x) - inter_offset) / inter_factor;\r\n                if (isFinite(_x))\r\n                    value = _x * factor + offset;\r\n                else\r\n                    value = NaN;\r\n            }\r\n            return value;\r\n        }\r\n        v_compute(xs) {\r\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\r\n            const result = new types_1.NumberArray(xs.length);\r\n            if (inter_factor == 0) {\r\n                for (let i = 0; i < xs.length; i++)\r\n                    result[i] = 0;\r\n            }\r\n            else {\r\n                for (let i = 0; i < xs.length; i++) {\r\n                    const _x = (Math.log(xs[i]) - inter_offset) / inter_factor;\r\n                    let value;\r\n                    if (isFinite(_x))\r\n                        value = _x * factor + offset;\r\n                    else\r\n                        value = NaN;\r\n                    result[i] = value;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        invert(xprime) {\r\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\r\n            const value = (xprime - offset) / factor;\r\n            return Math.exp(inter_factor * value + inter_offset);\r\n        }\r\n        v_invert(xprimes) {\r\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\r\n            const result = new types_1.NumberArray(xprimes.length);\r\n            for (let i = 0; i < xprimes.length; i++) {\r\n                const value = (xprimes[i] - offset) / factor;\r\n                result[i] = Math.exp(inter_factor * value + inter_offset);\r\n            }\r\n            return result;\r\n        }\r\n        _get_safe_factor(orig_start, orig_end) {\r\n            let start = orig_start < 0 ? 0 : orig_start;\r\n            let end = orig_end < 0 ? 0 : orig_end;\r\n            if (start == end) {\r\n                if (start == 0)\r\n                    [start, end] = [1, 10];\r\n                else {\r\n                    const log_val = Math.log(start) / Math.log(10);\r\n                    start = 10 ** Math.floor(log_val);\r\n                    if (Math.ceil(log_val) != Math.floor(log_val))\r\n                        end = 10 ** Math.ceil(log_val);\r\n                    else\r\n                        end = 10 ** (Math.ceil(log_val) + 1);\r\n                }\r\n            }\r\n            return [start, end];\r\n        }\r\n        /*protected*/ _compute_state() {\r\n            const source_start = this.source_range.start;\r\n            const source_end = this.source_range.end;\r\n            const target_start = this.target_range.start;\r\n            const target_end = this.target_range.end;\r\n            const screen_range = target_end - target_start;\r\n            const [start, end] = this._get_safe_factor(source_start, source_end);\r\n            let inter_factor;\r\n            let inter_offset;\r\n            if (start == 0) {\r\n                inter_factor = Math.log(end);\r\n                inter_offset = 0;\r\n            }\r\n            else {\r\n                inter_factor = Math.log(end) - Math.log(start);\r\n                inter_offset = Math.log(start);\r\n            }\r\n            const factor = screen_range;\r\n            const offset = target_start;\r\n            return [factor, offset, inter_factor, inter_offset];\r\n        }\r\n    }\r\n    exports.LogScale = LogScale;\r\n    LogScale.__name__ = \"LogScale\";\r\n}\r\n","/* models\\ranges\\range1d.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const range_1 = require(99) /* ./range */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class Range1d extends range_1.Range {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Range1d() {\r\n            this.define({\r\n                start: [p.Number, 0],\r\n                end: [p.Number, 1],\r\n                reset_start: [p.Number],\r\n                reset_end: [p.Number],\r\n            });\r\n        }\r\n        _set_auto_bounds() {\r\n            if (this.bounds == 'auto') {\r\n                const min = Math.min(this.reset_start, this.reset_end);\r\n                const max = Math.max(this.reset_start, this.reset_end);\r\n                this.setv({ bounds: [min, max] }, { silent: true });\r\n            }\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            if (this.reset_start == null) {\r\n                this.reset_start = this.start;\r\n            }\r\n            if (this.reset_end == null) {\r\n                this.reset_end = this.end;\r\n            }\r\n            this._set_auto_bounds();\r\n        }\r\n        get min() {\r\n            return Math.min(this.start, this.end);\r\n        }\r\n        get max() {\r\n            return Math.max(this.start, this.end);\r\n        }\r\n        reset() {\r\n            this._set_auto_bounds();\r\n            if (this.start != this.reset_start || this.end != this.reset_end)\r\n                this.setv({ start: this.reset_start, end: this.reset_end });\r\n            else\r\n                this.change.emit();\r\n        }\r\n    }\r\n    exports.Range1d = Range1d;\r\n    Range1d.__name__ = \"Range1d\";\r\n    Range1d.init_Range1d();\r\n}\r\n","/* core\\util\\text.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const dom_1 = require(72) /* ../dom */;\r\n    const _font_cache = new Map();\r\n    function measure_font(font) {\r\n        const metrics = _font_cache.get(font);\r\n        if (metrics != null)\r\n            return metrics;\r\n        const text = dom_1.span({ style: { font } }, \"Hg\");\r\n        const block = dom_1.div({ style: { display: \"inline-block\", width: \"1px\", height: \"0px\" } });\r\n        const elem = dom_1.div({}, text, block);\r\n        document.body.appendChild(elem);\r\n        try {\r\n            block.style.verticalAlign = \"baseline\";\r\n            const ascent = dom_1.offset(block).top - dom_1.offset(text).top;\r\n            block.style.verticalAlign = \"bottom\";\r\n            const height = dom_1.offset(block).top - dom_1.offset(text).top;\r\n            const result = { height, ascent, descent: height - ascent };\r\n            _font_cache.set(font, result);\r\n            return result;\r\n        }\r\n        finally {\r\n            document.body.removeChild(elem);\r\n        }\r\n    }\r\n    exports.measure_font = measure_font;\r\n    const _text_cache = new Map();\r\n    function measure_text(text, font) {\r\n        let size_cache = _text_cache.get(font);\r\n        if (size_cache != null) {\r\n            const size = size_cache.get(text);\r\n            if (size != null)\r\n                return size;\r\n        }\r\n        else {\r\n            size_cache = new Map();\r\n            _text_cache.set(font, size_cache);\r\n        }\r\n        const el = dom_1.div({ style: { display: \"inline-block\", \"white-space\": \"nowrap\", font } }, text);\r\n        document.body.appendChild(el);\r\n        try {\r\n            const { width, height } = el.getBoundingClientRect();\r\n            size_cache.set(text, { width, height });\r\n            return { width, height };\r\n        }\r\n        finally {\r\n            document.body.removeChild(el);\r\n        }\r\n    }\r\n    exports.measure_text = measure_text;\r\n}\r\n","/* models\\annotations\\label.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const text_annotation_1 = require(161) /* ./text_annotation */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class LabelView extends text_annotation_1.TextAnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.visuals.warm_cache();\r\n        }\r\n        _get_size() {\r\n            const { ctx } = this.layer;\r\n            this.visuals.text.set_value(ctx);\r\n            const { width, ascent } = ctx.measureText(this.model.text);\r\n            return { width, height: ascent };\r\n        }\r\n        _render() {\r\n            // Here because AngleSpec does units transform and label doesn't support specs\r\n            let angle;\r\n            switch (this.model.angle_units) {\r\n                case \"rad\": {\r\n                    angle = -this.model.angle;\r\n                    break;\r\n                }\r\n                case \"deg\": {\r\n                    angle = (-this.model.angle * Math.PI) / 180.0;\r\n                    break;\r\n                }\r\n            }\r\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\r\n            const xscale = this.coordinates.x_scale;\r\n            const yscale = this.coordinates.y_scale;\r\n            let sx = this.model.x_units == \"data\" ? xscale.compute(this.model.x) : panel.xview.compute(this.model.x);\r\n            let sy = this.model.y_units == \"data\" ? yscale.compute(this.model.y) : panel.yview.compute(this.model.y);\r\n            sx += this.model.x_offset;\r\n            sy -= this.model.y_offset;\r\n            const draw = this.model.render_mode == 'canvas' ? this._canvas_text.bind(this) : this._css_text.bind(this);\r\n            draw(this.layer.ctx, this.model.text, sx, sy, angle);\r\n        }\r\n    }\r\n    exports.LabelView = LabelView;\r\n    LabelView.__name__ = \"LabelView\";\r\n    class Label extends text_annotation_1.TextAnnotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Label() {\r\n            this.prototype.default_view = LabelView;\r\n            this.mixins([\r\n                mixins.Text /*Scalar*/,\r\n                [\"border_\", mixins.Line],\r\n                [\"background_\", mixins.Fill],\r\n            ]);\r\n            this.define({\r\n                x: [p.Number],\r\n                x_units: [p.SpatialUnits, 'data'],\r\n                y: [p.Number],\r\n                y_units: [p.SpatialUnits, 'data'],\r\n                text: [p.String],\r\n                angle: [p.Angle, 0],\r\n                angle_units: [p.AngleUnits, 'rad'],\r\n                x_offset: [p.Number, 0],\r\n                y_offset: [p.Number, 0],\r\n            });\r\n            this.override({\r\n                background_fill_color: null,\r\n                border_line_color: null,\r\n            });\r\n        }\r\n    }\r\n    exports.Label = Label;\r\n    Label.__name__ = \"Label\";\r\n    Label.init_Label();\r\n}\r\n","/* models\\annotations\\text_annotation.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const text_1 = require(159) /* ../../core/util/text */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    class TextAnnotationView extends annotation_1.AnnotationView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.rotate = true;\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            if (this.model.render_mode == 'css') {\r\n                this.el = dom_1.div();\r\n                this.plot_view.canvas_view.add_overlay(this.el);\r\n            }\r\n        }\r\n        remove() {\r\n            if (this.el != null)\r\n                dom_1.remove(this.el);\r\n            super.remove();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            if (this.model.render_mode == 'css') {\r\n                // dispatch CSS update immediately\r\n                this.connect(this.model.change, () => this.render());\r\n            }\r\n            else {\r\n                this.connect(this.model.change, () => this.plot_view.request_render());\r\n            }\r\n        }\r\n        render() {\r\n            if (!this.model.visible && this.model.render_mode == \"css\")\r\n                dom_1.undisplay(this.el);\r\n            super.render();\r\n        }\r\n        _calculate_text_dimensions(ctx, text) {\r\n            const { width } = ctx.measureText(text);\r\n            const { height } = text_1.measure_font(this.visuals.text.font_value());\r\n            return [width, height];\r\n        }\r\n        _calculate_bounding_box_dimensions(ctx, text) {\r\n            const [width, height] = this._calculate_text_dimensions(ctx, text);\r\n            let x_offset;\r\n            switch (ctx.textAlign) {\r\n                case 'left':\r\n                    x_offset = 0;\r\n                    break;\r\n                case 'center':\r\n                    x_offset = -width / 2;\r\n                    break;\r\n                case 'right':\r\n                    x_offset = -width;\r\n                    break;\r\n                default:\r\n                    assert_1.unreachable();\r\n            }\r\n            // guestimated from https://www.w3.org/TR/2dcontext/#dom-context-2d-textbaseline\r\n            let y_offset;\r\n            switch (ctx.textBaseline) {\r\n                case 'top':\r\n                    y_offset = 0.0;\r\n                    break;\r\n                case 'middle':\r\n                    y_offset = -0.5 * height;\r\n                    break;\r\n                case 'bottom':\r\n                    y_offset = -1.0 * height;\r\n                    break;\r\n                case 'alphabetic':\r\n                    y_offset = -0.8 * height;\r\n                    break;\r\n                case 'hanging':\r\n                    y_offset = -0.17 * height;\r\n                    break;\r\n                case 'ideographic':\r\n                    y_offset = -0.83 * height;\r\n                    break;\r\n                default:\r\n                    assert_1.unreachable();\r\n            }\r\n            return [x_offset, y_offset, width, height];\r\n        }\r\n        _canvas_text(ctx, text, sx, sy, angle) {\r\n            this.visuals.text.set_value(ctx);\r\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.translate(sx, sy);\r\n            if (angle)\r\n                ctx.rotate(angle);\r\n            ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\r\n            if (this.visuals.background_fill.doit) {\r\n                this.visuals.background_fill.set_value(ctx);\r\n                ctx.fill();\r\n            }\r\n            if (this.visuals.border_line.doit) {\r\n                this.visuals.border_line.set_value(ctx);\r\n                ctx.stroke();\r\n            }\r\n            if (this.visuals.text.doit) {\r\n                this.visuals.text.set_value(ctx);\r\n                ctx.fillText(text, 0, 0);\r\n            }\r\n            ctx.restore();\r\n        }\r\n        _css_text(ctx, text, sx, sy, angle) {\r\n            const { el } = this;\r\n            assert_1.assert(el != null);\r\n            dom_1.undisplay(el);\r\n            this.visuals.text.set_value(ctx);\r\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\r\n            // attempt to support vector string-style (\"8 4 8\") line dashing for css mode\r\n            const ld = this.visuals.border_line.line_dash.value();\r\n            const line_dash = ld.length < 2 ? \"solid\" : \"dashed\";\r\n            this.visuals.border_line.set_value(ctx);\r\n            this.visuals.background_fill.set_value(ctx);\r\n            el.style.position = 'absolute';\r\n            el.style.left = `${sx + bbox_dims[0]}px`;\r\n            el.style.top = `${sy + bbox_dims[1]}px`;\r\n            el.style.color = `${this.visuals.text.text_color.value()}`;\r\n            el.style.opacity = `${this.visuals.text.text_alpha.value()}`;\r\n            el.style.font = `${this.visuals.text.font_value()}`;\r\n            el.style.lineHeight = \"normal\"; // needed to prevent ipynb css override\r\n            if (angle) {\r\n                el.style.transform = `rotate(${angle}rad)`;\r\n            }\r\n            if (this.visuals.background_fill.doit) {\r\n                el.style.backgroundColor = `${this.visuals.background_fill.color_value()}`;\r\n            }\r\n            if (this.visuals.border_line.doit) {\r\n                el.style.borderStyle = `${line_dash}`;\r\n                el.style.borderWidth = `${this.visuals.border_line.line_width.value()}px`;\r\n                el.style.borderColor = `${this.visuals.border_line.color_value()}`;\r\n            }\r\n            el.textContent = text;\r\n            dom_1.display(el);\r\n        }\r\n    }\r\n    exports.TextAnnotationView = TextAnnotationView;\r\n    TextAnnotationView.__name__ = \"TextAnnotationView\";\r\n    class TextAnnotation extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_TextAnnotation() {\r\n            this.define({\r\n                render_mode: [p.RenderMode, \"canvas\"],\r\n            });\r\n        }\r\n    }\r\n    exports.TextAnnotation = TextAnnotation;\r\n    TextAnnotation.__name__ = \"TextAnnotation\";\r\n    TextAnnotation.init_TextAnnotation();\r\n}\r\n","/* models\\annotations\\label_set.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const text_annotation_1 = require(161) /* ./text_annotation */;\r\n    const column_data_source_1 = require(85) /* ../sources/column_data_source */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class LabelSetView extends text_annotation_1.TextAnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.set_data(this.model.source);\r\n            if (this.model.render_mode == 'css') {\r\n                for (let i = 0, end = this._text.length; i < end; i++) {\r\n                    const el = dom_1.div({ style: { display: \"none\" } });\r\n                    this.el.appendChild(el);\r\n                }\r\n            }\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            if (this.model.render_mode == 'css') {\r\n                // dispatch CSS update immediately\r\n                this.connect(this.model.change, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.render();\r\n                });\r\n                this.connect(this.model.source.streaming, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.render();\r\n                });\r\n                this.connect(this.model.source.patching, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.render();\r\n                });\r\n                this.connect(this.model.source.change, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.render();\r\n                });\r\n            }\r\n            else {\r\n                this.connect(this.model.change, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.plot_view.request_render();\r\n                });\r\n                this.connect(this.model.source.streaming, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.plot_view.request_render();\r\n                });\r\n                this.connect(this.model.source.patching, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.plot_view.request_render();\r\n                });\r\n                this.connect(this.model.source.change, () => {\r\n                    this.set_data(this.model.source);\r\n                    this.plot_view.request_render();\r\n                });\r\n            }\r\n        }\r\n        set_data(source) {\r\n            super.set_data(source);\r\n            this.visuals.warm_cache(source);\r\n        }\r\n        _map_data() {\r\n            const xscale = this.coordinates.x_scale;\r\n            const yscale = this.coordinates.y_scale;\r\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\r\n            const sx = this.model.x_units == \"data\" ? xscale.v_compute(this._x) : panel.xview.v_compute(this._x);\r\n            const sy = this.model.y_units == \"data\" ? yscale.v_compute(this._y) : panel.yview.v_compute(this._y);\r\n            return [sx, sy];\r\n        }\r\n        _render() {\r\n            const draw = this.model.render_mode == 'canvas' ? this._v_canvas_text.bind(this) : this._v_css_text.bind(this);\r\n            const { ctx } = this.layer;\r\n            const [sx, sy] = this._map_data();\r\n            for (let i = 0, end = this._text.length; i < end; i++) {\r\n                draw(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]);\r\n            }\r\n        }\r\n        _get_size() {\r\n            const { ctx } = this.layer;\r\n            this.visuals.text.set_value(ctx);\r\n            const { width, ascent } = ctx.measureText(this._text[0]);\r\n            return { width, height: ascent };\r\n        }\r\n        _v_canvas_text(ctx, i, text, sx, sy, angle) {\r\n            this.visuals.text.set_vectorize(ctx, i);\r\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.translate(sx, sy);\r\n            ctx.rotate(angle);\r\n            ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\r\n            if (this.visuals.background_fill.doit) {\r\n                this.visuals.background_fill.set_vectorize(ctx, i);\r\n                ctx.fill();\r\n            }\r\n            if (this.visuals.border_line.doit) {\r\n                this.visuals.border_line.set_vectorize(ctx, i);\r\n                ctx.stroke();\r\n            }\r\n            if (this.visuals.text.doit) {\r\n                this.visuals.text.set_vectorize(ctx, i);\r\n                ctx.fillText(text, 0, 0);\r\n            }\r\n            ctx.restore();\r\n        }\r\n        _v_css_text(ctx, i, text, sx, sy, angle) {\r\n            const el = this.el.children[i];\r\n            el.textContent = text;\r\n            this.visuals.text.set_vectorize(ctx, i);\r\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\r\n            // attempt to support vector-style (\"8 4 8\") line dashing for css mode\r\n            const ld = this.visuals.border_line.line_dash.value();\r\n            const line_dash = ld.length < 2 ? \"solid\" : \"dashed\";\r\n            this.visuals.border_line.set_vectorize(ctx, i);\r\n            this.visuals.background_fill.set_vectorize(ctx, i);\r\n            el.style.position = 'absolute';\r\n            el.style.left = `${sx + bbox_dims[0]}px`;\r\n            el.style.top = `${sy + bbox_dims[1]}px`;\r\n            el.style.color = `${this.visuals.text.text_color.value()}`;\r\n            el.style.opacity = `${this.visuals.text.text_alpha.value()}`;\r\n            el.style.font = `${this.visuals.text.font_value()}`;\r\n            el.style.lineHeight = \"normal\"; // needed to prevent ipynb css override\r\n            if (angle) {\r\n                el.style.transform = `rotate(${angle}rad)`;\r\n            }\r\n            if (this.visuals.background_fill.doit) {\r\n                el.style.backgroundColor = `${this.visuals.background_fill.color_value()}`;\r\n            }\r\n            if (this.visuals.border_line.doit) {\r\n                el.style.borderStyle = `${line_dash}`;\r\n                el.style.borderWidth = `${this.visuals.border_line.line_width.value()}px`;\r\n                el.style.borderColor = `${this.visuals.border_line.color_value()}`;\r\n            }\r\n            dom_1.display(el);\r\n        }\r\n    }\r\n    exports.LabelSetView = LabelSetView;\r\n    LabelSetView.__name__ = \"LabelSetView\";\r\n    class LabelSet extends text_annotation_1.TextAnnotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LabelSet() {\r\n            this.prototype.default_view = LabelSetView;\r\n            this.mixins([\r\n                mixins.TextVector,\r\n                [\"border_\", mixins.LineVector],\r\n                [\"background_\", mixins.FillVector],\r\n            ]);\r\n            this.define({\r\n                x: [p.NumberSpec],\r\n                y: [p.NumberSpec],\r\n                x_units: [p.SpatialUnits, 'data'],\r\n                y_units: [p.SpatialUnits, 'data'],\r\n                text: [p.StringSpec, { field: \"text\" }],\r\n                angle: [p.AngleSpec, 0],\r\n                x_offset: [p.NumberSpec, { value: 0 }],\r\n                y_offset: [p.NumberSpec, { value: 0 }],\r\n                source: [p.Instance, () => new column_data_source_1.ColumnDataSource()],\r\n            });\r\n            this.override({\r\n                background_fill_color: null,\r\n                border_line_color: null,\r\n            });\r\n        }\r\n    }\r\n    exports.LabelSet = LabelSet;\r\n    LabelSet.__name__ = \"LabelSet\";\r\n    LabelSet.init_LabelSet();\r\n}\r\n","/* models\\annotations\\legend.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const text_1 = require(159) /* ../../core/util/text */;\r\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    class LegendView extends annotation_1.AnnotationView {\r\n        cursor(_sx, _sy) {\r\n            return this.model.click_policy == \"none\" ? null : \"pointer\";\r\n        }\r\n        get legend_padding() {\r\n            return this.visuals.border_line.line_color.value() != null ? this.model.padding : 0;\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.plot_view.request_render());\r\n            this.connect(this.model.item_change, () => this.plot_view.request_render());\r\n        }\r\n        compute_legend_bbox() {\r\n            const legend_names = this.model.get_legend_names();\r\n            const { glyph_height, glyph_width } = this.model;\r\n            const { label_height, label_width } = this.model;\r\n            this.max_label_height = array_1.max([text_1.measure_font(this.visuals.label_text.font_value()).height, label_height, glyph_height]);\r\n            // this is to measure text properties\r\n            const { ctx } = this.layer;\r\n            ctx.save();\r\n            this.visuals.label_text.set_value(ctx);\r\n            this.text_widths = new Map();\r\n            for (const name of legend_names) {\r\n                this.text_widths.set(name, array_1.max([ctx.measureText(name).width, label_width]));\r\n            }\r\n            this.visuals.title_text.set_value(ctx);\r\n            this.title_height = this.model.title ? text_1.measure_font(this.visuals.title_text.font_value()).height + this.model.title_standoff : 0;\r\n            this.title_width = this.model.title ? ctx.measureText(this.model.title).width : 0;\r\n            ctx.restore();\r\n            const max_label_width = Math.max(array_1.max([...this.text_widths.values()]), 0);\r\n            const legend_margin = this.model.margin;\r\n            const { legend_padding } = this;\r\n            const legend_spacing = this.model.spacing;\r\n            const { label_standoff } = this.model;\r\n            let legend_height, legend_width;\r\n            if (this.model.orientation == \"vertical\") {\r\n                legend_height = legend_names.length * this.max_label_height + Math.max(legend_names.length - 1, 0) * legend_spacing + 2 * legend_padding + this.title_height;\r\n                legend_width = array_1.max([(max_label_width + glyph_width + label_standoff + 2 * legend_padding), this.title_width + 2 * legend_padding]);\r\n            }\r\n            else {\r\n                let item_width = 2 * legend_padding + Math.max(legend_names.length - 1, 0) * legend_spacing;\r\n                for (const [, width] of this.text_widths) {\r\n                    item_width += array_1.max([width, label_width]) + glyph_width + label_standoff;\r\n                }\r\n                legend_width = array_1.max([this.title_width + 2 * legend_padding, item_width]);\r\n                legend_height = this.max_label_height + this.title_height + 2 * legend_padding;\r\n            }\r\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\r\n            const [hr, vr] = panel.bbox.ranges;\r\n            const { location } = this.model;\r\n            let sx, sy;\r\n            if (types_1.isString(location)) {\r\n                switch (location) {\r\n                    case 'top_left':\r\n                        sx = hr.start + legend_margin;\r\n                        sy = vr.start + legend_margin;\r\n                        break;\r\n                    case 'top_center':\r\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\r\n                        sy = vr.start + legend_margin;\r\n                        break;\r\n                    case 'top_right':\r\n                        sx = hr.end - legend_margin - legend_width;\r\n                        sy = vr.start + legend_margin;\r\n                        break;\r\n                    case 'bottom_right':\r\n                        sx = hr.end - legend_margin - legend_width;\r\n                        sy = vr.end - legend_margin - legend_height;\r\n                        break;\r\n                    case 'bottom_center':\r\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\r\n                        sy = vr.end - legend_margin - legend_height;\r\n                        break;\r\n                    case 'bottom_left':\r\n                        sx = hr.start + legend_margin;\r\n                        sy = vr.end - legend_margin - legend_height;\r\n                        break;\r\n                    case 'center_left':\r\n                        sx = hr.start + legend_margin;\r\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\r\n                        break;\r\n                    case 'center':\r\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\r\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\r\n                        break;\r\n                    case 'center_right':\r\n                        sx = hr.end - legend_margin - legend_width;\r\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\r\n                        break;\r\n                }\r\n            }\r\n            else if (types_1.isArray(location) && location.length == 2) {\r\n                const [vx, vy] = location;\r\n                sx = panel.xview.compute(vx);\r\n                sy = panel.yview.compute(vy) - legend_height;\r\n            }\r\n            else\r\n                assert_1.unreachable();\r\n            return new bbox_1.BBox({ left: sx, top: sy, width: legend_width, height: legend_height });\r\n        }\r\n        interactive_bbox() {\r\n            return this.compute_legend_bbox();\r\n        }\r\n        interactive_hit(sx, sy) {\r\n            const bbox = this.interactive_bbox();\r\n            return bbox.contains(sx, sy);\r\n        }\r\n        on_hit(sx, sy) {\r\n            let yoffset;\r\n            const { glyph_width } = this.model;\r\n            const { legend_padding } = this;\r\n            const legend_spacing = this.model.spacing;\r\n            const { label_standoff } = this.model;\r\n            let xoffset = (yoffset = legend_padding);\r\n            const legend_bbox = this.compute_legend_bbox();\r\n            const vertical = this.model.orientation == \"vertical\";\r\n            for (const item of this.model.items) {\r\n                const labels = item.get_labels_list_from_label_prop();\r\n                for (const label of labels) {\r\n                    const x1 = legend_bbox.x + xoffset;\r\n                    const y1 = legend_bbox.y + yoffset + this.title_height;\r\n                    let w, h;\r\n                    if (vertical)\r\n                        [w, h] = [legend_bbox.width - 2 * legend_padding, this.max_label_height];\r\n                    else\r\n                        [w, h] = [this.text_widths.get(label) + glyph_width + label_standoff, this.max_label_height];\r\n                    const bbox = new bbox_1.BBox({ left: x1, top: y1, width: w, height: h });\r\n                    if (bbox.contains(sx, sy)) {\r\n                        switch (this.model.click_policy) {\r\n                            case \"hide\": {\r\n                                for (const r of item.renderers)\r\n                                    r.visible = !r.visible;\r\n                                break;\r\n                            }\r\n                            case \"mute\": {\r\n                                for (const r of item.renderers)\r\n                                    r.muted = !r.muted;\r\n                                break;\r\n                            }\r\n                        }\r\n                        return true;\r\n                    }\r\n                    if (vertical)\r\n                        yoffset += this.max_label_height + legend_spacing;\r\n                    else\r\n                        xoffset += this.text_widths.get(label) + glyph_width + label_standoff + legend_spacing;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        _render() {\r\n            if (this.model.items.length == 0)\r\n                return;\r\n            // set a backref on render so that items can later signal item_change upates\r\n            // on the model to trigger a re-render\r\n            for (const item of this.model.items) {\r\n                item.legend = this.model;\r\n            }\r\n            const { ctx } = this.layer;\r\n            const bbox = this.compute_legend_bbox();\r\n            ctx.save();\r\n            this._draw_legend_box(ctx, bbox);\r\n            this._draw_legend_items(ctx, bbox);\r\n            if (this.model.title)\r\n                this._draw_title(ctx, bbox);\r\n            ctx.restore();\r\n        }\r\n        _draw_legend_box(ctx, bbox) {\r\n            ctx.beginPath();\r\n            ctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);\r\n            this.visuals.background_fill.set_value(ctx);\r\n            ctx.fill();\r\n            if (this.visuals.border_line.doit) {\r\n                this.visuals.border_line.set_value(ctx);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        _draw_legend_items(ctx, bbox) {\r\n            const { glyph_width, glyph_height } = this.model;\r\n            const { legend_padding } = this;\r\n            const legend_spacing = this.model.spacing;\r\n            const { label_standoff } = this.model;\r\n            let xoffset = legend_padding;\r\n            let yoffset = legend_padding;\r\n            const vertical = this.model.orientation == \"vertical\";\r\n            for (const item of this.model.items) {\r\n                const labels = item.get_labels_list_from_label_prop();\r\n                const field = item.get_field_from_label_prop();\r\n                if (labels.length == 0)\r\n                    continue;\r\n                const active = (() => {\r\n                    switch (this.model.click_policy) {\r\n                        case \"none\": return true;\r\n                        case \"hide\": return array_1.every(item.renderers, r => r.visible);\r\n                        case \"mute\": return array_1.every(item.renderers, r => !r.muted);\r\n                    }\r\n                })();\r\n                for (const label of labels) {\r\n                    const x1 = bbox.x + xoffset;\r\n                    const y1 = bbox.y + yoffset + this.title_height;\r\n                    const x2 = x1 + glyph_width;\r\n                    const y2 = y1 + glyph_height;\r\n                    if (vertical)\r\n                        yoffset += this.max_label_height + legend_spacing;\r\n                    else\r\n                        xoffset += this.text_widths.get(label) + glyph_width + label_standoff + legend_spacing;\r\n                    this.visuals.label_text.set_value(ctx);\r\n                    ctx.fillText(label, x2 + label_standoff, y1 + this.max_label_height / 2.0);\r\n                    for (const r of item.renderers) {\r\n                        const view = this.plot_view.renderer_views.get(r);\r\n                        view.draw_legend(ctx, x1, x2, y1, y2, field, label, item.index);\r\n                    }\r\n                    if (!active) {\r\n                        let w, h;\r\n                        if (vertical)\r\n                            [w, h] = [bbox.width - 2 * legend_padding, this.max_label_height];\r\n                        else\r\n                            [w, h] = [this.text_widths.get(label) + glyph_width + label_standoff, this.max_label_height];\r\n                        ctx.beginPath();\r\n                        ctx.rect(x1, y1, w, h);\r\n                        this.visuals.inactive_fill.set_value(ctx);\r\n                        ctx.fill();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _draw_title(ctx, bbox) {\r\n            if (!this.visuals.title_text.doit)\r\n                return;\r\n            ctx.save();\r\n            ctx.translate(bbox.x0, bbox.y0 + this.title_height);\r\n            this.visuals.title_text.set_value(ctx);\r\n            ctx.fillText(this.model.title, this.legend_padding, this.legend_padding - this.model.title_standoff);\r\n            ctx.restore();\r\n        }\r\n        _get_size() {\r\n            const { width, height } = this.compute_legend_bbox();\r\n            return {\r\n                width: width + 2 * this.model.margin,\r\n                height: height + 2 * this.model.margin,\r\n            };\r\n        }\r\n    }\r\n    exports.LegendView = LegendView;\r\n    LegendView.__name__ = \"LegendView\";\r\n    class Legend extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.item_change = new signaling_1.Signal0(this, \"item_change\");\r\n        }\r\n        static init_Legend() {\r\n            this.prototype.default_view = LegendView;\r\n            this.mixins([\r\n                [\"label_\", mixins.Text],\r\n                [\"title_\", mixins.Text],\r\n                [\"inactive_\", mixins.Fill],\r\n                [\"border_\", mixins.Line],\r\n                [\"background_\", mixins.Fill],\r\n            ]);\r\n            this.define({\r\n                orientation: [p.Orientation, 'vertical'],\r\n                location: [p.Any, 'top_right'],\r\n                title: [p.String],\r\n                title_standoff: [p.Number, 5],\r\n                label_standoff: [p.Number, 5],\r\n                glyph_height: [p.Number, 20],\r\n                glyph_width: [p.Number, 20],\r\n                label_height: [p.Number, 20],\r\n                label_width: [p.Number, 20],\r\n                margin: [p.Number, 10],\r\n                padding: [p.Number, 10],\r\n                spacing: [p.Number, 3],\r\n                items: [p.Array, []],\r\n                click_policy: [p.Any, \"none\"],\r\n            });\r\n            this.override({\r\n                border_line_color: \"#e5e5e5\",\r\n                border_line_alpha: 0.5,\r\n                border_line_width: 1,\r\n                background_fill_color: \"#ffffff\",\r\n                background_fill_alpha: 0.95,\r\n                inactive_fill_color: \"white\",\r\n                inactive_fill_alpha: 0.7,\r\n                label_text_font_size: \"13px\",\r\n                label_text_baseline: \"middle\",\r\n                title_text_font_size: \"13px\",\r\n                title_text_font_style: \"italic\",\r\n            });\r\n        }\r\n        get_legend_names() {\r\n            const legend_names = [];\r\n            for (const item of this.items) {\r\n                const labels = item.get_labels_list_from_label_prop();\r\n                legend_names.push(...labels);\r\n            }\r\n            return legend_names;\r\n        }\r\n    }\r\n    exports.Legend = Legend;\r\n    Legend.__name__ = \"Legend\";\r\n    Legend.init_Legend();\r\n}\r\n","/* models\\annotations\\legend_item.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const columnar_data_source_1 = require(86) /* ../sources/columnar_data_source */;\r\n    const vectorization_1 = require(165) /* ../../core/vectorization */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    class LegendItem extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LegendItem() {\r\n            this.define({\r\n                label: [p.StringSpec, null],\r\n                renderers: [p.Array, []],\r\n                index: [p.Number, null],\r\n            });\r\n        }\r\n        /*protected*/ _check_data_sources_on_renderers() {\r\n            const field = this.get_field_from_label_prop();\r\n            if (field != null) {\r\n                if (this.renderers.length < 1) {\r\n                    return false;\r\n                }\r\n                const source = this.renderers[0].data_source;\r\n                if (source != null) {\r\n                    for (const r of this.renderers) {\r\n                        if (r.data_source != source) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        /*protected*/ _check_field_label_on_data_source() {\r\n            const field = this.get_field_from_label_prop();\r\n            if (field != null) {\r\n                if (this.renderers.length < 1) {\r\n                    return false;\r\n                }\r\n                const source = this.renderers[0].data_source;\r\n                if (source != null && !array_1.includes(source.columns(), field)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.legend = null;\r\n            this.connect(this.change, () => { var _a; return (_a = this.legend) === null || _a === void 0 ? void 0 : _a.item_change.emit(); });\r\n            // Validate data_sources match\r\n            const data_source_validation = this._check_data_sources_on_renderers();\r\n            if (!data_source_validation)\r\n                logging_1.logger.error(\"Non matching data sources on legend item renderers\");\r\n            // Validate label in data_source\r\n            const field_validation = this._check_field_label_on_data_source();\r\n            if (!field_validation)\r\n                logging_1.logger.error(`Bad column name on label: ${this.label}`);\r\n        }\r\n        get_field_from_label_prop() {\r\n            const { label } = this;\r\n            return vectorization_1.isField(label) ? label.field : null;\r\n        }\r\n        get_labels_list_from_label_prop() {\r\n            // Always return a list of the labels\r\n            if (vectorization_1.isValue(this.label)) {\r\n                const { value } = this.label;\r\n                return value != null ? [value] : [];\r\n            }\r\n            const field = this.get_field_from_label_prop();\r\n            if (field != null) {\r\n                let source;\r\n                if (this.renderers[0] && this.renderers[0].data_source != null)\r\n                    source = this.renderers[0].data_source;\r\n                else\r\n                    return [\"No source found\"];\r\n                if (source instanceof columnar_data_source_1.ColumnarDataSource) {\r\n                    const data = source.get_column(field);\r\n                    if (data != null)\r\n                        return array_1.uniq(Array.from(data));\r\n                    else\r\n                        return [\"Invalid field\"];\r\n                }\r\n            }\r\n            return [];\r\n        }\r\n    }\r\n    exports.LegendItem = LegendItem;\r\n    LegendItem.__name__ = \"LegendItem\";\r\n    LegendItem.init_LegendItem();\r\n}\r\n","/* core\\vectorization.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(8) /* ./util/types */;\r\n    function isValue(obj) {\r\n        return types_1.isPlainObject(obj) && \"value\" in obj;\r\n    }\r\n    exports.isValue = isValue;\r\n    function isField(obj) {\r\n        return types_1.isPlainObject(obj) && \"field\" in obj;\r\n    }\r\n    exports.isField = isField;\r\n}\r\n","/* models\\annotations\\poly_annotation.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class PolyAnnotationView extends annotation_1.AnnotationView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            // need to respond to either normal BB change events or silent\r\n            // \"data only updates\" that tools might want to use\r\n            this.connect(this.model.change, () => this.plot_view.request_render());\r\n            this.connect(this.model.data_update, () => this.plot_view.request_render());\r\n        }\r\n        _render() {\r\n            const { xs, ys } = this.model;\r\n            if (xs.length != ys.length)\r\n                return;\r\n            if (xs.length < 3 || ys.length < 3)\r\n                return;\r\n            const { frame } = this.plot_view;\r\n            const { ctx } = this.layer;\r\n            for (let i = 0, end = xs.length; i < end; i++) {\r\n                let sx;\r\n                if (this.model.xs_units == 'screen')\r\n                    sx = this.model.screen ? xs[i] : frame.xview.compute(xs[i]);\r\n                else\r\n                    throw new Error(\"not implemented\");\r\n                let sy;\r\n                if (this.model.ys_units == 'screen')\r\n                    sy = this.model.screen ? ys[i] : frame.yview.compute(ys[i]);\r\n                else\r\n                    throw new Error(\"not implemented\");\r\n                if (i == 0) {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx, sy);\r\n                }\r\n                else {\r\n                    ctx.lineTo(sx, sy);\r\n                }\r\n            }\r\n            ctx.closePath();\r\n            if (this.visuals.line.doit) {\r\n                this.visuals.line.set_value(ctx);\r\n                ctx.stroke();\r\n            }\r\n            if (this.visuals.fill.doit) {\r\n                this.visuals.fill.set_value(ctx);\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n    exports.PolyAnnotationView = PolyAnnotationView;\r\n    PolyAnnotationView.__name__ = \"PolyAnnotationView\";\r\n    class PolyAnnotation extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_PolyAnnotation() {\r\n            this.prototype.default_view = PolyAnnotationView;\r\n            this.mixins([mixins.Line /*Scalar*/, mixins.Fill /*Scalar*/]);\r\n            this.define({\r\n                xs: [p.Array, []],\r\n                xs_units: [p.SpatialUnits, 'data'],\r\n                ys: [p.Array, []],\r\n                ys_units: [p.SpatialUnits, 'data'],\r\n            });\r\n            this.internal({\r\n                screen: [p.Boolean, false],\r\n            });\r\n            this.override({\r\n                fill_color: \"#fff9ba\",\r\n                fill_alpha: 0.4,\r\n                line_color: \"#cccccc\",\r\n                line_alpha: 0.3,\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.data_update = new signaling_1.Signal0(this, \"data_update\");\r\n        }\r\n        update({ xs, ys }) {\r\n            this.setv({ xs, ys, screen: true }, { silent: true });\r\n            this.data_update.emit();\r\n        }\r\n    }\r\n    exports.PolyAnnotation = PolyAnnotation;\r\n    PolyAnnotation.__name__ = \"PolyAnnotation\";\r\n    PolyAnnotation.init_PolyAnnotation();\r\n}\r\n","/* models\\annotations\\slope.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class SlopeView extends annotation_1.AnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.plot_view.request_render());\r\n        }\r\n        _render() {\r\n            const gradient = this.model.gradient;\r\n            const y_intercept = this.model.y_intercept;\r\n            if (gradient == null || y_intercept == null) {\r\n                return;\r\n            }\r\n            const { frame } = this.plot_view;\r\n            const xscale = this.coordinates.x_scale;\r\n            const yscale = this.coordinates.y_scale;\r\n            const sy_start = frame.bbox.top;\r\n            const sy_end = sy_start + frame.bbox.height;\r\n            const y_start = yscale.invert(sy_start);\r\n            const y_end = yscale.invert(sy_end);\r\n            const x_start = (y_start - y_intercept) / gradient;\r\n            const x_end = (y_end - y_intercept) / gradient;\r\n            const sx_start = xscale.compute(x_start);\r\n            const sx_end = xscale.compute(x_end);\r\n            const { ctx } = this.layer;\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            this.visuals.line.set_value(ctx);\r\n            ctx.moveTo(sx_start, sy_start);\r\n            ctx.lineTo(sx_end, sy_end);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n    }\r\n    exports.SlopeView = SlopeView;\r\n    SlopeView.__name__ = \"SlopeView\";\r\n    class Slope extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Slope() {\r\n            this.prototype.default_view = SlopeView;\r\n            this.mixins(mixins.Line /*Scalar*/);\r\n            this.define({\r\n                gradient: [p.Number, null],\r\n                y_intercept: [p.Number, null],\r\n            });\r\n            this.override({\r\n                line_color: 'black',\r\n            });\r\n        }\r\n    }\r\n    exports.Slope = Slope;\r\n    Slope.__name__ = \"Slope\";\r\n    Slope.init_Slope();\r\n}\r\n","/* models\\annotations\\span.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class SpanView extends annotation_1.AnnotationView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.plot_view.request_paint(this));\r\n        }\r\n        _render() {\r\n            const { location } = this.model;\r\n            if (location == null) {\r\n                return;\r\n            }\r\n            const { frame } = this.plot_view;\r\n            const xscale = this.coordinates.x_scale;\r\n            const yscale = this.coordinates.y_scale;\r\n            const _calc_dim = (scale, view) => {\r\n                if (this.model.location_units == 'data')\r\n                    return scale.compute(location);\r\n                else\r\n                    return this.model.for_hover ? location : view.compute(location);\r\n            };\r\n            let height, sleft, stop, width;\r\n            if (this.model.dimension == 'width') {\r\n                stop = _calc_dim(yscale, frame.yview);\r\n                sleft = frame.bbox.left;\r\n                width = frame.bbox.width;\r\n                height = this.model.properties.line_width.value();\r\n            }\r\n            else {\r\n                stop = frame.bbox.top;\r\n                sleft = _calc_dim(xscale, frame.xview);\r\n                width = this.model.properties.line_width.value();\r\n                height = frame.bbox.height;\r\n            }\r\n            const { ctx } = this.layer;\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            this.visuals.line.set_value(ctx);\r\n            ctx.moveTo(sleft, stop);\r\n            if (this.model.dimension == \"width\") {\r\n                ctx.lineTo(sleft + width, stop);\r\n            }\r\n            else {\r\n                ctx.lineTo(sleft, stop + height);\r\n            }\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n    }\r\n    exports.SpanView = SpanView;\r\n    SpanView.__name__ = \"SpanView\";\r\n    class Span extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Span() {\r\n            this.prototype.default_view = SpanView;\r\n            this.mixins(mixins.Line /*Scalar*/);\r\n            this.define({\r\n                render_mode: [p.RenderMode, 'canvas'],\r\n                location: [p.Number, null],\r\n                location_units: [p.SpatialUnits, 'data'],\r\n                dimension: [p.Dimension, 'width'],\r\n            });\r\n            this.override({\r\n                line_color: 'black',\r\n            });\r\n            this.internal({\r\n                for_hover: [p.Boolean, false],\r\n            });\r\n        }\r\n    }\r\n    exports.Span = Span;\r\n    Span.__name__ = \"Span\";\r\n    Span.init_Span();\r\n}\r\n","/* models\\annotations\\title.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const text_annotation_1 = require(161) /* ./text_annotation */;\r\n    const visuals_1 = require(74) /* ../../core/visuals */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class TitleView extends text_annotation_1.TextAnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.visuals.text = new visuals_1.Text(this.model);\r\n        }\r\n        _get_location() {\r\n            const panel = this.panel;\r\n            const hmargin = this.model.offset;\r\n            const vmargin = 5;\r\n            let sx, sy;\r\n            const { bbox } = panel;\r\n            switch (panel.side) {\r\n                case 'above':\r\n                case 'below': {\r\n                    switch (this.model.vertical_align) {\r\n                        case 'top':\r\n                            sy = bbox.top + vmargin;\r\n                            break;\r\n                        case 'middle':\r\n                            sy = bbox.vcenter;\r\n                            break;\r\n                        case 'bottom':\r\n                            sy = bbox.bottom - vmargin;\r\n                            break;\r\n                    }\r\n                    switch (this.model.align) {\r\n                        case 'left':\r\n                            sx = bbox.left + hmargin;\r\n                            break;\r\n                        case 'center':\r\n                            sx = bbox.hcenter;\r\n                            break;\r\n                        case 'right':\r\n                            sx = bbox.right - hmargin;\r\n                            break;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'left': {\r\n                    switch (this.model.vertical_align) {\r\n                        case 'top':\r\n                            sx = bbox.left - vmargin;\r\n                            break;\r\n                        case 'middle':\r\n                            sx = bbox.hcenter;\r\n                            break;\r\n                        case 'bottom':\r\n                            sx = bbox.right + vmargin;\r\n                            break;\r\n                    }\r\n                    switch (this.model.align) {\r\n                        case 'left':\r\n                            sy = bbox.bottom - hmargin;\r\n                            break;\r\n                        case 'center':\r\n                            sy = bbox.vcenter;\r\n                            break;\r\n                        case 'right':\r\n                            sy = bbox.top + hmargin;\r\n                            break;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'right': {\r\n                    switch (this.model.vertical_align) {\r\n                        case 'top':\r\n                            sx = bbox.right - vmargin;\r\n                            break;\r\n                        case 'middle':\r\n                            sx = bbox.hcenter;\r\n                            break;\r\n                        case 'bottom':\r\n                            sx = bbox.left + vmargin;\r\n                            break;\r\n                    }\r\n                    switch (this.model.align) {\r\n                        case 'left':\r\n                            sy = bbox.top + hmargin;\r\n                            break;\r\n                        case 'center':\r\n                            sy = bbox.vcenter;\r\n                            break;\r\n                        case 'right':\r\n                            sy = bbox.bottom - hmargin;\r\n                            break;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            return [sx, sy];\r\n        }\r\n        _render() {\r\n            const { text } = this.model;\r\n            if (text == null || text.length == 0)\r\n                return;\r\n            this.model.text_baseline = this.model.vertical_align;\r\n            this.model.text_align = this.model.align;\r\n            const [sx, sy] = this._get_location();\r\n            const angle = this.panel.get_label_angle_heuristic('parallel');\r\n            const draw = this.model.render_mode == 'canvas' ? this._canvas_text.bind(this) : this._css_text.bind(this);\r\n            draw(this.layer.ctx, text, sx, sy, angle);\r\n        }\r\n        _get_size() {\r\n            const { text } = this.model;\r\n            if (text == null || text.length == 0)\r\n                return { width: 0, height: 0 };\r\n            else {\r\n                this.visuals.text.set_value(this.layer.ctx);\r\n                const { width, ascent } = this.layer.ctx.measureText(text);\r\n                return { width, height: ascent * this.visuals.text.text_line_height.value() + 10 };\r\n            }\r\n        }\r\n    }\r\n    exports.TitleView = TitleView;\r\n    TitleView.__name__ = \"TitleView\";\r\n    class Title extends text_annotation_1.TextAnnotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Title() {\r\n            this.prototype.default_view = TitleView;\r\n            this.mixins([\r\n                [\"border_\", mixins.Line],\r\n                [\"background_\", mixins.Fill],\r\n            ]);\r\n            this.define({\r\n                text: [p.String],\r\n                text_font: [p.Font, 'helvetica'],\r\n                text_font_size: [p.StringSpec, '13px'],\r\n                text_font_style: [p.FontStyle, 'bold'],\r\n                text_color: [p.ColorSpec, '#444444'],\r\n                text_alpha: [p.NumberSpec, 1.0],\r\n                text_line_height: [p.Number, 1.0],\r\n                vertical_align: [p.VerticalAlign, 'bottom'],\r\n                align: [p.TextAlign, 'left'],\r\n                offset: [p.Number, 0],\r\n            });\r\n            this.override({\r\n                background_fill_color: null,\r\n                border_line_color: null,\r\n            });\r\n            this.internal({\r\n                text_align: [p.TextAlign, 'left'],\r\n                text_baseline: [p.TextBaseline, 'bottom'],\r\n            });\r\n        }\r\n    }\r\n    exports.Title = Title;\r\n    Title.__name__ = \"Title\";\r\n    Title.init_Title();\r\n}\r\n","/* models\\annotations\\toolbar_panel.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const build_views_1 = require(115) /* ../../core/build_views */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class ToolbarPanelView extends annotation_1.AnnotationView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.rotate = true;\r\n            this._invalidate_toolbar = true;\r\n            this._previous_bbox = new bbox_1.BBox();\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.el = dom_1.div();\r\n            this.plot_view.canvas_view.add_event(this.el);\r\n        }\r\n        async lazy_initialize() {\r\n            this._toolbar_view = await build_views_1.build_view(this.model.toolbar, { parent: this });\r\n            this.plot_view.visibility_callbacks.push((visible) => this._toolbar_view.set_visibility(visible));\r\n        }\r\n        remove() {\r\n            this._toolbar_view.remove();\r\n            dom_1.remove(this.el);\r\n            super.remove();\r\n        }\r\n        render() {\r\n            if (!this.model.visible)\r\n                dom_1.undisplay(this.el);\r\n            super.render();\r\n        }\r\n        _render() {\r\n            // TODO: this should be handled by the layout\r\n            const { bbox } = this.panel;\r\n            if (!this._previous_bbox.equals(bbox)) {\r\n                dom_1.position(this.el, bbox);\r\n                this._previous_bbox = bbox;\r\n            }\r\n            if (this._invalidate_toolbar) {\r\n                this.el.style.position = \"absolute\";\r\n                this.el.style.overflow = \"hidden\";\r\n                this._toolbar_view.render();\r\n                dom_1.empty(this.el);\r\n                this.el.appendChild(this._toolbar_view.el);\r\n                this._invalidate_toolbar = false;\r\n            }\r\n            dom_1.display(this.el);\r\n        }\r\n        _get_size() {\r\n            const { tools, logo } = this.model.toolbar;\r\n            return {\r\n                width: tools.length * 30 + (logo != null ? 25 : 0),\r\n                height: 30,\r\n            };\r\n        }\r\n    }\r\n    exports.ToolbarPanelView = ToolbarPanelView;\r\n    ToolbarPanelView.__name__ = \"ToolbarPanelView\";\r\n    class ToolbarPanel extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ToolbarPanel() {\r\n            this.prototype.default_view = ToolbarPanelView;\r\n            this.define({\r\n                toolbar: [p.Instance],\r\n            });\r\n        }\r\n    }\r\n    exports.ToolbarPanel = ToolbarPanel;\r\n    ToolbarPanel.__name__ = \"ToolbarPanel\";\r\n    ToolbarPanel.init_ToolbarPanel();\r\n}\r\n","/* models\\annotations\\tooltip.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const annotation_1 = require(36) /* ./annotation */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const tooltips_1 = require(172) /* ../../styles/tooltips */;\r\n    const mixins_1 = require(173) /* ../../styles/mixins */;\r\n    const tooltips_css_1 = tslib_1.__importDefault(require(174) /* ../../styles/tooltips.css */);\r\n    const arrow_size = 10; // XXX: keep in sync with less\r\n    class TooltipView extends annotation_1.AnnotationView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.el = dom_1.div({ class: tooltips_1.bk_tooltip });\r\n            dom_1.undisplay(this.el);\r\n            this.plot_view.canvas_view.add_overlay(this.el);\r\n        }\r\n        remove() {\r\n            dom_1.remove(this.el);\r\n            super.remove();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.content.change, () => this.render());\r\n            this.connect(this.model.properties.position.change, () => this._reposition());\r\n        }\r\n        styles() {\r\n            return [...super.styles(), tooltips_css_1.default];\r\n        }\r\n        render() {\r\n            if (!this.model.visible)\r\n                dom_1.undisplay(this.el);\r\n            super.render();\r\n        }\r\n        _render() {\r\n            const { content } = this.model;\r\n            if (content == null) {\r\n                dom_1.undisplay(this.el);\r\n                return;\r\n            }\r\n            dom_1.empty(this.el);\r\n            dom_1.classes(this.el).toggle(tooltips_1.bk_tooltip_custom, this.model.custom);\r\n            this.el.appendChild(content);\r\n            if (this.model.show_arrow)\r\n                this.el.classList.add(tooltips_1.bk_tooltip_arrow);\r\n        }\r\n        _reposition() {\r\n            const { position } = this.model;\r\n            if (position == null) {\r\n                dom_1.undisplay(this.el);\r\n                return;\r\n            }\r\n            const [sx, sy] = position;\r\n            const side = (() => {\r\n                const area = this.parent.layout.bbox.relativize();\r\n                const { attachment } = this.model;\r\n                switch (attachment) {\r\n                    case \"horizontal\":\r\n                        return sx < area.hcenter ? \"right\" : \"left\";\r\n                    case \"vertical\":\r\n                        return sy < area.vcenter ? \"below\" : \"above\";\r\n                    default:\r\n                        return attachment;\r\n                }\r\n            })();\r\n            this.el.classList.remove(mixins_1.bk_right);\r\n            this.el.classList.remove(mixins_1.bk_left);\r\n            this.el.classList.remove(mixins_1.bk_above);\r\n            this.el.classList.remove(mixins_1.bk_below);\r\n            dom_1.display(this.el); // XXX: {offset,client}Width() gives 0 when display=\"none\"\r\n            // slightly confusing: side \"left\" (for example) is relative to point that\r\n            // is being annotated but CS class \".bk-left\" is relative to the tooltip itself\r\n            let top;\r\n            let left = null;\r\n            let right = null;\r\n            switch (side) {\r\n                case \"right\":\r\n                    this.el.classList.add(mixins_1.bk_left);\r\n                    left = sx + (this.el.offsetWidth - this.el.clientWidth) + arrow_size;\r\n                    top = sy - this.el.offsetHeight / 2;\r\n                    break;\r\n                case \"left\":\r\n                    this.el.classList.add(mixins_1.bk_right);\r\n                    right = (this.plot_view.layout.bbox.width - sx) + arrow_size;\r\n                    top = sy - this.el.offsetHeight / 2;\r\n                    break;\r\n                case \"below\":\r\n                    this.el.classList.add(mixins_1.bk_above);\r\n                    top = sy + (this.el.offsetHeight - this.el.clientHeight) + arrow_size;\r\n                    left = Math.round(sx - this.el.offsetWidth / 2);\r\n                    break;\r\n                case \"above\":\r\n                    this.el.classList.add(mixins_1.bk_below);\r\n                    top = sy - this.el.offsetHeight - arrow_size;\r\n                    left = Math.round(sx - this.el.offsetWidth / 2);\r\n                    break;\r\n            }\r\n            this.el.style.top = `${top}px`;\r\n            this.el.style.left = left != null ? `${left}px` : \"auto\";\r\n            this.el.style.right = right != null ? `${right}px` : \"auto\";\r\n        }\r\n    }\r\n    exports.TooltipView = TooltipView;\r\n    TooltipView.__name__ = \"TooltipView\";\r\n    class Tooltip extends annotation_1.Annotation {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Tooltip() {\r\n            this.prototype.default_view = TooltipView;\r\n            this.define({\r\n                attachment: [p.TooltipAttachment, 'horizontal'],\r\n                inner_only: [p.Boolean, true],\r\n                show_arrow: [p.Boolean, true],\r\n            });\r\n            this.override({\r\n                level: 'overlay',\r\n            });\r\n            this.internal({\r\n                position: [p.Any, null],\r\n                content: [p.Any, () => dom_1.div()],\r\n                custom: [p.Any],\r\n            });\r\n        }\r\n        clear() {\r\n            this.position = null;\r\n        }\r\n    }\r\n    exports.Tooltip = Tooltip;\r\n    Tooltip.__name__ = \"Tooltip\";\r\n    Tooltip.init_Tooltip();\r\n}\r\n","/* styles\\tooltips.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_tooltip = \"bk-tooltip\";\r\n    exports.bk_tooltip_arrow = \"bk-tooltip-arrow\";\r\n    exports.bk_tooltip_custom = \"bk-tooltip-custom\";\r\n    exports.bk_tooltip_row_label = \"bk-tooltip-row-label\";\r\n    exports.bk_tooltip_row_value = \"bk-tooltip-row-value\";\r\n    exports.bk_tooltip_color_block = \"bk-tooltip-color-block\";\r\n}\r\n","/* styles\\mixins.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_active = \"bk-active\";\r\n    exports.bk_inline = \"bk-inline\";\r\n    exports.bk_left = \"bk-left\";\r\n    exports.bk_right = \"bk-right\";\r\n    exports.bk_above = \"bk-above\";\r\n    exports.bk_below = \"bk-below\";\r\n    exports.bk_up = \"bk-up\";\r\n    exports.bk_down = \"bk-down\";\r\n    function bk_side(side) {\r\n        switch (side) {\r\n            case \"above\": return exports.bk_above;\r\n            case \"below\": return exports.bk_below;\r\n            case \"left\": return exports.bk_left;\r\n            case \"right\": return exports.bk_right;\r\n        }\r\n    }\r\n    exports.bk_side = bk_side;\r\n}\r\n","/* styles\\tooltips.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root {\n  /* Same border color used everywhere */\n  /* Gray of icons */\n}\n.bk-root .bk-tooltip {\n  font-weight: 300;\n  font-size: 12px;\n  position: absolute;\n  padding: 5px;\n  border: 1px solid #e5e5e5;\n  color: #2f2f2f;\n  background-color: white;\n  pointer-events: none;\n  opacity: 0.95;\n  z-index: 100;\n}\n.bk-root .bk-tooltip > div:not(:first-child) {\n  /* gives space when multiple elements are being hovered over */\n  margin-top: 5px;\n  border-top: #e5e5e5 1px dashed;\n}\n.bk-root .bk-tooltip.bk-left.bk-tooltip-arrow::before {\n  position: absolute;\n  margin: -7px 0 0 0;\n  top: 50%;\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-width: 7px 0 7px 0;\n  border-color: transparent;\n  content: \" \";\n  display: block;\n  left: -10px;\n  border-right-width: 10px;\n  border-right-color: #909599;\n}\n.bk-root .bk-tooltip.bk-left::before {\n  left: -10px;\n  border-right-width: 10px;\n  border-right-color: #909599;\n}\n.bk-root .bk-tooltip.bk-right.bk-tooltip-arrow::after {\n  position: absolute;\n  margin: -7px 0 0 0;\n  top: 50%;\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-width: 7px 0 7px 0;\n  border-color: transparent;\n  content: \" \";\n  display: block;\n  right: -10px;\n  border-left-width: 10px;\n  border-left-color: #909599;\n}\n.bk-root .bk-tooltip.bk-right::after {\n  right: -10px;\n  border-left-width: 10px;\n  border-left-color: #909599;\n}\n.bk-root .bk-tooltip.bk-above::before {\n  position: absolute;\n  margin: 0 0 0 -7px;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-width: 0 7px 0 7px;\n  border-color: transparent;\n  content: \" \";\n  display: block;\n  top: -10px;\n  border-bottom-width: 10px;\n  border-bottom-color: #909599;\n}\n.bk-root .bk-tooltip.bk-below::after {\n  position: absolute;\n  margin: 0 0 0 -7px;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-width: 0 7px 0 7px;\n  border-color: transparent;\n  content: \" \";\n  display: block;\n  bottom: -10px;\n  border-top-width: 10px;\n  border-top-color: #909599;\n}\n.bk-root .bk-tooltip-row-label {\n  text-align: right;\n  color: #26aae1;\n  /* blue from toolbar highlighting */\n}\n.bk-root .bk-tooltip-row-value {\n  color: default;\n  /* seems to be necessary for notebook */\n}\n.bk-root .bk-tooltip-color-block {\n  width: 12px;\n  height: 12px;\n  margin-left: 5px;\n  margin-right: 5px;\n  outline: #dddddd solid 1px;\n  display: inline-block;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* models\\annotations\\whisker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const upper_lower_1 = require(123) /* ./upper_lower */;\r\n    const arrow_head_1 = require(84) /* ./arrow_head */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class WhiskerView extends upper_lower_1.UpperLowerView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.source.streaming, () => this.set_data(this.model.source));\r\n            this.connect(this.model.source.patching, () => this.set_data(this.model.source));\r\n            this.connect(this.model.source.change, () => this.set_data(this.model.source));\r\n        }\r\n        _render() {\r\n            this._map_data();\r\n            const { ctx } = this.layer;\r\n            if (this.visuals.line.doit) {\r\n                for (let i = 0, end = this._lower_sx.length; i < end; i++) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(this._lower_sx[i], this._lower_sy[i]);\r\n                    ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n            const angle = this.model.dimension == \"height\" ? 0 : Math.PI / 2;\r\n            if (this.model.lower_head != null) {\r\n                for (let i = 0, end = this._lower_sx.length; i < end; i++) {\r\n                    ctx.save();\r\n                    ctx.translate(this._lower_sx[i], this._lower_sy[i]);\r\n                    ctx.rotate(angle + Math.PI);\r\n                    this.model.lower_head.render(ctx, i);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n            if (this.model.upper_head != null) {\r\n                for (let i = 0, end = this._upper_sx.length; i < end; i++) {\r\n                    ctx.save();\r\n                    ctx.translate(this._upper_sx[i], this._upper_sy[i]);\r\n                    ctx.rotate(angle);\r\n                    this.model.upper_head.render(ctx, i);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.WhiskerView = WhiskerView;\r\n    WhiskerView.__name__ = \"WhiskerView\";\r\n    class Whisker extends upper_lower_1.UpperLower {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Whisker() {\r\n            this.prototype.default_view = WhiskerView;\r\n            this.mixins(property_mixins_1.LineVector);\r\n            this.define({\r\n                lower_head: [p.Instance, () => new arrow_head_1.TeeHead({ level: \"underlay\", size: 10 })],\r\n                upper_head: [p.Instance, () => new arrow_head_1.TeeHead({ level: \"underlay\", size: 10 })],\r\n            });\r\n            this.override({\r\n                level: 'underlay',\r\n            });\r\n        }\r\n    }\r\n    exports.Whisker = Whisker;\r\n    Whisker.__name__ = \"Whisker\";\r\n    Whisker.init_Whisker();\r\n}\r\n","/* models\\axes\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var axis_1 = require(177) /* ./axis */;\r\n    exports.Axis = axis_1.Axis;\r\n    var categorical_axis_1 = require(179) /* ./categorical_axis */;\r\n    exports.CategoricalAxis = categorical_axis_1.CategoricalAxis;\r\n    var continuous_axis_1 = require(182) /* ./continuous_axis */;\r\n    exports.ContinuousAxis = continuous_axis_1.ContinuousAxis;\r\n    var datetime_axis_1 = require(183) /* ./datetime_axis */;\r\n    exports.DatetimeAxis = datetime_axis_1.DatetimeAxis;\r\n    var linear_axis_1 = require(184) /* ./linear_axis */;\r\n    exports.LinearAxis = linear_axis_1.LinearAxis;\r\n    var log_axis_1 = require(197) /* ./log_axis */;\r\n    exports.LogAxis = log_axis_1.LogAxis;\r\n    var mercator_axis_1 = require(200) /* ./mercator_axis */;\r\n    exports.MercatorAxis = mercator_axis_1.MercatorAxis;\r\n}\r\n","/* models\\axes\\axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const guide_renderer_1 = require(178) /* ../renderers/guide_renderer */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const factor_range_1 = require(98) /* ../ranges/factor_range */;\r\n    const { abs, min, max } = Math;\r\n    class AxisView extends guide_renderer_1.GuideRendererView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.rotate = true;\r\n        }\r\n        get panel() {\r\n            return this.layout;\r\n        }\r\n        get is_renderable() {\r\n            const [range, cross_range] = this.ranges;\r\n            return range.is_valid && cross_range.is_valid;\r\n        }\r\n        _render() {\r\n            var _a;\r\n            if (!this.is_renderable)\r\n                return;\r\n            const extents = {\r\n                tick: this._tick_extent(),\r\n                tick_label: this._tick_label_extents(),\r\n                axis_label: this._axis_label_extent(),\r\n            };\r\n            const { tick_coords } = this;\r\n            const ctx = this.layer.ctx;\r\n            ctx.save();\r\n            this._draw_rule(ctx, extents);\r\n            this._draw_major_ticks(ctx, extents, tick_coords);\r\n            this._draw_minor_ticks(ctx, extents, tick_coords);\r\n            this._draw_major_labels(ctx, extents, tick_coords);\r\n            this._draw_axis_label(ctx, extents, tick_coords);\r\n            (_a = this._paint) === null || _a === void 0 ? void 0 : _a.call(this, ctx, extents, tick_coords);\r\n            ctx.restore();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.plot_view.request_layout());\r\n        }\r\n        get_size() {\r\n            if (this.model.visible && this.model.fixed_location == null && this.is_renderable) {\r\n                const size = this._get_size();\r\n                return { width: 0 /* max */, height: Math.round(size) };\r\n            }\r\n            else\r\n                return { width: 0, height: 0 };\r\n        }\r\n        _get_size() {\r\n            return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();\r\n        }\r\n        get needs_clip() {\r\n            return this.model.fixed_location != null;\r\n        }\r\n        // drawing sub functions -----------------------------------------------------\r\n        _draw_rule(ctx, _extents) {\r\n            if (!this.visuals.axis_line.doit)\r\n                return;\r\n            const [xs, ys] = this.rule_coords;\r\n            const [sxs, sys] = this.coordinates.map_to_screen(xs, ys);\r\n            const [nx, ny] = this.normals;\r\n            const [xoff, yoff] = this.offsets;\r\n            this.visuals.axis_line.set_value(ctx);\r\n            ctx.beginPath();\r\n            ctx.moveTo(Math.round(sxs[0] + nx * xoff), Math.round(sys[0] + ny * yoff));\r\n            for (let i = 1; i < sxs.length; i++) {\r\n                const sx = Math.round(sxs[i] + nx * xoff);\r\n                const sy = Math.round(sys[i] + ny * yoff);\r\n                ctx.lineTo(sx, sy);\r\n            }\r\n            ctx.stroke();\r\n        }\r\n        _draw_major_ticks(ctx, _extents, tick_coords) {\r\n            const tin = this.model.major_tick_in;\r\n            const tout = this.model.major_tick_out;\r\n            const visuals = this.visuals.major_tick_line;\r\n            this._draw_ticks(ctx, tick_coords.major, tin, tout, visuals);\r\n        }\r\n        _draw_minor_ticks(ctx, _extents, tick_coords) {\r\n            const tin = this.model.minor_tick_in;\r\n            const tout = this.model.minor_tick_out;\r\n            const visuals = this.visuals.minor_tick_line;\r\n            this._draw_ticks(ctx, tick_coords.minor, tin, tout, visuals);\r\n        }\r\n        _draw_major_labels(ctx, extents, tick_coords) {\r\n            const coords = tick_coords.major;\r\n            const labels = this.compute_labels(coords[this.dimension]);\r\n            const orient = this.model.major_label_orientation;\r\n            const standoff = extents.tick + this.model.major_label_standoff;\r\n            const visuals = this.visuals.major_label_text;\r\n            this._draw_oriented_labels(ctx, labels, coords, orient, this.panel.side, standoff, visuals);\r\n        }\r\n        _draw_axis_label(ctx, extents, _tick_coords) {\r\n            if (this.model.axis_label == null || this.model.axis_label.length == 0 || this.model.fixed_location != null)\r\n                return;\r\n            let sx;\r\n            let sy;\r\n            const { bbox } = this.panel;\r\n            switch (this.panel.side) {\r\n                case \"above\":\r\n                    sx = bbox.hcenter;\r\n                    sy = bbox.bottom;\r\n                    break;\r\n                case \"below\":\r\n                    sx = bbox.hcenter;\r\n                    sy = bbox.top;\r\n                    break;\r\n                case \"left\":\r\n                    sx = bbox.right;\r\n                    sy = bbox.vcenter;\r\n                    break;\r\n                case \"right\":\r\n                    sx = bbox.left;\r\n                    sy = bbox.vcenter;\r\n                    break;\r\n                default:\r\n                    throw new Error(`unknown side: ${this.panel.side}`);\r\n            }\r\n            const coords = [[sx], [sy]];\r\n            const standoff = extents.tick + array_1.sum(extents.tick_label) + this.model.axis_label_standoff;\r\n            const visuals = this.visuals.axis_label_text;\r\n            this._draw_oriented_labels(ctx, [this.model.axis_label], coords, 'parallel', this.panel.side, standoff, visuals, \"screen\");\r\n        }\r\n        _draw_ticks(ctx, coords, tin, tout, visuals) {\r\n            if (!visuals.doit)\r\n                return;\r\n            const [x, y] = coords;\r\n            const [sxs, sys] = this.coordinates.map_to_screen(x, y);\r\n            const [nx, ny] = this.normals;\r\n            const [xoff, yoff] = this.offsets;\r\n            const [nxin, nyin] = [nx * (xoff - tin), ny * (yoff - tin)];\r\n            const [nxout, nyout] = [nx * (xoff + tout), ny * (yoff + tout)];\r\n            visuals.set_value(ctx);\r\n            ctx.beginPath();\r\n            for (let i = 0; i < sxs.length; i++) {\r\n                const sx0 = Math.round(sxs[i] + nxout);\r\n                const sy0 = Math.round(sys[i] + nyout);\r\n                const sx1 = Math.round(sxs[i] + nxin);\r\n                const sy1 = Math.round(sys[i] + nyin);\r\n                ctx.moveTo(sx0, sy0);\r\n                ctx.lineTo(sx1, sy1);\r\n            }\r\n            ctx.stroke();\r\n        }\r\n        _draw_oriented_labels(ctx, labels, coords, orient, _side, standoff, visuals, units = \"data\") {\r\n            if (!visuals.doit || labels.length == 0)\r\n                return;\r\n            let sxs, sys;\r\n            let xoff, yoff;\r\n            if (units == \"screen\") {\r\n                [sxs, sys] = coords;\r\n                [xoff, yoff] = [0, 0];\r\n            }\r\n            else {\r\n                const [dxs, dys] = coords;\r\n                [sxs, sys] = this.coordinates.map_to_screen(dxs, dys);\r\n                [xoff, yoff] = this.offsets;\r\n            }\r\n            const [nx, ny] = this.normals;\r\n            const nxd = nx * (xoff + standoff);\r\n            const nyd = ny * (yoff + standoff);\r\n            visuals.set_value(ctx);\r\n            this.panel.apply_label_text_heuristics(ctx, orient);\r\n            let angle;\r\n            if (types_1.isString(orient))\r\n                angle = this.panel.get_label_angle_heuristic(orient);\r\n            else\r\n                angle = -orient;\r\n            for (let i = 0; i < sxs.length; i++) {\r\n                const sx = Math.round(sxs[i] + nxd);\r\n                const sy = Math.round(sys[i] + nyd);\r\n                ctx.translate(sx, sy);\r\n                ctx.rotate(angle);\r\n                ctx.fillText(labels[i], 0, 0);\r\n                ctx.rotate(-angle);\r\n                ctx.translate(-sx, -sy);\r\n            }\r\n        }\r\n        // extents sub functions -----------------------------------------------------\r\n        /*protected*/ _axis_label_extent() {\r\n            if (this.model.axis_label == null || this.model.axis_label == \"\")\r\n                return 0;\r\n            const standoff = this.model.axis_label_standoff;\r\n            const visuals = this.visuals.axis_label_text;\r\n            return this._oriented_labels_extent([this.model.axis_label], \"parallel\", this.panel.side, standoff, visuals);\r\n        }\r\n        /*protected*/ _tick_extent() {\r\n            return this.model.major_tick_out;\r\n        }\r\n        /*protected*/ _tick_label_extent() {\r\n            return array_1.sum(this._tick_label_extents());\r\n        }\r\n        _tick_label_extents() {\r\n            const coords = this.tick_coords.major;\r\n            const labels = this.compute_labels(coords[this.dimension]);\r\n            const orient = this.model.major_label_orientation;\r\n            const standoff = this.model.major_label_standoff;\r\n            const visuals = this.visuals.major_label_text;\r\n            return [this._oriented_labels_extent(labels, orient, this.panel.side, standoff, visuals)];\r\n        }\r\n        _oriented_labels_extent(labels, orient, side, standoff, visuals) {\r\n            if (labels.length == 0)\r\n                return 0;\r\n            const ctx = this.layer.ctx;\r\n            visuals.set_value(ctx);\r\n            let hscale;\r\n            let angle;\r\n            if (types_1.isString(orient)) {\r\n                hscale = 1;\r\n                angle = this.panel.get_label_angle_heuristic(orient);\r\n            }\r\n            else {\r\n                hscale = 2;\r\n                angle = -orient;\r\n            }\r\n            angle = Math.abs(angle);\r\n            const c = Math.cos(angle);\r\n            const s = Math.sin(angle);\r\n            let extent = 0;\r\n            for (let i = 0; i < labels.length; i++) {\r\n                const w = ctx.measureText(labels[i]).width * 1.1;\r\n                const h = ctx.measureText(labels[i]).ascent * 0.9;\r\n                let val;\r\n                if (side == \"above\" || side == \"below\")\r\n                    val = w * s + (h / hscale) * c;\r\n                else\r\n                    val = w * c + (h / hscale) * s;\r\n                // update extent if current value is larger\r\n                if (val > extent)\r\n                    extent = val;\r\n            }\r\n            // only apply the standoff if we already have non-zero extent\r\n            if (extent > 0)\r\n                extent += standoff;\r\n            return extent;\r\n        }\r\n        // {{{ TODO: state\r\n        get normals() {\r\n            return this.panel.normals;\r\n        }\r\n        get dimension() {\r\n            return this.panel.dimension;\r\n        }\r\n        compute_labels(ticks) {\r\n            const labels = this.model.formatter.doFormat(ticks, this);\r\n            for (let i = 0; i < ticks.length; i++) {\r\n                if (ticks[i] in this.model.major_label_overrides)\r\n                    labels[i] = this.model.major_label_overrides[ticks[i]];\r\n            }\r\n            return labels;\r\n        }\r\n        get offsets() {\r\n            // If we have a fixed_position then we should respect that exactly and\r\n            // not apply any offsets (https://github.com/bokeh/bokeh/issues/8552)\r\n            if (this.model.fixed_location != null)\r\n                return [0, 0];\r\n            const { frame } = this.plot_view;\r\n            let [xoff, yoff] = [0, 0];\r\n            switch (this.panel.side) {\r\n                case \"below\":\r\n                    yoff = abs(this.panel.bbox.top - frame.bbox.bottom);\r\n                    break;\r\n                case \"above\":\r\n                    yoff = abs(this.panel.bbox.bottom - frame.bbox.top);\r\n                    break;\r\n                case \"right\":\r\n                    xoff = abs(this.panel.bbox.left - frame.bbox.right);\r\n                    break;\r\n                case \"left\":\r\n                    xoff = abs(this.panel.bbox.right - frame.bbox.left);\r\n                    break;\r\n            }\r\n            return [xoff, yoff];\r\n        }\r\n        get ranges() {\r\n            const i = this.dimension;\r\n            const j = (i + 1) % 2;\r\n            const { ranges } = this.coordinates;\r\n            return [ranges[i], ranges[j]];\r\n        }\r\n        get computed_bounds() {\r\n            const [range] = this.ranges;\r\n            const user_bounds = this.model.bounds;\r\n            const range_bounds = [range.min, range.max];\r\n            if (user_bounds == \"auto\")\r\n                return [range.min, range.max];\r\n            else {\r\n                let start;\r\n                let end;\r\n                const [user_start, user_end] = user_bounds;\r\n                const [range_start, range_end] = range_bounds;\r\n                if (abs(user_start - user_end) > abs(range_start - range_end)) {\r\n                    start = max(min(user_start, user_end), range_start);\r\n                    end = min(max(user_start, user_end), range_end);\r\n                }\r\n                else {\r\n                    start = min(user_start, user_end);\r\n                    end = max(user_start, user_end);\r\n                }\r\n                return [start, end];\r\n            }\r\n        }\r\n        get rule_coords() {\r\n            const i = this.dimension;\r\n            const j = (i + 1) % 2;\r\n            const [range] = this.ranges;\r\n            const [start, end] = this.computed_bounds;\r\n            const xs = new Array(2);\r\n            const ys = new Array(2);\r\n            const coords = [xs, ys];\r\n            coords[i][0] = Math.max(start, range.min);\r\n            coords[i][1] = Math.min(end, range.max);\r\n            if (coords[i][0] > coords[i][1])\r\n                coords[i][0] = coords[i][1] = NaN;\r\n            coords[j][0] = this.loc;\r\n            coords[j][1] = this.loc;\r\n            return coords;\r\n        }\r\n        get tick_coords() {\r\n            const i = this.dimension;\r\n            const j = (i + 1) % 2;\r\n            const [range] = this.ranges;\r\n            const [start, end] = this.computed_bounds;\r\n            const ticks = this.model.ticker.get_ticks(start, end, range, this.loc, {});\r\n            const majors = ticks.major;\r\n            const minors = ticks.minor;\r\n            const xs = [];\r\n            const ys = [];\r\n            const coords = [xs, ys];\r\n            const minor_xs = [];\r\n            const minor_ys = [];\r\n            const minor_coords = [minor_xs, minor_ys];\r\n            const [range_min, range_max] = [range.min, range.max];\r\n            for (let ii = 0; ii < majors.length; ii++) {\r\n                if (majors[ii] < range_min || majors[ii] > range_max)\r\n                    continue;\r\n                coords[i].push(majors[ii]);\r\n                coords[j].push(this.loc);\r\n            }\r\n            for (let ii = 0; ii < minors.length; ii++) {\r\n                if (minors[ii] < range_min || minors[ii] > range_max)\r\n                    continue;\r\n                minor_coords[i].push(minors[ii]);\r\n                minor_coords[j].push(this.loc);\r\n            }\r\n            return {\r\n                major: coords,\r\n                minor: minor_coords,\r\n            };\r\n        }\r\n        get loc() {\r\n            const { fixed_location } = this.model;\r\n            if (fixed_location != null) {\r\n                if (types_1.isNumber(fixed_location))\r\n                    return fixed_location;\r\n                const [, cross_range] = this.ranges;\r\n                if (cross_range instanceof factor_range_1.FactorRange)\r\n                    return cross_range.synthetic(fixed_location);\r\n                throw new Error(\"unexpected\");\r\n            }\r\n            const [, cross_range] = this.ranges;\r\n            switch (this.panel.side) {\r\n                case 'left':\r\n                case 'below':\r\n                    return cross_range.start;\r\n                case 'right':\r\n                case 'above':\r\n                    return cross_range.end;\r\n            }\r\n        }\r\n        // }}}\r\n        serializable_state() {\r\n            return Object.assign(Object.assign({}, super.serializable_state()), { bbox: this.layout.bbox.box });\r\n        }\r\n    }\r\n    exports.AxisView = AxisView;\r\n    AxisView.__name__ = \"AxisView\";\r\n    class Axis extends guide_renderer_1.GuideRenderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Axis() {\r\n            this.prototype.default_view = AxisView;\r\n            this.mixins([\r\n                [\"axis_\", mixins.Line],\r\n                [\"major_tick_\", mixins.Line],\r\n                [\"minor_tick_\", mixins.Line],\r\n                [\"major_label_\", mixins.Text],\r\n                [\"axis_label_\", mixins.Text],\r\n            ]);\r\n            this.define({\r\n                bounds: [p.Any, 'auto'],\r\n                ticker: [p.Instance],\r\n                formatter: [p.Instance],\r\n                axis_label: [p.String, ''],\r\n                axis_label_standoff: [p.Int, 5],\r\n                major_label_standoff: [p.Int, 5],\r\n                major_label_orientation: [p.Any, \"horizontal\"],\r\n                major_label_overrides: [p.Any, {}],\r\n                major_tick_in: [p.Number, 2],\r\n                major_tick_out: [p.Number, 6],\r\n                minor_tick_in: [p.Number, 0],\r\n                minor_tick_out: [p.Number, 4],\r\n                fixed_location: [p.Any, null],\r\n            });\r\n            this.override({\r\n                axis_line_color: 'black',\r\n                major_tick_line_color: 'black',\r\n                minor_tick_line_color: 'black',\r\n                major_label_text_font_size: \"11px\",\r\n                major_label_text_align: \"center\",\r\n                major_label_text_baseline: \"alphabetic\",\r\n                axis_label_text_font_size: \"13px\",\r\n                axis_label_text_font_style: \"italic\",\r\n            });\r\n        }\r\n    }\r\n    exports.Axis = Axis;\r\n    Axis.__name__ = \"Axis\";\r\n    Axis.init_Axis();\r\n}\r\n","/* models\\renderers\\guide_renderer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const renderer_1 = require(70) /* ./renderer */;\r\n    class GuideRendererView extends renderer_1.RendererView {\r\n    }\r\n    exports.GuideRendererView = GuideRendererView;\r\n    GuideRendererView.__name__ = \"GuideRendererView\";\r\n    class GuideRenderer extends renderer_1.Renderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GuideRenderer() {\r\n            this.override({\r\n                level: \"guide\",\r\n            });\r\n        }\r\n    }\r\n    exports.GuideRenderer = GuideRenderer;\r\n    GuideRenderer.__name__ = \"GuideRenderer\";\r\n    GuideRenderer.init_GuideRenderer();\r\n}\r\n","/* models\\axes\\categorical_axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const axis_1 = require(177) /* ./axis */;\r\n    const categorical_ticker_1 = require(180) /* ../tickers/categorical_ticker */;\r\n    const categorical_tick_formatter_1 = require(181) /* ../formatters/categorical_tick_formatter */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class CategoricalAxisView extends axis_1.AxisView {\r\n        _paint(ctx, extents, tick_coords) {\r\n            this._draw_group_separators(ctx, extents, tick_coords);\r\n        }\r\n        _draw_group_separators(ctx, _extents, _tick_coords) {\r\n            const [range] = this.ranges;\r\n            const [start, end] = this.computed_bounds;\r\n            if (!range.tops || range.tops.length < 2 || !this.visuals.separator_line.doit)\r\n                return;\r\n            const dim = this.dimension;\r\n            const alt = (dim + 1) % 2;\r\n            const coords = [[], []];\r\n            let ind = 0;\r\n            for (let i = 0; i < range.tops.length - 1; i++) {\r\n                let first, last;\r\n                for (let j = ind; j < range.factors.length; j++) {\r\n                    if (range.factors[j][0] == range.tops[i + 1]) {\r\n                        [first, last] = [range.factors[j - 1], range.factors[j]];\r\n                        ind = j;\r\n                        break;\r\n                    }\r\n                }\r\n                const pt = (range.synthetic(first) + range.synthetic(last)) / 2;\r\n                if (pt > start && pt < end) {\r\n                    coords[dim].push(pt);\r\n                    coords[alt].push(this.loc);\r\n                }\r\n            }\r\n            const tex = this._tick_label_extent();\r\n            this._draw_ticks(ctx, coords, -3, (tex - 6), this.visuals.separator_line);\r\n        }\r\n        _draw_major_labels(ctx, extents, _tick_coords) {\r\n            const info = this._get_factor_info();\r\n            let standoff = extents.tick + this.model.major_label_standoff;\r\n            for (let i = 0; i < info.length; i++) {\r\n                const [labels, coords, orient, visuals] = info[i];\r\n                this._draw_oriented_labels(ctx, labels, coords, orient, this.panel.side, standoff, visuals);\r\n                standoff += extents.tick_label[i];\r\n            }\r\n        }\r\n        _tick_label_extents() {\r\n            const info = this._get_factor_info();\r\n            const extents = [];\r\n            for (const [labels, , orient, visuals] of info) {\r\n                const extent = this._oriented_labels_extent(labels, orient, this.panel.side, this.model.major_label_standoff, visuals);\r\n                extents.push(extent);\r\n            }\r\n            return extents;\r\n        }\r\n        _get_factor_info() {\r\n            const [range] = this.ranges;\r\n            const [start, end] = this.computed_bounds;\r\n            const loc = this.loc;\r\n            const ticks = this.model.ticker.get_ticks(start, end, range, loc, {});\r\n            const coords = this.tick_coords;\r\n            const info = [];\r\n            if (range.levels == 1) {\r\n                const major = ticks.major;\r\n                const labels = this.model.formatter.doFormat(major, this);\r\n                info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);\r\n            }\r\n            else if (range.levels == 2) {\r\n                const major = ticks.major.map((x) => x[1]);\r\n                const labels = this.model.formatter.doFormat(major, this);\r\n                info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);\r\n                info.push([ticks.tops, coords.tops, this.model.group_label_orientation, this.visuals.group_text]);\r\n            }\r\n            else if (range.levels == 3) {\r\n                const major = ticks.major.map((x) => x[2]);\r\n                const labels = this.model.formatter.doFormat(major, this);\r\n                const mid_labels = ticks.mids.map((x) => x[1]);\r\n                info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);\r\n                info.push([mid_labels, coords.mids, this.model.subgroup_label_orientation, this.visuals.subgroup_text]);\r\n                info.push([ticks.tops, coords.tops, this.model.group_label_orientation, this.visuals.group_text]);\r\n            }\r\n            return info;\r\n        }\r\n        // {{{ TODO: state\r\n        get tick_coords() {\r\n            const i = this.dimension;\r\n            const j = (i + 1) % 2;\r\n            const [range] = this.ranges;\r\n            const [start, end] = this.computed_bounds;\r\n            const ticks = this.model.ticker.get_ticks(start, end, range, this.loc, {});\r\n            const coords = {\r\n                major: [[], []],\r\n                mids: [[], []],\r\n                tops: [[], []],\r\n                minor: [[], []],\r\n            };\r\n            coords.major[i] = ticks.major;\r\n            coords.major[j] = ticks.major.map((_x) => this.loc);\r\n            if (range.levels == 3) {\r\n                coords.mids[i] = ticks.mids;\r\n                coords.mids[j] = ticks.mids.map((_x) => this.loc);\r\n            }\r\n            if (range.levels > 1) {\r\n                coords.tops[i] = ticks.tops;\r\n                coords.tops[j] = ticks.tops.map((_x) => this.loc);\r\n            }\r\n            return coords;\r\n        }\r\n    }\r\n    exports.CategoricalAxisView = CategoricalAxisView;\r\n    CategoricalAxisView.__name__ = \"CategoricalAxisView\";\r\n    class CategoricalAxis extends axis_1.Axis {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CategoricalAxis() {\r\n            this.prototype.default_view = CategoricalAxisView;\r\n            this.mixins([\r\n                [\"separator_\", mixins.Line],\r\n                [\"group_\", mixins.Text],\r\n                [\"subgroup_\", mixins.Text],\r\n            ]);\r\n            this.define({\r\n                group_label_orientation: [p.Any, \"parallel\"],\r\n                subgroup_label_orientation: [p.Any, \"parallel\"],\r\n            });\r\n            this.override({\r\n                ticker: () => new categorical_ticker_1.CategoricalTicker(),\r\n                formatter: () => new categorical_tick_formatter_1.CategoricalTickFormatter(),\r\n                separator_line_color: \"lightgrey\",\r\n                separator_line_width: 2,\r\n                group_text_font_style: \"bold\",\r\n                group_text_font_size: \"11px\",\r\n                group_text_color: \"grey\",\r\n                subgroup_text_font_style: \"bold\",\r\n                subgroup_text_font_size: \"11px\",\r\n            });\r\n        }\r\n    }\r\n    exports.CategoricalAxis = CategoricalAxis;\r\n    CategoricalAxis.__name__ = \"CategoricalAxis\";\r\n    CategoricalAxis.init_CategoricalAxis();\r\n}\r\n","/* models\\tickers\\categorical_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const ticker_1 = require(129) /* ./ticker */;\r\n    class CategoricalTicker extends ticker_1.Ticker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        get_ticks(start, end, range, _cross_loc, _) {\r\n            const majors = this._collect(range.factors, range, start, end);\r\n            const tops = this._collect(range.tops || [], range, start, end);\r\n            const mids = this._collect(range.mids || [], range, start, end);\r\n            return {\r\n                major: majors,\r\n                minor: [],\r\n                tops,\r\n                mids,\r\n            };\r\n        }\r\n        _collect(factors, range, start, end) {\r\n            const result = [];\r\n            for (const factor of factors) {\r\n                const coord = range.synthetic(factor);\r\n                if (coord > start && coord < end)\r\n                    result.push(factor);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.CategoricalTicker = CategoricalTicker;\r\n    CategoricalTicker.__name__ = \"CategoricalTicker\";\r\n}\r\n","/* models\\formatters\\categorical_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    class CategoricalTickFormatter extends tick_formatter_1.TickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        doFormat(ticks, _opts) {\r\n            return array_1.copy(ticks);\r\n        }\r\n    }\r\n    exports.CategoricalTickFormatter = CategoricalTickFormatter;\r\n    CategoricalTickFormatter.__name__ = \"CategoricalTickFormatter\";\r\n}\r\n","/* models\\axes\\continuous_axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const axis_1 = require(177) /* ./axis */;\r\n    class ContinuousAxis extends axis_1.Axis {\r\n        // TODO: __view_type__: ContinuousAxisView\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.ContinuousAxis = ContinuousAxis;\r\n    ContinuousAxis.__name__ = \"ContinuousAxis\";\r\n}\r\n","/* models\\axes\\datetime_axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const linear_axis_1 = require(184) /* ./linear_axis */;\r\n    const datetime_tick_formatter_1 = require(185) /* ../formatters/datetime_tick_formatter */;\r\n    const datetime_ticker_1 = require(190) /* ../tickers/datetime_ticker */;\r\n    class DatetimeAxisView extends linear_axis_1.LinearAxisView {\r\n    }\r\n    exports.DatetimeAxisView = DatetimeAxisView;\r\n    DatetimeAxisView.__name__ = \"DatetimeAxisView\";\r\n    class DatetimeAxis extends linear_axis_1.LinearAxis {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_DatetimeAxis() {\r\n            this.prototype.default_view = DatetimeAxisView;\r\n            this.override({\r\n                ticker: () => new datetime_ticker_1.DatetimeTicker(),\r\n                formatter: () => new datetime_tick_formatter_1.DatetimeTickFormatter(),\r\n            });\r\n        }\r\n    }\r\n    exports.DatetimeAxis = DatetimeAxis;\r\n    DatetimeAxis.__name__ = \"DatetimeAxis\";\r\n    DatetimeAxis.init_DatetimeAxis();\r\n}\r\n","/* models\\axes\\linear_axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const axis_1 = require(177) /* ./axis */;\r\n    const continuous_axis_1 = require(182) /* ./continuous_axis */;\r\n    const basic_tick_formatter_1 = require(130) /* ../formatters/basic_tick_formatter */;\r\n    const basic_ticker_1 = require(126) /* ../tickers/basic_ticker */;\r\n    class LinearAxisView extends axis_1.AxisView {\r\n    }\r\n    exports.LinearAxisView = LinearAxisView;\r\n    LinearAxisView.__name__ = \"LinearAxisView\";\r\n    class LinearAxis extends continuous_axis_1.ContinuousAxis {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LinearAxis() {\r\n            this.prototype.default_view = LinearAxisView;\r\n            this.override({\r\n                ticker: () => new basic_ticker_1.BasicTicker(),\r\n                formatter: () => new basic_tick_formatter_1.BasicTickFormatter(),\r\n            });\r\n        }\r\n    }\r\n    exports.LinearAxis = LinearAxis;\r\n    LinearAxis.__name__ = \"LinearAxis\";\r\n    LinearAxis.init_LinearAxis();\r\n}\r\n","/* models\\formatters\\datetime_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const timezone_1 = tslib_1.__importDefault(require(186) /* timezone */);\r\n    const tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const templating_1 = require(187) /* ../../core/util/templating */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    function _us(t) {\r\n        // From double-precision unix (millisecond) timestamp get\r\n        // microsecond since last second. Precision seems to run\r\n        // out around the hundreds of nanoseconds scale, so rounding\r\n        // to the nearest microsecond should round to a nice\r\n        // microsecond / millisecond tick.\r\n        return Math.round(((t / 1000) % 1) * 1000000);\r\n    }\r\n    function _array(t) {\r\n        return timezone_1.default(t, \"%Y %m %d %H %M %S\").split(/\\s+/).map(e => parseInt(e, 10));\r\n    }\r\n    function _strftime(t, format) {\r\n        if (types_1.isFunction(format)) {\r\n            return format(t);\r\n        }\r\n        else {\r\n            // Python's datetime library augments the microsecond directive %f, which is not\r\n            // supported by the javascript library timezone: http://bigeasy.github.io/timezone/.\r\n            // Use a regular expression to replace %f directive with microseconds.\r\n            // TODO: what should we do for negative microsecond strings?\r\n            const microsecond_replacement_string = templating_1.sprintf(\"$1%06d\", _us(t));\r\n            format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);\r\n            if (format.indexOf(\"%\") == -1) {\r\n                // timezone seems to ignore any strings without any formatting directives,\r\n                // and just return the time argument back instead of the string argument.\r\n                // But we want the string argument, in case a user supplies a format string\r\n                // which doesn't contain a formatting directive or is only using %f.\r\n                return format;\r\n            }\r\n            return timezone_1.default(t, format);\r\n        }\r\n    }\r\n    // Labels of time units, from finest to coarsest.\r\n    const format_order = [\r\n        'microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years',\r\n    ];\r\n    class DatetimeTickFormatter extends tick_formatter_1.TickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            // Whether or not to strip the leading zeros on tick labels.\r\n            this.strip_leading_zeros = true;\r\n        }\r\n        static init_DatetimeTickFormatter() {\r\n            this.define({\r\n                microseconds: [p.Array, ['%fus']],\r\n                milliseconds: [p.Array, ['%3Nms', '%S.%3Ns']],\r\n                seconds: [p.Array, ['%Ss']],\r\n                minsec: [p.Array, [':%M:%S']],\r\n                minutes: [p.Array, [':%M', '%Mm']],\r\n                hourmin: [p.Array, ['%H:%M']],\r\n                hours: [p.Array, ['%Hh', '%H:%M']],\r\n                days: [p.Array, ['%m/%d', '%a%d']],\r\n                months: [p.Array, ['%m/%Y', '%b %Y']],\r\n                years: [p.Array, ['%Y']],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            // TODO (bev) trigger update on format change\r\n            this._update_width_formats();\r\n        }\r\n        _update_width_formats() {\r\n            const now = +timezone_1.default(new Date());\r\n            const _widths = function (fmt_strings) {\r\n                const sizes = fmt_strings.map((fmt_string) => _strftime(now, fmt_string).length);\r\n                const sorted = array_1.sort_by(array_1.zip(sizes, fmt_strings), ([size]) => size);\r\n                return array_1.unzip(sorted);\r\n            };\r\n            this._width_formats = {\r\n                microseconds: _widths(this.microseconds),\r\n                milliseconds: _widths(this.milliseconds),\r\n                seconds: _widths(this.seconds),\r\n                minsec: _widths(this.minsec),\r\n                minutes: _widths(this.minutes),\r\n                hourmin: _widths(this.hourmin),\r\n                hours: _widths(this.hours),\r\n                days: _widths(this.days),\r\n                months: _widths(this.months),\r\n                years: _widths(this.years),\r\n            };\r\n        }\r\n        // FIXME There is some unfortunate flicker when panning/zooming near the\r\n        // span boundaries.\r\n        // FIXME Rounding is weird at the 20-us scale and below.\r\n        _get_resolution_str(resolution_secs, span_secs) {\r\n            // Our resolution boundaries should not be round numbers, because we want\r\n            // them to fall between the possible tick intervals (which *are* round\r\n            // numbers, as we've worked hard to ensure).  Consequently, we adjust the\r\n            // resolution upwards a small amount (less than any possible step in\r\n            // scales) to make the effective boundaries slightly lower.\r\n            const adjusted_secs = resolution_secs * 1.1;\r\n            switch (false) {\r\n                case !(adjusted_secs < 1e-3): return \"microseconds\";\r\n                case !(adjusted_secs < 1.0): return \"milliseconds\";\r\n                case !(adjusted_secs < 60): return span_secs >= 60 ? \"minsec\" : \"seconds\";\r\n                case !(adjusted_secs < 3600): return span_secs >= 3600 ? \"hourmin\" : \"minutes\";\r\n                case !(adjusted_secs < (24 * 3600)): return \"hours\";\r\n                case !(adjusted_secs < (31 * 24 * 3600)): return \"days\";\r\n                case !(adjusted_secs < (365 * 24 * 3600)): return \"months\";\r\n                default: return \"years\";\r\n            }\r\n        }\r\n        doFormat(ticks, _opts) {\r\n            // In order to pick the right set of labels, we need to determine\r\n            // the resolution of the ticks.  We can do this using a ticker if\r\n            // it's provided, or by computing the resolution from the actual\r\n            // ticks we've been given.\r\n            if (ticks.length == 0)\r\n                return [];\r\n            const span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000.0;\r\n            const r = span / (ticks.length - 1);\r\n            const resol = this._get_resolution_str(r, span);\r\n            const [, [format]] = this._width_formats[resol];\r\n            // Apply the format to the tick values\r\n            const labels = [];\r\n            const resol_ndx = format_order.indexOf(resol);\r\n            // This dictionary maps the name of a time resolution (in @format_order)\r\n            // to its index in a time.localtime() timetuple.  The default is to map\r\n            // everything to index 0, which is year.  This is not ideal; it might cause\r\n            // a problem with the tick at midnight, january 1st, 0 a.d. being incorrectly\r\n            // promoted at certain tick resolutions.\r\n            const time_tuple_ndx_for_resol = {};\r\n            for (const fmt of format_order) {\r\n                time_tuple_ndx_for_resol[fmt] = 0;\r\n            }\r\n            time_tuple_ndx_for_resol.seconds = 5;\r\n            time_tuple_ndx_for_resol.minsec = 4;\r\n            time_tuple_ndx_for_resol.minutes = 4;\r\n            time_tuple_ndx_for_resol.hourmin = 3;\r\n            time_tuple_ndx_for_resol.hours = 3;\r\n            // As we format each tick, check to see if we are at a boundary of the\r\n            // next higher unit of time.  If so, replace the current format with one\r\n            // from that resolution.  This is not the best heuristic in the world,\r\n            // but it works!  There is some trickiness here due to having to deal\r\n            // with hybrid formats in a reasonable manner.\r\n            for (const t of ticks) {\r\n                let s, tm;\r\n                try {\r\n                    tm = _array(t);\r\n                    s = _strftime(t, format);\r\n                }\r\n                catch (error) {\r\n                    logging_1.logger.warn(`unable to format tick for timestamp value ${t}`);\r\n                    logging_1.logger.warn(` - ${error}`);\r\n                    labels.push(\"ERR\");\r\n                    continue;\r\n                }\r\n                let hybrid_handled = false;\r\n                let next_ndx = resol_ndx;\r\n                // The way to check that we are at the boundary of the next unit of\r\n                // time is by checking that we have 0 units of the resolution, i.e.\r\n                // we are at zero minutes, so display hours, or we are at zero seconds,\r\n                // so display minutes (and if that is zero as well, then display hours).\r\n                while (tm[time_tuple_ndx_for_resol[format_order[next_ndx]]] == 0) {\r\n                    let next_format;\r\n                    next_ndx += 1;\r\n                    if (next_ndx == format_order.length)\r\n                        break;\r\n                    if ((resol == \"minsec\" || resol == \"hourmin\") && !hybrid_handled) {\r\n                        if ((resol == \"minsec\" && tm[4] == 0 && tm[5] != 0) || (resol == \"hourmin\" && tm[3] == 0 && tm[4] != 0)) {\r\n                            next_format = this._width_formats[format_order[resol_ndx - 1]][1][0];\r\n                            s = _strftime(t, next_format);\r\n                            break;\r\n                        }\r\n                        else {\r\n                            hybrid_handled = true;\r\n                        }\r\n                    }\r\n                    next_format = this._width_formats[format_order[next_ndx]][1][0];\r\n                    s = _strftime(t, next_format);\r\n                }\r\n                // TODO: should expose this in api. %H, %d, etc use leading zeros and\r\n                // users might prefer to see them lined up correctly.\r\n                if (this.strip_leading_zeros) {\r\n                    let ss = s.replace(/^0+/g, \"\");\r\n                    if (ss != s && isNaN(parseInt(ss))) {\r\n                        // If the string can now be parsed as starting with an integer, then\r\n                        // leave all zeros stripped, otherwise start with a zero. Hence:\r\n                        // A label such as '000ms' should leave one zero.\r\n                        // A label such as '001ms' or '0-1ms' should not leave a leading zero.\r\n                        ss = `0${ss}`;\r\n                    }\r\n                    labels.push(ss);\r\n                }\r\n                else\r\n                    labels.push(s);\r\n            }\r\n            return labels;\r\n        }\r\n    }\r\n    exports.DatetimeTickFormatter = DatetimeTickFormatter;\r\n    DatetimeTickFormatter.__name__ = \"DatetimeTickFormatter\";\r\n    DatetimeTickFormatter.init_DatetimeTickFormatter();\r\n}\r\n","/* timezone\\index.js */ function _(require, module, exports) {\r\n    !function (definition) {\r\n        if (typeof module == \"object\" && module.exports)\r\n            module.exports = definition();\r\n        else if (typeof define == \"function\")\r\n            define(definition);\r\n        else\r\n            this.tz = definition();\r\n    }(function () {\r\n        /*\r\n          function die () {\r\n            console.log.apply(console, __slice.call(arguments, 0));\r\n            return process.exit(1);\r\n          }\r\n        \r\n          function say () { return console.log.apply(console, __slice.call(arguments, 0)) }\r\n        */\r\n        function actualize(entry, rule, year) {\r\n            var actualized, date = rule.day[1];\r\n            do {\r\n                actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));\r\n            } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0]);\r\n            actualized = {\r\n                clock: rule.clock,\r\n                sort: actualized.getTime(),\r\n                rule: rule,\r\n                save: rule.save * 6e4,\r\n                offset: entry.offset\r\n            };\r\n            actualized[actualized.clock] = actualized.sort + rule.time * 6e4;\r\n            if (actualized.posix) {\r\n                actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);\r\n            }\r\n            else {\r\n                actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);\r\n            }\r\n            return actualized;\r\n        }\r\n        function find(request, clock, time) {\r\n            var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules, j, year = new Date(time).getUTCFullYear(), off = 1;\r\n            for (i = 1, I = zone.length; i < I; i++)\r\n                if (zone[i][clock] <= time)\r\n                    break;\r\n            entry = zone[i];\r\n            if (entry.rules) {\r\n                rules = request[entry.rules];\r\n                for (j = year + 1; j >= year - off; --j)\r\n                    for (i = 0, I = rules.length; i < I; i++)\r\n                        if (rules[i].from <= j && j <= rules[i].to)\r\n                            actualized.push(actualize(entry, rules[i], j));\r\n                        else if (rules[i].to < j && off == 1)\r\n                            off = j - rules[i].to;\r\n                actualized.sort(function (a, b) { return a.sort - b.sort; });\r\n                for (i = 0, I = actualized.length; i < I; i++) {\r\n                    if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock])\r\n                        found = actualized[i];\r\n                }\r\n            }\r\n            if (found) {\r\n                if (abbrev = /^(.*)\\/(.*)$/.exec(entry.format)) {\r\n                    found.abbrev = abbrev[found.save ? 2 : 1];\r\n                }\r\n                else {\r\n                    found.abbrev = entry.format.replace(/%s/, found.rule.letter);\r\n                }\r\n            }\r\n            return found || entry;\r\n        }\r\n        function convertToWallclock(request, posix) {\r\n            if (request.zone == \"UTC\")\r\n                return posix;\r\n            request.entry = find(request, \"posix\", posix);\r\n            return posix + request.entry.offset + request.entry.save;\r\n        }\r\n        function convertToPOSIX(request, wallclock) {\r\n            if (request.zone == \"UTC\")\r\n                return wallclock;\r\n            var entry, diff;\r\n            request.entry = entry = find(request, \"wallclock\", wallclock);\r\n            diff = wallclock - entry.wallclock;\r\n            return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;\r\n        }\r\n        function adjust(request, posix, match) {\r\n            var increment = +(match[1] + 1) // conversion necessary for week day addition\r\n            , offset = match[2] * increment, index = UNITS.indexOf(match[3].toLowerCase()), date;\r\n            if (index > 9) {\r\n                posix += offset * TIME[index - 10];\r\n            }\r\n            else {\r\n                date = new Date(convertToWallclock(request, posix));\r\n                if (index < 7) {\r\n                    while (offset) {\r\n                        date.setUTCDate(date.getUTCDate() + increment);\r\n                        if (date.getUTCDay() == index)\r\n                            offset -= increment;\r\n                    }\r\n                }\r\n                else if (index == 7) {\r\n                    date.setUTCFullYear(date.getUTCFullYear() + offset);\r\n                }\r\n                else if (index == 8) {\r\n                    date.setUTCMonth(date.getUTCMonth() + offset);\r\n                }\r\n                else {\r\n                    date.setUTCDate(date.getUTCDate() + offset);\r\n                }\r\n                if ((posix = convertToPOSIX(request, date.getTime())) == null) {\r\n                    posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;\r\n                }\r\n            }\r\n            return posix;\r\n        }\r\n        function convert(vargs) {\r\n            if (!vargs.length)\r\n                return \"1.0.23\";\r\n            var request = Object.create(this), adjustments = [], i, I, $, argument, date;\r\n            for (i = 0; i < vargs.length; i++) { // leave the for loop alone, it works.\r\n                argument = vargs[i];\r\n                // https://twitter.com/bigeasy/status/215112186572439552\r\n                if (Array.isArray(argument)) {\r\n                    if (!i && !isNaN(argument[1])) {\r\n                        date = argument;\r\n                    }\r\n                    else {\r\n                        argument.splice.apply(vargs, [i--, 1].concat(argument));\r\n                    }\r\n                }\r\n                else if (isNaN(argument)) {\r\n                    $ = typeof argument;\r\n                    if ($ == \"string\") {\r\n                        if (~argument.indexOf(\"%\")) {\r\n                            request.format = argument;\r\n                        }\r\n                        else if (!i && argument == \"*\") {\r\n                            date = argument;\r\n                        }\r\n                        else if (!i && ($ = /^(\\d{4})-(\\d{2})-(\\d{2})(?:[T\\s](\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d+))?)?(Z|(([+-])(\\d{2}(:\\d{2}){0,2})))?)?$/.exec(argument))) {\r\n                            date = [];\r\n                            date.push.apply(date, $.slice(1, 8));\r\n                            if ($[9]) {\r\n                                date.push($[10] + 1);\r\n                                date.push.apply(date, $[11].split(/:/));\r\n                            }\r\n                            else if ($[8]) {\r\n                                date.push(1);\r\n                            }\r\n                        }\r\n                        else if (/^\\w{2,3}_\\w{2}$/.test(argument)) {\r\n                            request.locale = argument;\r\n                        }\r\n                        else if ($ = UNIT_RE.exec(argument)) {\r\n                            adjustments.push($);\r\n                        }\r\n                        else {\r\n                            request.zone = argument;\r\n                        }\r\n                    }\r\n                    else if ($ == \"function\") {\r\n                        if ($ = argument.call(request))\r\n                            return $;\r\n                    }\r\n                    else if (/^\\w{2,3}_\\w{2}$/.test(argument.name)) {\r\n                        request[argument.name] = argument;\r\n                    }\r\n                    else if (argument.zones) {\r\n                        for ($ in argument.zones)\r\n                            request[$] = argument.zones[$];\r\n                        for ($ in argument.rules)\r\n                            request[$] = argument.rules[$];\r\n                    }\r\n                }\r\n                else if (!i) {\r\n                    date = argument;\r\n                }\r\n            }\r\n            if (!request[request.locale])\r\n                delete request.locale;\r\n            if (!request[request.zone])\r\n                delete request.zone;\r\n            if (date != null) {\r\n                if (date == \"*\") {\r\n                    date = request.clock();\r\n                }\r\n                else if (Array.isArray(date)) {\r\n                    $ = [];\r\n                    I = !date[7];\r\n                    for (i = 0; i < 11; i++)\r\n                        $[i] = +(date[i] || 0); // conversion necessary for decrement\r\n                    --$[1]; // Grr..\r\n                    date = Date.UTC.apply(Date.UTC, $) + -$[7] * ($[8] * 36e5 + $[9] * 6e4 + $[10] * 1e3);\r\n                }\r\n                else {\r\n                    date = Math.floor(date);\r\n                }\r\n                if (!isNaN(date)) {\r\n                    if (I)\r\n                        date = convertToPOSIX(request, date);\r\n                    if (date == null)\r\n                        return date;\r\n                    for (i = 0, I = adjustments.length; i < I; i++) {\r\n                        date = adjust(request, date, adjustments[i]);\r\n                    }\r\n                    if (!request.format)\r\n                        return date;\r\n                    $ = new Date(convertToWallclock(request, date));\r\n                    return request.format.replace(/%([-0_^]?)(:{0,3})(\\d*)(.)/g, function (value, flag, colons, padding, specifier) {\r\n                        var f, fill = \"0\", pad;\r\n                        if (f = request[specifier]) {\r\n                            value = String(f.call(request, $, date, flag, colons.length));\r\n                            if ((flag || f.style) == \"_\")\r\n                                fill = \" \";\r\n                            pad = flag == \"-\" ? 0 : f.pad || 0;\r\n                            while (value.length < pad)\r\n                                value = fill + value;\r\n                            pad = flag == \"-\" ? 0 : padding || f.pad;\r\n                            while (value.length < pad)\r\n                                value = fill + value;\r\n                            if (specifier == \"N\" && pad < value.length)\r\n                                value = value.slice(0, pad);\r\n                            if (flag == \"^\")\r\n                                value = value.toUpperCase();\r\n                        }\r\n                        return value;\r\n                    });\r\n                }\r\n            }\r\n            return function () { return request.convert(arguments); };\r\n        }\r\n        var context = { clock: function () { return +(new Date()); },\r\n            zone: \"UTC\",\r\n            entry: { abbrev: \"UTC\", offset: 0, save: 0 },\r\n            UTC: 1,\r\n            z: function (date, posix, flag, delimiters) {\r\n                var offset = this.entry.offset + this.entry.save, seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;\r\n                for (i = 0; i < 3; i++) {\r\n                    parts.push((\"0\" + Math.floor(seconds / part)).slice(-2));\r\n                    seconds %= part;\r\n                    part /= 60;\r\n                }\r\n                if (flag == \"^\" && !offset)\r\n                    return \"Z\";\r\n                if (flag == \"^\")\r\n                    delimiters = 3;\r\n                if (delimiters == 3) {\r\n                    z = parts.join(\":\");\r\n                    z = z.replace(/:00$/, \"\");\r\n                    if (flag != \"^\")\r\n                        z = z.replace(/:00$/, \"\");\r\n                }\r\n                else if (delimiters) {\r\n                    z = parts.slice(0, delimiters + 1).join(\":\");\r\n                    if (flag == \"^\")\r\n                        z = z.replace(/:00$/, \"\");\r\n                }\r\n                else {\r\n                    z = parts.slice(0, 2).join(\"\");\r\n                }\r\n                z = (offset < 0 ? \"-\" : \"+\") + z;\r\n                z = z.replace(/([-+])(0)/, { \"_\": \" $1\", \"-\": \"$1\" }[flag] || \"$1$2\");\r\n                return z;\r\n            },\r\n            \"%\": function (date) { return \"%\"; },\r\n            n: function (date) { return \"\\n\"; },\r\n            t: function (date) { return \"\\t\"; },\r\n            U: function (date) { return weekOfYear(date, 0); },\r\n            W: function (date) { return weekOfYear(date, 1); },\r\n            V: function (date) { return isoWeek(date)[0]; },\r\n            G: function (date) { return isoWeek(date)[1]; },\r\n            g: function (date) { return isoWeek(date)[1] % 100; },\r\n            j: function (date) { return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1; },\r\n            s: function (date) { return Math.floor(date.getTime() / 1000); },\r\n            C: function (date) { return Math.floor(date.getUTCFullYear() / 100); },\r\n            N: function (date) { return date.getTime() % 1000 * 1000000; },\r\n            m: function (date) { return date.getUTCMonth() + 1; },\r\n            Y: function (date) { return date.getUTCFullYear(); },\r\n            y: function (date) { return date.getUTCFullYear() % 100; },\r\n            H: function (date) { return date.getUTCHours(); },\r\n            M: function (date) { return date.getUTCMinutes(); },\r\n            S: function (date) { return date.getUTCSeconds(); },\r\n            e: function (date) { return date.getUTCDate(); },\r\n            d: function (date) { return date.getUTCDate(); },\r\n            u: function (date) { return date.getUTCDay() || 7; },\r\n            w: function (date) { return date.getUTCDay(); },\r\n            l: function (date) { return date.getUTCHours() % 12 || 12; },\r\n            I: function (date) { return date.getUTCHours() % 12 || 12; },\r\n            k: function (date) { return date.getUTCHours(); },\r\n            Z: function (date) { return this.entry.abbrev; },\r\n            a: function (date) { return this[this.locale].day.abbrev[date.getUTCDay()]; },\r\n            A: function (date) { return this[this.locale].day.full[date.getUTCDay()]; },\r\n            h: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()]; },\r\n            b: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()]; },\r\n            B: function (date) { return this[this.locale].month.full[date.getUTCMonth()]; },\r\n            P: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase(); },\r\n            p: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)]; },\r\n            R: function (date, posix) { return this.convert([posix, \"%H:%M\"]); },\r\n            T: function (date, posix) { return this.convert([posix, \"%H:%M:%S\"]); },\r\n            D: function (date, posix) { return this.convert([posix, \"%m/%d/%y\"]); },\r\n            F: function (date, posix) { return this.convert([posix, \"%Y-%m-%d\"]); },\r\n            x: function (date, posix) { return this.convert([posix, this[this.locale].date]); },\r\n            r: function (date, posix) { return this.convert([posix, this[this.locale].time12 || '%I:%M:%S']); },\r\n            X: function (date, posix) { return this.convert([posix, this[this.locale].time24]); },\r\n            c: function (date, posix) { return this.convert([posix, this[this.locale].dateTime]); },\r\n            convert: convert,\r\n            locale: \"en_US\",\r\n            en_US: {\r\n                date: \"%m/%d/%Y\",\r\n                time24: \"%I:%M:%S %p\",\r\n                time12: \"%I:%M:%S %p\",\r\n                dateTime: \"%a %d %b %Y %I:%M:%S %p %Z\",\r\n                meridiem: [\"AM\", \"PM\"],\r\n                month: {\r\n                    abbrev: \"Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec\".split(\"|\"),\r\n                    full: \"January|February|March|April|May|June|July|August|September|October|November|December\".split(\"|\")\r\n                },\r\n                day: {\r\n                    abbrev: \"Sun|Mon|Tue|Wed|Thu|Fri|Sat\".split(\"|\"),\r\n                    full: \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday\".split(\"|\")\r\n                }\r\n            }\r\n        };\r\n        var UNITS = \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond\", UNIT_RE = new RegExp(\"^\\\\s*([+-])(\\\\d+)\\\\s+(\" + UNITS + \")s?\\\\s*$\", \"i\"), TIME = [36e5, 6e4, 1e3, 1];\r\n        UNITS = UNITS.toLowerCase().split(\"|\");\r\n        \"delmHMSUWVgCIky\".replace(/./g, function (e) { context[e].pad = 2; });\r\n        context.N.pad = 9;\r\n        context.j.pad = 3;\r\n        context.k.style = \"_\";\r\n        context.l.style = \"_\";\r\n        context.e.style = \"_\";\r\n        function weekOfYear(date, startOfWeek) {\r\n            var diff, nyd, weekStart;\r\n            nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));\r\n            diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);\r\n            if (nyd.getUTCDay() == startOfWeek) {\r\n                weekStart = 0;\r\n            }\r\n            else {\r\n                weekStart = 7 - nyd.getUTCDay() + startOfWeek;\r\n                if (weekStart == 8) {\r\n                    weekStart = 1;\r\n                }\r\n            }\r\n            return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;\r\n        }\r\n        function isoWeek(date) {\r\n            var nyd, nyy, week;\r\n            nyy = date.getUTCFullYear();\r\n            nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\r\n            week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);\r\n            if (!week) {\r\n                nyy = date.getUTCFullYear() - 1;\r\n                nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\r\n                week = nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29) ? 53 : 52;\r\n                return [week, date.getUTCFullYear() - 1];\r\n            }\r\n            else if (week == 53 && !(nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29))) {\r\n                return [1, date.getUTCFullYear() + 1];\r\n            }\r\n            else {\r\n                return [week, date.getUTCFullYear()];\r\n            }\r\n        }\r\n        return function () { return context.convert(arguments); };\r\n    });\r\n}\r\n","/* core\\util\\templating.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const Numbro = tslib_1.__importStar(require(188) /* @bokeh/numbro */);\r\n    const sprintf_js_1 = require(189) /* sprintf-js */;\r\n    const timezone_1 = tslib_1.__importDefault(require(186) /* timezone */);\r\n    const string_1 = require(29) /* ./string */;\r\n    const types_1 = require(8) /* ./types */;\r\n    exports.DEFAULT_FORMATTERS = {\r\n        numeral: (value, format, _special_vars) => Numbro.format(value, format),\r\n        datetime: (value, format, _special_vars) => timezone_1.default(value, format),\r\n        printf: (value, format, _special_vars) => sprintf(format, value),\r\n    };\r\n    function sprintf(format, ...args) {\r\n        return sprintf_js_1.sprintf(format, ...args);\r\n    }\r\n    exports.sprintf = sprintf;\r\n    function basic_formatter(value, _format, _special_vars) {\r\n        if (types_1.isNumber(value)) {\r\n            const format = (() => {\r\n                switch (false) {\r\n                    case Math.floor(value) != value:\r\n                        return \"%d\";\r\n                    case !(Math.abs(value) > 0.1) || !(Math.abs(value) < 1000):\r\n                        return \"%0.3f\";\r\n                    default:\r\n                        return \"%0.3e\";\r\n                }\r\n            })();\r\n            return sprintf(format, value);\r\n        }\r\n        else\r\n            return `${value}`; // get strings for categorical types\r\n    }\r\n    exports.basic_formatter = basic_formatter;\r\n    function get_formatter(raw_spec, format, formatters) {\r\n        // no format, use default built in formatter\r\n        if (format == null)\r\n            return basic_formatter;\r\n        // format spec in the formatters dict, use that\r\n        if (formatters != null && raw_spec in formatters) {\r\n            const formatter = formatters[raw_spec];\r\n            if (types_1.isString(formatter)) {\r\n                if (formatter in exports.DEFAULT_FORMATTERS)\r\n                    return exports.DEFAULT_FORMATTERS[formatter];\r\n                else\r\n                    throw new Error(`Unknown tooltip field formatter type '${formatter}'`);\r\n            }\r\n            return function (value, format, special_vars) {\r\n                return formatter.format(value, format, special_vars);\r\n            };\r\n        }\r\n        // otherwise use \"numeral\" as default\r\n        return exports.DEFAULT_FORMATTERS.numeral;\r\n    }\r\n    exports.get_formatter = get_formatter;\r\n    function _get_special_value(name, special_vars) {\r\n        if (name in special_vars)\r\n            return special_vars[name];\r\n        else\r\n            throw new Error(`Unknown special variable '\\$${name}'`);\r\n    }\r\n    function _get_column_value(name, data_source, i) {\r\n        const column = data_source.get_column(name);\r\n        // missing column\r\n        if (column == null)\r\n            return null;\r\n        // typical (non-image) index\r\n        if (types_1.isNumber(i))\r\n            return column[i];\r\n        // image index\r\n        const data = column[i.index];\r\n        if (types_1.isTypedArray(data) || types_1.isArray(data)) {\r\n            // inspect array of arrays\r\n            if (types_1.isArray(data[0])) {\r\n                const row = data[i.dim2];\r\n                return row[i.dim1];\r\n            }\r\n            else\r\n                return data[i.flat_index]; // inspect flat array\r\n        }\r\n        else\r\n            return data; // inspect per-image scalar data\r\n    }\r\n    function get_value(raw_name, data_source, i, special_vars) {\r\n        if (raw_name[0] == \"$\") {\r\n            const name = raw_name.substring(1);\r\n            return _get_special_value(name, special_vars);\r\n        }\r\n        else {\r\n            const name = raw_name.substring(1).replace(/[{}]/g, \"\");\r\n            return _get_column_value(name, data_source, i);\r\n        }\r\n    }\r\n    exports.get_value = get_value;\r\n    function replace_placeholders(content, data_source, i, formatters, special_vars = {}) {\r\n        let str;\r\n        let has_html;\r\n        if (types_1.isString(content)) {\r\n            str = content;\r\n            has_html = false;\r\n        }\r\n        else {\r\n            str = content.html;\r\n            has_html = true;\r\n        }\r\n        // this handles the special case @$name, replacing it with an @var corresponding to special_vars.name\r\n        str = str.replace(/@\\$name/g, (_match) => `@{${special_vars.name}}`);\r\n        //\r\n        // (?:\\$\\w+) - special vars: $x\r\n        // (?:@\\w+) - simple names: @foo\r\n        // (?:@{(?:[^{}]+)})) - full names: @{one two}\r\n        //\r\n        // (?:{([^{}]+)})? - (optional) format for all of the above: @foo{fmt}\r\n        //\r\n        str = str.replace(/((?:\\$\\w+)|(?:@\\w+)|(?:@{(?:[^{}]+)}))(?:{([^{}]+)})?/g, (_match, spec, format) => {\r\n            const value = get_value(spec, data_source, i, special_vars);\r\n            // missing value, return ???\r\n            if (value == null)\r\n                return `${string_1.escape(\"???\")}`;\r\n            // 'safe' format, return the value as-is\r\n            if (format == 'safe') {\r\n                has_html = true;\r\n                return `${value}`;\r\n            }\r\n            // format and escape everything else\r\n            const formatter = get_formatter(spec, format, formatters);\r\n            return `${string_1.escape(formatter(value, format, special_vars))}`;\r\n        });\r\n        if (!has_html)\r\n            return str;\r\n        else {\r\n            const parser = new DOMParser();\r\n            const document = parser.parseFromString(str, \"text/html\");\r\n            return [...document.body.childNodes];\r\n        }\r\n    }\r\n    exports.replace_placeholders = replace_placeholders;\r\n}\r\n","/* @bokeh\\numbro\\numbro.js */ function _(require, module, exports) {\r\n    /*!\r\n     * numbro.js\r\n     * version : 1.6.2\r\n     * author : Fretagsplatsen AB\r\n     * license : MIT\r\n     * http://www.foretagsplatsen.se\r\n     */\r\n    /************************************\r\n        Constants\r\n    ************************************/\r\n    var numbro, VERSION = '1.6.2', \r\n    // internal storage for culture config files\r\n    cultures = {}, \r\n    // Todo: Remove in 2.0.0\r\n    languages = cultures, currentCulture = 'en-US', zeroFormat = null, defaultFormat = '0,0', defaultCurrencyFormat = '0$', \r\n    // check for nodeJS\r\n    hasModule = (typeof module !== 'undefined' && module.exports), \r\n    // default culture\r\n    enUS = {\r\n        delimiters: {\r\n            thousands: ',',\r\n            decimal: '.'\r\n        },\r\n        abbreviations: {\r\n            thousand: 'k',\r\n            million: 'm',\r\n            billion: 'b',\r\n            trillion: 't'\r\n        },\r\n        ordinal: function (number) {\r\n            var b = number % 10;\r\n            return (~~(number % 100 / 10) === 1) ? 'th' :\r\n                (b === 1) ? 'st' :\r\n                    (b === 2) ? 'nd' :\r\n                        (b === 3) ? 'rd' : 'th';\r\n        },\r\n        currency: {\r\n            symbol: '$',\r\n            position: 'prefix'\r\n        },\r\n        defaults: {\r\n            currencyFormat: ',0000 a'\r\n        },\r\n        formats: {\r\n            fourDigits: '0000 a',\r\n            fullWithTwoDecimals: '$ ,0.00',\r\n            fullWithTwoDecimalsNoCurrency: ',0.00'\r\n        }\r\n    };\r\n    /************************************\r\n        Constructors\r\n    ************************************/\r\n    // Numbro prototype object\r\n    function Numbro(number) {\r\n        this._value = number;\r\n    }\r\n    function zeroes(count) {\r\n        var i, ret = '';\r\n        for (i = 0; i < count; i++) {\r\n            ret += '0';\r\n        }\r\n        return ret;\r\n    }\r\n    /**\r\n     * Implementation of toFixed() for numbers with exponent > 21\r\n     *\r\n     *\r\n     */\r\n    function toFixedLarge(value, precision) {\r\n        var mantissa, beforeDec, afterDec, exponent, str;\r\n        str = value.toString();\r\n        mantissa = str.split('e')[0];\r\n        exponent = str.split('e')[1];\r\n        beforeDec = mantissa.split('.')[0];\r\n        afterDec = mantissa.split('.')[1] || '';\r\n        str = beforeDec + afterDec + zeroes(exponent - afterDec.length);\r\n        if (precision > 0) {\r\n            str += '.' + zeroes(precision);\r\n        }\r\n        return str;\r\n    }\r\n    /**\r\n     * Implementation of toFixed() that treats floats more like decimals\r\n     *\r\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\r\n     * problems for accounting- and finance-related software.\r\n     */\r\n    function toFixed(value, precision, roundingFunction, optionals) {\r\n        var power = Math.pow(10, precision), optionalsRegExp, output;\r\n        if (value.toFixed(0).search('e') > -1) {\r\n            // Above 1e21, toFixed returns scientific notation, which\r\n            // is useless and unexpected\r\n            output = toFixedLarge(value, precision);\r\n        }\r\n        else {\r\n            //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);\r\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\r\n            output = (roundingFunction(value * power) / power).toFixed(precision);\r\n        }\r\n        if (optionals) {\r\n            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\r\n            output = output.replace(optionalsRegExp, '');\r\n        }\r\n        return output;\r\n    }\r\n    /************************************\r\n        Formatting\r\n    ************************************/\r\n    // determine what type of formatting we need to do\r\n    function formatNumbro(value, format, roundingFunction) {\r\n        var output;\r\n        // TODO: do something with `language`\r\n        // figure out what kind of format we are dealing with\r\n        if (format.indexOf('$') > -1) { // currency!!!!!\r\n            output = formatCurrency(value, format, roundingFunction);\r\n        }\r\n        else if (format.indexOf('%') > -1) { // percentage\r\n            output = formatPercentage(value, format, roundingFunction);\r\n        }\r\n        else if (format.indexOf(':') > -1) { // time\r\n            output = formatTime(value);\r\n        }\r\n        else { // plain ol' numbers or bytes\r\n            output = formatNumber(value, format, roundingFunction);\r\n        }\r\n        // return string\r\n        return output;\r\n    }\r\n    function formatCurrency(value, originalFormat, roundingFunction) {\r\n        var format = originalFormat, symbolIndex = format.indexOf('$'), openParenIndex = format.indexOf('('), plusSignIndex = format.indexOf('+'), minusSignIndex = format.indexOf('-'), space = '', decimalSeparator = '', spliceIndex, output;\r\n        if (format.indexOf('$') === -1) {\r\n            // Use defaults instead of the format provided\r\n            if (cultures[currentCulture].currency.position === 'infix') {\r\n                decimalSeparator = cultures[currentCulture].currency.symbol;\r\n                if (cultures[currentCulture].currency.spaceSeparated) {\r\n                    decimalSeparator = ' ' + decimalSeparator + ' ';\r\n                }\r\n            }\r\n            else if (cultures[currentCulture].currency.spaceSeparated) {\r\n                space = ' ';\r\n            }\r\n        }\r\n        else {\r\n            // check for space before or after currency\r\n            if (format.indexOf(' $') > -1) {\r\n                space = ' ';\r\n                format = format.replace(' $', '');\r\n            }\r\n            else if (format.indexOf('$ ') > -1) {\r\n                space = ' ';\r\n                format = format.replace('$ ', '');\r\n            }\r\n            else {\r\n                format = format.replace('$', '');\r\n            }\r\n        }\r\n        // Format The Number\r\n        output = formatNumber(value, format, roundingFunction, decimalSeparator);\r\n        if (originalFormat.indexOf('$') === -1) {\r\n            // Use defaults instead of the format provided\r\n            switch (cultures[currentCulture].currency.position) {\r\n                case 'postfix':\r\n                    if (output.indexOf(')') > -1) {\r\n                        output = output.split('');\r\n                        output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\r\n                        output = output.join('');\r\n                    }\r\n                    else {\r\n                        output = output + space + cultures[currentCulture].currency.symbol;\r\n                    }\r\n                    break;\r\n                case 'infix':\r\n                    break;\r\n                case 'prefix':\r\n                    if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\r\n                        output = output.split('');\r\n                        spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;\r\n                        output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\r\n                        output = output.join('');\r\n                    }\r\n                    else {\r\n                        output = cultures[currentCulture].currency.symbol + space + output;\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw Error('Currency position should be among [\"prefix\", \"infix\", \"postfix\"]');\r\n            }\r\n        }\r\n        else {\r\n            // position the symbol\r\n            if (symbolIndex <= 1) {\r\n                if (output.indexOf('(') > -1 || output.indexOf('+') > -1 || output.indexOf('-') > -1) {\r\n                    output = output.split('');\r\n                    spliceIndex = 1;\r\n                    if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {\r\n                        // the symbol appears before the \"(\", \"+\" or \"-\"\r\n                        spliceIndex = 0;\r\n                    }\r\n                    output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\r\n                    output = output.join('');\r\n                }\r\n                else {\r\n                    output = cultures[currentCulture].currency.symbol + space + output;\r\n                }\r\n            }\r\n            else {\r\n                if (output.indexOf(')') > -1) {\r\n                    output = output.split('');\r\n                    output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\r\n                    output = output.join('');\r\n                }\r\n                else {\r\n                    output = output + space + cultures[currentCulture].currency.symbol;\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n    function formatPercentage(value, format, roundingFunction) {\r\n        var space = '', output;\r\n        value = value * 100;\r\n        // check for space before %\r\n        if (format.indexOf(' %') > -1) {\r\n            space = ' ';\r\n            format = format.replace(' %', '');\r\n        }\r\n        else {\r\n            format = format.replace('%', '');\r\n        }\r\n        output = formatNumber(value, format, roundingFunction);\r\n        if (output.indexOf(')') > -1) {\r\n            output = output.split('');\r\n            output.splice(-1, 0, space + '%');\r\n            output = output.join('');\r\n        }\r\n        else {\r\n            output = output + space + '%';\r\n        }\r\n        return output;\r\n    }\r\n    function formatTime(value) {\r\n        var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - (hours * 60 * 60)) / 60), seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\r\n        return hours + ':' +\r\n            ((minutes < 10) ? '0' + minutes : minutes) + ':' +\r\n            ((seconds < 10) ? '0' + seconds : seconds);\r\n    }\r\n    function formatNumber(value, format, roundingFunction, sep) {\r\n        var negP = false, signed = false, optDec = false, abbr = '', i, abbrK = false, // force abbreviation to thousands\r\n        abbrM = false, // force abbreviation to millions\r\n        abbrB = false, // force abbreviation to billions\r\n        abbrT = false, // force abbreviation to trillions\r\n        abbrForce = false, // force abbreviation\r\n        bytes = '', ord = '', abs = Math.abs(value), binarySuffixes = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'], decimalSuffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], min, max, power, totalLength, length, minimumPrecision, pow, w, intPrecision, precision, prefix, postfix, thousands, d = '', forcedNeg = false, neg = false, indexOpenP, size, indexMinus, paren = '', minlen;\r\n        // check if number is zero and a custom zero format has been set\r\n        if (value === 0 && zeroFormat !== null) {\r\n            return zeroFormat;\r\n        }\r\n        if (!isFinite(value)) {\r\n            return '' + value;\r\n        }\r\n        if (format.indexOf('{') === 0) {\r\n            var end = format.indexOf('}');\r\n            if (end === -1) {\r\n                throw Error('Format should also contain a \"}\"');\r\n            }\r\n            prefix = format.slice(1, end);\r\n            format = format.slice(end + 1);\r\n        }\r\n        else {\r\n            prefix = '';\r\n        }\r\n        if (format.indexOf('}') === format.length - 1) {\r\n            var start = format.indexOf('{');\r\n            if (start === -1) {\r\n                throw Error('Format should also contain a \"{\"');\r\n            }\r\n            postfix = format.slice(start + 1, -1);\r\n            format = format.slice(0, start + 1);\r\n        }\r\n        else {\r\n            postfix = '';\r\n        }\r\n        // check for min length\r\n        var info;\r\n        if (format.indexOf('.') === -1) {\r\n            info = format.match(/([0-9]+).*/);\r\n        }\r\n        else {\r\n            info = format.match(/([0-9]+)\\..*/);\r\n        }\r\n        minlen = info === null ? -1 : info[1].length;\r\n        // see if we should use parentheses for negative number or if we should prefix with a sign\r\n        // if both are present we default to parentheses\r\n        if (format.indexOf('-') !== -1) {\r\n            forcedNeg = true;\r\n        }\r\n        if (format.indexOf('(') > -1) {\r\n            negP = true;\r\n            format = format.slice(1, -1);\r\n        }\r\n        else if (format.indexOf('+') > -1) {\r\n            signed = true;\r\n            format = format.replace(/\\+/g, '');\r\n        }\r\n        // see if abbreviation is wanted\r\n        if (format.indexOf('a') > -1) {\r\n            intPrecision = format.split('.')[0].match(/[0-9]+/g) || ['0'];\r\n            intPrecision = parseInt(intPrecision[0], 10);\r\n            // check if abbreviation is specified\r\n            abbrK = format.indexOf('aK') >= 0;\r\n            abbrM = format.indexOf('aM') >= 0;\r\n            abbrB = format.indexOf('aB') >= 0;\r\n            abbrT = format.indexOf('aT') >= 0;\r\n            abbrForce = abbrK || abbrM || abbrB || abbrT;\r\n            // check for space before abbreviation\r\n            if (format.indexOf(' a') > -1) {\r\n                abbr = ' ';\r\n                format = format.replace(' a', '');\r\n            }\r\n            else {\r\n                format = format.replace('a', '');\r\n            }\r\n            totalLength = Math.floor(Math.log(abs) / Math.LN10) + 1;\r\n            minimumPrecision = totalLength % 3;\r\n            minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;\r\n            if (intPrecision && abs !== 0) {\r\n                length = Math.floor(Math.log(abs) / Math.LN10) + 1 - intPrecision;\r\n                pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);\r\n                abs = abs / Math.pow(10, pow);\r\n                if (format.indexOf('.') === -1 && intPrecision > 3) {\r\n                    format += '[.]';\r\n                    size = length === 0 ? 0 : 3 * ~~(length / 3) - length;\r\n                    size = size < 0 ? size + 3 : size;\r\n                    for (i = 0; i < size; i++) {\r\n                        format += '0';\r\n                    }\r\n                }\r\n            }\r\n            if (Math.floor(Math.log(Math.abs(value)) / Math.LN10) + 1 !== intPrecision) {\r\n                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\r\n                    // trillion\r\n                    abbr = abbr + cultures[currentCulture].abbreviations.trillion;\r\n                    value = value / Math.pow(10, 12);\r\n                }\r\n                else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\r\n                    // billion\r\n                    abbr = abbr + cultures[currentCulture].abbreviations.billion;\r\n                    value = value / Math.pow(10, 9);\r\n                }\r\n                else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\r\n                    // million\r\n                    abbr = abbr + cultures[currentCulture].abbreviations.million;\r\n                    value = value / Math.pow(10, 6);\r\n                }\r\n                else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\r\n                    // thousand\r\n                    abbr = abbr + cultures[currentCulture].abbreviations.thousand;\r\n                    value = value / Math.pow(10, 3);\r\n                }\r\n            }\r\n        }\r\n        // see if we are formatting binary bytes\r\n        if (format.indexOf('b') > -1) {\r\n            // check for space before\r\n            if (format.indexOf(' b') > -1) {\r\n                bytes = ' ';\r\n                format = format.replace(' b', '');\r\n            }\r\n            else {\r\n                format = format.replace('b', '');\r\n            }\r\n            for (power = 0; power <= binarySuffixes.length; power++) {\r\n                min = Math.pow(1024, power);\r\n                max = Math.pow(1024, power + 1);\r\n                if (value >= min && value < max) {\r\n                    bytes = bytes + binarySuffixes[power];\r\n                    if (min > 0) {\r\n                        value = value / min;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // see if we are formatting decimal bytes\r\n        if (format.indexOf('d') > -1) {\r\n            // check for space before\r\n            if (format.indexOf(' d') > -1) {\r\n                bytes = ' ';\r\n                format = format.replace(' d', '');\r\n            }\r\n            else {\r\n                format = format.replace('d', '');\r\n            }\r\n            for (power = 0; power <= decimalSuffixes.length; power++) {\r\n                min = Math.pow(1000, power);\r\n                max = Math.pow(1000, power + 1);\r\n                if (value >= min && value < max) {\r\n                    bytes = bytes + decimalSuffixes[power];\r\n                    if (min > 0) {\r\n                        value = value / min;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // see if ordinal is wanted\r\n        if (format.indexOf('o') > -1) {\r\n            // check for space before\r\n            if (format.indexOf(' o') > -1) {\r\n                ord = ' ';\r\n                format = format.replace(' o', '');\r\n            }\r\n            else {\r\n                format = format.replace('o', '');\r\n            }\r\n            if (cultures[currentCulture].ordinal) {\r\n                ord = ord + cultures[currentCulture].ordinal(value);\r\n            }\r\n        }\r\n        if (format.indexOf('[.]') > -1) {\r\n            optDec = true;\r\n            format = format.replace('[.]', '.');\r\n        }\r\n        w = value.toString().split('.')[0];\r\n        precision = format.split('.')[1];\r\n        thousands = format.indexOf(',');\r\n        if (precision) {\r\n            if (precision.indexOf('*') !== -1) {\r\n                d = toFixed(value, value.toString().split('.')[1].length, roundingFunction);\r\n            }\r\n            else {\r\n                if (precision.indexOf('[') > -1) {\r\n                    precision = precision.replace(']', '');\r\n                    precision = precision.split('[');\r\n                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\r\n                }\r\n                else {\r\n                    d = toFixed(value, precision.length, roundingFunction);\r\n                }\r\n            }\r\n            w = d.split('.')[0];\r\n            if (d.split('.')[1].length) {\r\n                var p = sep ? abbr + sep : cultures[currentCulture].delimiters.decimal;\r\n                d = p + d.split('.')[1];\r\n            }\r\n            else {\r\n                d = '';\r\n            }\r\n            if (optDec && Number(d.slice(1)) === 0) {\r\n                d = '';\r\n            }\r\n        }\r\n        else {\r\n            w = toFixed(value, null, roundingFunction);\r\n        }\r\n        // format number\r\n        if (w.indexOf('-') > -1) {\r\n            w = w.slice(1);\r\n            neg = true;\r\n        }\r\n        if (w.length < minlen) {\r\n            w = new Array(minlen - w.length + 1).join('0') + w;\r\n        }\r\n        if (thousands > -1) {\r\n            w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' +\r\n                cultures[currentCulture].delimiters.thousands);\r\n        }\r\n        if (format.indexOf('.') === 0) {\r\n            w = '';\r\n        }\r\n        indexOpenP = format.indexOf('(');\r\n        indexMinus = format.indexOf('-');\r\n        if (indexOpenP < indexMinus) {\r\n            paren = ((negP && neg) ? '(' : '') + (((forcedNeg && neg) || (!negP && neg)) ? '-' : '');\r\n        }\r\n        else {\r\n            paren = (((forcedNeg && neg) || (!negP && neg)) ? '-' : '') + ((negP && neg) ? '(' : '');\r\n        }\r\n        return prefix +\r\n            paren + ((!neg && signed && value !== 0) ? '+' : '') +\r\n            w + d +\r\n            ((ord) ? ord : '') +\r\n            ((abbr && !sep) ? abbr : '') +\r\n            ((bytes) ? bytes : '') +\r\n            ((negP && neg) ? ')' : '') +\r\n            postfix;\r\n    }\r\n    /************************************\r\n        Top Level Functions\r\n    ************************************/\r\n    numbro = function (input) {\r\n        if (numbro.isNumbro(input)) {\r\n            input = input.value();\r\n        }\r\n        else if (input === 0 || typeof input === 'undefined') {\r\n            input = 0;\r\n        }\r\n        else if (!Number(input)) {\r\n            input = numbro.fn.unformat(input);\r\n        }\r\n        return new Numbro(Number(input));\r\n    };\r\n    // version number\r\n    numbro.version = VERSION;\r\n    // compare numbro object\r\n    numbro.isNumbro = function (obj) {\r\n        return obj instanceof Numbro;\r\n    };\r\n    /**\r\n     * This function allow the user to set a new language with a fallback if\r\n     * the language does not exist. If no fallback language is provided,\r\n     * it fallbacks to english.\r\n     *\r\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\r\n     * `setCulture` should be used instead.\r\n     */\r\n    numbro.setLanguage = function (newLanguage, fallbackLanguage) {\r\n        console.warn('`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead');\r\n        var key = newLanguage, prefix = newLanguage.split('-')[0], matchingLanguage = null;\r\n        if (!languages[key]) {\r\n            Object.keys(languages).forEach(function (language) {\r\n                if (!matchingLanguage && language.split('-')[0] === prefix) {\r\n                    matchingLanguage = language;\r\n                }\r\n            });\r\n            key = matchingLanguage || fallbackLanguage || 'en-US';\r\n        }\r\n        chooseCulture(key);\r\n    };\r\n    /**\r\n     * This function allow the user to set a new culture with a fallback if\r\n     * the culture does not exist. If no fallback culture is provided,\r\n     * it fallbacks to \"en-US\".\r\n     */\r\n    numbro.setCulture = function (newCulture, fallbackCulture) {\r\n        var key = newCulture, suffix = newCulture.split('-')[1], matchingCulture = null;\r\n        if (!cultures[key]) {\r\n            if (suffix) {\r\n                Object.keys(cultures).forEach(function (language) {\r\n                    if (!matchingCulture && language.split('-')[1] === suffix) {\r\n                        matchingCulture = language;\r\n                    }\r\n                });\r\n            }\r\n            key = matchingCulture || fallbackCulture || 'en-US';\r\n        }\r\n        chooseCulture(key);\r\n    };\r\n    /**\r\n     * This function will load languages and then set the global language.  If\r\n     * no arguments are passed in, it will simply return the current global\r\n     * language key.\r\n     *\r\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\r\n     * `culture` should be used instead.\r\n     */\r\n    numbro.language = function (key, values) {\r\n        console.warn('`language` is deprecated since version 1.6.0. Use `culture` instead');\r\n        if (!key) {\r\n            return currentCulture;\r\n        }\r\n        if (key && !values) {\r\n            if (!languages[key]) {\r\n                throw new Error('Unknown language : ' + key);\r\n            }\r\n            chooseCulture(key);\r\n        }\r\n        if (values || !languages[key]) {\r\n            setCulture(key, values);\r\n        }\r\n        return numbro;\r\n    };\r\n    /**\r\n     * This function will load cultures and then set the global culture.  If\r\n     * no arguments are passed in, it will simply return the current global\r\n     * culture code.\r\n     */\r\n    numbro.culture = function (code, values) {\r\n        if (!code) {\r\n            return currentCulture;\r\n        }\r\n        if (code && !values) {\r\n            if (!cultures[code]) {\r\n                throw new Error('Unknown culture : ' + code);\r\n            }\r\n            chooseCulture(code);\r\n        }\r\n        if (values || !cultures[code]) {\r\n            setCulture(code, values);\r\n        }\r\n        return numbro;\r\n    };\r\n    /**\r\n     * This function provides access to the loaded language data.  If\r\n     * no arguments are passed in, it will simply return the current\r\n     * global language object.\r\n     *\r\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\r\n     * `culture` should be used instead.\r\n     */\r\n    numbro.languageData = function (key) {\r\n        console.warn('`languageData` is deprecated since version 1.6.0. Use `cultureData` instead');\r\n        if (!key) {\r\n            return languages[currentCulture];\r\n        }\r\n        if (!languages[key]) {\r\n            throw new Error('Unknown language : ' + key);\r\n        }\r\n        return languages[key];\r\n    };\r\n    /**\r\n     * This function provides access to the loaded culture data.  If\r\n     * no arguments are passed in, it will simply return the current\r\n     * global culture object.\r\n     */\r\n    numbro.cultureData = function (code) {\r\n        if (!code) {\r\n            return cultures[currentCulture];\r\n        }\r\n        if (!cultures[code]) {\r\n            throw new Error('Unknown culture : ' + code);\r\n        }\r\n        return cultures[code];\r\n    };\r\n    numbro.culture('en-US', enUS);\r\n    /**\r\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\r\n     * `cultures` should be used instead.\r\n     */\r\n    numbro.languages = function () {\r\n        console.warn('`languages` is deprecated since version 1.6.0. Use `cultures` instead');\r\n        return languages;\r\n    };\r\n    numbro.cultures = function () {\r\n        return cultures;\r\n    };\r\n    numbro.zeroFormat = function (format) {\r\n        zeroFormat = typeof (format) === 'string' ? format : null;\r\n    };\r\n    numbro.defaultFormat = function (format) {\r\n        defaultFormat = typeof (format) === 'string' ? format : '0.0';\r\n    };\r\n    numbro.defaultCurrencyFormat = function (format) {\r\n        defaultCurrencyFormat = typeof (format) === 'string' ? format : '0$';\r\n    };\r\n    numbro.validate = function (val, culture) {\r\n        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, cultureData, temp;\r\n        //coerce val to string\r\n        if (typeof val !== 'string') {\r\n            val += '';\r\n            if (console.warn) {\r\n                console.warn('Numbro.js: Value is not string. It has been co-erced to: ', val);\r\n            }\r\n        }\r\n        //trim whitespaces from either sides\r\n        val = val.trim();\r\n        //if val is just digits return true\r\n        if (!!val.match(/^\\d+$/)) {\r\n            return true;\r\n        }\r\n        //if val is empty return false\r\n        if (val === '') {\r\n            return false;\r\n        }\r\n        //get the decimal and thousands separator from numbro.cultureData\r\n        try {\r\n            //check if the culture is understood by numbro. if not, default it to current culture\r\n            cultureData = numbro.cultureData(culture);\r\n        }\r\n        catch (e) {\r\n            cultureData = numbro.cultureData(numbro.culture());\r\n        }\r\n        //setup the delimiters and currency symbol based on culture\r\n        _currSymbol = cultureData.currency.symbol;\r\n        _abbrObj = cultureData.abbreviations;\r\n        _decimalSep = cultureData.delimiters.decimal;\r\n        if (cultureData.delimiters.thousands === '.') {\r\n            _thousandSep = '\\\\.';\r\n        }\r\n        else {\r\n            _thousandSep = cultureData.delimiters.thousands;\r\n        }\r\n        // validating currency symbol\r\n        temp = val.match(/^[^\\d]+/);\r\n        if (temp !== null) {\r\n            val = val.substr(1);\r\n            if (temp[0] !== _currSymbol) {\r\n                return false;\r\n            }\r\n        }\r\n        //validating abbreviation symbol\r\n        temp = val.match(/[^\\d]+$/);\r\n        if (temp !== null) {\r\n            val = val.slice(0, -1);\r\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million &&\r\n                temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\r\n                return false;\r\n            }\r\n        }\r\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\r\n        if (!val.match(/[^\\d.,]/g)) {\r\n            _valArray = val.split(_decimalSep);\r\n            if (_valArray.length > 2) {\r\n                return false;\r\n            }\r\n            else {\r\n                if (_valArray.length < 2) {\r\n                    return (!!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\r\n                }\r\n                else {\r\n                    if (_valArray[0].length === 1) {\r\n                        return (!!_valArray[0].match(/^\\d+$/) &&\r\n                            !_valArray[0].match(_thousandRegEx) &&\r\n                            !!_valArray[1].match(/^\\d+$/));\r\n                    }\r\n                    else {\r\n                        return (!!_valArray[0].match(/^\\d+.*\\d$/) &&\r\n                            !_valArray[0].match(_thousandRegEx) &&\r\n                            !!_valArray[1].match(/^\\d+$/));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /************************************\r\n        Helpers\r\n    ************************************/\r\n    function setCulture(code, values) {\r\n        cultures[code] = values;\r\n    }\r\n    function chooseCulture(code) {\r\n        currentCulture = code;\r\n        var defaults = cultures[code].defaults;\r\n        if (defaults && defaults.format) {\r\n            numbro.defaultFormat(defaults.format);\r\n        }\r\n        if (defaults && defaults.currencyFormat) {\r\n            numbro.defaultCurrencyFormat(defaults.currencyFormat);\r\n        }\r\n    }\r\n    function format(input, formatString, language, roundingFunction) {\r\n        if (language != null && language !== numbro.culture()) {\r\n            numbro.setCulture(language);\r\n        }\r\n        return formatNumbro(Number(input), formatString != null ? formatString : defaultFormat, roundingFunction == null ? Math.round : roundingFunction);\r\n    }\r\n    module.exports = { \"format\": format };\r\n}\r\n","/* sprintf-js\\src\\sprintf.js */ function _(require, module, exports) {\r\n    /* global window, exports, define */\r\n    !function () {\r\n        'use strict';\r\n        var re = {\r\n            not_string: /[^s]/,\r\n            not_bool: /[^t]/,\r\n            not_type: /[^T]/,\r\n            not_primitive: /[^v]/,\r\n            number: /[diefg]/,\r\n            numeric_arg: /[bcdiefguxX]/,\r\n            json: /[j]/,\r\n            not_json: /[^j]/,\r\n            text: /^[^\\x25]+/,\r\n            modulo: /^\\x25{2}/,\r\n            placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\r\n            key: /^([a-z_][a-z_\\d]*)/i,\r\n            key_access: /^\\.([a-z_][a-z_\\d]*)/i,\r\n            index_access: /^\\[(\\d+)\\]/,\r\n            sign: /^[+-]/\r\n        };\r\n        function sprintf(key) {\r\n            // `arguments` is not an array, but should be fine for this call\r\n            return sprintf_format(sprintf_parse(key), arguments);\r\n        }\r\n        function vsprintf(fmt, argv) {\r\n            return sprintf.apply(null, [fmt].concat(argv || []));\r\n        }\r\n        function sprintf_format(parse_tree, argv) {\r\n            var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;\r\n            for (i = 0; i < tree_length; i++) {\r\n                if (typeof parse_tree[i] === 'string') {\r\n                    output += parse_tree[i];\r\n                }\r\n                else if (typeof parse_tree[i] === 'object') {\r\n                    ph = parse_tree[i]; // convenience purposes only\r\n                    if (ph.keys) { // keyword argument\r\n                        arg = argv[cursor];\r\n                        for (k = 0; k < ph.keys.length; k++) {\r\n                            if (arg == undefined) {\r\n                                throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k - 1]));\r\n                            }\r\n                            arg = arg[ph.keys[k]];\r\n                        }\r\n                    }\r\n                    else if (ph.param_no) { // positional argument (explicit)\r\n                        arg = argv[ph.param_no];\r\n                    }\r\n                    else { // positional argument (implicit)\r\n                        arg = argv[cursor++];\r\n                    }\r\n                    if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\r\n                        arg = arg();\r\n                    }\r\n                    if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\r\n                        throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));\r\n                    }\r\n                    if (re.number.test(ph.type)) {\r\n                        is_positive = arg >= 0;\r\n                    }\r\n                    switch (ph.type) {\r\n                        case 'b':\r\n                            arg = parseInt(arg, 10).toString(2);\r\n                            break;\r\n                        case 'c':\r\n                            arg = String.fromCharCode(parseInt(arg, 10));\r\n                            break;\r\n                        case 'd':\r\n                        case 'i':\r\n                            arg = parseInt(arg, 10);\r\n                            break;\r\n                        case 'j':\r\n                            arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);\r\n                            break;\r\n                        case 'e':\r\n                            arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();\r\n                            break;\r\n                        case 'f':\r\n                            arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);\r\n                            break;\r\n                        case 'g':\r\n                            arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);\r\n                            break;\r\n                        case 'o':\r\n                            arg = (parseInt(arg, 10) >>> 0).toString(8);\r\n                            break;\r\n                        case 's':\r\n                            arg = String(arg);\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\r\n                            break;\r\n                        case 't':\r\n                            arg = String(!!arg);\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\r\n                            break;\r\n                        case 'T':\r\n                            arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\r\n                            break;\r\n                        case 'u':\r\n                            arg = parseInt(arg, 10) >>> 0;\r\n                            break;\r\n                        case 'v':\r\n                            arg = arg.valueOf();\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\r\n                            break;\r\n                        case 'x':\r\n                            arg = (parseInt(arg, 10) >>> 0).toString(16);\r\n                            break;\r\n                        case 'X':\r\n                            arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();\r\n                            break;\r\n                    }\r\n                    if (re.json.test(ph.type)) {\r\n                        output += arg;\r\n                    }\r\n                    else {\r\n                        if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\r\n                            sign = is_positive ? '+' : '-';\r\n                            arg = arg.toString().replace(re.sign, '');\r\n                        }\r\n                        else {\r\n                            sign = '';\r\n                        }\r\n                        pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';\r\n                        pad_length = ph.width - (sign + arg).length;\r\n                        pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';\r\n                        output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);\r\n                    }\r\n                }\r\n            }\r\n            return output;\r\n        }\r\n        var sprintf_cache = Object.create(null);\r\n        function sprintf_parse(fmt) {\r\n            if (sprintf_cache[fmt]) {\r\n                return sprintf_cache[fmt];\r\n            }\r\n            var _fmt = fmt, match, parse_tree = [], arg_names = 0;\r\n            while (_fmt) {\r\n                if ((match = re.text.exec(_fmt)) !== null) {\r\n                    parse_tree.push(match[0]);\r\n                }\r\n                else if ((match = re.modulo.exec(_fmt)) !== null) {\r\n                    parse_tree.push('%');\r\n                }\r\n                else if ((match = re.placeholder.exec(_fmt)) !== null) {\r\n                    if (match[2]) {\r\n                        arg_names |= 1;\r\n                        var field_list = [], replacement_field = match[2], field_match = [];\r\n                        if ((field_match = re.key.exec(replacement_field)) !== null) {\r\n                            field_list.push(field_match[1]);\r\n                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\r\n                                if ((field_match = re.key_access.exec(replacement_field)) !== null) {\r\n                                    field_list.push(field_match[1]);\r\n                                }\r\n                                else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\r\n                                    field_list.push(field_match[1]);\r\n                                }\r\n                                else {\r\n                                    throw new SyntaxError('[sprintf] failed to parse named argument key');\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            throw new SyntaxError('[sprintf] failed to parse named argument key');\r\n                        }\r\n                        match[2] = field_list;\r\n                    }\r\n                    else {\r\n                        arg_names |= 2;\r\n                    }\r\n                    if (arg_names === 3) {\r\n                        throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');\r\n                    }\r\n                    parse_tree.push({\r\n                        placeholder: match[0],\r\n                        param_no: match[1],\r\n                        keys: match[2],\r\n                        sign: match[3],\r\n                        pad_char: match[4],\r\n                        align: match[5],\r\n                        width: match[6],\r\n                        precision: match[7],\r\n                        type: match[8]\r\n                    });\r\n                }\r\n                else {\r\n                    throw new SyntaxError('[sprintf] unexpected placeholder');\r\n                }\r\n                _fmt = _fmt.substring(match[0].length);\r\n            }\r\n            return sprintf_cache[fmt] = parse_tree;\r\n        }\r\n        /**\r\n         * export to either browser or node.js\r\n         */\r\n        /* eslint-disable quote-props */\r\n        if (typeof exports !== 'undefined') {\r\n            exports['sprintf'] = sprintf;\r\n            exports['vsprintf'] = vsprintf;\r\n        }\r\n        if (typeof window !== 'undefined') {\r\n            window['sprintf'] = sprintf;\r\n            window['vsprintf'] = vsprintf;\r\n            if (typeof define === 'function' && define['amd']) {\r\n                define(function () {\r\n                    return {\r\n                        'sprintf': sprintf,\r\n                        'vsprintf': vsprintf\r\n                    };\r\n                });\r\n            }\r\n        }\r\n        /* eslint-enable quote-props */\r\n    }(); // eslint-disable-line\r\n}\r\n","/* models\\tickers\\datetime_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const adaptive_ticker_1 = require(127) /* ./adaptive_ticker */;\r\n    const composite_ticker_1 = require(191) /* ./composite_ticker */;\r\n    const days_ticker_1 = require(192) /* ./days_ticker */;\r\n    const months_ticker_1 = require(195) /* ./months_ticker */;\r\n    const years_ticker_1 = require(196) /* ./years_ticker */;\r\n    const util_1 = require(194) /* ./util */;\r\n    class DatetimeTicker extends composite_ticker_1.CompositeTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_DatetimeTicker() {\r\n            this.override({\r\n                num_minor_ticks: 0,\r\n                tickers: () => [\r\n                    // Sub-second.\r\n                    new adaptive_ticker_1.AdaptiveTicker({\r\n                        mantissas: [1, 2, 5],\r\n                        base: 10,\r\n                        min_interval: 0,\r\n                        max_interval: 500 * util_1.ONE_MILLI,\r\n                        num_minor_ticks: 0,\r\n                    }),\r\n                    // Seconds, minutes.\r\n                    new adaptive_ticker_1.AdaptiveTicker({\r\n                        mantissas: [1, 2, 5, 10, 15, 20, 30],\r\n                        base: 60,\r\n                        min_interval: util_1.ONE_SECOND,\r\n                        max_interval: 30 * util_1.ONE_MINUTE,\r\n                        num_minor_ticks: 0,\r\n                    }),\r\n                    // Hours.\r\n                    new adaptive_ticker_1.AdaptiveTicker({\r\n                        mantissas: [1, 2, 4, 6, 8, 12],\r\n                        base: 24.0,\r\n                        min_interval: util_1.ONE_HOUR,\r\n                        max_interval: 12 * util_1.ONE_HOUR,\r\n                        num_minor_ticks: 0,\r\n                    }),\r\n                    // Days.\r\n                    new days_ticker_1.DaysTicker({ days: array_1.range(1, 32) }),\r\n                    new days_ticker_1.DaysTicker({ days: array_1.range(1, 31, 3) }),\r\n                    new days_ticker_1.DaysTicker({ days: [1, 8, 15, 22] }),\r\n                    new days_ticker_1.DaysTicker({ days: [1, 15] }),\r\n                    // Months.\r\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 1) }),\r\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 2) }),\r\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 4) }),\r\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 6) }),\r\n                    // Years\r\n                    new years_ticker_1.YearsTicker({}),\r\n                ],\r\n            });\r\n        }\r\n    }\r\n    exports.DatetimeTicker = DatetimeTicker;\r\n    DatetimeTicker.__name__ = \"DatetimeTicker\";\r\n    DatetimeTicker.init_DatetimeTicker();\r\n}\r\n","/* models\\tickers\\composite_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const continuous_ticker_1 = require(128) /* ./continuous_ticker */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    class CompositeTicker extends continuous_ticker_1.ContinuousTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CompositeTicker() {\r\n            this.define({\r\n                tickers: [p.Array, []],\r\n            });\r\n        }\r\n        // The tickers should be in order of increasing interval size; specifically,\r\n        // if S comes before T, then it should be the case that\r\n        // S.get_max_interval() < T.get_min_interval().\r\n        // FIXME Enforce this automatically.\r\n        get min_intervals() {\r\n            return this.tickers.map((ticker) => ticker.get_min_interval());\r\n        }\r\n        get max_intervals() {\r\n            return this.tickers.map((ticker) => ticker.get_max_interval());\r\n        }\r\n        get min_interval() {\r\n            return this.min_intervals[0];\r\n        }\r\n        get max_interval() {\r\n            return this.max_intervals[0];\r\n        }\r\n        get_best_ticker(data_low, data_high, desired_n_ticks) {\r\n            const data_range = data_high - data_low;\r\n            const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\r\n            const ticker_ndxs = [\r\n                array_1.sorted_index(this.min_intervals, ideal_interval) - 1,\r\n                array_1.sorted_index(this.max_intervals, ideal_interval),\r\n            ];\r\n            const intervals = [\r\n                this.min_intervals[ticker_ndxs[0]],\r\n                this.max_intervals[ticker_ndxs[1]],\r\n            ];\r\n            const errors = intervals.map((interval) => {\r\n                return Math.abs(desired_n_ticks - (data_range / interval));\r\n            });\r\n            let best_ticker;\r\n            if (array_1.is_empty(errors.filter((e) => !isNaN(e)))) {\r\n                // this can happen if the data isn't loaded yet, we just default to the first scale\r\n                best_ticker = this.tickers[0];\r\n            }\r\n            else {\r\n                const best_index = array_1.argmin(errors);\r\n                const best_ticker_ndx = ticker_ndxs[best_index];\r\n                best_ticker = this.tickers[best_ticker_ndx];\r\n            }\r\n            return best_ticker;\r\n        }\r\n        get_interval(data_low, data_high, desired_n_ticks) {\r\n            const best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\r\n            return best_ticker.get_interval(data_low, data_high, desired_n_ticks);\r\n        }\r\n        get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {\r\n            const best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\r\n            return best_ticker.get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks);\r\n        }\r\n    }\r\n    exports.CompositeTicker = CompositeTicker;\r\n    CompositeTicker.__name__ = \"CompositeTicker\";\r\n    CompositeTicker.init_CompositeTicker();\r\n}\r\n","/* models\\tickers\\days_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const single_interval_ticker_1 = require(193) /* ./single_interval_ticker */;\r\n    const util_1 = require(194) /* ./util */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    // Given a start and end time in millis, returns the shortest array of\r\n    // consecutive months (as Dates) that surrounds both times.\r\n    function date_range_by_month(start_time, end_time) {\r\n        const start_date = util_1.last_month_no_later_than(new Date(start_time));\r\n        const end_date = util_1.last_month_no_later_than(new Date(end_time));\r\n        // XXX This is not a reliable technique in general, but it should be\r\n        // safe when the day of the month is 1.  (The problem case is this:\r\n        // Mar 31 -> Apr 31, which becomes May 1.)\r\n        end_date.setUTCMonth(end_date.getUTCMonth() + 1);\r\n        const dates = [];\r\n        const date = start_date;\r\n        while (true) {\r\n            dates.push(util_1.copy_date(date));\r\n            date.setUTCMonth(date.getUTCMonth() + 1);\r\n            if (date > end_date)\r\n                break;\r\n        }\r\n        return dates;\r\n    }\r\n    class DaysTicker extends single_interval_ticker_1.SingleIntervalTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_DaysTicker() {\r\n            this.define({\r\n                days: [p.Array, []],\r\n            });\r\n            this.override({\r\n                num_minor_ticks: 0,\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            const days = this.days;\r\n            if (days.length > 1)\r\n                this.interval = (days[1] - days[0]) * util_1.ONE_DAY;\r\n            else\r\n                this.interval = 31 * util_1.ONE_DAY;\r\n        }\r\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {\r\n            const month_dates = date_range_by_month(data_low, data_high);\r\n            const days = this.days;\r\n            const days_of_month = (month_date, interval) => {\r\n                const current_month = month_date.getUTCMonth();\r\n                const dates = [];\r\n                for (const day of days) {\r\n                    const day_date = util_1.copy_date(month_date);\r\n                    day_date.setUTCDate(day);\r\n                    // We can't use all of the values in this.days, because they may not\r\n                    // fall within the current month.  In fact, if, e.g., our month is 28 days\r\n                    // and we're marking every third day, we don't want day 28 to show up\r\n                    // because it'll be right next to the 1st of the next month.  So we\r\n                    // make sure we have a bit of room before we include a day.\r\n                    // TODO (bev) The above description does not exactly work because JS Date\r\n                    // is broken and will happily consider \"Feb 28 + 3*ONE_DAY\" to have month \"2\"\r\n                    const future_date = new Date(day_date.getTime() + (interval / 2));\r\n                    if (future_date.getUTCMonth() == current_month)\r\n                        dates.push(day_date);\r\n                }\r\n                return dates;\r\n            };\r\n            const interval = this.interval;\r\n            const day_dates = array_1.concat(month_dates.map((date) => days_of_month(date, interval)));\r\n            const all_ticks = day_dates.map((day_date) => day_date.getTime());\r\n            const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);\r\n            return {\r\n                major: ticks_in_range,\r\n                minor: [],\r\n            };\r\n        }\r\n    }\r\n    exports.DaysTicker = DaysTicker;\r\n    DaysTicker.__name__ = \"DaysTicker\";\r\n    DaysTicker.init_DaysTicker();\r\n}\r\n","/* models\\tickers\\single_interval_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const continuous_ticker_1 = require(128) /* ./continuous_ticker */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class SingleIntervalTicker extends continuous_ticker_1.ContinuousTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_SingleIntervalTicker() {\r\n            this.define({\r\n                interval: [p.Number],\r\n            });\r\n        }\r\n        get_interval(_data_low, _data_high, _n_desired_ticks) {\r\n            return this.interval;\r\n        }\r\n        get min_interval() {\r\n            return this.interval;\r\n        }\r\n        get max_interval() {\r\n            return this.interval;\r\n        }\r\n    }\r\n    exports.SingleIntervalTicker = SingleIntervalTicker;\r\n    SingleIntervalTicker.__name__ = \"SingleIntervalTicker\";\r\n    SingleIntervalTicker.init_SingleIntervalTicker();\r\n}\r\n","/* models\\tickers\\util.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    // TODO Clear out debugging code, etc.\r\n    // TODO Organize helper functions.\r\n    // TODO The years ticker doesn't always use the roundest numbers; it should\r\n    // probably use a special ticker.\r\n    // TODO Add tests.\r\n    // TODO There used to be a TODO: restore memoization.  So.... do that?\r\n    // TODO Instead of a get_ticks() method, there used to be an auto_ticks()\r\n    // function that took a lot of fancy arguments, but those arguments weren't\r\n    // used anywhere.  Should we restore them?\r\n    // Some time constants, in milliseconds.\r\n    exports.ONE_MILLI = 1.0;\r\n    exports.ONE_SECOND = 1000.0;\r\n    exports.ONE_MINUTE = 60.0 * exports.ONE_SECOND;\r\n    exports.ONE_HOUR = 60 * exports.ONE_MINUTE;\r\n    exports.ONE_DAY = 24 * exports.ONE_HOUR;\r\n    exports.ONE_MONTH = 30 * exports.ONE_DAY; // An approximation, obviously.\r\n    exports.ONE_YEAR = 365 * exports.ONE_DAY;\r\n    // ---------------------------------------------------------------------------\r\n    // Date/time utility functions\r\n    // ---------------------------------------------------------------------------\r\n    // Makes a copy of a date object.\r\n    function copy_date(date) {\r\n        return new Date(date.getTime());\r\n    }\r\n    exports.copy_date = copy_date;\r\n    // Rounds a date down to the month.\r\n    function last_month_no_later_than(date) {\r\n        const new_date = copy_date(date);\r\n        new_date.setUTCDate(1);\r\n        new_date.setUTCHours(0);\r\n        new_date.setUTCMinutes(0);\r\n        new_date.setUTCSeconds(0);\r\n        new_date.setUTCMilliseconds(0);\r\n        return new_date;\r\n    }\r\n    exports.last_month_no_later_than = last_month_no_later_than;\r\n    // Rounds a date down to the year.\r\n    function last_year_no_later_than(date) {\r\n        const new_date = last_month_no_later_than(date);\r\n        new_date.setUTCMonth(0);\r\n        return new_date;\r\n    }\r\n    exports.last_year_no_later_than = last_year_no_later_than;\r\n}\r\n","/* models\\tickers\\months_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const single_interval_ticker_1 = require(193) /* ./single_interval_ticker */;\r\n    const util_1 = require(194) /* ./util */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    // Given a start and end time in millis, returns the shortest array of\r\n    // consecutive years (as Dates) that surrounds both times.\r\n    function date_range_by_year(start_time, end_time) {\r\n        const start_date = util_1.last_year_no_later_than(new Date(start_time));\r\n        const end_date = util_1.last_year_no_later_than(new Date(end_time));\r\n        end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);\r\n        const dates = [];\r\n        const date = start_date;\r\n        while (true) {\r\n            dates.push(util_1.copy_date(date));\r\n            date.setUTCFullYear(date.getUTCFullYear() + 1);\r\n            if (date > end_date)\r\n                break;\r\n        }\r\n        return dates;\r\n    }\r\n    class MonthsTicker extends single_interval_ticker_1.SingleIntervalTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MonthsTicker() {\r\n            this.define({\r\n                months: [p.Array, []],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            const months = this.months;\r\n            if (months.length > 1)\r\n                this.interval = (months[1] - months[0]) * util_1.ONE_MONTH;\r\n            else\r\n                this.interval = 12 * util_1.ONE_MONTH;\r\n        }\r\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {\r\n            const year_dates = date_range_by_year(data_low, data_high);\r\n            const months = this.months;\r\n            const months_of_year = (year_date) => {\r\n                return months.map((month) => {\r\n                    const month_date = util_1.copy_date(year_date);\r\n                    month_date.setUTCMonth(month);\r\n                    return month_date;\r\n                });\r\n            };\r\n            const month_dates = array_1.concat(year_dates.map(months_of_year));\r\n            const all_ticks = month_dates.map((month_date) => month_date.getTime());\r\n            const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);\r\n            return {\r\n                major: ticks_in_range,\r\n                minor: [],\r\n            };\r\n        }\r\n    }\r\n    exports.MonthsTicker = MonthsTicker;\r\n    MonthsTicker.__name__ = \"MonthsTicker\";\r\n    MonthsTicker.init_MonthsTicker();\r\n}\r\n","/* models\\tickers\\years_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const basic_ticker_1 = require(126) /* ./basic_ticker */;\r\n    const single_interval_ticker_1 = require(193) /* ./single_interval_ticker */;\r\n    const util_1 = require(194) /* ./util */;\r\n    class YearsTicker extends single_interval_ticker_1.SingleIntervalTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.interval = util_1.ONE_YEAR;\r\n            this.basic_ticker = new basic_ticker_1.BasicTicker({ num_minor_ticks: 0 });\r\n        }\r\n        get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {\r\n            const start_year = util_1.last_year_no_later_than(new Date(data_low)).getUTCFullYear();\r\n            const end_year = util_1.last_year_no_later_than(new Date(data_high)).getUTCFullYear();\r\n            const years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, cross_loc, desired_n_ticks).major;\r\n            const all_ticks = years.map((year) => Date.UTC(year, 0, 1));\r\n            const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);\r\n            return {\r\n                major: ticks_in_range,\r\n                minor: [],\r\n            };\r\n        }\r\n    }\r\n    exports.YearsTicker = YearsTicker;\r\n    YearsTicker.__name__ = \"YearsTicker\";\r\n}\r\n","/* models\\axes\\log_axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const axis_1 = require(177) /* ./axis */;\r\n    const continuous_axis_1 = require(182) /* ./continuous_axis */;\r\n    const log_tick_formatter_1 = require(198) /* ../formatters/log_tick_formatter */;\r\n    const log_ticker_1 = require(199) /* ../tickers/log_ticker */;\r\n    class LogAxisView extends axis_1.AxisView {\r\n    }\r\n    exports.LogAxisView = LogAxisView;\r\n    LogAxisView.__name__ = \"LogAxisView\";\r\n    class LogAxis extends continuous_axis_1.ContinuousAxis {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LogAxis() {\r\n            this.prototype.default_view = LogAxisView;\r\n            this.override({\r\n                ticker: () => new log_ticker_1.LogTicker(),\r\n                formatter: () => new log_tick_formatter_1.LogTickFormatter(),\r\n            });\r\n        }\r\n    }\r\n    exports.LogAxis = LogAxis;\r\n    LogAxis.__name__ = \"LogAxis\";\r\n    LogAxis.init_LogAxis();\r\n}\r\n","/* models\\formatters\\log_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    const basic_tick_formatter_1 = require(130) /* ./basic_tick_formatter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class LogTickFormatter extends tick_formatter_1.TickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LogTickFormatter() {\r\n            this.define({\r\n                ticker: [p.Instance, null],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.basic_formatter = new basic_tick_formatter_1.BasicTickFormatter();\r\n        }\r\n        doFormat(ticks, opts) {\r\n            if (ticks.length == 0)\r\n                return [];\r\n            const base = this.ticker != null ? this.ticker.base : 10;\r\n            let small_interval = false;\r\n            const labels = new Array(ticks.length);\r\n            for (let i = 0, end = ticks.length; i < end; i++) {\r\n                labels[i] = `${base}^${Math.round(Math.log(ticks[i]) / Math.log(base))}`;\r\n                if (i > 0 && labels[i] == labels[i - 1]) {\r\n                    small_interval = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (small_interval)\r\n                return this.basic_formatter.doFormat(ticks, opts);\r\n            else\r\n                return labels;\r\n        }\r\n    }\r\n    exports.LogTickFormatter = LogTickFormatter;\r\n    LogTickFormatter.__name__ = \"LogTickFormatter\";\r\n    LogTickFormatter.init_LogTickFormatter();\r\n}\r\n","/* models\\tickers\\log_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const adaptive_ticker_1 = require(127) /* ./adaptive_ticker */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    class LogTicker extends adaptive_ticker_1.AdaptiveTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LogTicker() {\r\n            this.override({\r\n                mantissas: [1, 5],\r\n            });\r\n        }\r\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\r\n            const num_minor_ticks = this.num_minor_ticks;\r\n            const minor_ticks = [];\r\n            const base = this.base;\r\n            const log_low = Math.log(data_low) / Math.log(base);\r\n            const log_high = Math.log(data_high) / Math.log(base);\r\n            const log_interval = log_high - log_low;\r\n            let ticks;\r\n            if (!isFinite(log_interval)) {\r\n                ticks = [];\r\n            }\r\n            else if (log_interval < 2) { // treat as linear ticker\r\n                const interval = this.get_interval(data_low, data_high, desired_n_ticks);\r\n                const start_factor = Math.floor(data_low / interval);\r\n                const end_factor = Math.ceil(data_high / interval);\r\n                ticks = array_1.range(start_factor, end_factor + 1)\r\n                    .filter((factor) => factor != 0)\r\n                    .map((factor) => factor * interval)\r\n                    .filter((tick) => data_low <= tick && tick <= data_high);\r\n                if (num_minor_ticks > 0 && ticks.length > 0) {\r\n                    const minor_interval = interval / num_minor_ticks;\r\n                    const minor_offsets = array_1.range(0, num_minor_ticks).map((i) => i * minor_interval);\r\n                    for (const x of minor_offsets.slice(1)) {\r\n                        minor_ticks.push(ticks[0] - x);\r\n                    }\r\n                    for (const tick of ticks) {\r\n                        for (const x of minor_offsets) {\r\n                            minor_ticks.push(tick + x);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const startlog = Math.ceil(log_low * 0.999999);\r\n                const endlog = Math.floor(log_high * 1.000001);\r\n                const interval = Math.ceil((endlog - startlog) / 9.0);\r\n                ticks = array_1.range(startlog - 1, endlog + 1, interval)\r\n                    .map((i) => base ** i);\r\n                if (num_minor_ticks > 0 && ticks.length > 0) {\r\n                    const minor_interval = base ** interval / num_minor_ticks;\r\n                    const minor_offsets = array_1.range(1, num_minor_ticks + 1).map((i) => i * minor_interval);\r\n                    for (const x of minor_offsets) {\r\n                        minor_ticks.push(ticks[0] / x);\r\n                    }\r\n                    minor_ticks.push(ticks[0]);\r\n                    for (const tick of ticks) {\r\n                        for (const x of minor_offsets) {\r\n                            minor_ticks.push(tick * x);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                major: ticks.filter((tick) => data_low <= tick && tick <= data_high),\r\n                minor: minor_ticks.filter((tick) => data_low <= tick && tick <= data_high),\r\n            };\r\n        }\r\n    }\r\n    exports.LogTicker = LogTicker;\r\n    LogTicker.__name__ = \"LogTicker\";\r\n    LogTicker.init_LogTicker();\r\n}\r\n","/* models\\axes\\mercator_axis.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const axis_1 = require(177) /* ./axis */;\r\n    const linear_axis_1 = require(184) /* ./linear_axis */;\r\n    const mercator_tick_formatter_1 = require(201) /* ../formatters/mercator_tick_formatter */;\r\n    const mercator_ticker_1 = require(202) /* ../tickers/mercator_ticker */;\r\n    class MercatorAxisView extends axis_1.AxisView {\r\n    }\r\n    exports.MercatorAxisView = MercatorAxisView;\r\n    MercatorAxisView.__name__ = \"MercatorAxisView\";\r\n    class MercatorAxis extends linear_axis_1.LinearAxis {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MercatorAxis() {\r\n            this.prototype.default_view = MercatorAxisView;\r\n            this.override({\r\n                ticker: () => new mercator_ticker_1.MercatorTicker({ dimension: \"lat\" }),\r\n                formatter: () => new mercator_tick_formatter_1.MercatorTickFormatter({ dimension: \"lat\" }),\r\n            });\r\n        }\r\n    }\r\n    exports.MercatorAxis = MercatorAxis;\r\n    MercatorAxis.__name__ = \"MercatorAxis\";\r\n    MercatorAxis.init_MercatorAxis();\r\n}\r\n","/* models\\formatters\\mercator_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const basic_tick_formatter_1 = require(130) /* ./basic_tick_formatter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    class MercatorTickFormatter extends basic_tick_formatter_1.BasicTickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MercatorTickFormatter() {\r\n            this.define({\r\n                dimension: [p.LatLon],\r\n            });\r\n        }\r\n        doFormat(ticks, opts) {\r\n            if (this.dimension == null)\r\n                throw new Error(\"MercatorTickFormatter.dimension not configured\");\r\n            if (ticks.length == 0)\r\n                return [];\r\n            const n = ticks.length;\r\n            const proj_ticks = new Array(n);\r\n            if (this.dimension == \"lon\") {\r\n                for (let i = 0; i < n; i++) {\r\n                    const [lon] = projections_1.wgs84_mercator.invert(ticks[i], opts.loc);\r\n                    proj_ticks[i] = lon;\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0; i < n; i++) {\r\n                    const [, lat] = projections_1.wgs84_mercator.invert(opts.loc, ticks[i]);\r\n                    proj_ticks[i] = lat;\r\n                }\r\n            }\r\n            return super.doFormat(proj_ticks, opts);\r\n        }\r\n    }\r\n    exports.MercatorTickFormatter = MercatorTickFormatter;\r\n    MercatorTickFormatter.__name__ = \"MercatorTickFormatter\";\r\n    MercatorTickFormatter.init_MercatorTickFormatter();\r\n}\r\n","/* models\\tickers\\mercator_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const basic_ticker_1 = require(126) /* ./basic_ticker */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    class MercatorTicker extends basic_ticker_1.BasicTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MercatorTicker() {\r\n            this.define({\r\n                dimension: [p.LatLon],\r\n            });\r\n        }\r\n        get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {\r\n            if (this.dimension == null) {\r\n                throw new Error(`${this}.dimension wasn't configured`);\r\n            }\r\n            [data_low, data_high] = projections_1.clip_mercator(data_low, data_high, this.dimension);\r\n            if (this.dimension == \"lon\")\r\n                return this._get_ticks_lon(data_low, data_high, cross_loc, desired_n_ticks);\r\n            else\r\n                return this._get_ticks_lat(data_low, data_high, cross_loc, desired_n_ticks);\r\n        }\r\n        _get_ticks_lon(data_low, data_high, cross_loc, desired_n_ticks) {\r\n            const [proj_low] = projections_1.wgs84_mercator.invert(data_low, cross_loc);\r\n            const [proj_high, proj_cross_loc] = projections_1.wgs84_mercator.invert(data_high, cross_loc);\r\n            const proj_ticks = super.get_ticks_no_defaults(proj_low, proj_high, cross_loc, desired_n_ticks);\r\n            const major = [];\r\n            for (const tick of proj_ticks.major) {\r\n                if (projections_1.in_bounds(tick, \"lon\")) {\r\n                    const [lon] = projections_1.wgs84_mercator.compute(tick, proj_cross_loc);\r\n                    major.push(lon);\r\n                }\r\n            }\r\n            const minor = [];\r\n            for (const tick of proj_ticks.minor) {\r\n                if (projections_1.in_bounds(tick, \"lon\")) {\r\n                    const [lon] = projections_1.wgs84_mercator.compute(tick, proj_cross_loc);\r\n                    minor.push(lon);\r\n                }\r\n            }\r\n            return { major, minor };\r\n        }\r\n        _get_ticks_lat(data_low, data_high, cross_loc, desired_n_ticks) {\r\n            const [, proj_low] = projections_1.wgs84_mercator.invert(cross_loc, data_low);\r\n            const [proj_cross_loc, proj_high] = projections_1.wgs84_mercator.invert(cross_loc, data_high);\r\n            const proj_ticks = super.get_ticks_no_defaults(proj_low, proj_high, cross_loc, desired_n_ticks);\r\n            const major = [];\r\n            for (const tick of proj_ticks.major) {\r\n                if (projections_1.in_bounds(tick, \"lat\")) {\r\n                    const [, lat] = projections_1.wgs84_mercator.compute(proj_cross_loc, tick);\r\n                    major.push(lat);\r\n                }\r\n            }\r\n            const minor = [];\r\n            for (const tick of proj_ticks.minor) {\r\n                if (projections_1.in_bounds(tick, \"lat\")) {\r\n                    const [, lat] = projections_1.wgs84_mercator.compute(proj_cross_loc, tick);\r\n                    minor.push(lat);\r\n                }\r\n            }\r\n            return { major, minor };\r\n        }\r\n    }\r\n    exports.MercatorTicker = MercatorTicker;\r\n    MercatorTicker.__name__ = \"MercatorTicker\";\r\n    MercatorTicker.init_MercatorTicker();\r\n}\r\n","/* models\\callbacks\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var customjs_1 = require(204) /* ./customjs */;\r\n    exports.CustomJS = customjs_1.CustomJS;\r\n    var open_url_1 = require(206) /* ./open_url */;\r\n    exports.OpenURL = open_url_1.OpenURL;\r\n}\r\n","/* models\\callbacks\\customjs.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const callback_1 = require(205) /* ./callback */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const string_1 = require(29) /* ../../core/util/string */;\r\n    class CustomJS extends callback_1.Callback {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CustomJS() {\r\n            this.define({\r\n                args: [p.Any, {}],\r\n                code: [p.String, ''],\r\n            });\r\n        }\r\n        get names() {\r\n            return object_1.keys(this.args);\r\n        }\r\n        get values() {\r\n            return object_1.values(this.args);\r\n        }\r\n        get func() {\r\n            const code = string_1.use_strict(this.code);\r\n            return new Function(...this.names, \"cb_obj\", \"cb_data\", code);\r\n        }\r\n        execute(cb_obj, cb_data = {}) {\r\n            return this.func.apply(cb_obj, this.values.concat(cb_obj, cb_data));\r\n        }\r\n    }\r\n    exports.CustomJS = CustomJS;\r\n    CustomJS.__name__ = \"CustomJS\";\r\n    CustomJS.init_CustomJS();\r\n}\r\n","/* models\\callbacks\\callback.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class Callback extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.Callback = Callback;\r\n    Callback.__name__ = \"Callback\";\r\n}\r\n","/* models\\callbacks\\open_url.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const callback_1 = require(205) /* ./callback */;\r\n    const templating_1 = require(187) /* ../../core/util/templating */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class OpenURL extends callback_1.Callback {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_OpenURL() {\r\n            this.define({\r\n                url: [p.String, 'http://'],\r\n                same_tab: [p.Boolean, false],\r\n            });\r\n        }\r\n        execute(_cb_obj, { source }) {\r\n            const open_url = (i) => {\r\n                const url = templating_1.replace_placeholders(this.url, source, i);\r\n                if (!types_1.isString(url))\r\n                    throw new Error(\"HTML output is not supported in this context\");\r\n                if (this.same_tab)\r\n                    window.location.href = url;\r\n                else\r\n                    window.open(url);\r\n            };\r\n            const { selected } = source;\r\n            for (const i of selected.indices)\r\n                open_url(i);\r\n            for (const i of selected.line_indices)\r\n                open_url(i);\r\n            // TODO: multiline_indices: {[key: string]: number[]}\r\n        }\r\n    }\r\n    exports.OpenURL = OpenURL;\r\n    OpenURL.__name__ = \"OpenURL\";\r\n    OpenURL.init_OpenURL();\r\n}\r\n","/* models\\canvas\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var canvas_1 = require(77) /* ./canvas */;\r\n    exports.Canvas = canvas_1.Canvas;\r\n    var cartesian_frame_1 = require(208) /* ./cartesian_frame */;\r\n    exports.CartesianFrame = cartesian_frame_1.CartesianFrame;\r\n}\r\n","/* models\\canvas\\cartesian_frame.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const categorical_scale_1 = require(209) /* ../scales/categorical_scale */;\r\n    const continuous_scale_1 = require(146) /* ../scales/continuous_scale */;\r\n    const log_scale_1 = require(157) /* ../scales/log_scale */;\r\n    const range1d_1 = require(158) /* ../ranges/range1d */;\r\n    const data_range1d_1 = require(210) /* ../ranges/data_range1d */;\r\n    const factor_range_1 = require(98) /* ../ranges/factor_range */;\r\n    const layout_1 = require(212) /* ../../core/layout */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    class CartesianFrame extends layout_1.LayoutItem {\r\n        constructor(in_x_scale, in_y_scale, x_range, y_range, extra_x_ranges = {}, extra_y_ranges = {}) {\r\n            super();\r\n            this.in_x_scale = in_x_scale;\r\n            this.in_y_scale = in_y_scale;\r\n            this.x_range = x_range;\r\n            this.y_range = y_range;\r\n            this.extra_x_ranges = extra_x_ranges;\r\n            this.extra_y_ranges = extra_y_ranges;\r\n            assert_1.assert(in_x_scale.source_range == null && in_x_scale.target_range == null);\r\n            assert_1.assert(in_y_scale.source_range == null && in_y_scale.target_range == null);\r\n            this._configure_scales();\r\n        }\r\n        _get_ranges(range, extra_ranges) {\r\n            return new Map(object_1.entries(Object.assign(Object.assign({}, extra_ranges), { default: range })));\r\n        }\r\n        /*protected*/ _get_scales(scale, ranges, frame_range) {\r\n            const scales = new Map();\r\n            for (const [name, range] of ranges) {\r\n                if (range instanceof data_range1d_1.DataRange1d || range instanceof range1d_1.Range1d) {\r\n                    if (!(scale instanceof continuous_scale_1.ContinuousScale))\r\n                        throw new Error(`Range ${range.type} is incompatible is Scale ${scale.type}`);\r\n                }\r\n                if (range instanceof factor_range_1.FactorRange) {\r\n                    if (!(scale instanceof categorical_scale_1.CategoricalScale))\r\n                        throw new Error(`Range ${range.type} is incompatible is Scale ${scale.type}`);\r\n                }\r\n                if (scale instanceof log_scale_1.LogScale && range instanceof data_range1d_1.DataRange1d)\r\n                    range.scale_hint = \"log\";\r\n                const derived_scale = scale.clone();\r\n                derived_scale.setv({ source_range: range, target_range: frame_range });\r\n                scales.set(name, derived_scale);\r\n            }\r\n            return scales;\r\n        }\r\n        _configure_frame_ranges() {\r\n            // data to/from screen space transform (left-bottom <-> left-top origin)\r\n            const { bbox } = this;\r\n            this._x_target = new range1d_1.Range1d({ start: bbox.left, end: bbox.right });\r\n            this._y_target = new range1d_1.Range1d({ start: bbox.bottom, end: bbox.top });\r\n        }\r\n        _configure_scales() {\r\n            this._configure_frame_ranges();\r\n            this._x_ranges = this._get_ranges(this.x_range, this.extra_x_ranges);\r\n            this._y_ranges = this._get_ranges(this.y_range, this.extra_y_ranges);\r\n            this._x_scales = this._get_scales(this.in_x_scale, this._x_ranges, this._x_target);\r\n            this._y_scales = this._get_scales(this.in_y_scale, this._y_ranges, this._y_target);\r\n        }\r\n        _update_scales() {\r\n            this._configure_frame_ranges();\r\n            for (const [, scale] of this._x_scales) {\r\n                scale.target_range = this._x_target;\r\n            }\r\n            for (const [, scale] of this._y_scales) {\r\n                scale.target_range = this._y_target;\r\n            }\r\n        }\r\n        _set_geometry(outer, inner) {\r\n            super._set_geometry(outer, inner);\r\n            this._update_scales();\r\n        }\r\n        get x_ranges() {\r\n            return this._x_ranges;\r\n        }\r\n        get y_ranges() {\r\n            return this._y_ranges;\r\n        }\r\n        get x_scales() {\r\n            return this._x_scales;\r\n        }\r\n        get y_scales() {\r\n            return this._y_scales;\r\n        }\r\n        get x_scale() {\r\n            return this._x_scales.get(\"default\");\r\n        }\r\n        get y_scale() {\r\n            return this._y_scales.get(\"default\");\r\n        }\r\n        /** @deprecated */\r\n        get xscales() {\r\n            return object_1.to_object(this.x_scales);\r\n        }\r\n        /** @deprecated */\r\n        get yscales() {\r\n            return object_1.to_object(this.y_scales);\r\n        }\r\n    }\r\n    exports.CartesianFrame = CartesianFrame;\r\n    CartesianFrame.__name__ = \"CartesianFrame\";\r\n}\r\n","/* models\\scales\\categorical_scale.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const scale_1 = require(147) /* ./scale */;\r\n    class CategoricalScale extends scale_1.Scale {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        compute(x) {\r\n            return super._linear_compute(this.source_range.synthetic(x));\r\n        }\r\n        v_compute(xs) {\r\n            return super._linear_v_compute(this.source_range.v_synthetic(xs));\r\n        }\r\n        invert(xprime) {\r\n            return this._linear_invert(xprime);\r\n        }\r\n        v_invert(xprimes) {\r\n            return this._linear_v_invert(xprimes);\r\n        }\r\n    }\r\n    exports.CategoricalScale = CategoricalScale;\r\n    CategoricalScale.__name__ = \"CategoricalScale\";\r\n}\r\n","/* models\\ranges\\data_range1d.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const data_range_1 = require(211) /* ./data_range */;\r\n    const glyph_renderer_1 = require(90) /* ../renderers/glyph_renderer */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const bbox = tslib_1.__importStar(require(79) /* ../../core/util/bbox */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    class DataRange1d extends data_range_1.DataRange {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.have_updated_interactively = false;\r\n        }\r\n        static init_DataRange1d() {\r\n            this.define({\r\n                start: [p.Number],\r\n                end: [p.Number],\r\n                range_padding: [p.Number, 0.1],\r\n                range_padding_units: [p.PaddingUnits, \"percent\"],\r\n                flipped: [p.Boolean, false],\r\n                follow: [p.StartEnd],\r\n                follow_interval: [p.Number],\r\n                default_span: [p.Number, 2],\r\n                only_visible: [p.Boolean, false],\r\n            });\r\n            this.internal({\r\n                scale_hint: [p.String, 'auto'],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._initial_start = this.start;\r\n            this._initial_end = this.end;\r\n            this._initial_range_padding = this.range_padding;\r\n            this._initial_range_padding_units = this.range_padding_units;\r\n            this._initial_follow = this.follow;\r\n            this._initial_follow_interval = this.follow_interval;\r\n            this._initial_default_span = this.default_span;\r\n            this._plot_bounds = new Map();\r\n        }\r\n        get min() {\r\n            return Math.min(this.start, this.end);\r\n        }\r\n        get max() {\r\n            return Math.max(this.start, this.end);\r\n        }\r\n        computed_renderers() {\r\n            // TODO (bev) check that renderers actually configured with this range\r\n            const names = this.names;\r\n            let renderers = this.renderers;\r\n            if (renderers.length == 0) {\r\n                for (const plot of this.plots) {\r\n                    const rs = plot.renderers.filter((r) => r instanceof glyph_renderer_1.GlyphRenderer);\r\n                    renderers = renderers.concat(rs);\r\n                }\r\n            }\r\n            if (names.length > 0)\r\n                renderers = renderers.filter((r) => array_1.includes(names, r.name));\r\n            logging_1.logger.debug(`computed ${renderers.length} renderers for ${this}`);\r\n            for (const renderer of renderers) {\r\n                logging_1.logger.trace(` - ${renderer}`);\r\n            }\r\n            return renderers;\r\n        }\r\n        /*protected*/ _compute_plot_bounds(renderers, bounds) {\r\n            let result = bbox.empty();\r\n            for (const r of renderers) {\r\n                const rect = bounds.get(r);\r\n                if (rect != null && (r.visible || !this.only_visible)) {\r\n                    result = bbox.union(result, rect);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        adjust_bounds_for_aspect(bounds, ratio) {\r\n            const result = bbox.empty();\r\n            let width = bounds.x1 - bounds.x0;\r\n            if (width <= 0) {\r\n                width = 1.0;\r\n            }\r\n            let height = bounds.y1 - bounds.y0;\r\n            if (height <= 0) {\r\n                height = 1.0;\r\n            }\r\n            const xcenter = 0.5 * (bounds.x1 + bounds.x0);\r\n            const ycenter = 0.5 * (bounds.y1 + bounds.y0);\r\n            if (width < ratio * height) {\r\n                width = ratio * height;\r\n            }\r\n            else {\r\n                height = width / ratio;\r\n            }\r\n            result.x1 = xcenter + 0.5 * width;\r\n            result.x0 = xcenter - 0.5 * width;\r\n            result.y1 = ycenter + 0.5 * height;\r\n            result.y0 = ycenter - 0.5 * height;\r\n            return result;\r\n        }\r\n        /*protected*/ _compute_min_max(plot_bounds, dimension) {\r\n            let overall = bbox.empty();\r\n            for (const rect of plot_bounds) {\r\n                overall = bbox.union(overall, rect);\r\n            }\r\n            let min, max;\r\n            if (dimension == 0)\r\n                [min, max] = [overall.x0, overall.x1];\r\n            else\r\n                [min, max] = [overall.y0, overall.y1];\r\n            return [min, max];\r\n        }\r\n        /*protected*/ _compute_range(min, max) {\r\n            const range_padding = this.range_padding; // XXX: ? 0\r\n            let start, end;\r\n            if (this._initial_start != null)\r\n                min = this._initial_start;\r\n            if (this._initial_end != null)\r\n                max = this._initial_end;\r\n            if (this.scale_hint == \"log\") {\r\n                if (isNaN(min) || !isFinite(min) || min <= 0) {\r\n                    if (isNaN(max) || !isFinite(max) || max <= 0)\r\n                        min = 0.1;\r\n                    else\r\n                        min = max / 100;\r\n                    logging_1.logger.warn(`could not determine minimum data value for log axis, DataRange1d using value ${min}`);\r\n                }\r\n                if (isNaN(max) || !isFinite(max) || max <= 0) {\r\n                    if (isNaN(min) || !isFinite(min) || min <= 0)\r\n                        max = 10;\r\n                    else\r\n                        max = min * 100;\r\n                    logging_1.logger.warn(`could not determine maximum data value for log axis, DataRange1d using value ${max}`);\r\n                }\r\n                let center, span;\r\n                if (max == min) {\r\n                    span = this.default_span + 0.001;\r\n                    center = Math.log(min) / Math.log(10);\r\n                }\r\n                else {\r\n                    let log_min, log_max;\r\n                    if (this.range_padding_units == \"percent\") {\r\n                        log_min = Math.log(min) / Math.log(10);\r\n                        log_max = Math.log(max) / Math.log(10);\r\n                        span = (log_max - log_min) * (1 + range_padding);\r\n                    }\r\n                    else {\r\n                        log_min = Math.log(min - range_padding) / Math.log(10);\r\n                        log_max = Math.log(max + range_padding) / Math.log(10);\r\n                        span = log_max - log_min;\r\n                    }\r\n                    center = (log_min + log_max) / 2.0;\r\n                }\r\n                start = 10 ** (center - span / 2.0);\r\n                end = 10 ** (center + span / 2.0);\r\n            }\r\n            else {\r\n                let span;\r\n                if (max == min)\r\n                    span = this.default_span;\r\n                else {\r\n                    if (this.range_padding_units == \"percent\")\r\n                        span = (max - min) * (1 + range_padding);\r\n                    else\r\n                        span = (max - min) + 2 * range_padding;\r\n                }\r\n                const center = (max + min) / 2.0;\r\n                start = center - span / 2.0;\r\n                end = center + span / 2.0;\r\n            }\r\n            let follow_sign = +1;\r\n            if (this.flipped) {\r\n                [start, end] = [end, start];\r\n                follow_sign = -1;\r\n            }\r\n            const follow_interval = this.follow_interval;\r\n            if (follow_interval != null && Math.abs(start - end) > follow_interval) {\r\n                if (this.follow == 'start')\r\n                    end = start + follow_sign * follow_interval;\r\n                else if (this.follow == 'end')\r\n                    start = end - follow_sign * follow_interval;\r\n            }\r\n            return [start, end];\r\n        }\r\n        update(bounds, dimension, plot, ratio) {\r\n            if (this.have_updated_interactively)\r\n                return;\r\n            const renderers = this.computed_renderers();\r\n            // update the raw data bounds for all renderers we care about\r\n            let total_bounds = this._compute_plot_bounds(renderers, bounds);\r\n            if (ratio != null)\r\n                total_bounds = this.adjust_bounds_for_aspect(total_bounds, ratio);\r\n            this._plot_bounds.set(plot, total_bounds);\r\n            // compute the min/mix for our specified dimension\r\n            const [min, max] = this._compute_min_max(this._plot_bounds.values(), dimension);\r\n            // derive start, end from bounds and data range config\r\n            let [start, end] = this._compute_range(min, max);\r\n            if (this._initial_start != null) {\r\n                if (this.scale_hint == \"log\") {\r\n                    if (this._initial_start > 0)\r\n                        start = this._initial_start;\r\n                }\r\n                else\r\n                    start = this._initial_start;\r\n            }\r\n            if (this._initial_end != null) {\r\n                if (this.scale_hint == \"log\") {\r\n                    if (this._initial_end > 0)\r\n                        end = this._initial_end;\r\n                }\r\n                else\r\n                    end = this._initial_end;\r\n            }\r\n            // only trigger updates when there are changes\r\n            const [_start, _end] = [this.start, this.end];\r\n            if (start != _start || end != _end) {\r\n                const new_range = {};\r\n                if (start != _start)\r\n                    new_range.start = start;\r\n                if (end != _end)\r\n                    new_range.end = end;\r\n                this.setv(new_range);\r\n            }\r\n            if (this.bounds == 'auto')\r\n                this.setv({ bounds: [start, end] }, { silent: true });\r\n            this.change.emit();\r\n        }\r\n        reset() {\r\n            this.have_updated_interactively = false;\r\n            // change events silenced as PlotView.update_dataranges triggers property callbacks\r\n            this.setv({\r\n                range_padding: this._initial_range_padding,\r\n                range_padding_units: this._initial_range_padding_units,\r\n                follow: this._initial_follow,\r\n                follow_interval: this._initial_follow_interval,\r\n                default_span: this._initial_default_span,\r\n            }, { silent: true });\r\n            this.change.emit();\r\n        }\r\n    }\r\n    exports.DataRange1d = DataRange1d;\r\n    DataRange1d.__name__ = \"DataRange1d\";\r\n    DataRange1d.init_DataRange1d();\r\n}\r\n","/* models\\ranges\\data_range.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const range_1 = require(99) /* ./range */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class DataRange extends range_1.Range {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_DataRange() {\r\n            this.define({\r\n                names: [p.Array, []],\r\n                renderers: [p.Array, []],\r\n            });\r\n        }\r\n    }\r\n    exports.DataRange = DataRange;\r\n    DataRange.__name__ = \"DataRange\";\r\n    DataRange.init_DataRange();\r\n}\r\n","/* core\\layout\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var types_1 = require(213) /* ./types */;\r\n    exports.Sizeable = types_1.Sizeable;\r\n    exports.SizingPolicy = types_1.SizingPolicy;\r\n    var layoutable_1 = require(214) /* ./layoutable */;\r\n    exports.Layoutable = layoutable_1.Layoutable;\r\n    exports.LayoutItem = layoutable_1.LayoutItem;\r\n    var alignments_1 = require(215) /* ./alignments */;\r\n    exports.HStack = alignments_1.HStack;\r\n    exports.VStack = alignments_1.VStack;\r\n    exports.AnchorLayout = alignments_1.AnchorLayout;\r\n    var grid_1 = require(216) /* ./grid */;\r\n    exports.Grid = grid_1.Grid;\r\n    exports.Row = grid_1.Row;\r\n    exports.Column = grid_1.Column;\r\n    var html_1 = require(217) /* ./html */;\r\n    exports.ContentBox = html_1.ContentBox;\r\n    exports.VariadicBox = html_1.VariadicBox;\r\n}\r\n","/* core\\layout\\types.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const kinds_1 = require(21) /* ../kinds */;\r\n    const { min, max } = Math;\r\n    class Sizeable {\r\n        constructor(size = {}) {\r\n            this.width = size.width != null ? size.width : 0;\r\n            this.height = size.height != null ? size.height : 0;\r\n        }\r\n        bounded_to({ width, height }) {\r\n            return new Sizeable({\r\n                width: this.width == Infinity && width != null ? width : this.width,\r\n                height: this.height == Infinity && height != null ? height : this.height,\r\n            });\r\n        }\r\n        expanded_to({ width, height }) {\r\n            return new Sizeable({\r\n                width: width != Infinity ? max(this.width, width) : this.width,\r\n                height: height != Infinity ? max(this.height, height) : this.height,\r\n            });\r\n        }\r\n        expand_to({ width, height }) {\r\n            this.width = max(this.width, width);\r\n            this.height = max(this.height, height);\r\n        }\r\n        narrowed_to({ width, height }) {\r\n            return new Sizeable({\r\n                width: min(this.width, width),\r\n                height: min(this.height, height),\r\n            });\r\n        }\r\n        narrow_to({ width, height }) {\r\n            this.width = min(this.width, width);\r\n            this.height = min(this.height, height);\r\n        }\r\n        grow_by({ left, right, top, bottom }) {\r\n            const width = this.width + left + right;\r\n            const height = this.height + top + bottom;\r\n            return new Sizeable({ width, height });\r\n        }\r\n        shrink_by({ left, right, top, bottom }) {\r\n            const width = max(this.width - left - right, 0);\r\n            const height = max(this.height - top - bottom, 0);\r\n            return new Sizeable({ width, height });\r\n        }\r\n        map(w_fn, h_fn) {\r\n            return new Sizeable({\r\n                width: w_fn(this.width),\r\n                height: (h_fn != null ? h_fn : w_fn)(this.height),\r\n            });\r\n        }\r\n    }\r\n    exports.Sizeable = Sizeable;\r\n    Sizeable.__name__ = \"Sizeable\";\r\n    exports.SizingPolicy = kinds_1.Enum(\"fixed\", \"fit\", \"min\", \"max\");\r\n}\r\n","/* core\\layout\\layoutable.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(213) /* ./types */;\r\n    const bbox_1 = require(79) /* ../util/bbox */;\r\n    const { min, max, round } = Math;\r\n    class Layoutable {\r\n        constructor() {\r\n            this._bbox = new bbox_1.BBox();\r\n            this._inner_bbox = new bbox_1.BBox();\r\n        }\r\n        get bbox() {\r\n            return this._bbox;\r\n        }\r\n        get inner_bbox() {\r\n            return this._inner_bbox;\r\n        }\r\n        get sizing() {\r\n            return this._sizing;\r\n        }\r\n        set_sizing(sizing) {\r\n            const width_policy = sizing.width_policy || \"fit\";\r\n            const width = sizing.width;\r\n            const min_width = sizing.min_width != null ? sizing.min_width : 0;\r\n            const max_width = sizing.max_width != null ? sizing.max_width : Infinity;\r\n            const height_policy = sizing.height_policy || \"fit\";\r\n            const height = sizing.height;\r\n            const min_height = sizing.min_height != null ? sizing.min_height : 0;\r\n            const max_height = sizing.max_height != null ? sizing.max_height : Infinity;\r\n            const aspect = sizing.aspect;\r\n            const margin = sizing.margin || { top: 0, right: 0, bottom: 0, left: 0 };\r\n            const visible = sizing.visible !== false;\r\n            const halign = sizing.halign || \"start\";\r\n            const valign = sizing.valign || \"start\";\r\n            this._sizing = {\r\n                width_policy, min_width, width, max_width,\r\n                height_policy, min_height, height, max_height,\r\n                aspect,\r\n                margin,\r\n                visible,\r\n                halign,\r\n                valign,\r\n                size: { width, height },\r\n                min_size: { width: min_width, height: min_height },\r\n                max_size: { width: max_width, height: max_height },\r\n            };\r\n            this._init();\r\n        }\r\n        _init() { }\r\n        _set_geometry(outer, inner) {\r\n            this._bbox = outer;\r\n            this._inner_bbox = inner;\r\n        }\r\n        set_geometry(outer, inner) {\r\n            this._set_geometry(outer, inner || outer);\r\n        }\r\n        is_width_expanding() {\r\n            return this.sizing.width_policy == \"max\";\r\n        }\r\n        is_height_expanding() {\r\n            return this.sizing.height_policy == \"max\";\r\n        }\r\n        apply_aspect(viewport, { width, height }) {\r\n            const { aspect } = this.sizing;\r\n            if (aspect != null) {\r\n                const { width_policy, height_policy } = this.sizing;\r\n                const gt = (width, height) => {\r\n                    const policies = { max: 4, fit: 3, min: 2, fixed: 1 };\r\n                    return policies[width] > policies[height];\r\n                };\r\n                if (width_policy != \"fixed\" && height_policy != \"fixed\") {\r\n                    if (width_policy == height_policy) {\r\n                        const w_width = width;\r\n                        const w_height = round(width / aspect);\r\n                        const h_width = round(height * aspect);\r\n                        const h_height = height;\r\n                        const w_diff = Math.abs(viewport.width - w_width) + Math.abs(viewport.height - w_height);\r\n                        const h_diff = Math.abs(viewport.width - h_width) + Math.abs(viewport.height - h_height);\r\n                        if (w_diff <= h_diff) {\r\n                            width = w_width;\r\n                            height = w_height;\r\n                        }\r\n                        else {\r\n                            width = h_width;\r\n                            height = h_height;\r\n                        }\r\n                    }\r\n                    else if (gt(width_policy, height_policy)) {\r\n                        height = round(width / aspect);\r\n                    }\r\n                    else {\r\n                        width = round(height * aspect);\r\n                    }\r\n                }\r\n                else if (width_policy == \"fixed\") {\r\n                    height = round(width / aspect);\r\n                }\r\n                else if (height_policy == \"fixed\") {\r\n                    width = round(height * aspect);\r\n                }\r\n            }\r\n            return { width, height };\r\n        }\r\n        measure(viewport_size) {\r\n            if (!this.sizing.visible)\r\n                return { width: 0, height: 0 };\r\n            const exact_width = (width) => {\r\n                return this.sizing.width_policy == \"fixed\" && this.sizing.width != null ? this.sizing.width : width;\r\n            };\r\n            const exact_height = (height) => {\r\n                return this.sizing.height_policy == \"fixed\" && this.sizing.height != null ? this.sizing.height : height;\r\n            };\r\n            const viewport = new types_1.Sizeable(viewport_size)\r\n                .shrink_by(this.sizing.margin)\r\n                .map(exact_width, exact_height);\r\n            const computed = this._measure(viewport);\r\n            const clipped = this.clip_size(computed);\r\n            const width = exact_width(clipped.width);\r\n            const height = exact_height(clipped.height);\r\n            const size = this.apply_aspect(viewport, { width, height });\r\n            return Object.assign(Object.assign({}, computed), size);\r\n        }\r\n        compute(viewport = {}) {\r\n            const size_hint = this.measure({\r\n                width: viewport.width != null && this.is_width_expanding() ? viewport.width : Infinity,\r\n                height: viewport.height != null && this.is_height_expanding() ? viewport.height : Infinity,\r\n            });\r\n            const { width, height } = size_hint;\r\n            const outer = new bbox_1.BBox({ left: 0, top: 0, width, height });\r\n            let inner = undefined;\r\n            if (size_hint.inner != null) {\r\n                const { left, top, right, bottom } = size_hint.inner;\r\n                inner = new bbox_1.BBox({ left, top, right: width - right, bottom: height - bottom });\r\n            }\r\n            this.set_geometry(outer, inner);\r\n        }\r\n        get xview() {\r\n            return this.bbox.xview;\r\n        }\r\n        get yview() {\r\n            return this.bbox.yview;\r\n        }\r\n        clip_width(width) {\r\n            return max(this.sizing.min_width, min(width, this.sizing.max_width));\r\n        }\r\n        clip_height(height) {\r\n            return max(this.sizing.min_height, min(height, this.sizing.max_height));\r\n        }\r\n        clip_size({ width, height }) {\r\n            return {\r\n                width: this.clip_width(width),\r\n                height: this.clip_height(height),\r\n            };\r\n        }\r\n    }\r\n    exports.Layoutable = Layoutable;\r\n    Layoutable.__name__ = \"Layoutable\";\r\n    class LayoutItem extends Layoutable {\r\n        /*\r\n        constructor(readonly measure_fn: (viewport: Size) => Size) {\r\n          super()\r\n        }\r\n        protected _measure(viewport: Size): SizeHint {\r\n          return this.measure_fn(viewport)\r\n        }\r\n        protected _measure(viewport: Size): SizeHint {\r\n          return {\r\n            width: viewport.width != Infinity ? viewport.width : this.sizing.min_width,\r\n            height: viewport.height != Infinity ? viewport.height : this.sizing.min_width,\r\n          }\r\n        }\r\n        */\r\n        _measure(viewport) {\r\n            const { width_policy, height_policy } = this.sizing;\r\n            let width;\r\n            if (viewport.width == Infinity) {\r\n                width = this.sizing.width != null ? this.sizing.width : 0;\r\n            }\r\n            else {\r\n                switch (width_policy) {\r\n                    case \"fixed\": {\r\n                        width = this.sizing.width != null ? this.sizing.width : 0;\r\n                        break;\r\n                    }\r\n                    case \"min\": {\r\n                        width = this.sizing.width != null ? min(viewport.width, this.sizing.width) : 0;\r\n                        break;\r\n                    }\r\n                    case \"fit\": {\r\n                        width = this.sizing.width != null ? min(viewport.width, this.sizing.width) : viewport.width;\r\n                        break;\r\n                    }\r\n                    case \"max\": {\r\n                        width = this.sizing.width != null ? max(viewport.width, this.sizing.width) : viewport.width;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            let height;\r\n            if (viewport.height == Infinity) {\r\n                height = this.sizing.height != null ? this.sizing.height : 0;\r\n            }\r\n            else {\r\n                switch (height_policy) {\r\n                    case \"fixed\": {\r\n                        height = this.sizing.height != null ? this.sizing.height : 0;\r\n                        break;\r\n                    }\r\n                    case \"min\": {\r\n                        height = this.sizing.height != null ? min(viewport.height, this.sizing.height) : 0;\r\n                        break;\r\n                    }\r\n                    case \"fit\": {\r\n                        height = this.sizing.height != null ? min(viewport.height, this.sizing.height) : viewport.height;\r\n                        break;\r\n                    }\r\n                    case \"max\": {\r\n                        height = this.sizing.height != null ? max(viewport.height, this.sizing.height) : viewport.height;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return { width, height };\r\n        }\r\n    }\r\n    exports.LayoutItem = LayoutItem;\r\n    LayoutItem.__name__ = \"LayoutItem\";\r\n    class ContentLayoutable extends Layoutable {\r\n        _measure(viewport) {\r\n            const content_size = this._content_size();\r\n            const bounds = viewport\r\n                .bounded_to(this.sizing.size)\r\n                .bounded_to(content_size);\r\n            const width = (() => {\r\n                switch (this.sizing.width_policy) {\r\n                    case \"fixed\":\r\n                        return this.sizing.width != null ? this.sizing.width : content_size.width;\r\n                    case \"min\":\r\n                        return content_size.width;\r\n                    case \"fit\":\r\n                        return bounds.width;\r\n                    case \"max\":\r\n                        return Math.max(content_size.width, bounds.width);\r\n                }\r\n            })();\r\n            const height = (() => {\r\n                switch (this.sizing.height_policy) {\r\n                    case \"fixed\":\r\n                        return this.sizing.height != null ? this.sizing.height : content_size.height;\r\n                    case \"min\":\r\n                        return content_size.height;\r\n                    case \"fit\":\r\n                        return bounds.height;\r\n                    case \"max\":\r\n                        return Math.max(content_size.height, bounds.height);\r\n                }\r\n            })();\r\n            return { width, height };\r\n        }\r\n    }\r\n    exports.ContentLayoutable = ContentLayoutable;\r\n    ContentLayoutable.__name__ = \"ContentLayoutable\";\r\n}\r\n","/* core\\layout\\alignments.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const layoutable_1 = require(214) /* ./layoutable */;\r\n    const bbox_1 = require(79) /* ../util/bbox */;\r\n    class Stack extends layoutable_1.Layoutable {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.children = [];\r\n        }\r\n    }\r\n    exports.Stack = Stack;\r\n    Stack.__name__ = \"Stack\";\r\n    class HStack extends Stack {\r\n        _measure(_viewport) {\r\n            let width = 0;\r\n            let height = 0;\r\n            for (const child of this.children) {\r\n                const size_hint = child.measure({ width: 0, height: 0 });\r\n                width += size_hint.width;\r\n                height = Math.max(height, size_hint.height);\r\n            }\r\n            return { width, height };\r\n        }\r\n        _set_geometry(outer, inner) {\r\n            super._set_geometry(outer, inner);\r\n            const { top, bottom } = outer;\r\n            let { left } = outer;\r\n            for (const child of this.children) {\r\n                const { width } = child.measure({ width: 0, height: 0 });\r\n                child.set_geometry(new bbox_1.BBox({ left, width, top, bottom }));\r\n                left += width;\r\n            }\r\n        }\r\n    }\r\n    exports.HStack = HStack;\r\n    HStack.__name__ = \"HStack\";\r\n    class VStack extends Stack {\r\n        _measure(_viewport) {\r\n            let width = 0;\r\n            let height = 0;\r\n            for (const child of this.children) {\r\n                const size_hint = child.measure({ width: 0, height: 0 });\r\n                width = Math.max(width, size_hint.width);\r\n                height += size_hint.height;\r\n            }\r\n            return { width, height };\r\n        }\r\n        _set_geometry(outer, inner) {\r\n            super._set_geometry(outer, inner);\r\n            const { left, right } = outer;\r\n            let { top } = outer;\r\n            for (const child of this.children) {\r\n                const { height } = child.measure({ width: 0, height: 0 });\r\n                child.set_geometry(new bbox_1.BBox({ top, height, left, right }));\r\n                top += height;\r\n            }\r\n        }\r\n    }\r\n    exports.VStack = VStack;\r\n    VStack.__name__ = \"VStack\";\r\n    class AnchorLayout extends layoutable_1.Layoutable {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.children = [];\r\n        }\r\n        _measure(viewport) {\r\n            let width = 0;\r\n            let height = 0;\r\n            for (const { layout } of this.children) {\r\n                const size_hint = layout.measure(viewport);\r\n                width = Math.max(width, size_hint.width);\r\n                height = Math.max(height, size_hint.height);\r\n            }\r\n            return { width, height };\r\n        }\r\n        _set_geometry(outer, inner) {\r\n            super._set_geometry(outer, inner);\r\n            for (const { layout, anchor, margin } of this.children) {\r\n                const { left, right, top, bottom, hcenter, vcenter } = outer;\r\n                const { width, height } = layout.measure(outer);\r\n                let bbox;\r\n                switch (anchor) {\r\n                    case 'top_left':\r\n                        bbox = new bbox_1.BBox({ left: left + margin, top: top + margin, width, height });\r\n                        break;\r\n                    case 'top_center':\r\n                        bbox = new bbox_1.BBox({ hcenter, top: top + margin, width, height });\r\n                        break;\r\n                    case 'top_right':\r\n                        bbox = new bbox_1.BBox({ right: right - margin, top: top + margin, width, height });\r\n                        break;\r\n                    case 'bottom_right':\r\n                        bbox = new bbox_1.BBox({ right: right - margin, bottom: bottom - margin, width, height });\r\n                        break;\r\n                    case 'bottom_center':\r\n                        bbox = new bbox_1.BBox({ hcenter, bottom: bottom - margin, width, height });\r\n                        break;\r\n                    case 'bottom_left':\r\n                        bbox = new bbox_1.BBox({ left: left + margin, bottom: bottom - margin, width, height });\r\n                        break;\r\n                    case 'center_left':\r\n                        bbox = new bbox_1.BBox({ left: left + margin, vcenter, width, height });\r\n                        break;\r\n                    case 'center':\r\n                        bbox = new bbox_1.BBox({ hcenter, vcenter, width, height });\r\n                        break;\r\n                    case 'center_right':\r\n                        bbox = new bbox_1.BBox({ right: right - margin, vcenter, width, height });\r\n                        break;\r\n                }\r\n                layout.set_geometry(bbox);\r\n            }\r\n        }\r\n    }\r\n    exports.AnchorLayout = AnchorLayout;\r\n    AnchorLayout.__name__ = \"AnchorLayout\";\r\n}\r\n","/* core\\layout\\grid.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(213) /* ./types */;\r\n    const layoutable_1 = require(214) /* ./layoutable */;\r\n    const types_2 = require(8) /* ../util/types */;\r\n    const bbox_1 = require(79) /* ../util/bbox */;\r\n    const array_1 = require(9) /* ../util/array */;\r\n    const { max, round } = Math;\r\n    class DefaultMap {\r\n        constructor(def) {\r\n            this.def = def;\r\n            this._map = new Map();\r\n        }\r\n        get(key) {\r\n            let value = this._map.get(key);\r\n            if (value === undefined) {\r\n                value = this.def();\r\n                this._map.set(key, value);\r\n            }\r\n            return value;\r\n        }\r\n        apply(key, fn) {\r\n            const value = this.get(key);\r\n            this._map.set(key, fn(value));\r\n        }\r\n    }\r\n    DefaultMap.__name__ = \"DefaultMap\";\r\n    class Container {\r\n        constructor() {\r\n            this._items = [];\r\n            this._nrows = 0;\r\n            this._ncols = 0;\r\n        }\r\n        get nrows() {\r\n            return this._nrows;\r\n        }\r\n        get ncols() {\r\n            return this._ncols;\r\n        }\r\n        add(span, data) {\r\n            const { r1, c1 } = span;\r\n            this._nrows = max(this._nrows, r1 + 1);\r\n            this._ncols = max(this._ncols, c1 + 1);\r\n            this._items.push({ span, data });\r\n        }\r\n        at(r, c) {\r\n            const selected = this._items.filter(({ span }) => {\r\n                return span.r0 <= r && r <= span.r1 &&\r\n                    span.c0 <= c && c <= span.c1;\r\n            });\r\n            return selected.map(({ data }) => data);\r\n        }\r\n        row(r) {\r\n            const selected = this._items.filter(({ span }) => span.r0 <= r && r <= span.r1);\r\n            return selected.map(({ data }) => data);\r\n        }\r\n        col(c) {\r\n            const selected = this._items.filter(({ span }) => span.c0 <= c && c <= span.c1);\r\n            return selected.map(({ data }) => data);\r\n        }\r\n        foreach(fn) {\r\n            for (const { span, data } of this._items) {\r\n                fn(span, data);\r\n            }\r\n        }\r\n        map(fn) {\r\n            const result = new Container();\r\n            for (const { span, data } of this._items) {\r\n                result.add(span, fn(span, data));\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    Container.__name__ = \"Container\";\r\n    class Grid extends layoutable_1.Layoutable {\r\n        constructor(items = []) {\r\n            super();\r\n            this.items = items;\r\n            this.rows = \"auto\";\r\n            this.cols = \"auto\";\r\n            this.spacing = 0;\r\n            this.absolute = false;\r\n        }\r\n        is_width_expanding() {\r\n            if (super.is_width_expanding())\r\n                return true;\r\n            if (this.sizing.width_policy == \"fixed\")\r\n                return false;\r\n            const { cols } = this._state;\r\n            return array_1.some(cols, (col) => col.policy == \"max\");\r\n        }\r\n        is_height_expanding() {\r\n            if (super.is_height_expanding())\r\n                return true;\r\n            if (this.sizing.height_policy == \"fixed\")\r\n                return false;\r\n            const { rows } = this._state;\r\n            return array_1.some(rows, (row) => row.policy == \"max\");\r\n        }\r\n        _init() {\r\n            super._init();\r\n            const items = new Container();\r\n            for (const { layout, row, col, row_span, col_span } of this.items) {\r\n                if (layout.sizing.visible) {\r\n                    const r0 = row;\r\n                    const c0 = col;\r\n                    const r1 = row + (row_span != null ? row_span : 1) - 1;\r\n                    const c1 = col + (col_span != null ? col_span : 1) - 1;\r\n                    items.add({ r0, c0, r1, c1 }, layout);\r\n                }\r\n            }\r\n            const { nrows, ncols } = items;\r\n            const rows = new Array(nrows);\r\n            for (let y = 0; y < nrows; y++) {\r\n                const row = (() => {\r\n                    const sizing = types_2.isPlainObject(this.rows) ? this.rows[y] || this.rows[\"*\"] : this.rows;\r\n                    if (sizing == null)\r\n                        return { policy: \"auto\" };\r\n                    else if (types_2.isNumber(sizing))\r\n                        return { policy: \"fixed\", height: sizing };\r\n                    else if (types_2.isString(sizing))\r\n                        return { policy: sizing };\r\n                    else\r\n                        return sizing;\r\n                })();\r\n                const align = row.align || \"auto\";\r\n                if (row.policy == \"fixed\")\r\n                    rows[y] = { policy: \"fixed\", height: row.height, align };\r\n                else if (row.policy == \"min\")\r\n                    rows[y] = { policy: \"min\", align };\r\n                else if (row.policy == \"fit\" || row.policy == \"max\")\r\n                    rows[y] = { policy: row.policy, flex: row.flex || 1, align };\r\n                else if (row.policy == \"auto\") {\r\n                    if (array_1.some(items.row(y), (layout) => layout.is_height_expanding()))\r\n                        rows[y] = { policy: \"max\", flex: 1, align };\r\n                    else\r\n                        rows[y] = { policy: \"min\", align };\r\n                }\r\n                else\r\n                    throw new Error(\"unrechable\");\r\n            }\r\n            const cols = new Array(ncols);\r\n            for (let x = 0; x < ncols; x++) {\r\n                const col = (() => {\r\n                    const sizing = types_2.isPlainObject(this.cols) ? this.cols[x] || this.cols[\"*\"] : this.cols;\r\n                    if (sizing == null)\r\n                        return { policy: \"auto\" };\r\n                    else if (types_2.isNumber(sizing))\r\n                        return { policy: \"fixed\", width: sizing };\r\n                    else if (types_2.isString(sizing))\r\n                        return { policy: sizing };\r\n                    else\r\n                        return sizing;\r\n                })();\r\n                const align = col.align || \"auto\";\r\n                if (col.policy == \"fixed\")\r\n                    cols[x] = { policy: \"fixed\", width: col.width, align };\r\n                else if (col.policy == \"min\")\r\n                    cols[x] = { policy: \"min\", align };\r\n                else if (col.policy == \"fit\" || col.policy == \"max\")\r\n                    cols[x] = { policy: col.policy, flex: col.flex || 1, align };\r\n                else if (col.policy == \"auto\") {\r\n                    if (array_1.some(items.col(x), (layout) => layout.is_width_expanding()))\r\n                        cols[x] = { policy: \"max\", flex: 1, align };\r\n                    else\r\n                        cols[x] = { policy: \"min\", align };\r\n                }\r\n                else\r\n                    throw new Error(\"unrechable\");\r\n            }\r\n            const [rspacing, cspacing] = types_2.isNumber(this.spacing) ? [this.spacing, this.spacing] : this.spacing;\r\n            this._state = { items, nrows, ncols, rows, cols, rspacing, cspacing };\r\n        }\r\n        _measure_totals(row_heights, col_widths) {\r\n            const { nrows, ncols, rspacing, cspacing } = this._state;\r\n            return {\r\n                height: array_1.sum(row_heights) + (nrows - 1) * rspacing,\r\n                width: array_1.sum(col_widths) + (ncols - 1) * cspacing,\r\n            };\r\n        }\r\n        _measure_cells(cell_viewport) {\r\n            const { items, nrows, ncols, rows, cols, rspacing, cspacing } = this._state;\r\n            const row_heights = new Array(nrows);\r\n            for (let r = 0; r < nrows; r++) {\r\n                const row = rows[r];\r\n                row_heights[r] = row.policy == \"fixed\" ? row.height : 0;\r\n            }\r\n            const col_widths = new Array(ncols);\r\n            for (let c = 0; c < ncols; c++) {\r\n                const col = cols[c];\r\n                col_widths[c] = col.policy == \"fixed\" ? col.width : 0;\r\n            }\r\n            const size_hints = new Container();\r\n            items.foreach((span, layout) => {\r\n                const { r0, c0, r1, c1 } = span;\r\n                const rspace = (r1 - r0) * rspacing;\r\n                const cspace = (c1 - c0) * cspacing;\r\n                let height = 0;\r\n                for (let r = r0; r <= r1; r++) {\r\n                    height += cell_viewport(r, c0).height;\r\n                }\r\n                height += rspace;\r\n                let width = 0;\r\n                for (let c = c0; c <= c1; c++) {\r\n                    width += cell_viewport(r0, c).width;\r\n                }\r\n                width += cspace;\r\n                const size_hint = layout.measure({ width, height });\r\n                size_hints.add(span, { layout, size_hint });\r\n                const size = new types_1.Sizeable(size_hint).grow_by(layout.sizing.margin);\r\n                size.height -= rspace;\r\n                size.width -= cspace;\r\n                const radjustable = [];\r\n                for (let r = r0; r <= r1; r++) {\r\n                    const row = rows[r];\r\n                    if (row.policy == \"fixed\")\r\n                        size.height -= row.height;\r\n                    else\r\n                        radjustable.push(r);\r\n                }\r\n                if (size.height > 0) {\r\n                    const rheight = round(size.height / radjustable.length);\r\n                    for (const r of radjustable) {\r\n                        row_heights[r] = max(row_heights[r], rheight);\r\n                    }\r\n                }\r\n                const cadjustable = [];\r\n                for (let c = c0; c <= c1; c++) {\r\n                    const col = cols[c];\r\n                    if (col.policy == \"fixed\")\r\n                        size.width -= col.width;\r\n                    else\r\n                        cadjustable.push(c);\r\n                }\r\n                if (size.width > 0) {\r\n                    const cwidth = round(size.width / cadjustable.length);\r\n                    for (const c of cadjustable) {\r\n                        col_widths[c] = max(col_widths[c], cwidth);\r\n                    }\r\n                }\r\n            });\r\n            const size = this._measure_totals(row_heights, col_widths);\r\n            return { size, row_heights, col_widths, size_hints };\r\n        }\r\n        _measure_grid(viewport) {\r\n            const { nrows, ncols, rows, cols, rspacing, cspacing } = this._state;\r\n            const preferred = this._measure_cells((y, x) => {\r\n                const row = rows[y];\r\n                const col = cols[x];\r\n                return {\r\n                    width: col.policy == \"fixed\" ? col.width : Infinity,\r\n                    height: row.policy == \"fixed\" ? row.height : Infinity,\r\n                };\r\n            });\r\n            let available_height;\r\n            if (this.sizing.height_policy == \"fixed\" && this.sizing.height != null)\r\n                available_height = this.sizing.height;\r\n            else if (viewport.height != Infinity && this.is_height_expanding())\r\n                available_height = viewport.height;\r\n            else\r\n                available_height = preferred.size.height;\r\n            let height_flex = 0;\r\n            for (let y = 0; y < nrows; y++) {\r\n                const row = rows[y];\r\n                if (row.policy == \"fit\" || row.policy == \"max\")\r\n                    height_flex += row.flex;\r\n                else\r\n                    available_height -= preferred.row_heights[y];\r\n            }\r\n            available_height -= (nrows - 1) * rspacing;\r\n            if (height_flex != 0 && available_height > 0) {\r\n                for (let y = 0; y < nrows; y++) {\r\n                    const row = rows[y];\r\n                    if (row.policy == \"fit\" || row.policy == \"max\") {\r\n                        const height = round(available_height * (row.flex / height_flex));\r\n                        available_height -= height;\r\n                        preferred.row_heights[y] = height;\r\n                        height_flex -= row.flex;\r\n                    }\r\n                }\r\n            }\r\n            else if (available_height < 0) {\r\n                let nadjustable = 0;\r\n                for (let y = 0; y < nrows; y++) {\r\n                    const row = rows[y];\r\n                    if (row.policy != \"fixed\")\r\n                        nadjustable++;\r\n                }\r\n                let overflow_height = -available_height;\r\n                for (let y = 0; y < nrows; y++) {\r\n                    const row = rows[y];\r\n                    if (row.policy != \"fixed\") {\r\n                        const height = preferred.row_heights[y];\r\n                        const cutoff = round(overflow_height / nadjustable);\r\n                        preferred.row_heights[y] = max(height - cutoff, 0);\r\n                        overflow_height -= cutoff > height ? height : cutoff;\r\n                        nadjustable--;\r\n                    }\r\n                }\r\n            }\r\n            let available_width;\r\n            if (this.sizing.width_policy == \"fixed\" && this.sizing.width != null)\r\n                available_width = this.sizing.width;\r\n            else if (viewport.width != Infinity && this.is_width_expanding())\r\n                available_width = viewport.width;\r\n            else\r\n                available_width = preferred.size.width;\r\n            let width_flex = 0;\r\n            for (let x = 0; x < ncols; x++) {\r\n                const col = cols[x];\r\n                if (col.policy == \"fit\" || col.policy == \"max\")\r\n                    width_flex += col.flex;\r\n                else\r\n                    available_width -= preferred.col_widths[x];\r\n            }\r\n            available_width -= (ncols - 1) * cspacing;\r\n            if (width_flex != 0 && available_width > 0) {\r\n                for (let x = 0; x < ncols; x++) {\r\n                    const col = cols[x];\r\n                    if (col.policy == \"fit\" || col.policy == \"max\") {\r\n                        const width = round(available_width * (col.flex / width_flex));\r\n                        available_width -= width;\r\n                        preferred.col_widths[x] = width;\r\n                        width_flex -= col.flex;\r\n                    }\r\n                }\r\n            }\r\n            else if (available_width < 0) {\r\n                let nadjustable = 0;\r\n                for (let x = 0; x < ncols; x++) {\r\n                    const col = cols[x];\r\n                    if (col.policy != \"fixed\")\r\n                        nadjustable++;\r\n                }\r\n                let overflow_width = -available_width;\r\n                for (let x = 0; x < ncols; x++) {\r\n                    const col = cols[x];\r\n                    if (col.policy != \"fixed\") {\r\n                        const width = preferred.col_widths[x];\r\n                        const cutoff = round(overflow_width / nadjustable);\r\n                        preferred.col_widths[x] = max(width - cutoff, 0);\r\n                        overflow_width -= cutoff > width ? width : cutoff;\r\n                        nadjustable--;\r\n                    }\r\n                }\r\n            }\r\n            const { row_heights, col_widths, size_hints } = this._measure_cells((y, x) => {\r\n                return {\r\n                    width: preferred.col_widths[x],\r\n                    height: preferred.row_heights[y],\r\n                };\r\n            });\r\n            const size = this._measure_totals(row_heights, col_widths);\r\n            return { size, row_heights, col_widths, size_hints };\r\n        }\r\n        _measure(viewport) {\r\n            const { size } = this._measure_grid(viewport);\r\n            return size;\r\n        }\r\n        _set_geometry(outer, inner) {\r\n            super._set_geometry(outer, inner);\r\n            const { nrows, ncols, rspacing, cspacing } = this._state;\r\n            const { row_heights, col_widths, size_hints } = this._measure_grid(outer);\r\n            const rows = this._state.rows.map((row, r) => {\r\n                return Object.assign(Object.assign({}, row), { top: 0, height: row_heights[r], get bottom() { return this.top + this.height; } });\r\n            });\r\n            const cols = this._state.cols.map((col, c) => {\r\n                return Object.assign(Object.assign({}, col), { left: 0, width: col_widths[c], get right() { return this.left + this.width; } });\r\n            });\r\n            const items = size_hints.map((_, item) => {\r\n                return Object.assign(Object.assign({}, item), { outer: new bbox_1.BBox(), inner: new bbox_1.BBox() });\r\n            });\r\n            for (let r = 0, top = !this.absolute ? 0 : outer.top; r < nrows; r++) {\r\n                const row = rows[r];\r\n                row.top = top;\r\n                top += row.height + rspacing;\r\n            }\r\n            for (let c = 0, left = !this.absolute ? 0 : outer.left; c < ncols; c++) {\r\n                const col = cols[c];\r\n                col.left = left;\r\n                left += col.width + cspacing;\r\n            }\r\n            function span_width(c0, c1) {\r\n                let width = (c1 - c0) * cspacing;\r\n                for (let c = c0; c <= c1; c++) {\r\n                    width += cols[c].width;\r\n                }\r\n                return width;\r\n            }\r\n            function span_height(r0, r1) {\r\n                let height = (r1 - r0) * rspacing;\r\n                for (let r = r0; r <= r1; r++) {\r\n                    height += rows[r].height;\r\n                }\r\n                return height;\r\n            }\r\n            items.foreach(({ r0, c0, r1, c1 }, item) => {\r\n                const { layout, size_hint } = item;\r\n                const { sizing } = layout;\r\n                const { width, height } = size_hint;\r\n                const span = {\r\n                    width: span_width(c0, c1),\r\n                    height: span_height(r0, r1),\r\n                };\r\n                const halign = c0 == c1 && cols[c0].align != \"auto\" ? cols[c0].align : sizing.halign;\r\n                const valign = r0 == r1 && rows[r0].align != \"auto\" ? rows[r0].align : sizing.valign;\r\n                let left = cols[c0].left;\r\n                if (halign == \"start\")\r\n                    left += sizing.margin.left;\r\n                else if (halign == \"center\")\r\n                    left += round((span.width - width) / 2);\r\n                else if (halign == \"end\")\r\n                    left += span.width - sizing.margin.right - width;\r\n                let top = rows[r0].top;\r\n                if (valign == \"start\")\r\n                    top += sizing.margin.top;\r\n                else if (valign == \"center\")\r\n                    top += round((span.height - height) / 2);\r\n                else if (valign == \"end\")\r\n                    top += span.height - sizing.margin.bottom - height;\r\n                item.outer = new bbox_1.BBox({ left, top, width, height });\r\n            });\r\n            const row_aligns = rows.map(() => {\r\n                return {\r\n                    start: new DefaultMap(() => 0),\r\n                    end: new DefaultMap(() => 0),\r\n                };\r\n            });\r\n            const col_aligns = cols.map(() => {\r\n                return {\r\n                    start: new DefaultMap(() => 0),\r\n                    end: new DefaultMap(() => 0),\r\n                };\r\n            });\r\n            items.foreach(({ r0, c0, r1, c1 }, { size_hint, outer }) => {\r\n                const { inner } = size_hint;\r\n                if (inner != null) {\r\n                    row_aligns[r0].start.apply(outer.top, (v) => max(v, inner.top));\r\n                    row_aligns[r1].end.apply(rows[r1].bottom - outer.bottom, (v) => max(v, inner.bottom));\r\n                    col_aligns[c0].start.apply(outer.left, (v) => max(v, inner.left));\r\n                    col_aligns[c1].end.apply(cols[c1].right - outer.right, (v) => max(v, inner.right));\r\n                }\r\n            });\r\n            items.foreach(({ r0, c0, r1, c1 }, item) => {\r\n                const { size_hint, outer } = item;\r\n                function inner_bbox({ left, right, top, bottom }) {\r\n                    const width = outer.width - left - right;\r\n                    const height = outer.height - top - bottom;\r\n                    return new bbox_1.BBox({ left, top, width, height });\r\n                }\r\n                if (size_hint.inner != null) {\r\n                    let inner = inner_bbox(size_hint.inner);\r\n                    if (size_hint.align !== false) {\r\n                        const top = row_aligns[r0].start.get(outer.top);\r\n                        const bottom = row_aligns[r1].end.get(rows[r1].bottom - outer.bottom);\r\n                        const left = col_aligns[c0].start.get(outer.left);\r\n                        const right = col_aligns[c1].end.get(cols[c1].right - outer.right);\r\n                        try {\r\n                            inner = inner_bbox({ top, bottom, left, right });\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                    item.inner = inner;\r\n                }\r\n                else\r\n                    item.inner = outer;\r\n            });\r\n            items.foreach((_, { layout, outer, inner }) => {\r\n                layout.set_geometry(outer, inner);\r\n            });\r\n        }\r\n    }\r\n    exports.Grid = Grid;\r\n    Grid.__name__ = \"Grid\";\r\n    class Row extends Grid {\r\n        constructor(items) {\r\n            super();\r\n            this.items = items.map((item, i) => ({ layout: item, row: 0, col: i }));\r\n            this.rows = \"fit\";\r\n        }\r\n    }\r\n    exports.Row = Row;\r\n    Row.__name__ = \"Row\";\r\n    class Column extends Grid {\r\n        constructor(items) {\r\n            super();\r\n            this.items = items.map((item, i) => ({ layout: item, row: i, col: 0 }));\r\n            this.cols = \"fit\";\r\n        }\r\n    }\r\n    exports.Column = Column;\r\n    Column.__name__ = \"Column\";\r\n}\r\n","/* core\\layout\\html.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const layoutable_1 = require(214) /* ./layoutable */;\r\n    const types_1 = require(213) /* ./types */;\r\n    const dom_1 = require(72) /* ../dom */;\r\n    class ContentBox extends layoutable_1.ContentLayoutable {\r\n        constructor(el) {\r\n            super();\r\n            this.content_size = dom_1.unsized(el, () => new types_1.Sizeable(dom_1.size(el)));\r\n        }\r\n        _content_size() {\r\n            return this.content_size;\r\n        }\r\n    }\r\n    exports.ContentBox = ContentBox;\r\n    ContentBox.__name__ = \"ContentBox\";\r\n    class VariadicBox extends layoutable_1.Layoutable {\r\n        constructor(el) {\r\n            super();\r\n            this.el = el;\r\n        }\r\n        _measure(viewport) {\r\n            const bounded = new types_1.Sizeable(viewport).bounded_to(this.sizing.size);\r\n            return dom_1.sized(this.el, bounded, () => {\r\n                const content = new types_1.Sizeable(dom_1.content_size(this.el));\r\n                const { border, padding } = dom_1.extents(this.el);\r\n                return content.grow_by(border).grow_by(padding).map(Math.ceil);\r\n            });\r\n        }\r\n    }\r\n    exports.VariadicBox = VariadicBox;\r\n    VariadicBox.__name__ = \"VariadicBox\";\r\n    class CachedVariadicBox extends VariadicBox {\r\n        constructor(el) {\r\n            super(el);\r\n            this._cache = new Map();\r\n        }\r\n        _measure(viewport) {\r\n            const { width, height } = viewport;\r\n            const key = `${width},${height}`;\r\n            let size_hint = this._cache.get(key);\r\n            if (size_hint == null) {\r\n                size_hint = super._measure(viewport);\r\n                this._cache.set(key, size_hint);\r\n            }\r\n            return size_hint;\r\n        }\r\n        invalidate_cache() {\r\n            this._cache.clear();\r\n        }\r\n    }\r\n    exports.CachedVariadicBox = CachedVariadicBox;\r\n    CachedVariadicBox.__name__ = \"CachedVariadicBox\";\r\n}\r\n","/* models\\expressions\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var expression_1 = require(219) /* ./expression */;\r\n    exports.Expression = expression_1.Expression;\r\n    var stack_1 = require(220) /* ./stack */;\r\n    exports.Stack = stack_1.Stack;\r\n    var cumsum_1 = require(221) /* ./cumsum */;\r\n    exports.CumSum = cumsum_1.CumSum;\r\n}\r\n","/* models\\expressions\\expression.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class Expression extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._connected = new Set();\r\n            this._result = new Map();\r\n        }\r\n        v_compute(source) {\r\n            if (!this._connected.has(source)) {\r\n                this.connect(source.change, () => this._result.delete(source));\r\n                this.connect(source.patching, () => this._result.delete(source));\r\n                this.connect(source.streaming, () => this._result.delete(source));\r\n                this._connected.add(source);\r\n            }\r\n            let result = this._result.get(source);\r\n            if (result == null) {\r\n                result = this._v_compute(source);\r\n                this._result.set(source, result);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.Expression = Expression;\r\n    Expression.__name__ = \"Expression\";\r\n}\r\n","/* models\\expressions\\stack.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const expression_1 = require(219) /* ./expression */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class Stack extends expression_1.Expression {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Stack() {\r\n            this.define({\r\n                fields: [p.Array, []],\r\n            });\r\n        }\r\n        _v_compute(source) {\r\n            var _a;\r\n            const n = (_a = source.get_length()) !== null && _a !== void 0 ? _a : 0;\r\n            const result = new types_1.NumberArray(n);\r\n            for (const f of this.fields) {\r\n                const column = source.data[f];\r\n                if (column != null) {\r\n                    for (let i = 0, k = Math.min(n, column.length); i < k; i++) {\r\n                        result[i] += column[i];\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.Stack = Stack;\r\n    Stack.__name__ = \"Stack\";\r\n    Stack.init_Stack();\r\n}\r\n","/* models\\expressions\\cumsum.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const expression_1 = require(219) /* ./expression */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class CumSum extends expression_1.Expression {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CumSum() {\r\n            this.define({\r\n                field: [p.String],\r\n                include_zero: [p.Boolean, false],\r\n            });\r\n        }\r\n        _v_compute(source) {\r\n            const result = new types_1.NumberArray(source.get_length() || 0);\r\n            const col = source.data[this.field];\r\n            const offset = this.include_zero ? 1 : 0;\r\n            result[0] = this.include_zero ? 0 : col[0];\r\n            for (let i = 1; i < result.length; i++) {\r\n                result[i] = result[i - 1] + col[i - offset];\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.CumSum = CumSum;\r\n    CumSum.__name__ = \"CumSum\";\r\n    CumSum.init_CumSum();\r\n}\r\n","/* models\\filters\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var boolean_filter_1 = require(223) /* ./boolean_filter */;\r\n    exports.BooleanFilter = boolean_filter_1.BooleanFilter;\r\n    var customjs_filter_1 = require(225) /* ./customjs_filter */;\r\n    exports.CustomJSFilter = customjs_filter_1.CustomJSFilter;\r\n    var filter_1 = require(224) /* ./filter */;\r\n    exports.Filter = filter_1.Filter;\r\n    var group_filter_1 = require(226) /* ./group_filter */;\r\n    exports.GroupFilter = group_filter_1.GroupFilter;\r\n    var index_filter_1 = require(227) /* ./index_filter */;\r\n    exports.IndexFilter = index_filter_1.IndexFilter;\r\n}\r\n","/* models\\filters\\boolean_filter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const filter_1 = require(224) /* ./filter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    class BooleanFilter extends filter_1.Filter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_BooleanFilter() {\r\n            this.define({\r\n                booleans: [p.Array, null],\r\n            });\r\n        }\r\n        compute_indices(source) {\r\n            const size = source.length;\r\n            const { booleans } = this;\r\n            if (booleans == null) {\r\n                return types_1.Indices.all_set(size);\r\n            }\r\n            else {\r\n                return types_1.Indices.from_booleans(size, booleans);\r\n            }\r\n        }\r\n    }\r\n    exports.BooleanFilter = BooleanFilter;\r\n    BooleanFilter.__name__ = \"BooleanFilter\";\r\n    BooleanFilter.init_BooleanFilter();\r\n}\r\n","/* models\\filters\\filter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class Filter extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.Filter = Filter;\r\n    Filter.__name__ = \"Filter\";\r\n}\r\n","/* models\\filters\\customjs_filter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const filter_1 = require(224) /* ./filter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const types_2 = require(8) /* ../../core/util/types */;\r\n    const string_1 = require(29) /* ../../core/util/string */;\r\n    class CustomJSFilter extends filter_1.Filter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CustomJSFilter() {\r\n            this.define({\r\n                args: [p.Any, {}],\r\n                code: [p.String, ''],\r\n            });\r\n        }\r\n        get names() {\r\n            return object_1.keys(this.args);\r\n        }\r\n        get values() {\r\n            return object_1.values(this.args);\r\n        }\r\n        get func() {\r\n            const code = string_1.use_strict(this.code);\r\n            return new Function(...this.names, \"source\", code);\r\n        }\r\n        compute_indices(source) {\r\n            const size = source.length;\r\n            const filter = this.func(...this.values, source);\r\n            if (filter == null)\r\n                return types_1.Indices.all_set(size);\r\n            else if (types_2.isArrayOf(filter, types_2.isInteger))\r\n                return types_1.Indices.from_indices(size, filter);\r\n            else if (types_2.isArrayOf(filter, types_2.isBoolean))\r\n                return types_1.Indices.from_booleans(size, filter);\r\n            else\r\n                throw new Error(`expect an array of integers or booleans, or null, got ${filter}`);\r\n        }\r\n    }\r\n    exports.CustomJSFilter = CustomJSFilter;\r\n    CustomJSFilter.__name__ = \"CustomJSFilter\";\r\n    CustomJSFilter.init_CustomJSFilter();\r\n}\r\n","/* models\\filters\\group_filter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const filter_1 = require(224) /* ./filter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    class GroupFilter extends filter_1.Filter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GroupFilter() {\r\n            this.define({\r\n                column_name: [p.String],\r\n                group: [p.String],\r\n            });\r\n        }\r\n        compute_indices(source) {\r\n            const column = source.get_column(this.column_name);\r\n            if (column == null) {\r\n                logging_1.logger.warn(`${this}: groupby column '${this.column_name}' not found in the data source`);\r\n                return new types_1.Indices(source.length, 1);\r\n            }\r\n            else {\r\n                const indices = new types_1.Indices(source.length);\r\n                for (let i = 0; i < indices.size; i++) {\r\n                    if (column[i] === this.group)\r\n                        indices.set(i);\r\n                }\r\n                return indices;\r\n            }\r\n        }\r\n    }\r\n    exports.GroupFilter = GroupFilter;\r\n    GroupFilter.__name__ = \"GroupFilter\";\r\n    GroupFilter.init_GroupFilter();\r\n}\r\n","/* models\\filters\\index_filter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const filter_1 = require(224) /* ./filter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    class IndexFilter extends filter_1.Filter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_IndexFilter() {\r\n            this.define({\r\n                indices: [p.Array, null],\r\n            });\r\n        }\r\n        compute_indices(source) {\r\n            const size = source.length;\r\n            const { indices } = this;\r\n            if (indices == null) {\r\n                return types_1.Indices.all_set(size);\r\n            }\r\n            else {\r\n                return types_1.Indices.from_indices(size, indices);\r\n            }\r\n        }\r\n    }\r\n    exports.IndexFilter = IndexFilter;\r\n    IndexFilter.__name__ = \"IndexFilter\";\r\n    IndexFilter.init_IndexFilter();\r\n}\r\n","/* models\\formatters\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var basic_tick_formatter_1 = require(130) /* ./basic_tick_formatter */;\r\n    exports.BasicTickFormatter = basic_tick_formatter_1.BasicTickFormatter;\r\n    var categorical_tick_formatter_1 = require(181) /* ./categorical_tick_formatter */;\r\n    exports.CategoricalTickFormatter = categorical_tick_formatter_1.CategoricalTickFormatter;\r\n    var datetime_tick_formatter_1 = require(185) /* ./datetime_tick_formatter */;\r\n    exports.DatetimeTickFormatter = datetime_tick_formatter_1.DatetimeTickFormatter;\r\n    var func_tick_formatter_1 = require(229) /* ./func_tick_formatter */;\r\n    exports.FuncTickFormatter = func_tick_formatter_1.FuncTickFormatter;\r\n    var log_tick_formatter_1 = require(198) /* ./log_tick_formatter */;\r\n    exports.LogTickFormatter = log_tick_formatter_1.LogTickFormatter;\r\n    var mercator_tick_formatter_1 = require(201) /* ./mercator_tick_formatter */;\r\n    exports.MercatorTickFormatter = mercator_tick_formatter_1.MercatorTickFormatter;\r\n    var numeral_tick_formatter_1 = require(230) /* ./numeral_tick_formatter */;\r\n    exports.NumeralTickFormatter = numeral_tick_formatter_1.NumeralTickFormatter;\r\n    var printf_tick_formatter_1 = require(231) /* ./printf_tick_formatter */;\r\n    exports.PrintfTickFormatter = printf_tick_formatter_1.PrintfTickFormatter;\r\n    var tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    exports.TickFormatter = tick_formatter_1.TickFormatter;\r\n}\r\n","/* models\\formatters\\func_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const string_1 = require(29) /* ../../core/util/string */;\r\n    class FuncTickFormatter extends tick_formatter_1.TickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_FuncTickFormatter() {\r\n            this.define({\r\n                args: [p.Any, {}],\r\n                code: [p.String, ''],\r\n            });\r\n        }\r\n        get names() {\r\n            return object_1.keys(this.args);\r\n        }\r\n        get values() {\r\n            return object_1.values(this.args);\r\n        }\r\n        /*protected*/ _make_func() {\r\n            const code = string_1.use_strict(this.code);\r\n            return new Function(\"tick\", \"index\", \"ticks\", ...this.names, code);\r\n        }\r\n        doFormat(ticks, _opts) {\r\n            const cache = {};\r\n            const func = this._make_func().bind(cache);\r\n            return ticks.map((tick, index, ticks) => func(tick, index, ticks, ...this.values));\r\n        }\r\n    }\r\n    exports.FuncTickFormatter = FuncTickFormatter;\r\n    FuncTickFormatter.__name__ = \"FuncTickFormatter\";\r\n    FuncTickFormatter.init_FuncTickFormatter();\r\n}\r\n","/* models\\formatters\\numeral_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const Numbro = tslib_1.__importStar(require(188) /* @bokeh/numbro */);\r\n    const tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class NumeralTickFormatter extends tick_formatter_1.TickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_NumeralTickFormatter() {\r\n            this.define({\r\n                // TODO (bev) all of these could be tightened up\r\n                format: [p.String, '0,0'],\r\n                language: [p.String, 'en'],\r\n                rounding: [p.RoundingFunction, 'round'],\r\n            });\r\n        }\r\n        get _rounding_fn() {\r\n            switch (this.rounding) {\r\n                case \"round\":\r\n                case \"nearest\":\r\n                    return Math.round;\r\n                case \"floor\":\r\n                case \"rounddown\":\r\n                    return Math.floor;\r\n                case \"ceil\":\r\n                case \"roundup\":\r\n                    return Math.ceil;\r\n            }\r\n        }\r\n        doFormat(ticks, _opts) {\r\n            const { format, language, _rounding_fn } = this;\r\n            return ticks.map((tick) => Numbro.format(tick, format, language, _rounding_fn));\r\n        }\r\n    }\r\n    exports.NumeralTickFormatter = NumeralTickFormatter;\r\n    NumeralTickFormatter.__name__ = \"NumeralTickFormatter\";\r\n    NumeralTickFormatter.init_NumeralTickFormatter();\r\n}\r\n","/* models\\formatters\\printf_tick_formatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const tick_formatter_1 = require(131) /* ./tick_formatter */;\r\n    const templating_1 = require(187) /* ../../core/util/templating */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class PrintfTickFormatter extends tick_formatter_1.TickFormatter {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_PrintfTickFormatter() {\r\n            this.define({\r\n                format: [p.String, '%s'],\r\n            });\r\n        }\r\n        doFormat(ticks, _opts) {\r\n            return ticks.map((tick) => templating_1.sprintf(this.format, tick));\r\n        }\r\n    }\r\n    exports.PrintfTickFormatter = PrintfTickFormatter;\r\n    PrintfTickFormatter.__name__ = \"PrintfTickFormatter\";\r\n    PrintfTickFormatter.init_PrintfTickFormatter();\r\n}\r\n","/* models\\glyphs\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var annular_wedge_1 = require(233) /* ./annular_wedge */;\r\n    exports.AnnularWedge = annular_wedge_1.AnnularWedge;\r\n    var annulus_1 = require(234) /* ./annulus */;\r\n    exports.Annulus = annulus_1.Annulus;\r\n    var arc_1 = require(235) /* ./arc */;\r\n    exports.Arc = arc_1.Arc;\r\n    var bezier_1 = require(236) /* ./bezier */;\r\n    exports.Bezier = bezier_1.Bezier;\r\n    var circle_1 = require(237) /* ./circle */;\r\n    exports.Circle = circle_1.Circle;\r\n    var center_rotatable_1 = require(241) /* ./center_rotatable */;\r\n    exports.CenterRotatable = center_rotatable_1.CenterRotatable;\r\n    var ellipse_1 = require(242) /* ./ellipse */;\r\n    exports.Ellipse = ellipse_1.Ellipse;\r\n    var ellipse_oval_1 = require(243) /* ./ellipse_oval */;\r\n    exports.EllipseOval = ellipse_oval_1.EllipseOval;\r\n    var glyph_1 = require(94) /* ./glyph */;\r\n    exports.Glyph = glyph_1.Glyph;\r\n    var harea_1 = require(111) /* ./harea */;\r\n    exports.HArea = harea_1.HArea;\r\n    var hbar_1 = require(244) /* ./hbar */;\r\n    exports.HBar = hbar_1.HBar;\r\n    var hex_tile_1 = require(246) /* ./hex_tile */;\r\n    exports.HexTile = hex_tile_1.HexTile;\r\n    var image_1 = require(247) /* ./image */;\r\n    exports.Image = image_1.Image;\r\n    var image_rgba_1 = require(249) /* ./image_rgba */;\r\n    exports.ImageRGBA = image_rgba_1.ImageRGBA;\r\n    var image_url_1 = require(250) /* ./image_url */;\r\n    exports.ImageURL = image_url_1.ImageURL;\r\n    var line_1 = require(92) /* ./line */;\r\n    exports.Line = line_1.Line;\r\n    var multi_line_1 = require(252) /* ./multi_line */;\r\n    exports.MultiLine = multi_line_1.MultiLine;\r\n    var multi_polygons_1 = require(253) /* ./multi_polygons */;\r\n    exports.MultiPolygons = multi_polygons_1.MultiPolygons;\r\n    var oval_1 = require(254) /* ./oval */;\r\n    exports.Oval = oval_1.Oval;\r\n    var patch_1 = require(110) /* ./patch */;\r\n    exports.Patch = patch_1.Patch;\r\n    var patches_1 = require(255) /* ./patches */;\r\n    exports.Patches = patches_1.Patches;\r\n    var quad_1 = require(256) /* ./quad */;\r\n    exports.Quad = quad_1.Quad;\r\n    var quadratic_1 = require(257) /* ./quadratic */;\r\n    exports.Quadratic = quadratic_1.Quadratic;\r\n    var ray_1 = require(258) /* ./ray */;\r\n    exports.Ray = ray_1.Ray;\r\n    var rect_1 = require(259) /* ./rect */;\r\n    exports.Rect = rect_1.Rect;\r\n    var segment_1 = require(260) /* ./segment */;\r\n    exports.Segment = segment_1.Segment;\r\n    var step_1 = require(261) /* ./step */;\r\n    exports.Step = step_1.Step;\r\n    var text_1 = require(262) /* ./text */;\r\n    exports.Text = text_1.Text;\r\n    var varea_1 = require(113) /* ./varea */;\r\n    exports.VArea = varea_1.VArea;\r\n    var vbar_1 = require(263) /* ./vbar */;\r\n    exports.VBar = vbar_1.VBar;\r\n    var wedge_1 = require(264) /* ./wedge */;\r\n    exports.Wedge = wedge_1.Wedge;\r\n    var xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    exports.XYGlyph = xy_glyph_1.XYGlyph;\r\n}\r\n","/* models\\glyphs\\annular_wedge.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const math_1 = require(10) /* ../../core/util/math */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class AnnularWedgeView extends xy_glyph_1.XYGlyphView {\r\n        _map_data() {\r\n            if (this.model.properties.inner_radius.units == \"data\")\r\n                this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);\r\n            else\r\n                this.sinner_radius = this._inner_radius;\r\n            if (this.model.properties.outer_radius.units == \"data\")\r\n                this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);\r\n            else\r\n                this.souter_radius = this._outer_radius;\r\n            this._angle = new types_1.NumberArray(this._start_angle.length);\r\n            for (let i = 0, end = this._start_angle.length; i < end; i++) {\r\n                this._angle[i] = this._end_angle[i] - this._start_angle[i];\r\n            }\r\n        }\r\n        _render(ctx, indices, { sx, sy, _start_angle, _angle, sinner_radius, souter_radius }) {\r\n            const direction = this.model.properties.direction.value();\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i]))\r\n                    continue;\r\n                ctx.translate(sx[i], sy[i]);\r\n                ctx.rotate(_start_angle[i]);\r\n                ctx.beginPath();\r\n                ctx.moveTo(souter_radius[i], 0);\r\n                ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);\r\n                ctx.rotate(_angle[i]);\r\n                ctx.lineTo(sinner_radius[i], 0);\r\n                ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);\r\n                ctx.closePath();\r\n                ctx.rotate(-_angle[i] - _start_angle[i]);\r\n                ctx.translate(-sx[i], -sy[i]);\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    ctx.fill();\r\n                }\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            // check radius first\r\n            let x0, y0;\r\n            let x1, y1;\r\n            if (this.model.properties.outer_radius.units == \"data\") {\r\n                x0 = x - this.max_outer_radius;\r\n                x1 = x + this.max_outer_radius;\r\n                y0 = y - this.max_outer_radius;\r\n                y1 = y + this.max_outer_radius;\r\n            }\r\n            else {\r\n                const sx0 = sx - this.max_outer_radius;\r\n                const sx1 = sx + this.max_outer_radius;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                const sy0 = sy - this.max_outer_radius;\r\n                const sy1 = sy + this.max_outer_radius;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            }\r\n            const candidates = [];\r\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\r\n                const or2 = this.souter_radius[i] ** 2;\r\n                const ir2 = this.sinner_radius[i] ** 2;\r\n                const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\r\n                const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\r\n                const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\r\n                if (dist <= or2 && dist >= ir2)\r\n                    candidates.push(i);\r\n            }\r\n            const direction = this.model.properties.direction.value();\r\n            const indices = [];\r\n            for (const i of candidates) {\r\n                // NOTE: minus the angle because JS uses non-mathy convention for angles\r\n                const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\r\n                if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\r\n                    indices.push(i);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n        scenterxy(i) {\r\n            const r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;\r\n            const a = (this._start_angle[i] + this._end_angle[i]) / 2;\r\n            const scx = this.sx[i] + r * Math.cos(a);\r\n            const scy = this.sy[i] + r * Math.sin(a);\r\n            return [scx, scy];\r\n        }\r\n    }\r\n    exports.AnnularWedgeView = AnnularWedgeView;\r\n    AnnularWedgeView.__name__ = \"AnnularWedgeView\";\r\n    class AnnularWedge extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_AnnularWedge() {\r\n            this.prototype.default_view = AnnularWedgeView;\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.define({\r\n                direction: [p.Direction, 'anticlock'],\r\n                inner_radius: [p.DistanceSpec],\r\n                outer_radius: [p.DistanceSpec],\r\n                start_angle: [p.AngleSpec],\r\n                end_angle: [p.AngleSpec],\r\n            });\r\n        }\r\n    }\r\n    exports.AnnularWedge = AnnularWedge;\r\n    AnnularWedge.__name__ = \"AnnularWedge\";\r\n    AnnularWedge.init_AnnularWedge();\r\n}\r\n","/* models\\glyphs\\annulus.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const compat_1 = require(32) /* ../../core/util/compat */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class AnnulusView extends xy_glyph_1.XYGlyphView {\r\n        _map_data() {\r\n            if (this.model.properties.inner_radius.units == \"data\")\r\n                this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);\r\n            else\r\n                this.sinner_radius = this._inner_radius;\r\n            if (this.model.properties.outer_radius.units == \"data\")\r\n                this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);\r\n            else\r\n                this.souter_radius = this._outer_radius;\r\n        }\r\n        _render(ctx, indices, { sx, sy, sinner_radius, souter_radius }) {\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i]))\r\n                    continue;\r\n                // Because this visual has a whole in it, it proved \"challenging\"\r\n                // for some browsers to render if drawn in one go --- i.e. it did not\r\n                // work on IE. If we render in two parts (upper and lower part),\r\n                // it is unambiguous what part should be filled. The line is\r\n                // better drawn in one go though, otherwise the part where the pieces\r\n                // meet will not be fully closed due to aa.\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    ctx.beginPath();\r\n                    if (compat_1.is_ie) {\r\n                        // Draw two halves of the donut. Works on IE, but causes an aa line on Safari.\r\n                        for (const clockwise of [false, true]) {\r\n                            ctx.arc(sx[i], sy[i], sinner_radius[i], 0, Math.PI, clockwise);\r\n                            ctx.arc(sx[i], sy[i], souter_radius[i], Math.PI, 0, !clockwise);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Draw donut in one go. Does not work on iE.\r\n                        ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI, true);\r\n                        ctx.arc(sx[i], sy[i], souter_radius[i], 2 * Math.PI, 0, false);\r\n                    }\r\n                    ctx.fill();\r\n                }\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.beginPath();\r\n                    ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI);\r\n                    ctx.moveTo(sx[i] + souter_radius[i], sy[i]);\r\n                    ctx.arc(sx[i], sy[i], souter_radius[i], 0, 2 * Math.PI);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            let x0, y0;\r\n            let x1, y1;\r\n            if (this.model.properties.outer_radius.units == \"data\") {\r\n                x0 = x - this.max_outer_radius;\r\n                x1 = x + this.max_outer_radius;\r\n                y0 = y - this.max_outer_radius;\r\n                y1 = y + this.max_outer_radius;\r\n            }\r\n            else {\r\n                const sx0 = sx - this.max_outer_radius;\r\n                const sx1 = sx + this.max_outer_radius;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                const sy0 = sy - this.max_outer_radius;\r\n                const sy1 = sy + this.max_outer_radius;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            }\r\n            const indices = [];\r\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\r\n                const or2 = this.souter_radius[i] ** 2;\r\n                const ir2 = this.sinner_radius[i] ** 2;\r\n                const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\r\n                const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\r\n                const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\r\n                if (dist <= or2 && dist >= ir2)\r\n                    indices.push(i);\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\r\n            const len = index + 1;\r\n            const sx = new Array(len);\r\n            sx[index] = (x0 + x1) / 2;\r\n            const sy = new Array(len);\r\n            sy[index] = (y0 + y1) / 2;\r\n            const r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;\r\n            const sinner_radius = new Array(len);\r\n            sinner_radius[index] = r * 0.4;\r\n            const souter_radius = new Array(len);\r\n            souter_radius[index] = r * 0.8;\r\n            this._render(ctx, [index], { sx, sy, sinner_radius, souter_radius }); // XXX\r\n        }\r\n    }\r\n    exports.AnnulusView = AnnulusView;\r\n    AnnulusView.__name__ = \"AnnulusView\";\r\n    class Annulus extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Annulus() {\r\n            this.prototype.default_view = AnnulusView;\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.define({\r\n                inner_radius: [p.DistanceSpec],\r\n                outer_radius: [p.DistanceSpec],\r\n            });\r\n        }\r\n    }\r\n    exports.Annulus = Annulus;\r\n    Annulus.__name__ = \"Annulus\";\r\n    Annulus.init_Annulus();\r\n}\r\n","/* models\\glyphs\\arc.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class ArcView extends xy_glyph_1.XYGlyphView {\r\n        _map_data() {\r\n            if (this.model.properties.radius.units == \"data\")\r\n                this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\r\n            else\r\n                this.sradius = this._radius;\r\n        }\r\n        _render(ctx, indices, { sx, sy, sradius, _start_angle, _end_angle }) {\r\n            if (this.visuals.line.doit) {\r\n                const direction = this.model.properties.direction.value();\r\n                for (const i of indices) {\r\n                    if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i]))\r\n                        continue;\r\n                    ctx.beginPath();\r\n                    ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.ArcView = ArcView;\r\n    ArcView.__name__ = \"ArcView\";\r\n    class Arc extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Arc() {\r\n            this.prototype.default_view = ArcView;\r\n            this.mixins(property_mixins_1.LineVector);\r\n            this.define({\r\n                direction: [p.Direction, 'anticlock'],\r\n                radius: [p.DistanceSpec],\r\n                start_angle: [p.AngleSpec],\r\n                end_angle: [p.AngleSpec],\r\n            });\r\n        }\r\n    }\r\n    exports.Arc = Arc;\r\n    Arc.__name__ = \"Arc\";\r\n    Arc.init_Arc();\r\n}\r\n","/* models\\glyphs\\bezier.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    // algorithm adapted from http://stackoverflow.com/a/14429749/3406693\r\n    function _cbb(x0, y0, x1, y1, x2, y2, x3, y3) {\r\n        const tvalues = [];\r\n        const bounds = [[], []];\r\n        for (let i = 0; i <= 2; i++) {\r\n            let a, b, c;\r\n            if (i === 0) {\r\n                b = ((6 * x0) - (12 * x1)) + (6 * x2);\r\n                a = (((-3 * x0) + (9 * x1)) - (9 * x2)) + (3 * x3);\r\n                c = (3 * x1) - (3 * x0);\r\n            }\r\n            else {\r\n                b = ((6 * y0) - (12 * y1)) + (6 * y2);\r\n                a = (((-3 * y0) + (9 * y1)) - (9 * y2)) + (3 * y3);\r\n                c = (3 * y1) - (3 * y0);\r\n            }\r\n            if (Math.abs(a) < 1e-12) { // Numerical robustness\r\n                if (Math.abs(b) < 1e-12) // Numerical robustness\r\n                    continue;\r\n                const t = -c / b;\r\n                if (0 < t && t < 1)\r\n                    tvalues.push(t);\r\n                continue;\r\n            }\r\n            const b2ac = (b * b) - (4 * c * a);\r\n            const sqrtb2ac = Math.sqrt(b2ac);\r\n            if (b2ac < 0)\r\n                continue;\r\n            const t1 = (-b + sqrtb2ac) / (2 * a);\r\n            if (0 < t1 && t1 < 1)\r\n                tvalues.push(t1);\r\n            const t2 = (-b - sqrtb2ac) / (2 * a);\r\n            if (0 < t2 && t2 < 1)\r\n                tvalues.push(t2);\r\n        }\r\n        let j = tvalues.length;\r\n        const jlen = j;\r\n        while (j--) {\r\n            const t = tvalues[j];\r\n            const mt = 1 - t;\r\n            const x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\r\n            bounds[0][j] = x;\r\n            const y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\r\n            bounds[1][j] = y;\r\n        }\r\n        bounds[0][jlen] = x0;\r\n        bounds[1][jlen] = y0;\r\n        bounds[0][jlen + 1] = x3;\r\n        bounds[1][jlen + 1] = y3;\r\n        return [\r\n            Math.min(...bounds[0]),\r\n            Math.max(...bounds[1]),\r\n            Math.max(...bounds[0]),\r\n            Math.min(...bounds[1]),\r\n        ];\r\n    }\r\n    class BezierView extends glyph_1.GlyphView {\r\n        _project_data() {\r\n            projections_1.inplace.project_xy(this._x0, this._y0);\r\n            projections_1.inplace.project_xy(this._x1, this._y1);\r\n        }\r\n        _index_data(index) {\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx0[i] + this._cy0[i] + this._cx1[i] + this._cy1[i]))\r\n                    index.add_empty();\r\n                else {\r\n                    const [x0, y0, x1, y1] = _cbb(this._x0[i], this._y0[i], this._x1[i], this._y1[i], this._cx0[i], this._cy0[i], this._cx1[i], this._cy1[i]);\r\n                    index.add(x0, y0, x1, y1);\r\n                }\r\n            }\r\n        }\r\n        _render(ctx, indices, { sx0, sy0, sx1, sy1, scx0, scy0, scx1, scy1 }) {\r\n            if (this.visuals.line.doit) {\r\n                for (const i of indices) {\r\n                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx0[i] + scy0[i] + scx1[i] + scy1[i]))\r\n                        continue;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx0[i], sy0[i]);\r\n                    ctx.bezierCurveTo(scx0[i], scy0[i], scx1[i], scy1[i], sx1[i], sy1[i]);\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n        scenterxy() {\r\n            throw new Error(`${this}.scenterxy() is not implemented`);\r\n        }\r\n    }\r\n    exports.BezierView = BezierView;\r\n    BezierView.__name__ = \"BezierView\";\r\n    class Bezier extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Bezier() {\r\n            this.prototype.default_view = BezierView;\r\n            this.define({\r\n                x0: [p.XCoordinateSpec, { field: \"x0\" }],\r\n                y0: [p.YCoordinateSpec, { field: \"y0\" }],\r\n                x1: [p.XCoordinateSpec, { field: \"x1\" }],\r\n                y1: [p.YCoordinateSpec, { field: \"y1\" }],\r\n                cx0: [p.XCoordinateSpec, { field: \"cx0\" }],\r\n                cy0: [p.YCoordinateSpec, { field: \"cy0\" }],\r\n                cx1: [p.XCoordinateSpec, { field: \"cx1\" }],\r\n                cy1: [p.YCoordinateSpec, { field: \"cy1\" }],\r\n            });\r\n            this.mixins(property_mixins_1.LineVector);\r\n        }\r\n    }\r\n    exports.Bezier = Bezier;\r\n    Bezier.__name__ = \"Bezier\";\r\n    Bezier.init_Bezier();\r\n}\r\n","/* models\\glyphs\\circle.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const markers_1 = require(238) /* ./webgl/markers */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class CircleView extends xy_glyph_1.XYGlyphView {\r\n        initialize() {\r\n            super.initialize();\r\n            const { webgl } = this.renderer.plot_view.canvas_view;\r\n            if (webgl != null) {\r\n                this.glglyph = new markers_1.CircleGL(webgl.gl, this);\r\n            }\r\n        }\r\n        _map_data() {\r\n            // XXX: Order is important here: size is always present (at least\r\n            // a default), but radius is only present if a user specifies it.\r\n            if (this._radius != null) {\r\n                if (this.model.properties.radius.units == \"data\") {\r\n                    switch (this.model.radius_dimension) {\r\n                        case \"x\": {\r\n                            this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\r\n                            break;\r\n                        }\r\n                        case \"y\": {\r\n                            this.sradius = this.sdist(this.renderer.yscale, this._y, this._radius);\r\n                            break;\r\n                        }\r\n                        case \"max\": {\r\n                            const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\r\n                            const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\r\n                            this.sradius = arrayable_1.map(sradius_x, (s, i) => Math.max(s, sradius_y[i]));\r\n                            break;\r\n                        }\r\n                        case \"min\": {\r\n                            const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\r\n                            const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\r\n                            this.sradius = arrayable_1.map(sradius_x, (s, i) => Math.min(s, sradius_y[i]));\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.sradius = this._radius;\r\n                    this.max_size = 2 * this.max_radius;\r\n                }\r\n            }\r\n            else\r\n                this.sradius = arrayable_1.map(this._size, (s) => s / 2);\r\n        }\r\n        _mask_data() {\r\n            const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\r\n            let x0, y0;\r\n            let x1, y1;\r\n            if (this._radius != null && this.model.properties.radius.units == \"data\") {\r\n                const sx0 = hr.start;\r\n                const sx1 = hr.end;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                x0 -= this.max_radius;\r\n                x1 += this.max_radius;\r\n                const sy0 = vr.start;\r\n                const sy1 = vr.end;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n                y0 -= this.max_radius;\r\n                y1 += this.max_radius;\r\n            }\r\n            else {\r\n                const sx0 = hr.start - this.max_size;\r\n                const sx1 = hr.end + this.max_size;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                const sy0 = vr.start - this.max_size;\r\n                const sy1 = vr.end + this.max_size;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            }\r\n            return this.index.indices({ x0, x1, y0, y1 });\r\n        }\r\n        _render(ctx, indices, { sx, sy, sradius }) {\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + sradius[i]))\r\n                    continue;\r\n                ctx.beginPath();\r\n                ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    ctx.fill();\r\n                }\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            let x0, x1, y0, y1;\r\n            if (this._radius != null && this.model.properties.radius.units == \"data\") {\r\n                x0 = x - this.max_radius;\r\n                x1 = x + this.max_radius;\r\n                y0 = y - this.max_radius;\r\n                y1 = y + this.max_radius;\r\n            }\r\n            else {\r\n                const sx0 = sx - this.max_size;\r\n                const sx1 = sx + this.max_size;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                const sy0 = sy - this.max_size;\r\n                const sy1 = sy + this.max_size;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            }\r\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\r\n            const indices = [];\r\n            if (this._radius != null && this.model.properties.radius.units == \"data\") {\r\n                for (const i of candidates) {\r\n                    const r2 = this.sradius[i] ** 2;\r\n                    const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\r\n                    const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\r\n                    const dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\r\n                    if (dist <= r2) {\r\n                        indices.push(i);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (const i of candidates) {\r\n                    const r2 = this.sradius[i] ** 2;\r\n                    const dist = (this.sx[i] - sx) ** 2 + (this.sy[i] - sy) ** 2;\r\n                    if (dist <= r2) {\r\n                        indices.push(i);\r\n                    }\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_span(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const bounds = this.bounds();\r\n            let x0, x1, y0, y1;\r\n            if (geometry.direction == 'h') {\r\n                // use circle bounds instead of current pointer y coordinates\r\n                let sx0, sx1;\r\n                y0 = bounds.y0;\r\n                y1 = bounds.y1;\r\n                if (this._radius != null && this.model.properties.radius.units == \"data\") {\r\n                    sx0 = sx - this.max_radius;\r\n                    sx1 = sx + this.max_radius;\r\n                    [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                }\r\n                else {\r\n                    const ms = this.max_size / 2;\r\n                    sx0 = sx - ms;\r\n                    sx1 = sx + ms;\r\n                    [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                }\r\n            }\r\n            else {\r\n                // use circle bounds instead of current pointer x coordinates\r\n                let sy0, sy1;\r\n                x0 = bounds.x0;\r\n                x1 = bounds.x1;\r\n                if (this._radius != null && this.model.properties.radius.units == \"data\") {\r\n                    sy0 = sy - this.max_radius;\r\n                    sy1 = sy + this.max_radius;\r\n                    [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n                }\r\n                else {\r\n                    const ms = this.max_size / 2;\r\n                    sy0 = sy - ms;\r\n                    sy1 = sy + ms;\r\n                    [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n                }\r\n            }\r\n            const indices = [...this.index.indices({ x0, x1, y0, y1 })];\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_rect(geometry) {\r\n            const { sx0, sx1, sy0, sy1 } = geometry;\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            const indices = [...this.index.indices({ x0, x1, y0, y1 })];\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_poly(geometry) {\r\n            const { sx, sy } = geometry;\r\n            // TODO (bev) use spatial index to pare candidate list\r\n            const candidates = array_1.range(0, this.sx.length);\r\n            const indices = [];\r\n            for (let i = 0, end = candidates.length; i < end; i++) {\r\n                const index = candidates[i];\r\n                if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\r\n                    indices.push(index);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        // circle does not inherit from marker (since it also accepts radius) so we\r\n        // must supply a draw_legend for it  here\r\n        draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\r\n            // using objects like this seems a little wonky, since the keys are coerced to\r\n            // stings, but it works\r\n            const len = index + 1;\r\n            const sx = new Array(len);\r\n            sx[index] = (x0 + x1) / 2;\r\n            const sy = new Array(len);\r\n            sy[index] = (y0 + y1) / 2;\r\n            const sradius = new Array(len);\r\n            sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;\r\n            this._render(ctx, [index], { sx, sy, sradius }); // XXX\r\n        }\r\n    }\r\n    exports.CircleView = CircleView;\r\n    CircleView.__name__ = \"CircleView\";\r\n    class Circle extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Circle() {\r\n            this.prototype.default_view = CircleView;\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.define({\r\n                angle: [p.AngleSpec, 0],\r\n                size: [p.DistanceSpec, { units: \"screen\", value: 4 }],\r\n                radius: [p.DistanceSpec, undefined, { optional: true }],\r\n                radius_dimension: [p.RadiusDimension, 'x'],\r\n            });\r\n        }\r\n    }\r\n    exports.Circle = Circle;\r\n    Circle.__name__ = \"Circle\";\r\n    Circle.init_Circle();\r\n}\r\n","/* models\\glyphs\\webgl\\markers.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const utils_1 = require(103) /* ./utils */;\r\n    const base_1 = require(107) /* ./base */;\r\n    const markers_vert_1 = require(239) /* ./markers.vert */;\r\n    const markers_frag_1 = require(240) /* ./markers.frag */;\r\n    const circle_1 = require(237) /* ../circle */;\r\n    const arrayable_1 = require(12) /* ../../../core/util/arrayable */;\r\n    const logging_1 = require(19) /* ../../../core/logging */;\r\n    const color_1 = require(22) /* ../../../core/util/color */;\r\n    function attach_float(prog, vbo, att_name, n, visual, name) {\r\n        // Attach a float attribute to the program. Use singleton value if we can,\r\n        // otherwise use VBO to apply array.\r\n        if (!visual.doit) {\r\n            vbo.used = false;\r\n            prog.set_attribute(att_name, 'float', [0]);\r\n        }\r\n        else if (visual[name].is_value) {\r\n            vbo.used = false;\r\n            prog.set_attribute(att_name, 'float', [visual[name].value()]);\r\n        }\r\n        else {\r\n            vbo.used = true;\r\n            const a = new Float32Array(visual.get_array(name));\r\n            vbo.set_size(n * 4);\r\n            vbo.set_data(0, a);\r\n            prog.set_attribute(att_name, 'float', vbo);\r\n        }\r\n    }\r\n    exports.attach_float = attach_float;\r\n    function attach_color(prog, vbo, att_name, n, visual, prefix) {\r\n        // Attach the color attribute to the program. If there's just one color,\r\n        // then use this single color for all vertices (no VBO). Otherwise we\r\n        // create an array and upload that to the VBO, which we attahce to the prog.\r\n        const m = 4;\r\n        const colorname = prefix + '_color';\r\n        const alphaname = prefix + '_alpha';\r\n        if (!visual.doit) {\r\n            // Don't draw (draw transparent)\r\n            vbo.used = false;\r\n            prog.set_attribute(att_name, 'vec4', [0, 0, 0, 0]);\r\n        }\r\n        else {\r\n            // Use vbo; we need an array for both the color and the alpha\r\n            vbo.used = true;\r\n            let colors;\r\n            if (visual[colorname].is_value) {\r\n                const val = color_1.encode_rgba(color_1.color2rgba(visual[colorname].value()));\r\n                const array = new Uint32Array(n);\r\n                array.fill(val);\r\n                colors = array;\r\n            }\r\n            else\r\n                colors = visual.get_array(colorname);\r\n            let alphas;\r\n            if (visual[alphaname].is_value) {\r\n                const val = visual[alphaname].value();\r\n                const array = new Float32Array(n);\r\n                array.fill(val);\r\n                alphas = array;\r\n            }\r\n            else\r\n                alphas = visual.get_array(alphaname);\r\n            // Create array of rgbs\r\n            const a = new Float32Array(n * m);\r\n            for (let i = 0, end = n; i < end; i++) {\r\n                const rgba = color_1.decode_rgba(colors[i]);\r\n                if (rgba[3] == 1.0)\r\n                    rgba[3] = alphas[i];\r\n                a.set(rgba, i * m);\r\n            }\r\n            // Attach vbo\r\n            vbo.set_size(n * m * 4);\r\n            vbo.set_data(0, a);\r\n            prog.set_attribute(att_name, 'vec4', vbo);\r\n        }\r\n    }\r\n    exports.attach_color = attach_color;\r\n    // Base class for markers. All markers share the same GLSL, except for one\r\n    // function that defines the marker geometry.\r\n    class MarkerGL extends base_1.BaseGLGlyph {\r\n        init() {\r\n            const { gl } = this;\r\n            const vert = markers_vert_1.vertex_shader;\r\n            const frag = markers_frag_1.fragment_shader(this._marker_code);\r\n            // The program\r\n            this.prog = new utils_1.Program(gl);\r\n            this.prog.set_shaders(vert, frag);\r\n            // Real attributes\r\n            this.vbo_sx = new utils_1.VertexBuffer(gl);\r\n            this.prog.set_attribute('a_sx', 'float', this.vbo_sx);\r\n            this.vbo_sy = new utils_1.VertexBuffer(gl);\r\n            this.prog.set_attribute('a_sy', 'float', this.vbo_sy);\r\n            this.vbo_s = new utils_1.VertexBuffer(gl);\r\n            this.prog.set_attribute('a_size', 'float', this.vbo_s);\r\n            this.vbo_a = new utils_1.VertexBuffer(gl);\r\n            this.prog.set_attribute('a_angle', 'float', this.vbo_a);\r\n            // VBO's for attributes (they may not be used if value is singleton)\r\n            this.vbo_linewidth = new utils_1.VertexBuffer(gl);\r\n            this.vbo_fg_color = new utils_1.VertexBuffer(gl);\r\n            this.vbo_bg_color = new utils_1.VertexBuffer(gl);\r\n            this.index_buffer = new utils_1.IndexBuffer(gl);\r\n        }\r\n        draw(indices, mainGlyph, trans) {\r\n            // The main glyph has the data, *this* glyph has the visuals.\r\n            const mainGlGlyph = mainGlyph.glglyph;\r\n            const { nvertices } = mainGlGlyph;\r\n            // Upload data if we must. Only happens for main glyph.\r\n            if (mainGlGlyph.data_changed) {\r\n                mainGlGlyph._set_data(nvertices);\r\n                if (this.glyph instanceof circle_1.CircleView && this.glyph._radius != null) {\r\n                    // Keep screen radius up-to-date for circle glyph. Only happens when a radius is given\r\n                    this.vbo_s.set_data(0, arrayable_1.map(this.glyph.sradius, (s) => s * 2));\r\n                }\r\n                mainGlGlyph.data_changed = false;\r\n            }\r\n            // Update visuals if we must. Can happen for all glyphs.\r\n            if (this.visuals_changed) {\r\n                this._set_visuals(nvertices);\r\n                this.visuals_changed = false;\r\n            }\r\n            // Handle transformation to device coordinates\r\n            this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\r\n            this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\r\n            // Select buffers from main glyph\r\n            // (which may be this glyph but maybe not if this is a (non)selection glyph)\r\n            this.prog.set_attribute('a_sx', 'float', mainGlGlyph.vbo_sx);\r\n            this.prog.set_attribute('a_sy', 'float', mainGlGlyph.vbo_sy);\r\n            this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\r\n            this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\r\n            // Draw directly or using indices. Do not handle indices if they do not\r\n            // fit in a uint16; WebGL 1.0 does not support uint32.\r\n            if (indices.length == 0)\r\n                return;\r\n            else if (indices.length === nvertices)\r\n                this.prog.draw(this.gl.POINTS, [0, nvertices]);\r\n            else if (nvertices < 65535) {\r\n                // On IE the marker size is reduced to 1 px when using an index buffer\r\n                // A MS Edge dev on Twitter said on 24-04-2014: \"gl_PointSize > 1.0 works\r\n                // in DrawArrays; gl_PointSize > 1.0 in DrawElements is coming soon in the\r\n                // next renderer update.\r\n                const ua = window.navigator.userAgent;\r\n                if ((ua.indexOf(\"MSIE \") + ua.indexOf(\"Trident/\") + ua.indexOf(\"Edge/\")) > 0) {\r\n                    logging_1.logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\r\n                }\r\n                this.index_buffer.set_size(indices.length * 2);\r\n                this.index_buffer.set_data(0, new Uint16Array(indices));\r\n                this.prog.draw(this.gl.POINTS, this.index_buffer);\r\n            }\r\n            else {\r\n                // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\r\n                // First collect indices in chunks\r\n                const chunksize = 64000; // 65536\r\n                const chunks = [];\r\n                for (let i = 0, end = Math.ceil(nvertices / chunksize); i < end; i++) {\r\n                    chunks.push([]);\r\n                }\r\n                for (let i = 0, end = indices.length; i < end; i++) {\r\n                    const uint16_index = indices[i] % chunksize;\r\n                    const chunk = Math.floor(indices[i] / chunksize);\r\n                    chunks[chunk].push(uint16_index);\r\n                }\r\n                // Then draw each chunk\r\n                for (let chunk = 0, end = chunks.length; chunk < end; chunk++) {\r\n                    const these_indices = new Uint16Array(chunks[chunk]);\r\n                    const offset = chunk * chunksize * 4;\r\n                    if (these_indices.length === 0) {\r\n                        continue;\r\n                    }\r\n                    this.prog.set_attribute('a_sx', 'float', mainGlGlyph.vbo_sx, 0, offset);\r\n                    this.prog.set_attribute('a_sy', 'float', mainGlGlyph.vbo_sy, 0, offset);\r\n                    this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\r\n                    this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\r\n                    if (this.vbo_linewidth.used) {\r\n                        this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\r\n                    }\r\n                    if (this.vbo_fg_color.used) {\r\n                        this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\r\n                    }\r\n                    if (this.vbo_bg_color.used) {\r\n                        this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\r\n                    }\r\n                    // The actual drawing\r\n                    this.index_buffer.set_size(these_indices.length * 2);\r\n                    this.index_buffer.set_data(0, these_indices);\r\n                    this.prog.draw(this.gl.POINTS, this.index_buffer);\r\n                }\r\n            }\r\n        }\r\n        _set_data(nvertices) {\r\n            const n = nvertices * 4; // in bytes\r\n            // Set buffer size\r\n            this.vbo_sx.set_size(n);\r\n            this.vbo_sy.set_size(n);\r\n            this.vbo_a.set_size(n);\r\n            this.vbo_s.set_size(n);\r\n            this.vbo_sx.set_data(0, this.glyph.sx);\r\n            this.vbo_sy.set_data(0, this.glyph.sy);\r\n            if (this.glyph._angle != null) {\r\n                this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\r\n            }\r\n            if (this.glyph instanceof circle_1.CircleView && this.glyph._radius != null)\r\n                this.vbo_s.set_data(0, arrayable_1.map(this.glyph.sradius, (s) => s * 2));\r\n            else\r\n                this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\r\n        }\r\n        _set_visuals(nvertices) {\r\n            attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\r\n            attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\r\n            attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\r\n            // Static value for antialias. Smaller aa-region to obtain crisper images\r\n            this.prog.set_uniform('u_antialias', 'float', [0.8]);\r\n        }\r\n    }\r\n    exports.MarkerGL = MarkerGL;\r\n    MarkerGL.__name__ = \"MarkerGL\";\r\n    function mk_marker(code) {\r\n        return class extends MarkerGL {\r\n            get _marker_code() {\r\n                return code;\r\n            }\r\n        };\r\n    }\r\n    const glsl = tslib_1.__importStar(require(240) /* ./markers.frag */);\r\n    exports.AsteriskGL = mk_marker(glsl.asterisk);\r\n    exports.CircleGL = mk_marker(glsl.circle);\r\n    exports.CircleCrossGL = mk_marker(glsl.circlecross);\r\n    exports.CircleXGL = mk_marker(glsl.circlex);\r\n    exports.CrossGL = mk_marker(glsl.cross);\r\n    exports.DiamondGL = mk_marker(glsl.diamond);\r\n    exports.DiamondCrossGL = mk_marker(glsl.diamondcross);\r\n    exports.HexGL = mk_marker(glsl.hex);\r\n    exports.InvertedTriangleGL = mk_marker(glsl.invertedtriangle);\r\n    exports.SquareGL = mk_marker(glsl.square);\r\n    exports.SquareCrossGL = mk_marker(glsl.squarecross);\r\n    exports.SquareXGL = mk_marker(glsl.squarex);\r\n    exports.TriangleGL = mk_marker(glsl.triangle);\r\n    exports.XGL = mk_marker(glsl.x);\r\n}\r\n","/* models\\glyphs\\webgl\\markers.vert.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.vertex_shader = `\r\nprecision mediump float;\r\nconst float SQRT_2 = 1.4142135623730951;\r\n//\r\nuniform float u_pixel_ratio;\r\nuniform vec2 u_canvas_size;\r\nuniform vec2 u_offset;\r\nuniform vec2 u_scale;\r\nuniform float u_antialias;\r\n//\r\nattribute float a_sx;\r\nattribute float a_sy;\r\nattribute float a_size;\r\nattribute float a_angle;  // in radians\r\nattribute float a_linewidth;\r\nattribute vec4  a_fg_color;\r\nattribute vec4  a_bg_color;\r\n//\r\nvarying float v_linewidth;\r\nvarying float v_size;\r\nvarying vec4  v_fg_color;\r\nvarying vec4  v_bg_color;\r\nvarying vec2  v_rotation;\r\n\r\nvoid main (void)\r\n{\r\n    v_size = a_size * u_pixel_ratio;\r\n    v_linewidth = a_linewidth * u_pixel_ratio;\r\n    v_fg_color = a_fg_color;\r\n    v_bg_color = a_bg_color;\r\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\r\n    vec2 pos = vec2(a_sx, a_sy);  // in pixels\r\n    pos += 0.5;  // make up for Bokeh's offset\r\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\r\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\r\n    gl_Position.y *= -1.0;\r\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\r\n}\r\n`;\r\n}\r\n","/* models\\glyphs\\webgl\\markers.frag.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.fragment_shader = (marker_code) => `\r\nprecision mediump float;\r\nconst float SQRT_2 = 1.4142135623730951;\r\nconst float PI = 3.14159265358979323846264;\r\n//\r\nuniform float u_antialias;\r\n//\r\nvarying vec4  v_fg_color;\r\nvarying vec4  v_bg_color;\r\nvarying float v_linewidth;\r\nvarying float v_size;\r\nvarying vec2  v_rotation;\r\n\r\n${marker_code}\r\n\r\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\r\n{\r\n    vec4 frag_color;\r\n    float t = linewidth/2.0 - antialias;\r\n    float signed_distance = distance;\r\n    float border_distance = abs(signed_distance) - t;\r\n    float alpha = border_distance/antialias;\r\n    alpha = exp(-alpha*alpha);\r\n\r\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\r\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\r\n    float select = float(bool(fg_color.a));\r\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\r\n    // Similarly, if we want a transparent bg\r\n    select = float(bool(bg_color.a));\r\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\r\n\r\n    if( border_distance < 0.0)\r\n        frag_color = fg_color;\r\n    else if( signed_distance < 0.0 ) {\r\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\r\n    } else {\r\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\r\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\r\n        } else {\r\n            discard;\r\n        }\r\n    }\r\n    return frag_color;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\r\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\r\n             v_rotation.y*P.x + v_rotation.x*P.y);\r\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\r\n    float distance = marker(P*point_size, v_size);\r\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\r\n}\r\n`;\r\n    exports.circle = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    return length(P) - size/2.0;\r\n}\r\n`;\r\n    exports.square = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    return max(abs(P.x), abs(P.y)) - size/2.0;\r\n}\r\n`;\r\n    exports.diamond = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\r\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\r\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\r\n    return r1 / SQRT_2;\r\n}\r\n`;\r\n    exports.hex = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    vec2 q = abs(P);\r\n    return max(q.y * 0.57735 + q.x - 1.0 * size/2.0, q.y - 0.866 * size/2.0);\r\n}\r\n`;\r\n    exports.triangle = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    P.y -= size * 0.3;\r\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\r\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\r\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\r\n    float r2 = P.y;\r\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\r\n}\r\n`;\r\n    exports.invertedtriangle = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    P.y += size * 0.3;\r\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\r\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\r\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\r\n    float r2 = - P.y;\r\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\r\n}\r\n`;\r\n    exports.cross = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;   // 2.5 is a tweak\r\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\r\n    return max(square, cross);\r\n}\r\n`;\r\n    exports.circlecross = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    // Define quadrants\r\n    float qs = size / 2.0;  // quadrant size\r\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\r\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\r\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\r\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\r\n    // Intersect main shape with quadrants (to form cross)\r\n    float circle = length(P) - size/2.0;\r\n    float c1 = max(circle, s1);\r\n    float c2 = max(circle, s2);\r\n    float c3 = max(circle, s3);\r\n    float c4 = max(circle, s4);\r\n    // Union\r\n    return min(min(min(c1, c2), c3), c4);\r\n}\r\n`;\r\n    exports.squarecross = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    // Define quadrants\r\n    float qs = size / 2.0;  // quadrant size\r\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\r\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\r\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\r\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\r\n    // Intersect main shape with quadrants (to form cross)\r\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\r\n    float c1 = max(square, s1);\r\n    float c2 = max(square, s2);\r\n    float c3 = max(square, s3);\r\n    float c4 = max(square, s4);\r\n    // Union\r\n    return min(min(min(c1, c2), c3), c4);\r\n}\r\n`;\r\n    exports.diamondcross = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    // Define quadrants\r\n    float qs = size / 2.0;  // quadrant size\r\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\r\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\r\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\r\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\r\n    // Intersect main shape with quadrants (to form cross)\r\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\r\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\r\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\r\n    diamond /= SQRT_2;\r\n    float c1 = max(diamond, s1);\r\n    float c2 = max(diamond, s2);\r\n    float c3 = max(diamond, s3);\r\n    float c4 = max(diamond, s4);\r\n    // Union\r\n    return min(min(min(c1, c2), c3), c4);\r\n}\r\n`;\r\n    exports.x = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    float circle = length(P) - size / 1.6;\r\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\r\n    return max(circle, X);\r\n}\r\n`;\r\n    exports.circlex = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    float x = P.x - P.y;\r\n    float y = P.x + P.y;\r\n    // Define quadrants\r\n    float qs = size / 2.0;  // quadrant size\r\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\r\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\r\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\r\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\r\n    // Intersect main shape with quadrants (to form cross)\r\n    float circle = length(P) - size/2.0;\r\n    float c1 = max(circle, s1);\r\n    float c2 = max(circle, s2);\r\n    float c3 = max(circle, s3);\r\n    float c4 = max(circle, s4);\r\n    // Union\r\n    float almost = min(min(min(c1, c2), c3), c4);\r\n    // In this case, the X is also outside of the main shape\r\n    float Xmask = length(P) - size / 1.6;  // a circle\r\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\r\n    return min(max(X, Xmask), almost);\r\n}\r\n`;\r\n    exports.squarex = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    float x = P.x - P.y;\r\n    float y = P.x + P.y;\r\n    // Define quadrants\r\n    float qs = size / 2.0;  // quadrant size\r\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\r\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\r\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\r\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\r\n    // Intersect main shape with quadrants (to form cross)\r\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\r\n    float c1 = max(square, s1);\r\n    float c2 = max(square, s2);\r\n    float c3 = max(square, s3);\r\n    float c4 = max(square, s4);\r\n    // Union\r\n    return min(min(min(c1, c2), c3), c4);\r\n}\r\n`;\r\n    exports.asterisk = `\r\nfloat marker(vec2 P, float size)\r\n{\r\n    // Masks\r\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\r\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\r\n    // Shapes\r\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\r\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\r\n    // Result is union of masked shapes\r\n    return min(max(X, diamond), max(cross, square));\r\n}\r\n`;\r\n}\r\n","/* models\\glyphs\\center_rotatable.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class CenterRotatableView extends xy_glyph_1.XYGlyphView {\r\n    }\r\n    exports.CenterRotatableView = CenterRotatableView;\r\n    CenterRotatableView.__name__ = \"CenterRotatableView\";\r\n    class CenterRotatable extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CenterRotatable() {\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.define({\r\n                angle: [p.AngleSpec, 0],\r\n                width: [p.DistanceSpec],\r\n                height: [p.DistanceSpec],\r\n            });\r\n        }\r\n    }\r\n    exports.CenterRotatable = CenterRotatable;\r\n    CenterRotatable.__name__ = \"CenterRotatable\";\r\n    CenterRotatable.init_CenterRotatable();\r\n}\r\n","/* models\\glyphs\\ellipse.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const ellipse_oval_1 = require(243) /* ./ellipse_oval */;\r\n    class EllipseView extends ellipse_oval_1.EllipseOvalView {\r\n    }\r\n    exports.EllipseView = EllipseView;\r\n    EllipseView.__name__ = \"EllipseView\";\r\n    class Ellipse extends ellipse_oval_1.EllipseOval {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Ellipse() {\r\n            this.prototype.default_view = EllipseView;\r\n        }\r\n    }\r\n    exports.Ellipse = Ellipse;\r\n    Ellipse.__name__ = \"Ellipse\";\r\n    Ellipse.init_Ellipse();\r\n}\r\n","/* models\\glyphs\\ellipse_oval.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const center_rotatable_1 = require(241) /* ./center_rotatable */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class EllipseOvalView extends center_rotatable_1.CenterRotatableView {\r\n        _set_data() {\r\n            this.max_w2 = 0;\r\n            if (this.model.properties.width.units == \"data\")\r\n                this.max_w2 = this.max_width / 2;\r\n            this.max_h2 = 0;\r\n            if (this.model.properties.height.units == \"data\")\r\n                this.max_h2 = this.max_height / 2;\r\n        }\r\n        _map_data() {\r\n            if (this.model.properties.width.units == \"data\")\r\n                this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');\r\n            else\r\n                this.sw = this._width;\r\n            if (this.model.properties.height.units == \"data\")\r\n                this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');\r\n            else\r\n                this.sh = this._height;\r\n        }\r\n        _render(ctx, indices, { sx, sy, sw, sh, _angle }) {\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + _angle[i]))\r\n                    continue;\r\n                ctx.beginPath();\r\n                ctx.ellipse(sx[i], sy[i], sw[i] / 2.0, sh[i] / 2.0, _angle[i], 0, 2 * Math.PI);\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    ctx.fill();\r\n                }\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            let x0, x1, y0, y1, cond, sx0, sx1, sy0, sy1;\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            if (this.model.properties.width.units == \"data\") {\r\n                x0 = x - this.max_width;\r\n                x1 = x + this.max_width;\r\n            }\r\n            else {\r\n                sx0 = sx - this.max_width;\r\n                sx1 = sx + this.max_width;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            }\r\n            if (this.model.properties.height.units == \"data\") {\r\n                y0 = y - this.max_height;\r\n                y1 = y + this.max_height;\r\n            }\r\n            else {\r\n                sy0 = sy - this.max_height;\r\n                sy1 = sy + this.max_height;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            }\r\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\r\n            const indices = [];\r\n            for (const i of candidates) {\r\n                cond = hittest.point_in_ellipse(sx, sy, this._angle[i], this.sh[i] / 2, this.sw[i] / 2, this.sx[i], this.sy[i]);\r\n                if (cond) {\r\n                    indices.push(i);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\r\n            const len = index + 1;\r\n            const sx = new Array(len);\r\n            sx[index] = (x0 + x1) / 2;\r\n            const sy = new Array(len);\r\n            sy[index] = (y0 + y1) / 2;\r\n            const scale = this.sw[index] / this.sh[index];\r\n            const d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\r\n            const sw = new Array(len);\r\n            const sh = new Array(len);\r\n            if (scale > 1) {\r\n                sw[index] = d;\r\n                sh[index] = d / scale;\r\n            }\r\n            else {\r\n                sw[index] = d * scale;\r\n                sh[index] = d;\r\n            }\r\n            this._render(ctx, [index], { sx, sy, sw, sh, _angle: [0] }); // XXX\r\n        }\r\n        _bounds({ x0, x1, y0, y1 }) {\r\n            return {\r\n                x0: x0 - this.max_w2,\r\n                x1: x1 + this.max_w2,\r\n                y0: y0 - this.max_h2,\r\n                y1: y1 + this.max_h2,\r\n            };\r\n        }\r\n    }\r\n    exports.EllipseOvalView = EllipseOvalView;\r\n    EllipseOvalView.__name__ = \"EllipseOvalView\";\r\n    class EllipseOval extends center_rotatable_1.CenterRotatable {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.EllipseOval = EllipseOval;\r\n    EllipseOval.__name__ = \"EllipseOval\";\r\n}\r\n","/* models\\glyphs\\hbar.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const box_1 = require(245) /* ./box */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class HBarView extends box_1.BoxView {\r\n        scenterxy(i) {\r\n            const scx = (this.sleft[i] + this.sright[i]) / 2;\r\n            const scy = this.sy[i];\r\n            return [scx, scy];\r\n        }\r\n        _lrtb(i) {\r\n            const l = Math.min(this._left[i], this._right[i]);\r\n            const r = Math.max(this._left[i], this._right[i]);\r\n            const t = this._y[i] + 0.5 * this._height[i];\r\n            const b = this._y[i] - 0.5 * this._height[i];\r\n            return [l, r, t, b];\r\n        }\r\n        _map_data() {\r\n            this.sy = this.renderer.yscale.v_compute(this._y);\r\n            this.sh = this.sdist(this.renderer.yscale, this._y, this._height, \"center\");\r\n            this.sleft = this.renderer.xscale.v_compute(this._left);\r\n            this.sright = this.renderer.xscale.v_compute(this._right);\r\n            const n = this.sy.length;\r\n            this.stop = new types_1.NumberArray(n);\r\n            this.sbottom = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                this.stop[i] = this.sy[i] - this.sh[i] / 2;\r\n                this.sbottom[i] = this.sy[i] + this.sh[i] / 2;\r\n            }\r\n            this._clamp_viewport();\r\n        }\r\n    }\r\n    exports.HBarView = HBarView;\r\n    HBarView.__name__ = \"HBarView\";\r\n    class HBar extends box_1.Box {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_HBar() {\r\n            this.prototype.default_view = HBarView;\r\n            this.define({\r\n                left: [p.XCoordinateSpec, { value: 0 }],\r\n                y: [p.YCoordinateSpec, { field: \"y\" }],\r\n                height: [p.NumberSpec, { value: 1 }],\r\n                right: [p.XCoordinateSpec, { field: \"right\" }],\r\n            });\r\n        }\r\n    }\r\n    exports.HBar = HBar;\r\n    HBar.__name__ = \"HBar\";\r\n    HBar.init_HBar();\r\n}\r\n","/* models\\glyphs\\box.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class BoxView extends glyph_1.GlyphView {\r\n        get_anchor_point(anchor, i, _spt) {\r\n            const left = Math.min(this.sleft[i], this.sright[i]);\r\n            const right = Math.max(this.sright[i], this.sleft[i]);\r\n            const top = Math.min(this.stop[i], this.sbottom[i]); // screen coordinates !!!\r\n            const bottom = Math.max(this.sbottom[i], this.stop[i]); //\r\n            switch (anchor) {\r\n                case \"top_left\": return { x: left, y: top };\r\n                case \"top_center\": return { x: (left + right) / 2, y: top };\r\n                case \"top_right\": return { x: right, y: top };\r\n                case \"bottom_left\": return { x: left, y: bottom };\r\n                case \"bottom_center\": return { x: (left + right) / 2, y: bottom };\r\n                case \"bottom_right\": return { x: right, y: bottom };\r\n                case \"center_left\": return { x: left, y: (top + bottom) / 2 };\r\n                case \"center\": return { x: (left + right) / 2, y: (top + bottom) / 2 };\r\n                case \"center_right\": return { x: right, y: (top + bottom) / 2 };\r\n                default: return null;\r\n            }\r\n        }\r\n        _index_data(index) {\r\n            const { min, max } = Math;\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const [l, r, t, b] = this._lrtb(i);\r\n                if (isNaN(l + r + t + b) || !isFinite(l + r + t + b))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(min(l, r), min(t, b), max(r, l), max(t, b));\r\n            }\r\n        }\r\n        _render(ctx, indices, { sleft, sright, stop, sbottom }) {\r\n            for (const i of indices) {\r\n                if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i]))\r\n                    continue;\r\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    ctx.beginPath();\r\n                    ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\r\n                    ctx.fill();\r\n                }\r\n                this.visuals.hatch.doit2(ctx, i, () => {\r\n                    ctx.beginPath();\r\n                    ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\r\n                    ctx.fill();\r\n                }, () => this.renderer.request_render());\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.beginPath();\r\n                    ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        // We need to clamp the endpoints inside the viewport, because various browser canvas\r\n        // implementations have issues drawing rects with enpoints far outside the viewport\r\n        _clamp_viewport() {\r\n            const hr = this.renderer.plot_view.frame.bbox.h_range;\r\n            const vr = this.renderer.plot_view.frame.bbox.v_range;\r\n            const n = this.stop.length;\r\n            for (let i = 0; i < n; i++) {\r\n                this.stop[i] = Math.max(this.stop[i], vr.start);\r\n                this.sbottom[i] = Math.min(this.sbottom[i], vr.end);\r\n                this.sleft[i] = Math.max(this.sleft[i], hr.start);\r\n                this.sright[i] = Math.min(this.sright[i], hr.end);\r\n            }\r\n        }\r\n        _hit_rect(geometry) {\r\n            return this._hit_rect_against_index(geometry);\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            const indices = [...this.index.indices({ x0: x, y0: y, x1: x, y1: y })];\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_span(geometry) {\r\n            const { sx, sy } = geometry;\r\n            let indices;\r\n            if (geometry.direction == 'v') {\r\n                const y = this.renderer.yscale.invert(sy);\r\n                const hr = this.renderer.plot_view.frame.bbox.h_range;\r\n                const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\r\n                indices = [...this.index.indices({ x0, y0: y, x1, y1: y })];\r\n            }\r\n            else {\r\n                const x = this.renderer.xscale.invert(sx);\r\n                const vr = this.renderer.plot_view.frame.bbox.v_range;\r\n                const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\r\n                indices = [...this.index.indices({ x0: x, y0, x1: x, y1 })];\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.BoxView = BoxView;\r\n    BoxView.__name__ = \"BoxView\";\r\n    class Box extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Box() {\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector, property_mixins_1.HatchVector]);\r\n        }\r\n    }\r\n    exports.Box = Box;\r\n    Box.__name__ = \"Box\";\r\n    Box.init_Box();\r\n}\r\n","/* models\\glyphs\\hex_tile.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class HexTileView extends glyph_1.GlyphView {\r\n        scenterxy(i) {\r\n            const scx = this.sx[i];\r\n            const scy = this.sy[i];\r\n            return [scx, scy];\r\n        }\r\n        _set_data() {\r\n            const n = this._q.length;\r\n            const { orientation, size, aspect_scale } = this.model;\r\n            this._x = new types_1.NumberArray(n);\r\n            this._y = new types_1.NumberArray(n);\r\n            const sqrt3 = Math.sqrt(3);\r\n            if (orientation == \"pointytop\") {\r\n                for (let i = 0; i < n; i++) {\r\n                    this._x[i] = size * sqrt3 * (this._q[i] + this._r[i] / 2) / aspect_scale;\r\n                    this._y[i] = -size * 3 / 2 * this._r[i];\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0; i < n; i++) {\r\n                    this._x[i] = size * 3 / 2 * this._q[i];\r\n                    this._y[i] = -size * sqrt3 * (this._r[i] + this._q[i] / 2) * aspect_scale;\r\n                }\r\n            }\r\n        }\r\n        _project_data() {\r\n            projections_1.inplace.project_xy(this._x, this._y);\r\n        }\r\n        _index_data(index) {\r\n            let ysize = this.model.size;\r\n            let xsize = Math.sqrt(3) * ysize / 2;\r\n            if (this.model.orientation == \"flattop\") {\r\n                [xsize, ysize] = [ysize, xsize];\r\n                ysize *= this.model.aspect_scale;\r\n            }\r\n            else\r\n                xsize /= this.model.aspect_scale;\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const x = this._x[i];\r\n                const y = this._y[i];\r\n                if (isNaN(x + y) || !isFinite(x + y))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(x - xsize, y - ysize, x + xsize, y + ysize);\r\n            }\r\n        }\r\n        // overriding map_data instead of _map_data because the default automatic mappings\r\n        // for other glyphs (with cartesian coordinates) is not useful\r\n        map_data() {\r\n            [this.sx, this.sy] = this.renderer.coordinates.map_to_screen(this._x, this._y);\r\n            [this.svx, this.svy] = this._get_unscaled_vertices();\r\n        }\r\n        _get_unscaled_vertices() {\r\n            const size = this.model.size;\r\n            const aspect_scale = this.model.aspect_scale;\r\n            if (this.model.orientation == \"pointytop\") {\r\n                const rscale = this.renderer.yscale;\r\n                const hscale = this.renderer.xscale;\r\n                const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\r\n                const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) / aspect_scale; // assumes linear scale\r\n                const r2 = r / 2.0;\r\n                const svx = [0, -h, -h, 0, h, h];\r\n                const svy = [r, r2, -r2, -r, -r2, r2];\r\n                return [svx, svy];\r\n            }\r\n            else {\r\n                const rscale = this.renderer.xscale;\r\n                const hscale = this.renderer.yscale;\r\n                const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\r\n                const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) * aspect_scale; // assumes linear scale\r\n                const r2 = r / 2.0;\r\n                const svx = [r, r2, -r2, -r, -r2, r2];\r\n                const svy = [0, -h, -h, 0, h, h];\r\n                return [svx, svy];\r\n            }\r\n        }\r\n        _render(ctx, indices, { sx, sy, svx, svy, _scale }) {\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + _scale[i]))\r\n                    continue;\r\n                ctx.translate(sx[i], sy[i]);\r\n                ctx.beginPath();\r\n                for (let j = 0; j < 6; j++) {\r\n                    ctx.lineTo(svx[j] * _scale[i], svy[j] * _scale[i]);\r\n                }\r\n                ctx.closePath();\r\n                ctx.translate(-sx[i], -sy[i]);\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    ctx.fill();\r\n                }\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\r\n            const indices = [];\r\n            for (const i of candidates) {\r\n                if (hittest.point_in_poly(sx - this.sx[i], sy - this.sy[i], this.svx, this.svy)) {\r\n                    indices.push(i);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_span(geometry) {\r\n            const { sx, sy } = geometry;\r\n            let indices;\r\n            if (geometry.direction == 'v') {\r\n                const y = this.renderer.yscale.invert(sy);\r\n                const hr = this.renderer.plot_view.frame.bbox.h_range;\r\n                const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\r\n                indices = [...this.index.indices({ x0, y0: y, x1, y1: y })];\r\n            }\r\n            else {\r\n                const x = this.renderer.xscale.invert(sx);\r\n                const vr = this.renderer.plot_view.frame.bbox.v_range;\r\n                const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\r\n                indices = [...this.index.indices({ x0: x, y0, x1: x, y1 })];\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_rect(geometry) {\r\n            const { sx0, sx1, sy0, sy1 } = geometry;\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            const indices = [...this.index.indices({ x0, x1, y0, y1 })];\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.HexTileView = HexTileView;\r\n    HexTileView.__name__ = \"HexTileView\";\r\n    class HexTile extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_HexTile() {\r\n            this.prototype.default_view = HexTileView;\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.define({\r\n                r: [p.NumberSpec],\r\n                q: [p.NumberSpec],\r\n                size: [p.Number, 1.0],\r\n                aspect_scale: [p.Number, 1.0],\r\n                scale: [p.NumberSpec, 1.0],\r\n                orientation: [p.HexTileOrientation, \"pointytop\"],\r\n            });\r\n            this.override({ line_color: null });\r\n        }\r\n    }\r\n    exports.HexTile = HexTile;\r\n    HexTile.__name__ = \"HexTile\";\r\n    HexTile.init_HexTile();\r\n}\r\n","/* models\\glyphs\\image.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const image_base_1 = require(248) /* ./image_base */;\r\n    const linear_color_mapper_1 = require(141) /* ../mappers/linear_color_mapper */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class ImageView extends image_base_1.ImageBaseView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.color_mapper.change, () => this._update_image());\r\n        }\r\n        _update_image() {\r\n            // Only reset image_data if already initialized\r\n            if (this.image_data != null) {\r\n                this._set_data(null);\r\n                this.renderer.plot_view.request_render();\r\n            }\r\n        }\r\n        _flat_img_to_buf8(img) {\r\n            const cmap = this.model.color_mapper.rgba_mapper;\r\n            return cmap.v_compute(img);\r\n        }\r\n    }\r\n    exports.ImageView = ImageView;\r\n    ImageView.__name__ = \"ImageView\";\r\n    // NOTE: this needs to be redefined here, because palettes are located in bokeh-api.js bundle\r\n    const Greys9 = () => [\"#000000\", \"#252525\", \"#525252\", \"#737373\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\", \"#f0f0f0\", \"#ffffff\"];\r\n    class Image extends image_base_1.ImageBase {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Image() {\r\n            this.prototype.default_view = ImageView;\r\n            this.define({\r\n                color_mapper: [p.Instance, () => new linear_color_mapper_1.LinearColorMapper({ palette: Greys9() })],\r\n            });\r\n        }\r\n    }\r\n    exports.Image = Image;\r\n    Image.__name__ = \"Image\";\r\n    Image.init_Image();\r\n}\r\n","/* models\\glyphs\\image_base.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const ndarray_1 = require(30) /* ../../core/util/ndarray */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    class ImageBaseView extends xy_glyph_1.XYGlyphView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\r\n        }\r\n        _render(ctx, indices, { image_data, sx, sy, sw, sh }) {\r\n            const old_smoothing = ctx.getImageSmoothingEnabled();\r\n            ctx.setImageSmoothingEnabled(false);\r\n            ctx.globalAlpha = this.model.global_alpha;\r\n            for (const i of indices) {\r\n                if (image_data[i] == null || isNaN(sx[i] + sy[i] + sw[i] + sh[i]))\r\n                    continue;\r\n                const y_offset = sy[i];\r\n                ctx.translate(0, y_offset);\r\n                ctx.scale(1, -1);\r\n                ctx.translate(0, -y_offset);\r\n                ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\r\n                ctx.translate(0, y_offset);\r\n                ctx.scale(1, -1);\r\n                ctx.translate(0, -y_offset);\r\n            }\r\n            ctx.setImageSmoothingEnabled(old_smoothing);\r\n        }\r\n        _set_data(indices) {\r\n            this._set_width_heigh_data();\r\n            for (let i = 0, end = this._image.length; i < end; i++) {\r\n                if (indices != null && indices.indexOf(i) < 0)\r\n                    continue;\r\n                const img = this._image[i];\r\n                let flat_img;\r\n                if (ndarray_1.is_NDArray(img)) {\r\n                    assert_1.assert(img.dimension == 2, \"expected a 2D array\");\r\n                    flat_img = img;\r\n                    this._height[i] = img.shape[0];\r\n                    this._width[i] = img.shape[1];\r\n                }\r\n                else {\r\n                    flat_img = array_1.concat(img);\r\n                    this._height[i] = img.length;\r\n                    this._width[i] = img[0].length;\r\n                }\r\n                const buf8 = this._flat_img_to_buf8(flat_img);\r\n                this._set_image_data_from_buffer(i, buf8);\r\n            }\r\n        }\r\n        _index_data(index) {\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const [l, r, t, b] = this._lrtb(i);\r\n                if (isNaN(l + r + t + b) || !isFinite(l + r + t + b))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(l, b, r, t);\r\n            }\r\n        }\r\n        _lrtb(i) {\r\n            const xr = this.renderer.xscale.source_range;\r\n            const x1 = this._x[i];\r\n            const x2 = xr.is_reversed ? x1 - this._dw[i] : x1 + this._dw[i];\r\n            const yr = this.renderer.yscale.source_range;\r\n            const y1 = this._y[i];\r\n            const y2 = yr.is_reversed ? y1 - this._dh[i] : y1 + this._dh[i];\r\n            const [l, r] = x1 < x2 ? [x1, x2] : [x2, x1];\r\n            const [b, t] = y1 < y2 ? [y1, y2] : [y2, y1];\r\n            return [l, r, t, b];\r\n        }\r\n        _set_width_heigh_data() {\r\n            if (this.image_data == null || this.image_data.length != this._image.length)\r\n                this.image_data = new Array(this._image.length);\r\n            if (this._width == null || this._width.length != this._image.length)\r\n                this._width = new types_1.NumberArray(this._image.length);\r\n            if (this._height == null || this._height.length != this._image.length)\r\n                this._height = new types_1.NumberArray(this._image.length);\r\n        }\r\n        _get_or_create_canvas(i) {\r\n            const _image_data = this.image_data[i];\r\n            if (_image_data != null && _image_data.width == this._width[i] &&\r\n                _image_data.height == this._height[i])\r\n                return _image_data;\r\n            else {\r\n                const canvas = document.createElement('canvas');\r\n                canvas.width = this._width[i];\r\n                canvas.height = this._height[i];\r\n                return canvas;\r\n            }\r\n        }\r\n        _set_image_data_from_buffer(i, buf8) {\r\n            const canvas = this._get_or_create_canvas(i);\r\n            const ctx = canvas.getContext('2d');\r\n            const image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\r\n            image_data.data.set(buf8);\r\n            ctx.putImageData(image_data, 0, 0);\r\n            this.image_data[i] = canvas;\r\n        }\r\n        _map_data() {\r\n            switch (this.model.properties.dw.units) {\r\n                case \"data\": {\r\n                    this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);\r\n                    break;\r\n                }\r\n                case \"screen\": {\r\n                    this.sw = this._dw;\r\n                    break;\r\n                }\r\n            }\r\n            switch (this.model.properties.dh.units) {\r\n                case \"data\": {\r\n                    this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);\r\n                    break;\r\n                }\r\n                case \"screen\": {\r\n                    this.sh = this._dh;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        _image_index(index, x, y) {\r\n            const [l, r, t, b] = this._lrtb(index);\r\n            const width = this._width[index];\r\n            const height = this._height[index];\r\n            const dx = (r - l) / width;\r\n            const dy = (t - b) / height;\r\n            let dim1 = Math.floor((x - l) / dx);\r\n            let dim2 = Math.floor((y - b) / dy);\r\n            if (this.renderer.xscale.source_range.is_reversed)\r\n                dim1 = width - dim1 - 1;\r\n            if (this.renderer.yscale.source_range.is_reversed)\r\n                dim2 = height - dim2 - 1;\r\n            return { index, dim1, dim2, flat_index: dim2 * width + dim1 };\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            const candidates = this.index.indices({ x0: x, x1: x, y0: y, y1: y });\r\n            const result = new selection_1.Selection();\r\n            for (const index of candidates) {\r\n                if (sx != Infinity && sy != Infinity) {\r\n                    result.image_indices.push(this._image_index(index, x, y));\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    exports.ImageBaseView = ImageBaseView;\r\n    ImageBaseView.__name__ = \"ImageBaseView\";\r\n    class ImageBase extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ImageBase() {\r\n            this.define({\r\n                image: [p.NDArraySpec],\r\n                dw: [p.DistanceSpec],\r\n                dh: [p.DistanceSpec],\r\n                dilate: [p.Boolean, false],\r\n                global_alpha: [p.Number, 1.0],\r\n            });\r\n        }\r\n    }\r\n    exports.ImageBase = ImageBase;\r\n    ImageBase.__name__ = \"ImageBase\";\r\n    ImageBase.init_ImageBase();\r\n}\r\n","/* models\\glyphs\\image_rgba.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const image_base_1 = require(248) /* ./image_base */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    class ImageRGBAView extends image_base_1.ImageBaseView {\r\n        _flat_img_to_buf8(img) {\r\n            let array;\r\n            if (types_1.isArray(img)) {\r\n                array = new Uint32Array(img);\r\n            }\r\n            else {\r\n                array = img;\r\n            }\r\n            return new Uint8Array(array.buffer);\r\n        }\r\n    }\r\n    exports.ImageRGBAView = ImageRGBAView;\r\n    ImageRGBAView.__name__ = \"ImageRGBAView\";\r\n    class ImageRGBA extends image_base_1.ImageBase {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ImageRGBA() {\r\n            this.prototype.default_view = ImageRGBAView;\r\n        }\r\n    }\r\n    exports.ImageRGBA = ImageRGBA;\r\n    ImageRGBA.__name__ = \"ImageRGBA\";\r\n    ImageRGBA.init_ImageRGBA();\r\n}\r\n","/* models\\glyphs\\image_url.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const image_1 = require(251) /* ../../core/util/image */;\r\n    class ImageURLView extends xy_glyph_1.XYGlyphView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._images_rendered = false;\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\r\n        }\r\n        _index_data(index) {\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                // TODO: add a proper implementation (same as ImageBase?)\r\n                index.add_empty();\r\n            }\r\n        }\r\n        _set_data() {\r\n            if (this.image == null || this.image.length != this._url.length)\r\n                this.image = arrayable_1.map(this._url, () => null);\r\n            const { retry_attempts, retry_timeout } = this.model;\r\n            for (let i = 0, end = this._url.length; i < end; i++) {\r\n                const url = this._url[i];\r\n                if (url == null || url == \"\")\r\n                    continue;\r\n                new image_1.ImageLoader(url, {\r\n                    loaded: (image) => {\r\n                        this.image[i] = image;\r\n                        this.renderer.request_render();\r\n                    },\r\n                    attempts: retry_attempts + 1,\r\n                    timeout: retry_timeout,\r\n                });\r\n            }\r\n            const w_data = this.model.properties.w.units == \"data\";\r\n            const h_data = this.model.properties.h.units == \"data\";\r\n            const n = this._x.length;\r\n            const xs = new types_1.NumberArray(w_data ? 2 * n : n);\r\n            const ys = new types_1.NumberArray(h_data ? 2 * n : n);\r\n            const { anchor } = this.model;\r\n            function x0x1(x, w) {\r\n                switch (anchor) {\r\n                    case \"top_left\":\r\n                    case \"bottom_left\":\r\n                    case \"center_left\":\r\n                        return [x, x + w];\r\n                    case \"top_center\":\r\n                    case \"bottom_center\":\r\n                    case \"center\":\r\n                        return [x - w / 2, x + w / 2];\r\n                    case \"top_right\":\r\n                    case \"bottom_right\":\r\n                    case \"center_right\":\r\n                        return [x - w, x];\r\n                }\r\n            }\r\n            function y0y1(y, h) {\r\n                switch (anchor) {\r\n                    case \"top_left\":\r\n                    case \"top_center\":\r\n                    case \"top_right\":\r\n                        return [y, y - h];\r\n                    case \"bottom_left\":\r\n                    case \"bottom_center\":\r\n                    case \"bottom_right\":\r\n                        return [y + h, y];\r\n                    case \"center_left\":\r\n                    case \"center\":\r\n                    case \"center_right\":\r\n                        return [y + h / 2, y - h / 2];\r\n                }\r\n            }\r\n            // if the width/height are in screen units, don't try to include them in bounds\r\n            if (w_data) {\r\n                for (let i = 0; i < n; i++) {\r\n                    [xs[i], xs[n + i]] = x0x1(this._x[i], this._w[i]);\r\n                }\r\n            }\r\n            else\r\n                xs.set(this._x, 0);\r\n            if (h_data) {\r\n                for (let i = 0; i < n; i++) {\r\n                    [ys[i], ys[n + i]] = y0y1(this._y[i], this._h[i]);\r\n                }\r\n            }\r\n            else\r\n                ys.set(this._y, 0);\r\n            const [x0, x1] = arrayable_1.minmax(xs);\r\n            const [y0, y1] = arrayable_1.minmax(ys);\r\n            this._bounds_rect = { x0, x1, y0, y1 };\r\n        }\r\n        has_finished() {\r\n            return super.has_finished() && this._images_rendered == true;\r\n        }\r\n        _map_data() {\r\n            // Better to check this.model.w and this.model.h for null since the set_data\r\n            // machinery will have converted this._w and this._w to lists of null\r\n            const ws = this.model.w != null ? this._w : arrayable_1.map(this._x, () => NaN);\r\n            const hs = this.model.h != null ? this._h : arrayable_1.map(this._x, () => NaN);\r\n            switch (this.model.properties.w.units) {\r\n                case \"data\": {\r\n                    this.sw = this.sdist(this.renderer.xscale, this._x, ws, \"edge\", this.model.dilate);\r\n                    break;\r\n                }\r\n                case \"screen\": {\r\n                    this.sw = ws;\r\n                    break;\r\n                }\r\n            }\r\n            switch (this.model.properties.h.units) {\r\n                case \"data\": {\r\n                    this.sh = this.sdist(this.renderer.yscale, this._y, hs, \"edge\", this.model.dilate);\r\n                    break;\r\n                }\r\n                case \"screen\": {\r\n                    this.sh = hs;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        _render(ctx, indices, { image, sx, sy, sw, sh, _angle }) {\r\n            // TODO (bev): take actual border width into account when clipping\r\n            const { frame } = this.renderer.plot_view;\r\n            ctx.rect(frame.bbox.left + 1, frame.bbox.top + 1, frame.bbox.width - 2, frame.bbox.height - 2);\r\n            ctx.clip();\r\n            let finished = true;\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + _angle[i]))\r\n                    continue;\r\n                const img = image[i];\r\n                if (img == null) {\r\n                    finished = false;\r\n                    continue;\r\n                }\r\n                this._render_image(ctx, i, img, sx, sy, sw, sh, _angle);\r\n            }\r\n            if (finished && !this._images_rendered) {\r\n                this._images_rendered = true;\r\n                this.notify_finished();\r\n            }\r\n        }\r\n        _final_sx_sy(anchor, sx, sy, sw, sh) {\r\n            switch (anchor) {\r\n                case 'top_left': return [sx, sy];\r\n                case 'top_center': return [sx - (sw / 2), sy];\r\n                case 'top_right': return [sx - sw, sy];\r\n                case 'center_right': return [sx - sw, sy - (sh / 2)];\r\n                case 'bottom_right': return [sx - sw, sy - sh];\r\n                case 'bottom_center': return [sx - (sw / 2), sy - sh];\r\n                case 'bottom_left': return [sx, sy - sh];\r\n                case 'center_left': return [sx, sy - (sh / 2)];\r\n                case 'center': return [sx - (sw / 2), sy - (sh / 2)];\r\n            }\r\n        }\r\n        _render_image(ctx, i, image, sx, sy, sw, sh, angle) {\r\n            if (isNaN(sw[i]))\r\n                sw[i] = image.width;\r\n            if (isNaN(sh[i]))\r\n                sh[i] = image.height;\r\n            const { anchor } = this.model;\r\n            const [sxi, syi] = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]);\r\n            ctx.save();\r\n            ctx.globalAlpha = this.model.global_alpha;\r\n            const sw2 = sw[i] / 2;\r\n            const sh2 = sh[i] / 2;\r\n            if (angle[i]) {\r\n                ctx.translate(sxi, syi);\r\n                //rotation about center of image\r\n                ctx.translate(sw2, sh2);\r\n                ctx.rotate(angle[i]);\r\n                ctx.translate(-sw2, -sh2);\r\n                ctx.drawImage(image, 0, 0, sw[i], sh[i]);\r\n                ctx.translate(sw2, sh2);\r\n                ctx.rotate(-angle[i]);\r\n                ctx.translate(-sw2, -sh2);\r\n                ctx.translate(-sxi, -syi);\r\n            }\r\n            else\r\n                ctx.drawImage(image, sxi, syi, sw[i], sh[i]);\r\n            ctx.restore();\r\n        }\r\n        bounds() {\r\n            return this._bounds_rect;\r\n        }\r\n    }\r\n    exports.ImageURLView = ImageURLView;\r\n    ImageURLView.__name__ = \"ImageURLView\";\r\n    class ImageURL extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ImageURL() {\r\n            this.prototype.default_view = ImageURLView;\r\n            this.define({\r\n                url: [p.StringSpec],\r\n                anchor: [p.Anchor, 'top_left'],\r\n                global_alpha: [p.Number, 1.0],\r\n                angle: [p.AngleSpec, 0],\r\n                w: [p.DistanceSpec],\r\n                h: [p.DistanceSpec],\r\n                dilate: [p.Boolean, false],\r\n                retry_attempts: [p.Number, 0],\r\n                retry_timeout: [p.Number, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.ImageURL = ImageURL;\r\n    ImageURL.__name__ = \"ImageURL\";\r\n    ImageURL.init_ImageURL();\r\n}\r\n","/* core\\util\\image.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const logging_1 = require(19) /* ../logging */;\r\n    class ImageLoader {\r\n        constructor(url, options = {}) {\r\n            this._image = new Image();\r\n            this._finished = false;\r\n            const { attempts = 1, timeout = 1 } = options;\r\n            this.promise = new Promise((resolve, _reject) => {\r\n                this._image.crossOrigin = \"anonymous\";\r\n                let retries = 0;\r\n                this._image.onerror = () => {\r\n                    if (++retries == attempts) {\r\n                        const message = `unable to load ${url} image after ${attempts} attempts`;\r\n                        logging_1.logger.warn(message);\r\n                        if (this._image.crossOrigin != null) {\r\n                            logging_1.logger.warn(`attempting to load ${url} without a cross origin policy`);\r\n                            this._image.crossOrigin = null;\r\n                            retries = 0;\r\n                        }\r\n                        else {\r\n                            if (options.failed != null)\r\n                                options.failed();\r\n                            return; // XXX reject(new Error(message))\r\n                        }\r\n                    }\r\n                    setTimeout(() => this._image.src = url, timeout);\r\n                };\r\n                this._image.onload = () => {\r\n                    this._finished = true;\r\n                    if (options.loaded != null)\r\n                        options.loaded(this._image);\r\n                    resolve(this._image);\r\n                };\r\n                this._image.src = url;\r\n            });\r\n        }\r\n        get finished() {\r\n            return this._finished;\r\n        }\r\n        get image() {\r\n            return this._image;\r\n        }\r\n    }\r\n    exports.ImageLoader = ImageLoader;\r\n    ImageLoader.__name__ = \"ImageLoader\";\r\n}\r\n","/* models\\glyphs\\multi_line.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class MultiLineView extends glyph_1.GlyphView {\r\n        _project_data() {\r\n            projections_1.inplace.project_xy(this._xs.array, this._ys.array);\r\n        }\r\n        _index_data(index) {\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const xsi = this._xs.get(i);\r\n                if (xsi.length == 0) {\r\n                    index.add_empty();\r\n                    continue;\r\n                }\r\n                const ysi = this._ys.get(i);\r\n                if (ysi.length == 0) {\r\n                    index.add_empty();\r\n                    continue;\r\n                }\r\n                const [x0, x1] = arrayable_1.minmax(xsi);\r\n                const [y0, y1] = arrayable_1.minmax(ysi);\r\n                index.add(x0, y0, x1, y1);\r\n            }\r\n        }\r\n        _render(ctx, indices, { sxs, sys }) {\r\n            for (const i of indices) {\r\n                const sx = sxs.get(i);\r\n                const sy = sys.get(i);\r\n                this.visuals.line.set_vectorize(ctx, i);\r\n                for (let j = 0, end = sx.length; j < end; j++) {\r\n                    if (j == 0) {\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(sx[j], sy[j]);\r\n                        continue;\r\n                    }\r\n                    else if (isNaN(sx[j]) || isNaN(sy[j])) {\r\n                        ctx.stroke();\r\n                        ctx.beginPath();\r\n                        continue;\r\n                    }\r\n                    else\r\n                        ctx.lineTo(sx[j], sy[j]);\r\n                }\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            const point = { x: geometry.sx, y: geometry.sy };\r\n            let shortest = 9999;\r\n            const hits = new Map();\r\n            for (let i = 0, end = this.sxs.length; i < end; i++) {\r\n                const threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);\r\n                const sxsi = this.sxs.get(i);\r\n                const sysi = this.sys.get(i);\r\n                let points = null;\r\n                for (let j = 0, endj = sxsi.length - 1; j < endj; j++) {\r\n                    const p0 = { x: sxsi[j], y: sysi[j] };\r\n                    const p1 = { x: sxsi[j + 1], y: sysi[j + 1] };\r\n                    const dist = hittest.dist_to_segment(point, p0, p1);\r\n                    if (dist < threshold && dist < shortest) {\r\n                        shortest = dist;\r\n                        points = [j];\r\n                    }\r\n                }\r\n                if (points != null) {\r\n                    hits.set(i, points);\r\n                }\r\n            }\r\n            return new selection_1.Selection({\r\n                indices: [...hits.keys()],\r\n                multiline_indices: object_1.to_object(hits),\r\n            });\r\n        }\r\n        _hit_span(geometry) {\r\n            const { sx, sy } = geometry;\r\n            let val;\r\n            let vs;\r\n            if (geometry.direction == 'v') {\r\n                val = this.renderer.yscale.invert(sy);\r\n                vs = this._ys;\r\n            }\r\n            else {\r\n                val = this.renderer.xscale.invert(sx);\r\n                vs = this._xs;\r\n            }\r\n            const hits = new Map();\r\n            for (let i = 0, end = vs.length; i < end; i++) {\r\n                const vsi = vs.get(i);\r\n                const points = [];\r\n                for (let j = 0, endj = vsi.length - 1; j < endj; j++) {\r\n                    if (vsi[j] <= val && val <= vsi[j + 1])\r\n                        points.push(j);\r\n                }\r\n                if (points.length > 0) {\r\n                    hits.set(i, points);\r\n                }\r\n            }\r\n            return new selection_1.Selection({\r\n                indices: [...hits.keys()],\r\n                multiline_indices: object_1.to_object(hits),\r\n            });\r\n        }\r\n        get_interpolation_hit(i, point_i, geometry) {\r\n            const xsi = this._xs.get(i);\r\n            const ysi = this._ys.get(i);\r\n            const x2 = xsi[point_i];\r\n            const y2 = ysi[point_i];\r\n            const x3 = xsi[point_i + 1];\r\n            const y3 = ysi[point_i + 1];\r\n            return utils_1.line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n        scenterxy() {\r\n            throw new Error(`${this}.scenterxy() is not implemented`);\r\n        }\r\n    }\r\n    exports.MultiLineView = MultiLineView;\r\n    MultiLineView.__name__ = \"MultiLineView\";\r\n    class MultiLine extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MultiLine() {\r\n            this.prototype.default_view = MultiLineView;\r\n            this.define({\r\n                xs: [p.XCoordinateSeqSpec, { field: \"xs\" }],\r\n                ys: [p.YCoordinateSeqSpec, { field: \"ys\" }],\r\n            });\r\n            this.mixins(property_mixins_1.LineVector);\r\n        }\r\n    }\r\n    exports.MultiLine = MultiLine;\r\n    MultiLine.__name__ = \"MultiLine\";\r\n    MultiLine.init_MultiLine();\r\n}\r\n","/* models\\glyphs\\multi_polygons.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const spatial_1 = require(95) /* ../../core/util/spatial */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const arrayable_2 = require(12) /* ../../core/util/arrayable */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    class MultiPolygonsView extends glyph_1.GlyphView {\r\n        _project_data() {\r\n            // TODO\r\n        }\r\n        _index_data(index) {\r\n            const { min, max } = Math;\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const xsi = this._xs[i];\r\n                const ysi = this._ys[i];\r\n                if (xsi.length == 0 || ysi.length == 0) {\r\n                    index.add_empty();\r\n                    continue;\r\n                }\r\n                let xi0 = +Infinity;\r\n                let xi1 = -Infinity;\r\n                let yi0 = +Infinity;\r\n                let yi1 = -Infinity;\r\n                for (let j = 0, endj = xsi.length; j < endj; j++) {\r\n                    const xsij = xsi[j][0]; // do not use holes\r\n                    const ysij = ysi[j][0]; // do not use holes\r\n                    if (xsij.length != 0 && ysij.length != 0) {\r\n                        const [xij0, xij1] = arrayable_1.minmax(xsij);\r\n                        const [yij0, yij1] = arrayable_1.minmax(ysij);\r\n                        xi0 = min(xi0, xij0);\r\n                        xi1 = max(xi1, xij1);\r\n                        yi0 = min(yi0, yij0);\r\n                        yi1 = max(yi1, yij1);\r\n                    }\r\n                }\r\n                if (!isFinite(xi0 + xi1 + yi0 + yi1))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(xi0, yi0, xi1, yi1);\r\n            }\r\n            this._hole_index = this._index_hole_data();\r\n        }\r\n        _index_hole_data() {\r\n            const { min, max } = Math;\r\n            const { data_size } = this;\r\n            const index = new spatial_1.SpatialIndex(data_size);\r\n            for (let i = 0; i < data_size; i++) {\r\n                const xsi = this._xs[i];\r\n                const ysi = this._ys[i];\r\n                if (xsi.length == 0 || ysi.length == 0) {\r\n                    index.add_empty();\r\n                    continue;\r\n                }\r\n                let xi0 = +Infinity;\r\n                let xi1 = -Infinity;\r\n                let yi0 = +Infinity;\r\n                let yi1 = -Infinity;\r\n                for (let j = 0, endj = xsi.length; j < endj; j++) {\r\n                    const xsij = xsi[j];\r\n                    const ysij = ysi[j];\r\n                    if (xsij.length > 1 && ysij.length > 1) {\r\n                        for (let k = 1, endk = xsij.length; k < endk; k++) {\r\n                            const [xij0, xij1] = arrayable_1.minmax(xsij[k]);\r\n                            const [yij0, yij1] = arrayable_1.minmax(ysij[k]);\r\n                            xi0 = min(xi0, xij0);\r\n                            xi1 = max(xi1, xij1);\r\n                            yi0 = min(yi0, yij0);\r\n                            yi1 = max(yi1, yij1);\r\n                        }\r\n                    }\r\n                }\r\n                if (!isFinite(xi0 + xi1 + yi0 + yi1))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(xi0, yi0, xi1, yi1);\r\n            }\r\n            index.finish();\r\n            return index;\r\n        }\r\n        _mask_data() {\r\n            const xr = this.renderer.plot_view.frame.x_range;\r\n            const [x0, x1] = [xr.min, xr.max];\r\n            const yr = this.renderer.plot_view.frame.y_range;\r\n            const [y0, y1] = [yr.min, yr.max];\r\n            return this.index.indices({ x0, x1, y0, y1 });\r\n        }\r\n        _inner_loop(ctx, sx, sy) {\r\n            ctx.beginPath();\r\n            for (let j = 0, endj = sx.length; j < endj; j++) {\r\n                for (let k = 0, endk = sx[j].length; k < endk; k++) {\r\n                    const _sx = sx[j][k];\r\n                    const _sy = sy[j][k];\r\n                    for (let l = 0, endl = _sx.length; l < endl; l++) {\r\n                        if (l == 0) {\r\n                            ctx.moveTo(_sx[l], _sy[l]);\r\n                            continue;\r\n                        }\r\n                        else\r\n                            ctx.lineTo(_sx[l], _sy[l]);\r\n                    }\r\n                    ctx.closePath();\r\n                }\r\n            }\r\n        }\r\n        _render(ctx, indices, { sxs, sys }) {\r\n            if (this.visuals.fill.doit || this.visuals.line.doit) {\r\n                for (const i of indices) {\r\n                    const [sx, sy] = [sxs[i], sys[i]];\r\n                    if (this.visuals.fill.doit) {\r\n                        this.visuals.fill.set_vectorize(ctx, i);\r\n                        this._inner_loop(ctx, sx, sy);\r\n                        ctx.fill(\"evenodd\");\r\n                    }\r\n                    this.visuals.hatch.doit2(ctx, i, () => {\r\n                        this._inner_loop(ctx, sx, sy);\r\n                        ctx.fill(\"evenodd\");\r\n                    }, () => this.renderer.request_render());\r\n                    if (this.visuals.line.doit) {\r\n                        this.visuals.line.set_vectorize(ctx, i);\r\n                        this._inner_loop(ctx, sx, sy);\r\n                        ctx.stroke();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _hit_rect(geometry) {\r\n            const { sx0, sx1, sy0, sy1 } = geometry;\r\n            const xs = [sx0, sx1, sx1, sx0];\r\n            const ys = [sy0, sy0, sy1, sy1];\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\r\n            const indices = [];\r\n            for (const index of candidates) {\r\n                const sxss = this.sxs[index];\r\n                const syss = this.sys[index];\r\n                let hit = true;\r\n                for (let j = 0, endj = sxss.length; j < endj; j++) {\r\n                    for (let k = 0, endk = sxss[j][0].length; k < endk; k++) {\r\n                        const sx = sxss[j][0][k];\r\n                        const sy = syss[j][0][k];\r\n                        if (!hittest.point_in_poly(sx, sy, xs, ys)) {\r\n                            hit = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!hit)\r\n                        break;\r\n                }\r\n                if (hit) {\r\n                    indices.push(index);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\r\n            const hole_candidates = this._hole_index.indices({ x0: x, y0: y, x1: x, y1: y });\r\n            const indices = [];\r\n            for (const index of candidates) {\r\n                const sxs = this.sxs[index];\r\n                const sys = this.sys[index];\r\n                for (let j = 0, endj = sxs.length; j < endj; j++) {\r\n                    const nk = sxs[j].length;\r\n                    if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0])) {\r\n                        if (nk == 1) {\r\n                            indices.push(index);\r\n                        }\r\n                        else if (!hole_candidates.get(index)) {\r\n                            indices.push(index);\r\n                        }\r\n                        else if (nk > 1) {\r\n                            let in_a_hole = false;\r\n                            for (let k = 1; k < nk; k++) {\r\n                                const sxs_k = sxs[j][k];\r\n                                const sys_k = sys[j][k];\r\n                                if (hittest.point_in_poly(sx, sy, sxs_k, sys_k)) {\r\n                                    in_a_hole = true;\r\n                                    break;\r\n                                }\r\n                                else {\r\n                                    continue;\r\n                                }\r\n                            }\r\n                            if (!in_a_hole) {\r\n                                indices.push(index);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _get_snap_coord(array) {\r\n            return arrayable_2.sum(array) / array.length;\r\n        }\r\n        scenterxy(i, sx, sy) {\r\n            if (this.sxs[i].length == 1) {\r\n                // We don't have discontinuous objects so we're ok\r\n                const scx = this._get_snap_coord(this.sxs[i][0][0]);\r\n                const scy = this._get_snap_coord(this.sys[i][0][0]);\r\n                return [scx, scy];\r\n            }\r\n            else {\r\n                // We have discontinuous objects, so we need to find which\r\n                // one we're in, we can use point_in_poly again\r\n                const sxs = this.sxs[i];\r\n                const sys = this.sys[i];\r\n                for (let j = 0, end = sxs.length; j < end; j++) {\r\n                    if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0])) {\r\n                        const scx = this._get_snap_coord(sxs[j][0]);\r\n                        const scy = this._get_snap_coord(sys[j][0]);\r\n                        return [scx, scy];\r\n                    }\r\n                }\r\n            }\r\n            assert_1.unreachable();\r\n        }\r\n        map_data() {\r\n            const n_i = this._xs.length;\r\n            this.sxs = new Array(n_i);\r\n            this.sys = new Array(n_i);\r\n            for (let i = 0; i < n_i; i++) {\r\n                const n_j = this._xs[i].length;\r\n                this.sxs[i] = new Array(n_j);\r\n                this.sys[i] = new Array(n_j);\r\n                for (let j = 0; j < n_j; j++) {\r\n                    const n_k = this._xs[i][j].length;\r\n                    this.sxs[i][j] = new Array(n_k);\r\n                    this.sys[i][j] = new Array(n_k);\r\n                    for (let k = 0; k < n_k; k++) {\r\n                        const [sx, sy] = this.renderer.coordinates.map_to_screen(this._xs[i][j][k], this._ys[i][j][k]);\r\n                        this.sxs[i][j][k] = sx;\r\n                        this.sys[i][j][k] = sy;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.MultiPolygonsView = MultiPolygonsView;\r\n    MultiPolygonsView.__name__ = \"MultiPolygonsView\";\r\n    class MultiPolygons extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MultiPolygons() {\r\n            this.prototype.default_view = MultiPolygonsView;\r\n            this.define({\r\n                xs: [p.XCoordinateSeqSeqSeqSpec, { field: \"xs\" }],\r\n                ys: [p.YCoordinateSeqSeqSeqSpec, { field: \"ys\" }],\r\n            });\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector, property_mixins_1.HatchVector]);\r\n        }\r\n    }\r\n    exports.MultiPolygons = MultiPolygons;\r\n    MultiPolygons.__name__ = \"MultiPolygons\";\r\n    MultiPolygons.init_MultiPolygons();\r\n}\r\n","/* models\\glyphs\\oval.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const ellipse_oval_1 = require(243) /* ./ellipse_oval */;\r\n    class OvalView extends ellipse_oval_1.EllipseOvalView {\r\n        _map_data() {\r\n            super._map_data();\r\n            // oval drawn from bezier curves = ellipse with width reduced by 3/4\r\n            const { sw } = this;\r\n            const n = sw.length;\r\n            for (let i = 0; i < n; i++) {\r\n                sw[i] *= 0.75;\r\n            }\r\n        }\r\n    }\r\n    exports.OvalView = OvalView;\r\n    OvalView.__name__ = \"OvalView\";\r\n    class Oval extends ellipse_oval_1.EllipseOval {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Oval() {\r\n            this.prototype.default_view = OvalView;\r\n        }\r\n    }\r\n    exports.Oval = Oval;\r\n    Oval.__name__ = \"Oval\";\r\n    Oval.init_Oval();\r\n}\r\n","/* models\\glyphs\\patches.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    class PatchesView extends glyph_1.GlyphView {\r\n        _project_data() {\r\n            projections_1.inplace.project_xy(this._xs.array, this._ys.array);\r\n        }\r\n        _index_data(index) {\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const xsi = this._xs.get(i);\r\n                const ysi = this._ys.get(i);\r\n                if (xsi.length == 0)\r\n                    index.add_empty();\r\n                else {\r\n                    const [x0, x1] = arrayable_1.minmax(xsi);\r\n                    const [y0, y1] = arrayable_1.minmax(ysi);\r\n                    index.add(x0, y0, x1, y1);\r\n                }\r\n            }\r\n        }\r\n        _mask_data() {\r\n            const xr = this.renderer.plot_view.frame.x_range;\r\n            const [x0, x1] = [xr.min, xr.max];\r\n            const yr = this.renderer.plot_view.frame.y_range;\r\n            const [y0, y1] = [yr.min, yr.max];\r\n            return this.index.indices({ x0, x1, y0, y1 });\r\n        }\r\n        _inner_loop(ctx, sx, sy, func) {\r\n            for (let j = 0, end = sx.length; j < end; j++) {\r\n                if (j == 0) {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx[j], sy[j]);\r\n                    continue;\r\n                }\r\n                else if (isNaN(sx[j] + sy[j])) {\r\n                    ctx.closePath();\r\n                    func.apply(ctx);\r\n                    ctx.beginPath();\r\n                    continue;\r\n                }\r\n                else\r\n                    ctx.lineTo(sx[j], sy[j]);\r\n            }\r\n            ctx.closePath();\r\n            func.call(ctx);\r\n        }\r\n        _render(ctx, indices, { sxs, sys }) {\r\n            for (const i of indices) {\r\n                const sx = sxs.get(i);\r\n                const sy = sys.get(i);\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    this._inner_loop(ctx, sx, sy, ctx.fill);\r\n                }\r\n                this.visuals.hatch.doit2(ctx, i, () => this._inner_loop(ctx, sx, sy, ctx.fill), () => this.renderer.request_render());\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    this._inner_loop(ctx, sx, sy, ctx.stroke);\r\n                }\r\n            }\r\n        }\r\n        _hit_rect(geometry) {\r\n            const { sx0, sx1, sy0, sy1 } = geometry;\r\n            const xs = [sx0, sx1, sx1, sx0];\r\n            const ys = [sy0, sy0, sy1, sy1];\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\r\n            const indices = [];\r\n            for (const index of candidates) {\r\n                const sxss = this.sxs.get(index);\r\n                const syss = this.sys.get(index);\r\n                let hit = true;\r\n                for (let j = 0, endj = sxss.length; j < endj; j++) {\r\n                    const sx = sxss[j];\r\n                    const sy = syss[j];\r\n                    if (!hittest.point_in_poly(sx, sy, xs, ys)) {\r\n                        hit = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (hit) {\r\n                    indices.push(index);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\r\n            const indices = [];\r\n            for (const index of candidates) {\r\n                const sxsi = this.sxs.get(index);\r\n                const sysi = this.sys.get(index);\r\n                const n = sxsi.length;\r\n                for (let k = 0, j = 0;; j++) {\r\n                    if (isNaN(sxsi[j]) || j == n) {\r\n                        const sxsi_kj = sxsi.subarray(k, j);\r\n                        const sysi_kj = sysi.subarray(k, j);\r\n                        if (hittest.point_in_poly(sx, sy, sxsi_kj, sysi_kj)) {\r\n                            indices.push(index);\r\n                            break;\r\n                        }\r\n                        k = j + 1;\r\n                    }\r\n                    if (j == n)\r\n                        break;\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _get_snap_coord(array) {\r\n            return arrayable_1.sum(array) / array.length;\r\n        }\r\n        scenterxy(i, sx, sy) {\r\n            const sxsi = this.sxs.get(i);\r\n            const sysi = this.sys.get(i);\r\n            const n = sxsi.length;\r\n            let has_nan = false;\r\n            for (let k = 0, j = 0;; j++) {\r\n                const this_nan = isNaN(sxsi[j]);\r\n                has_nan = has_nan || this_nan;\r\n                if (j == n && !has_nan) {\r\n                    const scx = this._get_snap_coord(sxsi);\r\n                    const scy = this._get_snap_coord(sysi);\r\n                    return [scx, scy];\r\n                }\r\n                if (this_nan || j == n) {\r\n                    const sxsi_kj = sxsi.subarray(k, j);\r\n                    const sysi_kj = sysi.subarray(k, j);\r\n                    if (hittest.point_in_poly(sx, sy, sxsi_kj, sysi_kj)) {\r\n                        const scx = this._get_snap_coord(sxsi_kj);\r\n                        const scy = this._get_snap_coord(sysi_kj);\r\n                        return [scx, scy];\r\n                    }\r\n                    k = j + 1;\r\n                }\r\n                if (j == n)\r\n                    break;\r\n            }\r\n            assert_1.unreachable();\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.PatchesView = PatchesView;\r\n    PatchesView.__name__ = \"PatchesView\";\r\n    class Patches extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Patches() {\r\n            this.prototype.default_view = PatchesView;\r\n            this.define({\r\n                xs: [p.XCoordinateSeqSpec, { field: \"xs\" }],\r\n                ys: [p.YCoordinateSeqSpec, { field: \"ys\" }],\r\n            });\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector, property_mixins_1.HatchVector]);\r\n        }\r\n    }\r\n    exports.Patches = Patches;\r\n    Patches.__name__ = \"Patches\";\r\n    Patches.init_Patches();\r\n}\r\n","/* models\\glyphs\\quad.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const box_1 = require(245) /* ./box */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class QuadView extends box_1.BoxView {\r\n        scenterxy(i) {\r\n            const scx = (this.sleft[i] + this.sright[i]) / 2;\r\n            const scy = (this.stop[i] + this.sbottom[i]) / 2;\r\n            return [scx, scy];\r\n        }\r\n        _lrtb(i) {\r\n            const l = this._left[i];\r\n            const r = this._right[i];\r\n            const t = this._top[i];\r\n            const b = this._bottom[i];\r\n            return [l, r, t, b];\r\n        }\r\n    }\r\n    exports.QuadView = QuadView;\r\n    QuadView.__name__ = \"QuadView\";\r\n    class Quad extends box_1.Box {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Quad() {\r\n            this.prototype.default_view = QuadView;\r\n            this.define({\r\n                right: [p.XCoordinateSpec, { field: \"right\" }],\r\n                bottom: [p.YCoordinateSpec, { field: \"bottom\" }],\r\n                left: [p.XCoordinateSpec, { field: \"left\" }],\r\n                top: [p.YCoordinateSpec, { field: \"top\" }],\r\n            });\r\n        }\r\n    }\r\n    exports.Quad = Quad;\r\n    Quad.__name__ = \"Quad\";\r\n    Quad.init_Quad();\r\n}\r\n","/* models\\glyphs\\quadratic.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    // Formula from: http://pomax.nihongoresources.com/pages/bezier/\r\n    //\r\n    // if segment is quadratic bezier do:\r\n    //   for both directions do:\r\n    //     if control between start and end, compute linear bounding box\r\n    //     otherwise, compute\r\n    //       bound = u(1-t)^2 + 2v(1-t)t + wt^2\r\n    //         (with t = ((u-v) / (u-2v+w)), with {u = start, v = control, w = end})\r\n    //       if control precedes start, min = bound, otherwise max = bound\r\n    function _qbb(u, v, w) {\r\n        if (v == (u + w) / 2)\r\n            return [u, w];\r\n        else {\r\n            const t = (u - v) / ((u - (2 * v)) + w);\r\n            const bd = (u * (1 - t) ** 2) + (2 * v * (1 - t) * t) + (w * t ** 2);\r\n            return [Math.min(u, w, bd), Math.max(u, w, bd)];\r\n        }\r\n    }\r\n    class QuadraticView extends glyph_1.GlyphView {\r\n        _project_data() {\r\n            projections_1.inplace.project_xy(this._x0, this._y0);\r\n            projections_1.inplace.project_xy(this._x1, this._y1);\r\n        }\r\n        _index_data(index) {\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx[i] + this._cy[i]))\r\n                    index.add_empty();\r\n                else {\r\n                    const [x0, x1] = _qbb(this._x0[i], this._cx[i], this._x1[i]);\r\n                    const [y0, y1] = _qbb(this._y0[i], this._cy[i], this._y1[i]);\r\n                    index.add(x0, y0, x1, y1);\r\n                }\r\n            }\r\n        }\r\n        _render(ctx, indices, { sx0, sy0, sx1, sy1, scx, scy }) {\r\n            if (this.visuals.line.doit) {\r\n                for (const i of indices) {\r\n                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx[i] + scy[i]))\r\n                        continue;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx0[i], sy0[i]);\r\n                    ctx.quadraticCurveTo(scx[i], scy[i], sx1[i], sy1[i]);\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n        scenterxy() {\r\n            throw new Error(`${this}.scenterxy() is not implemented`);\r\n        }\r\n    }\r\n    exports.QuadraticView = QuadraticView;\r\n    QuadraticView.__name__ = \"QuadraticView\";\r\n    class Quadratic extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Quadratic() {\r\n            this.prototype.default_view = QuadraticView;\r\n            this.define({\r\n                x0: [p.XCoordinateSpec, { field: \"x0\" }],\r\n                y0: [p.YCoordinateSpec, { field: \"y0\" }],\r\n                x1: [p.XCoordinateSpec, { field: \"x1\" }],\r\n                y1: [p.YCoordinateSpec, { field: \"y1\" }],\r\n                cx: [p.XCoordinateSpec, { field: \"cx\" }],\r\n                cy: [p.YCoordinateSpec, { field: \"cy\" }],\r\n            });\r\n            this.mixins(property_mixins_1.LineVector);\r\n        }\r\n    }\r\n    exports.Quadratic = Quadratic;\r\n    Quadratic.__name__ = \"Quadratic\";\r\n    Quadratic.init_Quadratic();\r\n}\r\n","/* models\\glyphs\\ray.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class RayView extends xy_glyph_1.XYGlyphView {\r\n        _map_data() {\r\n            if (this.model.properties.length.units == \"data\")\r\n                this.slength = this.sdist(this.renderer.xscale, this._x, this._length);\r\n            else\r\n                this.slength = this._length;\r\n        }\r\n        _render(ctx, indices, { sx, sy, slength, _angle }) {\r\n            if (this.visuals.line.doit) {\r\n                const width = this.renderer.plot_view.frame.bbox.width;\r\n                const height = this.renderer.plot_view.frame.bbox.height;\r\n                const inf_len = 2 * (width + height);\r\n                for (let i = 0, end = slength.length; i < end; i++) {\r\n                    if (slength[i] == 0)\r\n                        slength[i] = inf_len;\r\n                }\r\n                for (const i of indices) {\r\n                    if (isNaN(sx[i] + sy[i] + _angle[i] + slength[i]))\r\n                        continue;\r\n                    ctx.translate(sx[i], sy[i]);\r\n                    ctx.rotate(_angle[i]);\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(0, 0);\r\n                    ctx.lineTo(slength[i], 0);\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                    ctx.rotate(-_angle[i]);\r\n                    ctx.translate(-sx[i], -sy[i]);\r\n                }\r\n            }\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.RayView = RayView;\r\n    RayView.__name__ = \"RayView\";\r\n    class Ray extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Ray() {\r\n            this.prototype.default_view = RayView;\r\n            this.mixins(property_mixins_1.LineVector);\r\n            this.define({\r\n                length: [p.DistanceSpec],\r\n                angle: [p.AngleSpec],\r\n            });\r\n        }\r\n    }\r\n    exports.Ray = Ray;\r\n    Ray.__name__ = \"Ray\";\r\n    Ray.init_Ray();\r\n}\r\n","/* models\\glyphs\\rect.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const center_rotatable_1 = require(241) /* ./center_rotatable */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const arrayable_1 = require(12) /* ../../core/util/arrayable */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class RectView extends center_rotatable_1.CenterRotatableView {\r\n        _set_data() {\r\n            this.max_w2 = 0;\r\n            if (this.model.properties.width.units == \"data\")\r\n                this.max_w2 = this.max_width / 2;\r\n            this.max_h2 = 0;\r\n            if (this.model.properties.height.units == \"data\")\r\n                this.max_h2 = this.max_height / 2;\r\n        }\r\n        _map_data() {\r\n            if (this.model.properties.width.units == \"data\")\r\n                [this.sw, this.sx0] = this._map_dist_corner_for_data_side_length(this._x, this._width, this.renderer.xscale);\r\n            else {\r\n                this.sw = this._width;\r\n                const n = this.sx.length;\r\n                this.sx0 = new types_1.NumberArray(n);\r\n                for (let i = 0; i < n; i++)\r\n                    this.sx0[i] = this.sx[i] - this.sw[i] / 2;\r\n            }\r\n            if (this.model.properties.height.units == \"data\")\r\n                [this.sh, this.sy1] = this._map_dist_corner_for_data_side_length(this._y, this._height, this.renderer.yscale);\r\n            else {\r\n                this.sh = this._height;\r\n                const n = this.sy.length;\r\n                this.sy1 = new types_1.NumberArray(n);\r\n                for (let i = 0; i < n; i++)\r\n                    this.sy1[i] = this.sy[i] - this.sh[i] / 2;\r\n            }\r\n            const n = this.sw.length;\r\n            this.ssemi_diag = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++)\r\n                this.ssemi_diag[i] = Math.sqrt((this.sw[i] / 2 * this.sw[i]) / 2 + (this.sh[i] / 2 * this.sh[i]) / 2);\r\n        }\r\n        _render(ctx, indices, { sx, sy, sx0, sy1, sw, sh, _angle }) {\r\n            if (this.visuals.fill.doit) {\r\n                for (const i of indices) {\r\n                    if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i]))\r\n                        continue;\r\n                    //no need to test the return value, we call fillRect for every glyph anyway\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    if (_angle[i]) {\r\n                        ctx.translate(sx[i], sy[i]);\r\n                        ctx.rotate(_angle[i]);\r\n                        ctx.fillRect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\r\n                        ctx.rotate(-_angle[i]);\r\n                        ctx.translate(-sx[i], -sy[i]);\r\n                    }\r\n                    else\r\n                        ctx.fillRect(sx0[i], sy1[i], sw[i], sh[i]);\r\n                }\r\n            }\r\n            if (this.visuals.line.doit) {\r\n                ctx.beginPath();\r\n                for (const i of indices) {\r\n                    if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i]))\r\n                        continue;\r\n                    // fillRect does not fill zero-height or -width rects, but rect(...)\r\n                    // does seem to stroke them (1px wide or tall). Explicitly ignore rects\r\n                    // with zero width or height to be consistent\r\n                    if (sw[i] == 0 || sh[i] == 0)\r\n                        continue;\r\n                    if (_angle[i]) {\r\n                        ctx.translate(sx[i], sy[i]);\r\n                        ctx.rotate(_angle[i]);\r\n                        ctx.rect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\r\n                        ctx.rotate(-_angle[i]);\r\n                        ctx.translate(-sx[i], -sy[i]);\r\n                    }\r\n                    else\r\n                        ctx.rect(sx0[i], sy1[i], sw[i], sh[i]);\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                    ctx.beginPath();\r\n                }\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        _hit_rect(geometry) {\r\n            return this._hit_rect_against_index(geometry);\r\n        }\r\n        _hit_point(geometry) {\r\n            let { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            const n = this.sx0.length;\r\n            const scenter_x = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                scenter_x[i] = this.sx0[i] + this.sw[i] / 2;\r\n            }\r\n            const scenter_y = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                scenter_y[i] = this.sy1[i] + this.sh[i] / 2;\r\n            }\r\n            const max_x2_ddist = arrayable_1.max(this._ddist(0, scenter_x, this.ssemi_diag));\r\n            const max_y2_ddist = arrayable_1.max(this._ddist(1, scenter_y, this.ssemi_diag));\r\n            const x0 = x - max_x2_ddist;\r\n            const x1 = x + max_x2_ddist;\r\n            const y0 = y - max_y2_ddist;\r\n            const y1 = y + max_y2_ddist;\r\n            let width_in;\r\n            let height_in;\r\n            const indices = [];\r\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\r\n                if (this._angle[i]) {\r\n                    const s = Math.sin(-this._angle[i]);\r\n                    const c = Math.cos(-this._angle[i]);\r\n                    const px = c * (sx - this.sx[i]) - s * (sy - this.sy[i]) + this.sx[i];\r\n                    const py = s * (sx - this.sx[i]) + c * (sy - this.sy[i]) + this.sy[i];\r\n                    sx = px;\r\n                    sy = py;\r\n                    width_in = Math.abs(this.sx[i] - sx) <= this.sw[i] / 2;\r\n                    height_in = Math.abs(this.sy[i] - sy) <= this.sh[i] / 2;\r\n                }\r\n                else {\r\n                    const dx = sx - this.sx0[i];\r\n                    const dy = sy - this.sy1[i];\r\n                    width_in = 0 <= dx && dx <= this.sw[i];\r\n                    height_in = 0 <= dy && dy <= this.sh[i];\r\n                }\r\n                if (width_in && height_in) {\r\n                    indices.push(i);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _map_dist_corner_for_data_side_length(coord, side_length, scale) {\r\n            const n = coord.length;\r\n            const pt0 = new Float64Array(n);\r\n            const pt1 = new Float64Array(n);\r\n            for (let i = 0; i < n; i++) {\r\n                pt0[i] = coord[i] - side_length[i] / 2;\r\n                pt1[i] = coord[i] + side_length[i] / 2;\r\n            }\r\n            const spt0 = scale.v_compute(pt0);\r\n            const spt1 = scale.v_compute(pt1);\r\n            const sside_length = this.sdist(scale, pt0, side_length, 'edge', this.model.dilate);\r\n            let spt_corner = spt0;\r\n            for (let i = 0; i < n; i++) {\r\n                const spt0i = spt0[i];\r\n                const spt1i = spt1[i];\r\n                if (!isNaN(spt0i + spt1i) && spt0i != spt1i) {\r\n                    spt_corner = spt0i < spt1i ? spt0 : spt1;\r\n                    break;\r\n                }\r\n            }\r\n            return [sside_length, spt_corner];\r\n        }\r\n        _ddist(dim, spts, spans) {\r\n            const scale = dim == 0 ? this.renderer.xscale : this.renderer.yscale;\r\n            const spt0 = spts;\r\n            const m = spt0.length;\r\n            const spt1 = new types_1.NumberArray(m);\r\n            for (let i = 0; i < m; i++)\r\n                spt1[i] = spt0[i] + spans[i];\r\n            const pt0 = scale.v_invert(spt0);\r\n            const pt1 = scale.v_invert(spt1);\r\n            const n = pt0.length;\r\n            const ddist = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++)\r\n                ddist[i] = Math.abs(pt1[i] - pt0[i]);\r\n            return ddist;\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n        _bounds({ x0, x1, y0, y1 }) {\r\n            return {\r\n                x0: x0 - this.max_w2,\r\n                x1: x1 + this.max_w2,\r\n                y0: y0 - this.max_h2,\r\n                y1: y1 + this.max_h2,\r\n            };\r\n        }\r\n    }\r\n    exports.RectView = RectView;\r\n    RectView.__name__ = \"RectView\";\r\n    class Rect extends center_rotatable_1.CenterRotatable {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Rect() {\r\n            this.prototype.default_view = RectView;\r\n            this.define({\r\n                dilate: [p.Boolean, false],\r\n            });\r\n        }\r\n    }\r\n    exports.Rect = Rect;\r\n    Rect.__name__ = \"Rect\";\r\n    Rect.init_Rect();\r\n}\r\n","/* models\\glyphs\\segment.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    const glyph_1 = require(94) /* ./glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class SegmentView extends glyph_1.GlyphView {\r\n        _project_data() {\r\n            projections_1.inplace.project_xy(this._x0, this._y0);\r\n            projections_1.inplace.project_xy(this._x1, this._y1);\r\n        }\r\n        _index_data(index) {\r\n            const { min, max } = Math;\r\n            const { data_size } = this;\r\n            for (let i = 0; i < data_size; i++) {\r\n                const x0 = this._x0[i];\r\n                const x1 = this._x1[i];\r\n                const y0 = this._y0[i];\r\n                const y1 = this._y1[i];\r\n                if (isNaN(x0 + x1 + y0 + y1))\r\n                    index.add_empty();\r\n                else\r\n                    index.add(min(x0, x1), min(y0, y1), max(x0, x1), max(y0, y1));\r\n            }\r\n        }\r\n        _render(ctx, indices, { sx0, sy0, sx1, sy1 }) {\r\n            if (this.visuals.line.doit) {\r\n                for (const i of indices) {\r\n                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i]))\r\n                        continue;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx0[i], sy0[i]);\r\n                    ctx.lineTo(sx1[i], sy1[i]);\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const point = { x: sx, y: sy };\r\n            const lw_voffset = 2; // FIXME: Use maximum of segments line_width/2 instead of magic constant 2\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx - lw_voffset, sx + lw_voffset);\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy - lw_voffset, sy + lw_voffset);\r\n            const candidates = this.index.indices({ x0, y0, x1, y1 });\r\n            const indices = [];\r\n            for (const i of candidates) {\r\n                const threshold2 = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2) ** 2;\r\n                const p0 = { x: this.sx0[i], y: this.sy0[i] };\r\n                const p1 = { x: this.sx1[i], y: this.sy1[i] };\r\n                const dist2 = hittest.dist_to_segment_squared(point, p0, p1);\r\n                if (dist2 < threshold2) {\r\n                    indices.push(i);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_span(geometry) {\r\n            const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\r\n            const { sx, sy } = geometry;\r\n            let v0;\r\n            let v1;\r\n            let val;\r\n            if (geometry.direction == 'v') {\r\n                val = this.renderer.yscale.invert(sy);\r\n                [v0, v1] = [this._y0, this._y1];\r\n            }\r\n            else {\r\n                val = this.renderer.xscale.invert(sx);\r\n                [v0, v1] = [this._x0, this._x1];\r\n            }\r\n            const indices = [];\r\n            const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\r\n            const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\r\n            const candidates = this.index.indices({ x0, y0, x1, y1 });\r\n            for (const i of candidates) {\r\n                if ((v0[i] <= val && val <= v1[i]) || (v1[i] <= val && val <= v0[i]))\r\n                    indices.push(i);\r\n                const threshold = 1.5 + (this.visuals.line.cache_select('line_width', i) / 2); // Maximum pixel difference to detect hit\r\n                if (v0[i] == v1[i]) {\r\n                    if (geometry.direction == 'h') {\r\n                        if (Math.abs(this.sx0[i] - sx) <= threshold) {\r\n                            indices.push(i);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (Math.abs(this.sy0[i] - sy) <= threshold) {\r\n                            indices.push(i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        scenterxy(i) {\r\n            const scx = (this.sx0[i] + this.sx1[i]) / 2;\r\n            const scy = (this.sy0[i] + this.sy1[i]) / 2;\r\n            return [scx, scy];\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.SegmentView = SegmentView;\r\n    SegmentView.__name__ = \"SegmentView\";\r\n    class Segment extends glyph_1.Glyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Segment() {\r\n            this.prototype.default_view = SegmentView;\r\n            this.define({\r\n                x0: [p.XCoordinateSpec, { field: \"x0\" }],\r\n                y0: [p.YCoordinateSpec, { field: \"y0\" }],\r\n                x1: [p.XCoordinateSpec, { field: \"x1\" }],\r\n                y1: [p.YCoordinateSpec, { field: \"y1\" }],\r\n            });\r\n            this.mixins(property_mixins_1.LineVector);\r\n        }\r\n    }\r\n    exports.Segment = Segment;\r\n    Segment.__name__ = \"Segment\";\r\n    Segment.init_Segment();\r\n}\r\n","/* models\\glyphs\\step.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class StepView extends xy_glyph_1.XYGlyphView {\r\n        _render(ctx, indices, { sx, sy }) {\r\n            let drawing = false;\r\n            let last_index = null;\r\n            this.visuals.line.set_value(ctx);\r\n            const L = indices.length;\r\n            if (L < 2)\r\n                return;\r\n            ctx.beginPath();\r\n            ctx.moveTo(sx[0], sy[0]);\r\n            for (const i of indices) {\r\n                let x1, x2;\r\n                let y1, y2;\r\n                switch (this.model.mode) {\r\n                    case \"before\": {\r\n                        [x1, y1] = [sx[i - 1], sy[i]];\r\n                        [x2, y2] = [sx[i], sy[i]];\r\n                        break;\r\n                    }\r\n                    case \"after\": {\r\n                        [x1, y1] = [sx[i], sy[i - 1]];\r\n                        [x2, y2] = [sx[i], sy[i]];\r\n                        break;\r\n                    }\r\n                    case \"center\": {\r\n                        const xm = (sx[i - 1] + sx[i]) / 2;\r\n                        [x1, y1] = [xm, sy[i - 1]];\r\n                        [x2, y2] = [xm, sy[i]];\r\n                        break;\r\n                    }\r\n                    default:\r\n                        throw new Error(\"unexpected\");\r\n                }\r\n                if (drawing) {\r\n                    if (!isFinite(sx[i] + sy[i])) {\r\n                        ctx.stroke();\r\n                        ctx.beginPath();\r\n                        drawing = false;\r\n                        last_index = i;\r\n                        continue;\r\n                    }\r\n                    if (last_index != null && i - last_index > 1) {\r\n                        ctx.stroke();\r\n                        drawing = false;\r\n                    }\r\n                }\r\n                if (drawing) {\r\n                    ctx.lineTo(x1, y1);\r\n                    ctx.lineTo(x2, y2);\r\n                }\r\n                else {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(sx[i], sy[i]);\r\n                    drawing = true;\r\n                }\r\n                last_index = i;\r\n            }\r\n            ctx.lineTo(sx[L - 1], sy[L - 1]);\r\n            ctx.stroke();\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n    }\r\n    exports.StepView = StepView;\r\n    StepView.__name__ = \"StepView\";\r\n    class Step extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Step() {\r\n            this.prototype.default_view = StepView;\r\n            this.mixins(property_mixins_1.LineVector);\r\n            this.define({\r\n                mode: [p.StepMode, \"before\"],\r\n            });\r\n        }\r\n    }\r\n    exports.Step = Step;\r\n    Step.__name__ = \"Step\";\r\n    Step.init_Step();\r\n}\r\n","/* models\\glyphs\\text.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const text_1 = require(159) /* ../../core/util/text */;\r\n    const assert_1 = require(11) /* ../../core/util/assert */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class TextView extends xy_glyph_1.XYGlyphView {\r\n        _rotate_point(x, y, xoff, yoff, angle) {\r\n            const sxr = (x - xoff) * Math.cos(angle) - (y - yoff) * Math.sin(angle) + xoff;\r\n            const syr = (x - xoff) * Math.sin(angle) + (y - yoff) * Math.cos(angle) + yoff;\r\n            return [sxr, syr];\r\n        }\r\n        _text_bounds(x0, y0, width, height) {\r\n            const xvals = [x0, x0 + width, x0 + width, x0, x0];\r\n            const yvals = [y0, y0, y0 - height, y0 - height, y0];\r\n            return [xvals, yvals];\r\n        }\r\n        _render(ctx, indices, { sx, sy, _x_offset, _y_offset, _angle, _text }) {\r\n            this._sys = [];\r\n            this._sxs = [];\r\n            for (const i of indices) {\r\n                this._sxs[i] = [];\r\n                this._sys[i] = [];\r\n                if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || _text[i] == null)\r\n                    continue;\r\n                if (this.visuals.text.doit) {\r\n                    const text = `${_text[i]}`;\r\n                    ctx.save();\r\n                    ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);\r\n                    ctx.rotate(_angle[i]);\r\n                    this.visuals.text.set_vectorize(ctx, i);\r\n                    const font = this.visuals.text.cache_select(\"font\", i);\r\n                    const { height } = text_1.measure_font(font);\r\n                    const line_height = this.visuals.text.text_line_height.value() * height;\r\n                    if (text.indexOf(\"\\n\") == -1) {\r\n                        ctx.fillText(text, 0, 0);\r\n                        const x0 = sx[i] + _x_offset[i];\r\n                        const y0 = sy[i] + _y_offset[i];\r\n                        const width = ctx.measureText(text).width;\r\n                        const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\r\n                        this._sxs[i].push(xvalues);\r\n                        this._sys[i].push(yvalues);\r\n                    }\r\n                    else {\r\n                        const lines = text.split(\"\\n\");\r\n                        const block_height = line_height * lines.length;\r\n                        const baseline = this.visuals.text.cache_select(\"text_baseline\", i);\r\n                        let y;\r\n                        switch (baseline) {\r\n                            case \"top\": {\r\n                                y = 0;\r\n                                break;\r\n                            }\r\n                            case \"middle\": {\r\n                                y = (-block_height / 2) + (line_height / 2);\r\n                                break;\r\n                            }\r\n                            case \"bottom\": {\r\n                                y = -block_height + line_height;\r\n                                break;\r\n                            }\r\n                            default: {\r\n                                y = 0;\r\n                                console.warn(`'${baseline}' baseline not supported with multi line text`);\r\n                            }\r\n                        }\r\n                        for (const line of lines) {\r\n                            ctx.fillText(line, 0, y);\r\n                            const x0 = sx[i] + _x_offset[i];\r\n                            const y0 = y + sy[i] + _y_offset[i];\r\n                            const width = ctx.measureText(line).width;\r\n                            const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\r\n                            this._sxs[i].push(xvalues);\r\n                            this._sys[i].push(yvalues);\r\n                            y += line_height;\r\n                        }\r\n                    }\r\n                    ctx.restore();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const indices = [];\r\n            for (let i = 0; i < this._sxs.length; i++) {\r\n                const sxs = this._sxs[i];\r\n                const sys = this._sys[i];\r\n                const n = sxs.length;\r\n                for (let j = 0, endj = n; j < endj; j++) {\r\n                    const [sxr, syr] = this._rotate_point(sx, sy, sxs[n - 1][0], sys[n - 1][0], -this._angle[i]);\r\n                    if (hittest.point_in_poly(sxr, syr, sxs[j], sys[j])) {\r\n                        indices.push(i);\r\n                    }\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        scenterxy(i) {\r\n            const sxs = this._sxs[i];\r\n            const sys = this._sys[i];\r\n            assert_1.assert(sxs.length != 0 && sys.length != 0);\r\n            const sx0 = sxs[0][0];\r\n            const sy0 = sys[0][0];\r\n            const sxc = (sxs[0][2] + sx0) / 2;\r\n            const syc = (sys[0][2] + sy0) / 2;\r\n            const [sxcr, sycr] = this._rotate_point(sxc, syc, sx0, sy0, this._angle[i]);\r\n            return [sxcr, sycr];\r\n        }\r\n    }\r\n    exports.TextView = TextView;\r\n    TextView.__name__ = \"TextView\";\r\n    class Text extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Text() {\r\n            this.prototype.default_view = TextView;\r\n            this.mixins(property_mixins_1.TextVector);\r\n            this.define({\r\n                text: [p.NullStringSpec, { field: \"text\" }],\r\n                angle: [p.AngleSpec, 0],\r\n                x_offset: [p.NumberSpec, 0],\r\n                y_offset: [p.NumberSpec, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.Text = Text;\r\n    Text.__name__ = \"Text\";\r\n    Text.init_Text();\r\n}\r\n","/* models\\glyphs\\vbar.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const box_1 = require(245) /* ./box */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class VBarView extends box_1.BoxView {\r\n        scenterxy(i) {\r\n            const scx = this.sx[i];\r\n            const scy = (this.stop[i] + this.sbottom[i]) / 2;\r\n            return [scx, scy];\r\n        }\r\n        _lrtb(i) {\r\n            const l = this._x[i] - (this._width[i] / 2);\r\n            const r = this._x[i] + (this._width[i] / 2);\r\n            const t = Math.max(this._top[i], this._bottom[i]);\r\n            const b = Math.min(this._top[i], this._bottom[i]);\r\n            return [l, r, t, b];\r\n        }\r\n        _map_data() {\r\n            this.sx = this.renderer.xscale.v_compute(this._x);\r\n            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, \"center\");\r\n            this.stop = this.renderer.yscale.v_compute(this._top);\r\n            this.sbottom = this.renderer.yscale.v_compute(this._bottom);\r\n            const n = this.sx.length;\r\n            this.sleft = new types_1.NumberArray(n);\r\n            this.sright = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                this.sleft[i] = this.sx[i] - this.sw[i] / 2;\r\n                this.sright[i] = this.sx[i] + this.sw[i] / 2;\r\n            }\r\n            this._clamp_viewport();\r\n        }\r\n    }\r\n    exports.VBarView = VBarView;\r\n    VBarView.__name__ = \"VBarView\";\r\n    class VBar extends box_1.Box {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_VBar() {\r\n            this.prototype.default_view = VBarView;\r\n            this.define({\r\n                x: [p.XCoordinateSpec, { field: \"x\" }],\r\n                bottom: [p.YCoordinateSpec, { value: 0 }],\r\n                width: [p.NumberSpec, { value: 1 }],\r\n                top: [p.YCoordinateSpec, { field: \"top\" }],\r\n            });\r\n        }\r\n    }\r\n    exports.VBar = VBar;\r\n    VBar.__name__ = \"VBar\";\r\n    VBar.init_VBar();\r\n}\r\n","/* models\\glyphs\\wedge.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ./xy_glyph */;\r\n    const utils_1 = require(100) /* ./utils */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const math_1 = require(10) /* ../../core/util/math */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class WedgeView extends xy_glyph_1.XYGlyphView {\r\n        _map_data() {\r\n            if (this.model.properties.radius.units == \"data\")\r\n                this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\r\n            else\r\n                this.sradius = this._radius;\r\n        }\r\n        _render(ctx, indices, { sx, sy, sradius, _start_angle, _end_angle }) {\r\n            const direction = this.model.properties.direction.value();\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i]))\r\n                    continue;\r\n                ctx.beginPath();\r\n                ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\r\n                ctx.lineTo(sx[i], sy[i]);\r\n                ctx.closePath();\r\n                if (this.visuals.fill.doit) {\r\n                    this.visuals.fill.set_vectorize(ctx, i);\r\n                    ctx.fill();\r\n                }\r\n                if (this.visuals.line.doit) {\r\n                    this.visuals.line.set_vectorize(ctx, i);\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        }\r\n        _hit_point(geometry) {\r\n            let dist, sx0, sx1, sy0, sy1, x0, x1, y0, y1;\r\n            const { sx, sy } = geometry;\r\n            const x = this.renderer.xscale.invert(sx);\r\n            const y = this.renderer.yscale.invert(sy);\r\n            // check diameter first\r\n            const max_diameter = 2 * this.max_radius;\r\n            if (this.model.properties.radius.units === \"data\") {\r\n                x0 = x - max_diameter;\r\n                x1 = x + max_diameter;\r\n                y0 = y - max_diameter;\r\n                y1 = y + max_diameter;\r\n            }\r\n            else {\r\n                sx0 = sx - max_diameter;\r\n                sx1 = sx + max_diameter;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n                sy0 = sy - max_diameter;\r\n                sy1 = sy + max_diameter;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            }\r\n            const candidates = [];\r\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\r\n                const r2 = this.sradius[i] ** 2;\r\n                [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\r\n                [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\r\n                dist = (sx0 - sx1) ** 2 + (sy0 - sy1) ** 2;\r\n                if (dist <= r2) {\r\n                    candidates.push(i);\r\n                }\r\n            }\r\n            const direction = this.model.properties.direction.value();\r\n            const indices = [];\r\n            for (const i of candidates) {\r\n                // NOTE: minus the angle because JS uses non-mathy convention for angles\r\n                const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\r\n                if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\r\n                    indices.push(i);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        draw_legend_for_index(ctx, bbox, index) {\r\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\r\n        }\r\n        scenterxy(i) {\r\n            const r = this.sradius[i] / 2;\r\n            const a = (this._start_angle[i] + this._end_angle[i]) / 2;\r\n            const scx = this.sx[i] + r * Math.cos(a);\r\n            const scy = this.sy[i] + r * Math.sin(a);\r\n            return [scx, scy];\r\n        }\r\n    }\r\n    exports.WedgeView = WedgeView;\r\n    WedgeView.__name__ = \"WedgeView\";\r\n    class Wedge extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Wedge() {\r\n            this.prototype.default_view = WedgeView;\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.define({\r\n                direction: [p.Direction, 'anticlock'],\r\n                radius: [p.DistanceSpec],\r\n                start_angle: [p.AngleSpec],\r\n                end_angle: [p.AngleSpec],\r\n            });\r\n        }\r\n    }\r\n    exports.Wedge = Wedge;\r\n    Wedge.__name__ = \"Wedge\";\r\n    Wedge.init_Wedge();\r\n}\r\n","/* models\\graphs\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    tslib_1.__exportStar(require(117) /* ./graph_hit_test_policy */, exports);\r\n    tslib_1.__exportStar(require(266) /* ./layout_provider */, exports);\r\n    tslib_1.__exportStar(require(267) /* ./static_layout_provider */, exports);\r\n}\r\n","/* models\\graphs\\layout_provider.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    class LayoutProvider extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.LayoutProvider = LayoutProvider;\r\n    LayoutProvider.__name__ = \"LayoutProvider\";\r\n}\r\n","/* models\\graphs\\static_layout_provider.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const layout_provider_1 = require(266) /* ./layout_provider */;\r\n    const types_1 = require(24) /* ../../core/types */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class StaticLayoutProvider extends layout_provider_1.LayoutProvider {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_StaticLayoutProvider() {\r\n            this.define({\r\n                graph_layout: [p.Any, {}],\r\n            });\r\n        }\r\n        get_node_coordinates(node_source) {\r\n            const index = node_source.data.index;\r\n            const n = index.length;\r\n            const xs = new types_1.NumberArray(n);\r\n            const ys = new types_1.NumberArray(n);\r\n            for (let i = 0; i < n; i++) {\r\n                const point = this.graph_layout[index[i]];\r\n                const [x, y] = point !== null && point !== void 0 ? point : [NaN, NaN];\r\n                xs[i] = x;\r\n                ys[i] = y;\r\n            }\r\n            return [xs, ys];\r\n        }\r\n        get_edge_coordinates(edge_source) {\r\n            const starts = edge_source.data.start;\r\n            const ends = edge_source.data.end;\r\n            const n = starts.length;\r\n            const xs = [];\r\n            const ys = [];\r\n            const has_paths = edge_source.data.xs != null && edge_source.data.ys != null;\r\n            for (let i = 0; i < n; i++) {\r\n                const in_layout = this.graph_layout[starts[i]] != null && this.graph_layout[ends[i]] != null;\r\n                if (has_paths && in_layout) {\r\n                    xs.push(edge_source.data.xs[i]);\r\n                    ys.push(edge_source.data.ys[i]);\r\n                }\r\n                else {\r\n                    let start, end;\r\n                    if (in_layout) {\r\n                        start = this.graph_layout[starts[i]];\r\n                        end = this.graph_layout[ends[i]];\r\n                    }\r\n                    else {\r\n                        start = [NaN, NaN];\r\n                        end = [NaN, NaN];\r\n                    }\r\n                    xs.push([start[0], end[0]]);\r\n                    ys.push([start[1], end[1]]);\r\n                }\r\n            }\r\n            return [xs, ys];\r\n        }\r\n    }\r\n    exports.StaticLayoutProvider = StaticLayoutProvider;\r\n    StaticLayoutProvider.__name__ = \"StaticLayoutProvider\";\r\n    StaticLayoutProvider.init_StaticLayoutProvider();\r\n}\r\n","/* models\\grids\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var grid_1 = require(269) /* ./grid */;\r\n    exports.Grid = grid_1.Grid;\r\n}\r\n","/* models\\grids\\grid.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const guide_renderer_1 = require(178) /* ../renderers/guide_renderer */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    class GridView extends guide_renderer_1.GuideRendererView {\r\n        _render() {\r\n            const ctx = this.layer.ctx;\r\n            ctx.save();\r\n            this._draw_regions(ctx);\r\n            this._draw_minor_grids(ctx);\r\n            this._draw_grids(ctx);\r\n            ctx.restore();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.request_render());\r\n        }\r\n        _draw_regions(ctx) {\r\n            if (!this.visuals.band_fill.doit && !this.visuals.band_hatch.doit)\r\n                return;\r\n            this.visuals.band_fill.set_value(ctx);\r\n            const [xs, ys] = this.grid_coords('major', false);\r\n            for (let i = 0; i < xs.length - 1; i++) {\r\n                if (i % 2 != 1)\r\n                    continue;\r\n                const [sx0, sy0] = this.coordinates.map_to_screen(xs[i], ys[i]);\r\n                const [sx1, sy1] = this.coordinates.map_to_screen(xs[i + 1], ys[i + 1]);\r\n                if (this.visuals.band_fill.doit)\r\n                    ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\r\n                this.visuals.band_hatch.doit2(ctx, i, () => {\r\n                    ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\r\n                }, () => this.request_render());\r\n            }\r\n        }\r\n        _draw_grids(ctx) {\r\n            if (!this.visuals.grid_line.doit)\r\n                return;\r\n            const [xs, ys] = this.grid_coords('major');\r\n            this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);\r\n        }\r\n        _draw_minor_grids(ctx) {\r\n            if (!this.visuals.minor_grid_line.doit)\r\n                return;\r\n            const [xs, ys] = this.grid_coords('minor');\r\n            this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);\r\n        }\r\n        _draw_grid_helper(ctx, visuals, xs, ys) {\r\n            visuals.set_value(ctx);\r\n            ctx.beginPath();\r\n            for (let i = 0; i < xs.length; i++) {\r\n                const [sx, sy] = this.coordinates.map_to_screen(xs[i], ys[i]);\r\n                ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));\r\n                for (let i = 1; i < sx.length; i++) {\r\n                    ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));\r\n                }\r\n            }\r\n            ctx.stroke();\r\n        }\r\n        // {{{ TODO: state\r\n        ranges() {\r\n            const i = this.model.dimension;\r\n            const j = (i + 1) % 2;\r\n            const { ranges } = this.coordinates;\r\n            return [ranges[i], ranges[j]];\r\n        }\r\n        computed_bounds() {\r\n            const [range] = this.ranges();\r\n            const user_bounds = this.model.bounds;\r\n            const range_bounds = [range.min, range.max];\r\n            let start;\r\n            let end;\r\n            if (types_1.isArray(user_bounds)) {\r\n                start = Math.min(user_bounds[0], user_bounds[1]);\r\n                end = Math.max(user_bounds[0], user_bounds[1]);\r\n                if (start < range_bounds[0])\r\n                    start = range_bounds[0];\r\n                // XXX:\r\n                //else if (start > range_bounds[1])\r\n                //  start = null\r\n                if (end > range_bounds[1])\r\n                    end = range_bounds[1];\r\n                // XXX:\r\n                //else if (end < range_bounds[0])\r\n                //  end = null\r\n            }\r\n            else {\r\n                [start, end] = range_bounds;\r\n                for (const axis_view of this.plot_view.axis_views) {\r\n                    if (axis_view.dimension == this.model.dimension\r\n                        && axis_view.model.x_range_name == this.model.x_range_name\r\n                        && axis_view.model.y_range_name == this.model.y_range_name) {\r\n                        [start, end] = axis_view.computed_bounds;\r\n                    }\r\n                }\r\n            }\r\n            return [start, end];\r\n        }\r\n        grid_coords(location, exclude_ends = true) {\r\n            const i = this.model.dimension;\r\n            const j = (i + 1) % 2;\r\n            const [range, cross_range] = this.ranges();\r\n            let [start, end] = this.computed_bounds();\r\n            [start, end] = [Math.min(start, end), Math.max(start, end)];\r\n            const coords = [[], []];\r\n            // TODO: (bev) using cross_range.min for cross_loc is a bit of a cheat. Since we\r\n            // currently only support \"straight line\" grids, this should be OK for now. If\r\n            // we ever want to support \"curved\" grids, e.g. for some projections, we may\r\n            // have to communicate more than just a single cross location.\r\n            const ticker = this.model.get_ticker();\r\n            if (ticker == null) {\r\n                return coords;\r\n            }\r\n            const ticks = ticker.get_ticks(start, end, range, cross_range.min, {})[location];\r\n            const min = range.min;\r\n            const max = range.max;\r\n            const cmin = cross_range.min;\r\n            const cmax = cross_range.max;\r\n            if (!exclude_ends) {\r\n                if (ticks[0] != min)\r\n                    ticks.splice(0, 0, min);\r\n                if (ticks[ticks.length - 1] != max)\r\n                    ticks.push(max);\r\n            }\r\n            for (let ii = 0; ii < ticks.length; ii++) {\r\n                if ((ticks[ii] == min || ticks[ii] == max) && exclude_ends)\r\n                    continue;\r\n                const dim_i = [];\r\n                const dim_j = [];\r\n                const N = 2;\r\n                for (let n = 0; n < N; n++) {\r\n                    const loc = cmin + (cmax - cmin) / (N - 1) * n;\r\n                    dim_i.push(ticks[ii]);\r\n                    dim_j.push(loc);\r\n                }\r\n                coords[i].push(dim_i);\r\n                coords[j].push(dim_j);\r\n            }\r\n            return coords;\r\n        }\r\n    }\r\n    exports.GridView = GridView;\r\n    GridView.__name__ = \"GridView\";\r\n    class Grid extends guide_renderer_1.GuideRenderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Grid() {\r\n            this.prototype.default_view = GridView;\r\n            this.mixins([\r\n                [\"grid_\", mixins.Line],\r\n                [\"minor_grid_\", mixins.Line],\r\n                [\"band_\", mixins.Fill],\r\n                [\"band_\", mixins.Hatch],\r\n            ]);\r\n            this.define({\r\n                bounds: [p.Any, 'auto'],\r\n                dimension: [p.Any, 0],\r\n                axis: [p.Instance],\r\n                ticker: [p.Instance],\r\n            });\r\n            this.override({\r\n                level: \"underlay\",\r\n                band_fill_color: null,\r\n                band_fill_alpha: 0,\r\n                grid_line_color: '#e5e5e5',\r\n                minor_grid_line_color: null,\r\n            });\r\n        }\r\n        get_ticker() {\r\n            if (this.ticker != null) {\r\n                return this.ticker;\r\n            }\r\n            if (this.axis != null) {\r\n                return this.axis.ticker;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    exports.Grid = Grid;\r\n    Grid.__name__ = \"Grid\";\r\n    Grid.init_Grid();\r\n}\r\n","/* models\\layouts\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var box_1 = require(271) /* ./box */;\r\n    exports.Box = box_1.Box;\r\n    var column_1 = require(274) /* ./column */;\r\n    exports.Column = column_1.Column;\r\n    var grid_box_1 = require(275) /* ./grid_box */;\r\n    exports.GridBox = grid_box_1.GridBox;\r\n    var html_box_1 = require(276) /* ./html_box */;\r\n    exports.HTMLBox = html_box_1.HTMLBox;\r\n    var layout_dom_1 = require(272) /* ./layout_dom */;\r\n    exports.LayoutDOM = layout_dom_1.LayoutDOM;\r\n    var row_1 = require(277) /* ./row */;\r\n    exports.Row = row_1.Row;\r\n    var spacer_1 = require(278) /* ./spacer */;\r\n    exports.Spacer = spacer_1.Spacer;\r\n    var tabs_1 = require(279) /* ./tabs */;\r\n    exports.Panel = tabs_1.Panel;\r\n    exports.Tabs = tabs_1.Tabs;\r\n    var widget_box_1 = require(286) /* ./widget_box */;\r\n    exports.WidgetBox = widget_box_1.WidgetBox;\r\n}\r\n","/* models\\layouts\\box.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const layout_dom_1 = require(272) /* ./layout_dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class BoxView extends layout_dom_1.LayoutDOMView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.children.change, () => this.rebuild());\r\n        }\r\n        get child_models() {\r\n            return this.model.children;\r\n        }\r\n    }\r\n    exports.BoxView = BoxView;\r\n    BoxView.__name__ = \"BoxView\";\r\n    class Box extends layout_dom_1.LayoutDOM {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Box() {\r\n            this.define({\r\n                children: [p.Array, []],\r\n                spacing: [p.Number, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.Box = Box;\r\n    Box.__name__ = \"Box\";\r\n    Box.init_Box();\r\n}\r\n","/* models\\layouts\\layout_dom.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const model_1 = require(81) /* ../../model */;\r\n    const enums_1 = require(20) /* ../../core/enums */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const build_views_1 = require(115) /* ../../core/build_views */;\r\n    const dom_view_1 = require(78) /* ../../core/dom_view */;\r\n    const layout_1 = require(212) /* ../../core/layout */;\r\n    const root_1 = require(273) /* ../../styles/root */;\r\n    const canvas_1 = require(77) /* ../canvas/canvas */;\r\n    class LayoutDOMView extends dom_view_1.DOMView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._idle_notified = false;\r\n            this._offset_parent = null;\r\n            this._viewport = {};\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.el.style.position = this.is_root ? \"relative\" : \"absolute\";\r\n            this._child_views = new Map();\r\n        }\r\n        async lazy_initialize() {\r\n            await this.build_child_views();\r\n        }\r\n        remove() {\r\n            for (const child_view of this.child_views)\r\n                child_view.remove();\r\n            this._child_views.clear();\r\n            super.remove();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            if (this.is_root) {\r\n                this._on_resize = () => this.resize_layout();\r\n                window.addEventListener(\"resize\", this._on_resize);\r\n                this._parent_observer = setInterval(() => {\r\n                    const offset_parent = this.el.offsetParent;\r\n                    if (this._offset_parent != offset_parent) {\r\n                        this._offset_parent = offset_parent;\r\n                        if (offset_parent != null) {\r\n                            this.compute_viewport();\r\n                            this.invalidate_layout();\r\n                        }\r\n                    }\r\n                }, 250);\r\n            }\r\n            const p = this.model.properties;\r\n            this.on_change([\r\n                p.width, p.height,\r\n                p.min_width, p.min_height,\r\n                p.max_width, p.max_height,\r\n                p.margin,\r\n                p.width_policy, p.height_policy, p.sizing_mode,\r\n                p.aspect_ratio,\r\n                p.visible,\r\n            ], () => this.invalidate_layout());\r\n            this.on_change([\r\n                p.background,\r\n                p.css_classes,\r\n            ], () => this.invalidate_render());\r\n        }\r\n        disconnect_signals() {\r\n            if (this._parent_observer != null)\r\n                clearTimeout(this._parent_observer);\r\n            if (this._on_resize != null)\r\n                window.removeEventListener(\"resize\", this._on_resize);\r\n            super.disconnect_signals();\r\n        }\r\n        css_classes() {\r\n            return super.css_classes().concat(this.model.css_classes);\r\n        }\r\n        get child_views() {\r\n            return this.child_models.map((child) => this._child_views.get(child));\r\n        }\r\n        async build_child_views() {\r\n            await build_views_1.build_views(this._child_views, this.child_models, { parent: this });\r\n        }\r\n        render() {\r\n            super.render();\r\n            dom_1.empty(this.el); // XXX: this should be in super\r\n            const { background } = this.model;\r\n            this.el.style.backgroundColor = background != null ? background : \"\";\r\n            dom_1.classes(this.el).clear().add(...this.css_classes());\r\n            for (const child_view of this.child_views) {\r\n                this.el.appendChild(child_view.el);\r\n                child_view.render();\r\n            }\r\n        }\r\n        update_layout() {\r\n            for (const child_view of this.child_views)\r\n                child_view.update_layout();\r\n            this._update_layout();\r\n        }\r\n        update_position() {\r\n            this.el.style.display = this.model.visible ? \"block\" : \"none\";\r\n            const margin = this.is_root ? this.layout.sizing.margin : undefined;\r\n            dom_1.position(this.el, this.layout.bbox, margin);\r\n            for (const child_view of this.child_views)\r\n                child_view.update_position();\r\n        }\r\n        after_layout() {\r\n            for (const child_view of this.child_views)\r\n                child_view.after_layout();\r\n            this._has_finished = true;\r\n        }\r\n        compute_viewport() {\r\n            this._viewport = this._viewport_size();\r\n        }\r\n        renderTo(element) {\r\n            element.appendChild(this.el);\r\n            this._offset_parent = this.el.offsetParent;\r\n            this.compute_viewport();\r\n            this.build();\r\n        }\r\n        build() {\r\n            this.assert_root();\r\n            this.render();\r\n            this.update_layout();\r\n            this.compute_layout();\r\n            return this;\r\n        }\r\n        async rebuild() {\r\n            await this.build_child_views();\r\n            this.invalidate_render();\r\n        }\r\n        compute_layout() {\r\n            const start = Date.now();\r\n            this.layout.compute(this._viewport);\r\n            this.update_position();\r\n            this.after_layout();\r\n            logging_1.logger.debug(`layout computed in ${Date.now() - start} ms`);\r\n            this.notify_finished();\r\n        }\r\n        resize_layout() {\r\n            this.root.compute_viewport();\r\n            this.root.compute_layout();\r\n        }\r\n        invalidate_layout() {\r\n            this.root.update_layout();\r\n            this.root.compute_layout();\r\n        }\r\n        invalidate_render() {\r\n            this.render();\r\n            this.invalidate_layout();\r\n        }\r\n        has_finished() {\r\n            if (!super.has_finished())\r\n                return false;\r\n            for (const child_view of this.child_views) {\r\n                if (!child_view.has_finished())\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        notify_finished() {\r\n            if (!this.is_root)\r\n                this.root.notify_finished();\r\n            else {\r\n                if (!this._idle_notified && this.has_finished()) {\r\n                    if (this.model.document != null) {\r\n                        this._idle_notified = true;\r\n                        this.model.document.notify_idle(this.model);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _width_policy() {\r\n            return this.model.width != null ? \"fixed\" : \"fit\";\r\n        }\r\n        _height_policy() {\r\n            return this.model.height != null ? \"fixed\" : \"fit\";\r\n        }\r\n        box_sizing() {\r\n            let { width_policy, height_policy, aspect_ratio } = this.model;\r\n            if (width_policy == \"auto\")\r\n                width_policy = this._width_policy();\r\n            if (height_policy == \"auto\")\r\n                height_policy = this._height_policy();\r\n            const { sizing_mode } = this.model;\r\n            if (sizing_mode != null) {\r\n                if (sizing_mode == \"fixed\")\r\n                    width_policy = height_policy = \"fixed\";\r\n                else if (sizing_mode == \"stretch_both\")\r\n                    width_policy = height_policy = \"max\";\r\n                else if (sizing_mode == \"stretch_width\")\r\n                    width_policy = \"max\";\r\n                else if (sizing_mode == \"stretch_height\")\r\n                    height_policy = \"max\";\r\n                else {\r\n                    if (aspect_ratio == null)\r\n                        aspect_ratio = \"auto\";\r\n                    switch (sizing_mode) {\r\n                        case \"scale_width\":\r\n                            width_policy = \"max\";\r\n                            height_policy = \"min\";\r\n                            break;\r\n                        case \"scale_height\":\r\n                            width_policy = \"min\";\r\n                            height_policy = \"max\";\r\n                            break;\r\n                        case \"scale_both\":\r\n                            width_policy = \"max\";\r\n                            height_policy = \"max\";\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            const sizing = { width_policy, height_policy };\r\n            const { min_width, min_height } = this.model;\r\n            if (min_width != null)\r\n                sizing.min_width = min_width;\r\n            if (min_height != null)\r\n                sizing.min_height = min_height;\r\n            const { width, height } = this.model;\r\n            if (width != null)\r\n                sizing.width = width;\r\n            if (height != null)\r\n                sizing.height = height;\r\n            const { max_width, max_height } = this.model;\r\n            if (max_width != null)\r\n                sizing.max_width = max_width;\r\n            if (max_height != null)\r\n                sizing.max_height = max_height;\r\n            if (aspect_ratio == \"auto\" && width != null && height != null)\r\n                sizing.aspect = width / height;\r\n            else if (types_1.isNumber(aspect_ratio))\r\n                sizing.aspect = aspect_ratio;\r\n            const { margin } = this.model;\r\n            if (margin != null) {\r\n                if (types_1.isNumber(margin))\r\n                    sizing.margin = { top: margin, right: margin, bottom: margin, left: margin };\r\n                else if (margin.length == 2) {\r\n                    const [vertical, horizontal] = margin;\r\n                    sizing.margin = { top: vertical, right: horizontal, bottom: vertical, left: horizontal };\r\n                }\r\n                else {\r\n                    const [top, right, bottom, left] = margin;\r\n                    sizing.margin = { top, right, bottom, left };\r\n                }\r\n            }\r\n            sizing.visible = this.model.visible;\r\n            const { align } = this.model;\r\n            if (types_1.isArray(align))\r\n                [sizing.halign, sizing.valign] = align;\r\n            else\r\n                sizing.halign = sizing.valign = align;\r\n            return sizing;\r\n        }\r\n        _viewport_size() {\r\n            return dom_1.undisplayed(this.el, () => {\r\n                let measuring = this.el;\r\n                while (measuring = measuring.parentElement) {\r\n                    // .bk-root element doesn't bring any value\r\n                    if (measuring.classList.contains(root_1.bk_root))\r\n                        continue;\r\n                    // we reached <body> element, so use viewport size\r\n                    if (measuring == document.body) {\r\n                        const { margin: { left, right, top, bottom } } = dom_1.extents(document.body);\r\n                        const width = Math.ceil(document.documentElement.clientWidth - left - right);\r\n                        const height = Math.ceil(document.documentElement.clientHeight - top - bottom);\r\n                        return { width, height };\r\n                    }\r\n                    // stop on first element with sensible dimensions\r\n                    const { padding: { left, right, top, bottom } } = dom_1.extents(measuring);\r\n                    const { width, height } = measuring.getBoundingClientRect();\r\n                    const inner_width = Math.ceil(width - left - right);\r\n                    const inner_height = Math.ceil(height - top - bottom);\r\n                    if (inner_width > 0 || inner_height > 0)\r\n                        return {\r\n                            width: inner_width > 0 ? inner_width : undefined,\r\n                            height: inner_height > 0 ? inner_height : undefined,\r\n                        };\r\n                }\r\n                // this element is detached from DOM\r\n                return {};\r\n            });\r\n        }\r\n        export(type, hidpi = true) {\r\n            const output_backend = type == \"png\" ? \"canvas\" : \"svg\";\r\n            const composite = new canvas_1.CanvasLayer(output_backend, hidpi);\r\n            const { width, height } = this.layout.bbox;\r\n            composite.resize(width, height);\r\n            for (const view of this.child_views) {\r\n                const region = view.export(type, hidpi);\r\n                const { x, y } = view.layout.bbox;\r\n                composite.ctx.drawImage(region.canvas, x, y);\r\n            }\r\n            return composite;\r\n        }\r\n        serializable_state() {\r\n            return Object.assign(Object.assign({}, super.serializable_state()), { bbox: this.layout.bbox.box, children: this.child_views.map((child) => child.serializable_state()) });\r\n        }\r\n    }\r\n    exports.LayoutDOMView = LayoutDOMView;\r\n    LayoutDOMView.__name__ = \"LayoutDOMView\";\r\n    class LayoutDOM extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LayoutDOM() {\r\n            this.define((types) => {\r\n                const { Boolean, Number, String, Null, Auto, Color, Array, Tuple, Or } = types;\r\n                const Number2 = Tuple(Number, Number);\r\n                const Number4 = Tuple(Number, Number, Number, Number);\r\n                return {\r\n                    width: [Or(Number, Null), null],\r\n                    height: [Or(Number, Null), null],\r\n                    min_width: [Or(Number, Null), null],\r\n                    min_height: [Or(Number, Null), null],\r\n                    max_width: [Or(Number, Null), null],\r\n                    max_height: [Or(Number, Null), null],\r\n                    margin: [Or(Number, Number2, Number4), [0, 0, 0, 0]],\r\n                    width_policy: [Or(layout_1.SizingPolicy, Auto), \"auto\"],\r\n                    height_policy: [Or(layout_1.SizingPolicy, Auto), \"auto\"],\r\n                    aspect_ratio: [Or(Number, Auto, Null), null],\r\n                    sizing_mode: [Or(enums_1.SizingMode, Null), null],\r\n                    visible: [Boolean, true],\r\n                    disabled: [Boolean, false],\r\n                    align: [Or(enums_1.Align, Tuple(enums_1.Align, enums_1.Align)), \"start\"],\r\n                    background: [Or(Color, Null), null],\r\n                    css_classes: [Array(String), []],\r\n                };\r\n            });\r\n        }\r\n    }\r\n    exports.LayoutDOM = LayoutDOM;\r\n    LayoutDOM.__name__ = \"LayoutDOM\";\r\n    LayoutDOM.init_LayoutDOM();\r\n}\r\n","/* styles\\root.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_root = \"bk-root\";\r\n}\r\n","/* models\\layouts\\column.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const box_1 = require(271) /* ./box */;\r\n    const grid_1 = require(216) /* ../../core/layout/grid */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class ColumnView extends box_1.BoxView {\r\n        _update_layout() {\r\n            const items = this.child_views.map((child) => child.layout);\r\n            this.layout = new grid_1.Column(items);\r\n            this.layout.rows = this.model.rows;\r\n            this.layout.spacing = [this.model.spacing, 0];\r\n            this.layout.set_sizing(this.box_sizing());\r\n        }\r\n    }\r\n    exports.ColumnView = ColumnView;\r\n    ColumnView.__name__ = \"ColumnView\";\r\n    class Column extends box_1.Box {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Column() {\r\n            this.prototype.default_view = ColumnView;\r\n            this.define({\r\n                rows: [p.Any, \"auto\"],\r\n            });\r\n        }\r\n    }\r\n    exports.Column = Column;\r\n    Column.__name__ = \"Column\";\r\n    Column.init_Column();\r\n}\r\n","/* models\\layouts\\grid_box.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const layout_dom_1 = require(272) /* ./layout_dom */;\r\n    const grid_1 = require(216) /* ../../core/layout/grid */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class GridBoxView extends layout_dom_1.LayoutDOMView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.children.change, () => this.rebuild());\r\n        }\r\n        get child_models() {\r\n            return this.model.children.map(([child]) => child);\r\n        }\r\n        _update_layout() {\r\n            this.layout = new grid_1.Grid();\r\n            this.layout.rows = this.model.rows;\r\n            this.layout.cols = this.model.cols;\r\n            this.layout.spacing = this.model.spacing;\r\n            for (const [child, row, col, row_span, col_span] of this.model.children) {\r\n                const child_view = this._child_views.get(child);\r\n                this.layout.items.push({ layout: child_view.layout, row, col, row_span, col_span });\r\n            }\r\n            this.layout.set_sizing(this.box_sizing());\r\n        }\r\n    }\r\n    exports.GridBoxView = GridBoxView;\r\n    GridBoxView.__name__ = \"GridBoxView\";\r\n    class GridBox extends layout_dom_1.LayoutDOM {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GridBox() {\r\n            this.prototype.default_view = GridBoxView;\r\n            this.define({\r\n                children: [p.Array, []],\r\n                rows: [p.Any, \"auto\"],\r\n                cols: [p.Any, \"auto\"],\r\n                spacing: [p.Any, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.GridBox = GridBox;\r\n    GridBox.__name__ = \"GridBox\";\r\n    GridBox.init_GridBox();\r\n}\r\n","/* models\\layouts\\html_box.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const layout_dom_1 = require(272) /* ../layouts/layout_dom */;\r\n    const layout_1 = require(212) /* ../../core/layout */;\r\n    class HTMLBoxView extends layout_dom_1.LayoutDOMView {\r\n        get child_models() {\r\n            return [];\r\n        }\r\n        _update_layout() {\r\n            this.layout = new layout_1.ContentBox(this.el);\r\n            this.layout.set_sizing(this.box_sizing());\r\n        }\r\n    }\r\n    exports.HTMLBoxView = HTMLBoxView;\r\n    HTMLBoxView.__name__ = \"HTMLBoxView\";\r\n    class HTMLBox extends layout_dom_1.LayoutDOM {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n    }\r\n    exports.HTMLBox = HTMLBox;\r\n    HTMLBox.__name__ = \"HTMLBox\";\r\n}\r\n","/* models\\layouts\\row.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const box_1 = require(271) /* ./box */;\r\n    const grid_1 = require(216) /* ../../core/layout/grid */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class RowView extends box_1.BoxView {\r\n        _update_layout() {\r\n            const items = this.child_views.map((child) => child.layout);\r\n            this.layout = new grid_1.Row(items);\r\n            this.layout.cols = this.model.cols;\r\n            this.layout.spacing = [0, this.model.spacing];\r\n            this.layout.set_sizing(this.box_sizing());\r\n        }\r\n    }\r\n    exports.RowView = RowView;\r\n    RowView.__name__ = \"RowView\";\r\n    class Row extends box_1.Box {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Row() {\r\n            this.prototype.default_view = RowView;\r\n            this.define({\r\n                cols: [p.Any, \"auto\"],\r\n            });\r\n        }\r\n    }\r\n    exports.Row = Row;\r\n    Row.__name__ = \"Row\";\r\n    Row.init_Row();\r\n}\r\n","/* models\\layouts\\spacer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const layout_dom_1 = require(272) /* ./layout_dom */;\r\n    const layout_1 = require(212) /* ../../core/layout */;\r\n    class SpacerView extends layout_dom_1.LayoutDOMView {\r\n        get child_models() {\r\n            return [];\r\n        }\r\n        _update_layout() {\r\n            this.layout = new layout_1.LayoutItem();\r\n            this.layout.set_sizing(this.box_sizing());\r\n        }\r\n    }\r\n    exports.SpacerView = SpacerView;\r\n    SpacerView.__name__ = \"SpacerView\";\r\n    class Spacer extends layout_dom_1.LayoutDOM {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Spacer() {\r\n            this.prototype.default_view = SpacerView;\r\n        }\r\n    }\r\n    exports.Spacer = Spacer;\r\n    Spacer.__name__ = \"Spacer\";\r\n    Spacer.init_Spacer();\r\n}\r\n","/* models\\layouts\\tabs.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const layout_1 = require(212) /* ../../core/layout */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const layout_dom_1 = require(272) /* ./layout_dom */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const mixins_1 = require(173) /* ../../styles/mixins */;\r\n    const tabs_1 = require(280) /* ../../styles/tabs */;\r\n    const buttons_1 = require(281) /* ../../styles/buttons */;\r\n    const menus_1 = require(282) /* ../../styles/menus */;\r\n    const buttons_css_1 = tslib_1.__importDefault(require(283) /* ../../styles/buttons.css */);\r\n    const menus_css_1 = tslib_1.__importDefault(require(284) /* ../../styles/menus.css */);\r\n    const tabs_css_1 = tslib_1.__importDefault(require(285) /* ../../styles/tabs.css */);\r\n    class TabsView extends layout_dom_1.LayoutDOMView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.tabs.change, () => this.rebuild());\r\n            this.connect(this.model.properties.active.change, () => this.on_active_change());\r\n        }\r\n        styles() {\r\n            return [...super.styles(), buttons_css_1.default, menus_css_1.default, tabs_css_1.default];\r\n        }\r\n        get child_models() {\r\n            return this.model.tabs.map((tab) => tab.child);\r\n        }\r\n        _update_layout() {\r\n            const loc = this.model.tabs_location;\r\n            const vertical = loc == \"above\" || loc == \"below\";\r\n            // XXX: this is a hack, this should be handled by \"fit\" policy in grid layout\r\n            const { scroll_el, headers_el } = this;\r\n            this.header = new class extends layout_1.ContentBox {\r\n                _measure(viewport) {\r\n                    const min_headers = 3;\r\n                    const scroll = dom_1.size(scroll_el);\r\n                    const headers = dom_1.children(headers_el).slice(0, min_headers).map((el) => dom_1.size(el));\r\n                    const { width, height } = super._measure(viewport);\r\n                    if (vertical) {\r\n                        const min_width = scroll.width + array_1.sum(headers.map((size) => size.width));\r\n                        return { width: viewport.width != Infinity ? viewport.width : min_width, height };\r\n                    }\r\n                    else {\r\n                        const min_height = scroll.height + array_1.sum(headers.map((size) => size.height));\r\n                        return { width, height: viewport.height != Infinity ? viewport.height : min_height };\r\n                    }\r\n                }\r\n            }(this.header_el);\r\n            if (vertical)\r\n                this.header.set_sizing({ width_policy: \"fit\", height_policy: \"fixed\" });\r\n            else\r\n                this.header.set_sizing({ width_policy: \"fixed\", height_policy: \"fit\" });\r\n            let row = 1;\r\n            let col = 1;\r\n            switch (loc) {\r\n                case \"above\":\r\n                    row -= 1;\r\n                    break;\r\n                case \"below\":\r\n                    row += 1;\r\n                    break;\r\n                case \"left\":\r\n                    col -= 1;\r\n                    break;\r\n                case \"right\":\r\n                    col += 1;\r\n                    break;\r\n            }\r\n            const header = { layout: this.header, row, col };\r\n            const panels = this.child_views.map((child_view) => {\r\n                return { layout: child_view.layout, row: 1, col: 1 };\r\n            });\r\n            this.layout = new layout_1.Grid([header, ...panels]);\r\n            this.layout.set_sizing(this.box_sizing());\r\n        }\r\n        update_position() {\r\n            super.update_position();\r\n            this.header_el.style.position = \"absolute\"; // XXX: do it in position()\r\n            dom_1.position(this.header_el, this.header.bbox);\r\n            const loc = this.model.tabs_location;\r\n            const vertical = loc == \"above\" || loc == \"below\";\r\n            const scroll_el_size = dom_1.size(this.scroll_el);\r\n            const headers_el_size = dom_1.scroll_size(this.headers_el);\r\n            if (vertical) {\r\n                const { width } = this.header.bbox;\r\n                if (headers_el_size.width > width) {\r\n                    this.wrapper_el.style.maxWidth = `${width - scroll_el_size.width}px`;\r\n                    dom_1.display(this.scroll_el);\r\n                }\r\n                else {\r\n                    this.wrapper_el.style.maxWidth = \"\";\r\n                    dom_1.undisplay(this.scroll_el);\r\n                }\r\n            }\r\n            else {\r\n                const { height } = this.header.bbox;\r\n                if (headers_el_size.height > height) {\r\n                    this.wrapper_el.style.maxHeight = `${height - scroll_el_size.height}px`;\r\n                    dom_1.display(this.scroll_el);\r\n                }\r\n                else {\r\n                    this.wrapper_el.style.maxHeight = \"\";\r\n                    dom_1.undisplay(this.scroll_el);\r\n                }\r\n            }\r\n            const { child_views } = this;\r\n            for (const child_view of child_views)\r\n                dom_1.hide(child_view.el);\r\n            const tab = child_views[this.model.active];\r\n            if (tab != null)\r\n                dom_1.show(tab.el);\r\n        }\r\n        render() {\r\n            super.render();\r\n            const { active } = this.model;\r\n            const loc = this.model.tabs_location;\r\n            const vertical = loc == \"above\" || loc == \"below\";\r\n            const headers = this.model.tabs.map((tab, i) => {\r\n                const el = dom_1.div({ class: [tabs_1.bk_tab, i == active ? mixins_1.bk_active : null] }, tab.title);\r\n                el.addEventListener(\"click\", (event) => {\r\n                    if (event.target == event.currentTarget)\r\n                        this.change_active(i);\r\n                });\r\n                if (tab.closable) {\r\n                    const close_el = dom_1.div({ class: tabs_1.bk_close });\r\n                    close_el.addEventListener(\"click\", (event) => {\r\n                        if (event.target == event.currentTarget) {\r\n                            this.model.tabs = array_1.remove_at(this.model.tabs, i);\r\n                            const ntabs = this.model.tabs.length;\r\n                            if (this.model.active > ntabs - 1)\r\n                                this.model.active = ntabs - 1;\r\n                        }\r\n                    });\r\n                    el.appendChild(close_el);\r\n                }\r\n                return el;\r\n            });\r\n            this.headers_el = dom_1.div({ class: [tabs_1.bk_headers] }, headers);\r\n            this.wrapper_el = dom_1.div({ class: tabs_1.bk_headers_wrapper }, this.headers_el);\r\n            const left_el = dom_1.div({ class: [buttons_1.bk_btn, buttons_1.bk_btn_default], disabled: \"\" }, dom_1.div({ class: [menus_1.bk_caret, mixins_1.bk_left] }));\r\n            const right_el = dom_1.div({ class: [buttons_1.bk_btn, buttons_1.bk_btn_default] }, dom_1.div({ class: [menus_1.bk_caret, mixins_1.bk_right] }));\r\n            let scroll_index = 0;\r\n            const do_scroll = (dir) => {\r\n                return () => {\r\n                    const ntabs = this.model.tabs.length;\r\n                    if (dir == \"left\")\r\n                        scroll_index = Math.max(scroll_index - 1, 0);\r\n                    else\r\n                        scroll_index = Math.min(scroll_index + 1, ntabs - 1);\r\n                    if (scroll_index == 0)\r\n                        left_el.setAttribute(\"disabled\", \"\");\r\n                    else\r\n                        left_el.removeAttribute(\"disabled\");\r\n                    if (scroll_index == ntabs - 1)\r\n                        right_el.setAttribute(\"disabled\", \"\");\r\n                    else\r\n                        right_el.removeAttribute(\"disabled\");\r\n                    const sizes = dom_1.children(this.headers_el)\r\n                        .slice(0, scroll_index)\r\n                        .map((el) => el.getBoundingClientRect());\r\n                    if (vertical) {\r\n                        const left = -array_1.sum(sizes.map((size) => size.width));\r\n                        this.headers_el.style.left = `${left}px`;\r\n                    }\r\n                    else {\r\n                        const top = -array_1.sum(sizes.map((size) => size.height));\r\n                        this.headers_el.style.top = `${top}px`;\r\n                    }\r\n                };\r\n            };\r\n            left_el.addEventListener(\"click\", do_scroll(\"left\"));\r\n            right_el.addEventListener(\"click\", do_scroll(\"right\"));\r\n            this.scroll_el = dom_1.div({ class: buttons_1.bk_btn_group }, left_el, right_el);\r\n            this.header_el = dom_1.div({ class: [tabs_1.bk_tabs_header, mixins_1.bk_side(loc)] }, this.scroll_el, this.wrapper_el);\r\n            this.el.appendChild(this.header_el);\r\n        }\r\n        change_active(i) {\r\n            if (i != this.model.active) {\r\n                this.model.active = i;\r\n            }\r\n        }\r\n        on_active_change() {\r\n            const i = this.model.active;\r\n            const headers = dom_1.children(this.headers_el);\r\n            for (const el of headers)\r\n                el.classList.remove(mixins_1.bk_active);\r\n            headers[i].classList.add(mixins_1.bk_active);\r\n            const { child_views } = this;\r\n            for (const child_view of child_views)\r\n                dom_1.hide(child_view.el);\r\n            dom_1.show(child_views[i].el);\r\n        }\r\n    }\r\n    exports.TabsView = TabsView;\r\n    TabsView.__name__ = \"TabsView\";\r\n    class Tabs extends layout_dom_1.LayoutDOM {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Tabs() {\r\n            this.prototype.default_view = TabsView;\r\n            this.define({\r\n                tabs: [p.Array, []],\r\n                tabs_location: [p.Location, \"above\"],\r\n                active: [p.Number, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.Tabs = Tabs;\r\n    Tabs.__name__ = \"Tabs\";\r\n    Tabs.init_Tabs();\r\n    class Panel extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Panel() {\r\n            this.define({\r\n                title: [p.String, \"\"],\r\n                child: [p.Instance],\r\n                closable: [p.Boolean, false],\r\n            });\r\n        }\r\n    }\r\n    exports.Panel = Panel;\r\n    Panel.__name__ = \"Panel\";\r\n    Panel.init_Panel();\r\n}\r\n","/* styles\\tabs.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_tabs_header = \"bk-tabs-header\";\r\n    exports.bk_headers_wrapper = \"bk-headers-wrapper\";\r\n    exports.bk_headers = \"bk-headers\";\r\n    exports.bk_tab = \"bk-tab\";\r\n    exports.bk_close = \"bk-close\";\r\n}\r\n","/* styles\\buttons.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_btn = \"bk-btn\";\r\n    exports.bk_btn_group = \"bk-btn-group\";\r\n    exports.bk_btn_default = \"bk-btn-default\";\r\n    exports.bk_btn_primary = \"bk-btn-primary\";\r\n    exports.bk_btn_success = \"bk-btn-success\";\r\n    exports.bk_btn_warning = \"bk-btn-warning\";\r\n    exports.bk_btn_danger = \"bk-btn-danger\";\r\n    function bk_btn_type(button_type) {\r\n        switch (button_type) {\r\n            case \"default\": return exports.bk_btn_default;\r\n            case \"primary\": return exports.bk_btn_primary;\r\n            case \"success\": return exports.bk_btn_success;\r\n            case \"warning\": return exports.bk_btn_warning;\r\n            case \"danger\": return exports.bk_btn_danger;\r\n        }\r\n    }\r\n    exports.bk_btn_type = bk_btn_type;\r\n    exports.bk_dropdown_toggle = \"bk-dropdown-toggle\";\r\n}\r\n","/* styles\\menus.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_menu = \"bk-menu\";\r\n    exports.bk_caret = \"bk-caret\";\r\n    exports.bk_divider = \"bk-divider\";\r\n}\r\n","/* styles\\buttons.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root .bk-btn {\n  height: 100%;\n  display: inline-block;\n  text-align: center;\n  vertical-align: middle;\n  white-space: nowrap;\n  cursor: pointer;\n  padding: 6px 12px;\n  font-size: 12px;\n  border: 1px solid transparent;\n  border-radius: 4px;\n  outline: 0;\n  user-select: none;\n  -ms-user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n}\n.bk-root .bk-btn:hover,\n.bk-root .bk-btn:focus {\n  text-decoration: none;\n}\n.bk-root .bk-btn:active,\n.bk-root .bk-btn.bk-active {\n  background-image: none;\n  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);\n}\n.bk-root .bk-btn[disabled] {\n  cursor: not-allowed;\n  pointer-events: none;\n  opacity: 0.65;\n  box-shadow: none;\n}\n.bk-root .bk-btn-default {\n  color: #333;\n  background-color: #fff;\n  border-color: #ccc;\n}\n.bk-root .bk-btn-default:hover {\n  background-color: #f5f5f5;\n  border-color: #b8b8b8;\n}\n.bk-root .bk-btn-default.bk-active {\n  background-color: #ebebeb;\n  border-color: #adadad;\n}\n.bk-root .bk-btn-default[disabled],\n.bk-root .bk-btn-default[disabled]:hover,\n.bk-root .bk-btn-default[disabled]:focus,\n.bk-root .bk-btn-default[disabled]:active,\n.bk-root .bk-btn-default[disabled].bk-active {\n  background-color: #e6e6e6;\n  border-color: #ccc;\n}\n.bk-root .bk-btn-primary {\n  color: #fff;\n  background-color: #428bca;\n  border-color: #357ebd;\n}\n.bk-root .bk-btn-primary:hover {\n  background-color: #3681c1;\n  border-color: #2c699e;\n}\n.bk-root .bk-btn-primary.bk-active {\n  background-color: #3276b1;\n  border-color: #285e8e;\n}\n.bk-root .bk-btn-primary[disabled],\n.bk-root .bk-btn-primary[disabled]:hover,\n.bk-root .bk-btn-primary[disabled]:focus,\n.bk-root .bk-btn-primary[disabled]:active,\n.bk-root .bk-btn-primary[disabled].bk-active {\n  background-color: #506f89;\n  border-color: #357ebd;\n}\n.bk-root .bk-btn-success {\n  color: #fff;\n  background-color: #5cb85c;\n  border-color: #4cae4c;\n}\n.bk-root .bk-btn-success:hover {\n  background-color: #4eb24e;\n  border-color: #409240;\n}\n.bk-root .bk-btn-success.bk-active {\n  background-color: #47a447;\n  border-color: #398439;\n}\n.bk-root .bk-btn-success[disabled],\n.bk-root .bk-btn-success[disabled]:hover,\n.bk-root .bk-btn-success[disabled]:focus,\n.bk-root .bk-btn-success[disabled]:active,\n.bk-root .bk-btn-success[disabled].bk-active {\n  background-color: #667b66;\n  border-color: #4cae4c;\n}\n.bk-root .bk-btn-warning {\n  color: #fff;\n  background-color: #f0ad4e;\n  border-color: #eea236;\n}\n.bk-root .bk-btn-warning:hover {\n  background-color: #eea43b;\n  border-color: #e89014;\n}\n.bk-root .bk-btn-warning.bk-active {\n  background-color: #ed9c28;\n  border-color: #d58512;\n}\n.bk-root .bk-btn-warning[disabled],\n.bk-root .bk-btn-warning[disabled]:hover,\n.bk-root .bk-btn-warning[disabled]:focus,\n.bk-root .bk-btn-warning[disabled]:active,\n.bk-root .bk-btn-warning[disabled].bk-active {\n  background-color: #c89143;\n  border-color: #eea236;\n}\n.bk-root .bk-btn-danger {\n  color: #fff;\n  background-color: #d9534f;\n  border-color: #d43f3a;\n}\n.bk-root .bk-btn-danger:hover {\n  background-color: #d5433e;\n  border-color: #bd2d29;\n}\n.bk-root .bk-btn-danger.bk-active {\n  background-color: #d2322d;\n  border-color: #ac2925;\n}\n.bk-root .bk-btn-danger[disabled],\n.bk-root .bk-btn-danger[disabled]:hover,\n.bk-root .bk-btn-danger[disabled]:focus,\n.bk-root .bk-btn-danger[disabled]:active,\n.bk-root .bk-btn-danger[disabled].bk-active {\n  background-color: #a55350;\n  border-color: #d43f3a;\n}\n.bk-root .bk-btn-group {\n  height: 100%;\n  display: flex;\n  display: -webkit-flex;\n  flex-wrap: nowrap;\n  -webkit-flex-wrap: nowrap;\n  align-items: center;\n  -webkit-align-items: center;\n  flex-direction: row;\n  -webkit-flex-direction: row;\n}\n.bk-root .bk-btn-group > .bk-btn {\n  flex-grow: 1;\n  -webkit-flex-grow: 1;\n}\n.bk-root .bk-btn-group > .bk-btn + .bk-btn {\n  margin-left: -1px;\n}\n.bk-root .bk-btn-group > .bk-btn:first-child:not(:last-child) {\n  border-bottom-right-radius: 0;\n  border-top-right-radius: 0;\n}\n.bk-root .bk-btn-group > .bk-btn:not(:first-child):last-child {\n  border-bottom-left-radius: 0;\n  border-top-left-radius: 0;\n}\n.bk-root .bk-btn-group > .bk-btn:not(:first-child):not(:last-child) {\n  border-radius: 0;\n}\n.bk-root .bk-btn-group .bk-dropdown-toggle {\n  flex: 0 0 0;\n  -webkit-flex: 0 0 0;\n  padding: 6px 6px;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* styles\\menus.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root .bk-menu-icon {\n  width: 28px;\n  height: 28px;\n  background-size: 60%;\n  background-color: transparent;\n  background-repeat: no-repeat;\n  background-position: center center;\n}\n.bk-root .bk-context-menu {\n  position: absolute;\n  display: inline-flex;\n  display: -webkit-inline-flex;\n  flex-wrap: nowrap;\n  -webkit-flex-wrap: nowrap;\n  user-select: none;\n  -ms-user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  width: auto;\n  height: auto;\n  z-index: 100;\n  cursor: pointer;\n  font-size: 12px;\n  background-color: #fff;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);\n}\n.bk-root .bk-context-menu.bk-horizontal {\n  flex-direction: row;\n  -webkit-flex-direction: row;\n}\n.bk-root .bk-context-menu.bk-vertical {\n  flex-direction: column;\n  -webkit-flex-direction: column;\n}\n.bk-root .bk-context-menu > .bk-divider {\n  cursor: default;\n  overflow: hidden;\n  background-color: #e5e5e5;\n}\n.bk-root .bk-context-menu.bk-horizontal > .bk-divider {\n  width: 1px;\n  margin: 5px 0;\n}\n.bk-root .bk-context-menu.bk-vertical > .bk-divider {\n  height: 1px;\n  margin: 0 5px;\n}\n.bk-root .bk-context-menu > :not(.bk-divider) {\n  border: 1px solid transparent;\n}\n.bk-root .bk-context-menu > :not(.bk-divider).bk-active {\n  border-color: #26aae1;\n}\n.bk-root .bk-context-menu > :not(.bk-divider):hover {\n  background-color: #f9f9f9;\n}\n.bk-root .bk-context-menu.bk-horizontal > :not(.bk-divider):first-child {\n  border-top-left-radius: 4px;\n  border-bottom-left-radius: 4px;\n}\n.bk-root .bk-context-menu.bk-horizontal > :not(.bk-divider):last-child {\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n.bk-root .bk-context-menu.bk-vertical > :not(.bk-divider):first-child {\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n}\n.bk-root .bk-context-menu.bk-vertical > :not(.bk-divider):last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n.bk-root .bk-menu {\n  position: absolute;\n  left: 0;\n  width: 100%;\n  z-index: 100;\n  cursor: pointer;\n  font-size: 12px;\n  background-color: #fff;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);\n}\n.bk-root .bk-menu.bk-above {\n  bottom: 100%;\n}\n.bk-root .bk-menu.bk-below {\n  top: 100%;\n}\n.bk-root .bk-menu > .bk-divider {\n  height: 1px;\n  margin: 7.5px 0;\n  overflow: hidden;\n  background-color: #e5e5e5;\n}\n.bk-root .bk-menu > :not(.bk-divider) {\n  padding: 6px 12px;\n}\n.bk-root .bk-menu > :not(.bk-divider):hover,\n.bk-root .bk-menu > :not(.bk-divider).bk-active {\n  background-color: #e6e6e6;\n}\n.bk-root .bk-caret {\n  display: inline-block;\n  vertical-align: middle;\n  width: 0;\n  height: 0;\n  margin: 0 5px;\n}\n.bk-root .bk-caret.bk-down {\n  border-top: 4px solid;\n}\n.bk-root .bk-caret.bk-up {\n  border-bottom: 4px solid;\n}\n.bk-root .bk-caret.bk-down,\n.bk-root .bk-caret.bk-up {\n  border-right: 4px solid transparent;\n  border-left: 4px solid transparent;\n}\n.bk-root .bk-caret.bk-left {\n  border-right: 4px solid;\n}\n.bk-root .bk-caret.bk-right {\n  border-left: 4px solid;\n}\n.bk-root .bk-caret.bk-left,\n.bk-root .bk-caret.bk-right {\n  border-top: 4px solid transparent;\n  border-bottom: 4px solid transparent;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* styles\\tabs.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root .bk-tabs-header {\n  display: flex;\n  display: -webkit-flex;\n  flex-wrap: nowrap;\n  -webkit-flex-wrap: nowrap;\n  align-items: center;\n  -webkit-align-items: center;\n  overflow: hidden;\n  user-select: none;\n  -ms-user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n}\n.bk-root .bk-tabs-header .bk-btn-group {\n  height: auto;\n  margin-right: 5px;\n}\n.bk-root .bk-tabs-header .bk-btn-group > .bk-btn {\n  flex-grow: 0;\n  -webkit-flex-grow: 0;\n  height: auto;\n  padding: 4px 4px;\n}\n.bk-root .bk-tabs-header .bk-headers-wrapper {\n  flex-grow: 1;\n  -webkit-flex-grow: 1;\n  overflow: hidden;\n  color: #666666;\n}\n.bk-root .bk-tabs-header.bk-above .bk-headers-wrapper {\n  border-bottom: 1px solid #e6e6e6;\n}\n.bk-root .bk-tabs-header.bk-right .bk-headers-wrapper {\n  border-left: 1px solid #e6e6e6;\n}\n.bk-root .bk-tabs-header.bk-below .bk-headers-wrapper {\n  border-top: 1px solid #e6e6e6;\n}\n.bk-root .bk-tabs-header.bk-left .bk-headers-wrapper {\n  border-right: 1px solid #e6e6e6;\n}\n.bk-root .bk-tabs-header.bk-above,\n.bk-root .bk-tabs-header.bk-below {\n  flex-direction: row;\n  -webkit-flex-direction: row;\n}\n.bk-root .bk-tabs-header.bk-above .bk-headers,\n.bk-root .bk-tabs-header.bk-below .bk-headers {\n  flex-direction: row;\n  -webkit-flex-direction: row;\n}\n.bk-root .bk-tabs-header.bk-left,\n.bk-root .bk-tabs-header.bk-right {\n  flex-direction: column;\n  -webkit-flex-direction: column;\n}\n.bk-root .bk-tabs-header.bk-left .bk-headers,\n.bk-root .bk-tabs-header.bk-right .bk-headers {\n  flex-direction: column;\n  -webkit-flex-direction: column;\n}\n.bk-root .bk-tabs-header .bk-headers {\n  position: relative;\n  display: flex;\n  display: -webkit-flex;\n  flex-wrap: nowrap;\n  -webkit-flex-wrap: nowrap;\n  align-items: center;\n  -webkit-align-items: center;\n}\n.bk-root .bk-tabs-header .bk-tab {\n  padding: 4px 8px;\n  border: solid transparent;\n  white-space: nowrap;\n  cursor: pointer;\n}\n.bk-root .bk-tabs-header .bk-tab:hover {\n  background-color: #f2f2f2;\n}\n.bk-root .bk-tabs-header .bk-tab.bk-active {\n  color: #4d4d4d;\n  background-color: white;\n  border-color: #e6e6e6;\n}\n.bk-root .bk-tabs-header .bk-tab .bk-close {\n  margin-left: 10px;\n}\n.bk-root .bk-tabs-header.bk-above .bk-tab {\n  border-width: 3px 1px 0px 1px;\n  border-radius: 4px 4px 0 0;\n}\n.bk-root .bk-tabs-header.bk-right .bk-tab {\n  border-width: 1px 3px 1px 0px;\n  border-radius: 0 4px 4px 0;\n}\n.bk-root .bk-tabs-header.bk-below .bk-tab {\n  border-width: 0px 1px 3px 1px;\n  border-radius: 0 0 4px 4px;\n}\n.bk-root .bk-tabs-header.bk-left .bk-tab {\n  border-width: 1px 0px 1px 3px;\n  border-radius: 4px 0 0 4px;\n}\n.bk-root .bk-close {\n  display: inline-block;\n  width: 10px;\n  height: 10px;\n  vertical-align: middle;\n  background-image: url('data:image/svg+xml;utf8,\\\n      <svg viewPort=\"0 0 10 10\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\\\n        <line x1=\"1\" y1=\"9\" x2=\"9\" y2=\"1\" stroke=\"gray\" stroke-width=\"2\"/>\\\n        <line x1=\"1\" y1=\"1\" x2=\"9\" y2=\"9\" stroke=\"gray\" stroke-width=\"2\"/>\\\n      </svg>');\n}\n.bk-root .bk-close:hover {\n  background-image: url('data:image/svg+xml;utf8,\\\n      <svg viewPort=\"0 0 10 10\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\\\n        <line x1=\"1\" y1=\"9\" x2=\"9\" y2=\"1\" stroke=\"red\" stroke-width=\"2\"/>\\\n        <line x1=\"1\" y1=\"1\" x2=\"9\" y2=\"9\" stroke=\"red\" stroke-width=\"2\"/>\\\n      </svg>');\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* models\\layouts\\widget_box.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const column_1 = require(274) /* ./column */;\r\n    class WidgetBoxView extends column_1.ColumnView {\r\n    }\r\n    exports.WidgetBoxView = WidgetBoxView;\r\n    WidgetBoxView.__name__ = \"WidgetBoxView\";\r\n    class WidgetBox extends column_1.Column {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_WidgetBox() {\r\n            this.prototype.default_view = WidgetBoxView;\r\n        }\r\n    }\r\n    exports.WidgetBox = WidgetBox;\r\n    WidgetBox.__name__ = \"WidgetBox\";\r\n    WidgetBox.init_WidgetBox();\r\n}\r\n","/* models\\markers\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    tslib_1.__exportStar(require(288) /* ./defs */, exports);\r\n    var marker_1 = require(289) /* ./marker */;\r\n    exports.Marker = marker_1.Marker;\r\n    var scatter_1 = require(290) /* ./scatter */;\r\n    exports.Scatter = scatter_1.Scatter;\r\n}\r\n","/* models\\markers\\defs.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const marker_1 = require(289) /* ./marker */;\r\n    const glmarks = tslib_1.__importStar(require(238) /* ../glyphs/webgl/markers */);\r\n    const SQ3 = Math.sqrt(3);\r\n    function _one_line(ctx, r) {\r\n        ctx.moveTo(-r, 0);\r\n        ctx.lineTo(r, 0);\r\n    }\r\n    function _one_x(ctx, r) {\r\n        ctx.rotate(Math.PI / 4);\r\n        _one_cross(ctx, r);\r\n        ctx.rotate(-Math.PI / 4);\r\n    }\r\n    function _one_y(ctx, r) {\r\n        const h = r * SQ3;\r\n        const a = h / 3;\r\n        ctx.moveTo(-h / 2, -a);\r\n        ctx.lineTo(0, 0);\r\n        ctx.lineTo(h / 2, -a);\r\n        ctx.lineTo(0, 0);\r\n        ctx.lineTo(0, r);\r\n    }\r\n    function _one_cross(ctx, r) {\r\n        ctx.moveTo(0, r);\r\n        ctx.lineTo(0, -r);\r\n        ctx.moveTo(-r, 0);\r\n        ctx.lineTo(r, 0);\r\n    }\r\n    function _one_dot(ctx, r) {\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, r / 4, 0, 2 * Math.PI, false);\r\n        ctx.closePath();\r\n    }\r\n    function _one_diamond(ctx, r) {\r\n        ctx.moveTo(0, r);\r\n        ctx.lineTo(r / 1.5, 0);\r\n        ctx.lineTo(0, -r);\r\n        ctx.lineTo(-r / 1.5, 0);\r\n        ctx.closePath();\r\n    }\r\n    function _one_hex(ctx, r) {\r\n        const r2 = r / 2;\r\n        const h = SQ3 * r2;\r\n        ctx.moveTo(r, 0);\r\n        ctx.lineTo(r2, -h);\r\n        ctx.lineTo(-r2, -h);\r\n        ctx.lineTo(-r, 0);\r\n        ctx.lineTo(-r2, h);\r\n        ctx.lineTo(r2, h);\r\n        ctx.closePath();\r\n    }\r\n    function _one_tri(ctx, r) {\r\n        const h = r * SQ3;\r\n        const a = h / 3;\r\n        ctx.moveTo(-r, a);\r\n        ctx.lineTo(r, a);\r\n        ctx.lineTo(0, a - h);\r\n        ctx.closePath();\r\n    }\r\n    function asterisk(ctx, i, r, line, _fill) {\r\n        _one_cross(ctx, r);\r\n        _one_x(ctx, r);\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function circle(ctx, i, r, line, fill) {\r\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function circle_cross(ctx, i, r, line, fill) {\r\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            _one_cross(ctx, r);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function circle_dot(ctx, i, r, line, fill) {\r\n        circle(ctx, i, r, line, fill);\r\n        dot(ctx, i, r, line, fill);\r\n    }\r\n    function circle_y(ctx, i, r, line, fill) {\r\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            _one_y(ctx, r);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function circle_x(ctx, i, r, line, fill) {\r\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            _one_x(ctx, r);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function cross(ctx, i, r, line, _fill) {\r\n        _one_cross(ctx, r);\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function diamond(ctx, i, r, line, fill) {\r\n        _one_diamond(ctx, r);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function diamond_cross(ctx, i, r, line, fill) {\r\n        _one_diamond(ctx, r);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.moveTo(0, r);\r\n            ctx.lineTo(0, -r);\r\n            ctx.moveTo(-r / 1.5, 0);\r\n            ctx.lineTo(r / 1.5, 0);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function diamond_dot(ctx, i, r, line, fill) {\r\n        diamond(ctx, i, r, line, fill);\r\n        dot(ctx, i, r, line, fill);\r\n    }\r\n    function dot(ctx, i, r, line, _fill) {\r\n        _one_dot(ctx, r);\r\n        line.set_vectorize(ctx, i);\r\n        ctx.fillStyle = ctx.strokeStyle; // NOTE: dots use line color for fill to match\r\n        ctx.fill();\r\n    }\r\n    function hex(ctx, i, r, line, fill) {\r\n        _one_hex(ctx, r);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function hex_dot(ctx, i, r, line, fill) {\r\n        hex(ctx, i, r, line, fill);\r\n        dot(ctx, i, r, line, fill);\r\n    }\r\n    function inverted_triangle(ctx, i, r, line, fill) {\r\n        ctx.rotate(Math.PI);\r\n        _one_tri(ctx, r);\r\n        ctx.rotate(-Math.PI);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function plus(ctx, i, r, line, fill) {\r\n        const a = 3 * r / 8;\r\n        const b = r;\r\n        const xs = [a, a, b, b, a, a, -a, -a, -b, -b, -a, -a];\r\n        const ys = [b, a, a, -a, -a, -b, -b, -a, -a, a, a, b];\r\n        ctx.moveTo(xs[0], ys[0]);\r\n        for (i = 1; i < 12; i++)\r\n            ctx.lineTo(xs[i], ys[i]);\r\n        ctx.closePath();\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function square(ctx, i, r, line, fill) {\r\n        const size = 2 * r;\r\n        ctx.rect(-r, -r, size, size);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function square_pin(ctx, i, r, line, fill) {\r\n        const a = 3 * r / 8;\r\n        ctx.moveTo(-r, -r);\r\n        /* eslint-disable space-in-parens */\r\n        ctx.quadraticCurveTo(0, -a, r, -r);\r\n        ctx.quadraticCurveTo(a, 0, r, r);\r\n        ctx.quadraticCurveTo(0, a, -r, r);\r\n        ctx.quadraticCurveTo(-a, 0, -r, -r);\r\n        /* eslint-ensable space-in-parens */\r\n        ctx.closePath();\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function square_cross(ctx, i, r, line, fill) {\r\n        const size = 2 * r;\r\n        ctx.rect(-r, -r, size, size);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            _one_cross(ctx, r);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function square_dot(ctx, i, r, line, fill) {\r\n        square(ctx, i, r, line, fill);\r\n        dot(ctx, i, r, line, fill);\r\n    }\r\n    function square_x(ctx, i, r, line, fill) {\r\n        const size = 2 * r;\r\n        ctx.rect(-r, -r, size, size);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.moveTo(-r, r);\r\n            ctx.lineTo(r, -r);\r\n            ctx.moveTo(-r, -r);\r\n            ctx.lineTo(r, r);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function triangle(ctx, i, r, line, fill) {\r\n        _one_tri(ctx, r);\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function triangle_dot(ctx, i, r, line, fill) {\r\n        triangle(ctx, i, r, line, fill);\r\n        dot(ctx, i, r, line, fill);\r\n    }\r\n    function triangle_pin(ctx, i, r, line, fill) {\r\n        const h = r * SQ3;\r\n        const a = h / 3;\r\n        const b = 3 * a / 8;\r\n        ctx.moveTo(-r, a);\r\n        ctx.quadraticCurveTo(0, b, r, a);\r\n        ctx.quadraticCurveTo(SQ3 * b / 2, b / 2, 0, a - h);\r\n        ctx.quadraticCurveTo(-SQ3 * b / 2, b / 2, -r, a);\r\n        ctx.closePath();\r\n        if (fill.doit) {\r\n            fill.set_vectorize(ctx, i);\r\n            ctx.fill();\r\n        }\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function dash(ctx, i, r, line, _fill) {\r\n        _one_line(ctx, r);\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function x(ctx, i, r, line, _fill) {\r\n        _one_x(ctx, r);\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function y(ctx, i, r, line, _fill) {\r\n        _one_y(ctx, r);\r\n        if (line.doit) {\r\n            line.set_vectorize(ctx, i);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n    function _mk_model(type, f, glglyph_cls) {\r\n        var _a;\r\n        const view = class extends marker_1.MarkerView {\r\n            static initClass() {\r\n                this.prototype._render_one = f;\r\n                this.prototype.glglyph_cls = glglyph_cls;\r\n            }\r\n        };\r\n        view.initClass();\r\n        const model = (_a = class extends marker_1.Marker {\r\n            static initClass() {\r\n                this.prototype.default_view = view;\r\n            }\r\n        },\r\n            _a.__name__ = type,\r\n            _a);\r\n        model.initClass();\r\n        return model;\r\n    }\r\n    // markers are final, so no need to export views\r\n    exports.Asterisk = _mk_model('Asterisk', asterisk, glmarks.AsteriskGL);\r\n    exports.CircleCross = _mk_model('CircleCross', circle_cross, glmarks.CircleCrossGL);\r\n    exports.CircleDot = _mk_model('CircleDot', circle_dot);\r\n    exports.CircleY = _mk_model('CircleY', circle_y);\r\n    exports.CircleX = _mk_model('CircleX', circle_x, glmarks.CircleXGL);\r\n    exports.Cross = _mk_model('Cross', cross, glmarks.CrossGL);\r\n    exports.Dash = _mk_model('Dash', dash);\r\n    exports.Diamond = _mk_model('Diamond', diamond, glmarks.DiamondGL);\r\n    exports.DiamondCross = _mk_model('DiamondCross', diamond_cross, glmarks.DiamondCrossGL);\r\n    exports.DiamondDot = _mk_model('DiamondDot', diamond_dot);\r\n    exports.Dot = _mk_model('Dot', dot);\r\n    exports.Hex = _mk_model('Hex', hex, glmarks.HexGL);\r\n    exports.HexDot = _mk_model('HexDot', hex_dot);\r\n    exports.InvertedTriangle = _mk_model('InvertedTriangle', inverted_triangle, glmarks.InvertedTriangleGL);\r\n    exports.Plus = _mk_model('Plus', plus);\r\n    exports.Square = _mk_model('Square', square, glmarks.SquareGL);\r\n    exports.SquareCross = _mk_model('SquareCross', square_cross, glmarks.SquareCrossGL);\r\n    exports.SquareDot = _mk_model('SquareDot', square_dot);\r\n    exports.SquarePin = _mk_model('SquarePin', square_pin);\r\n    exports.SquareX = _mk_model('SquareX', square_x, glmarks.SquareXGL);\r\n    exports.Triangle = _mk_model('Triangle', triangle, glmarks.TriangleGL);\r\n    exports.TriangleDot = _mk_model('TriangleDot', triangle_dot);\r\n    exports.TrianglePin = _mk_model('TrianglePin', triangle_pin);\r\n    exports.X = _mk_model('X', x, glmarks.XGL);\r\n    exports.Y = _mk_model('Y', y);\r\n    exports.marker_funcs = {\r\n        asterisk,\r\n        circle,\r\n        circle_cross,\r\n        circle_dot,\r\n        circle_y,\r\n        circle_x,\r\n        cross,\r\n        diamond,\r\n        diamond_dot,\r\n        diamond_cross,\r\n        dot,\r\n        hex,\r\n        hex_dot,\r\n        inverted_triangle,\r\n        plus,\r\n        square,\r\n        square_cross,\r\n        square_dot,\r\n        square_pin,\r\n        square_x,\r\n        triangle,\r\n        triangle_dot,\r\n        triangle_pin,\r\n        dash,\r\n        x,\r\n        y,\r\n    };\r\n}\r\n","/* models\\markers\\marker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const xy_glyph_1 = require(93) /* ../glyphs/xy_glyph */;\r\n    const property_mixins_1 = require(28) /* ../../core/property_mixins */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../core/hittest */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const selection_1 = require(88) /* ../selections/selection */;\r\n    class MarkerView extends xy_glyph_1.XYGlyphView {\r\n        initialize() {\r\n            super.initialize();\r\n            const { webgl } = this.renderer.plot_view.canvas_view;\r\n            if (webgl != null && this.glglyph_cls != null) {\r\n                this.glglyph = new this.glglyph_cls(webgl.gl, this);\r\n            }\r\n        }\r\n        _render(ctx, indices, { sx, sy, _size, _angle }) {\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i]))\r\n                    continue;\r\n                const r = _size[i] / 2;\r\n                ctx.beginPath();\r\n                ctx.translate(sx[i], sy[i]);\r\n                if (_angle[i])\r\n                    ctx.rotate(_angle[i]);\r\n                this._render_one(ctx, i, r, this.visuals.line, this.visuals.fill);\r\n                if (_angle[i])\r\n                    ctx.rotate(-_angle[i]);\r\n                ctx.translate(-sx[i], -sy[i]);\r\n            }\r\n        }\r\n        _mask_data() {\r\n            // dilate the inner screen region by max_size and map back to data space for use in spatial query\r\n            const hr = this.renderer.plot_view.frame.bbox.h_range;\r\n            const sx0 = hr.start - this.max_size;\r\n            const sx1 = hr.end + this.max_size;\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            const vr = this.renderer.plot_view.frame.bbox.v_range;\r\n            const sy0 = vr.start - this.max_size;\r\n            const sy1 = vr.end + this.max_size;\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            return this.index.indices({ x0, x1, y0, y1 });\r\n        }\r\n        _hit_point(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const sx0 = sx - this.max_size;\r\n            const sx1 = sx + this.max_size;\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            const sy0 = sy - this.max_size;\r\n            const sy1 = sy + this.max_size;\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\r\n            const indices = [];\r\n            for (const i of candidates) {\r\n                const s2 = this._size[i] / 2;\r\n                if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {\r\n                    indices.push(i);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_span(geometry) {\r\n            const { sx, sy } = geometry;\r\n            const bounds = this.bounds();\r\n            const ms = this.max_size / 2;\r\n            let x0, x1, y0, y1;\r\n            if (geometry.direction == 'h') {\r\n                y0 = bounds.y0;\r\n                y1 = bounds.y1;\r\n                const sx0 = sx - ms;\r\n                const sx1 = sx + ms;\r\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            }\r\n            else {\r\n                x0 = bounds.x0;\r\n                x1 = bounds.x1;\r\n                const sy0 = sy - ms;\r\n                const sy1 = sy + ms;\r\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            }\r\n            const indices = [...this.index.indices({ x0, x1, y0, y1 })];\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_rect(geometry) {\r\n            const { sx0, sx1, sy0, sy1 } = geometry;\r\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\r\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\r\n            const indices = [...this.index.indices({ x0, x1, y0, y1 })];\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _hit_poly(geometry) {\r\n            const { sx, sy } = geometry;\r\n            // TODO (bev) use spatial index to pare candidate list\r\n            const candidates = array_1.range(0, this.sx.length);\r\n            const indices = [];\r\n            for (let i = 0, end = candidates.length; i < end; i++) {\r\n                const index = candidates[i];\r\n                if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\r\n                    indices.push(index);\r\n                }\r\n            }\r\n            return new selection_1.Selection({ indices });\r\n        }\r\n        _get_legend_args({ x0, x1, y0, y1 }, index) {\r\n            // using objects like this seems a little wonky, since the keys are coerced to strings, but it works\r\n            const len = index + 1;\r\n            const sx = new Array(len);\r\n            sx[index] = (x0 + x1) / 2;\r\n            const sy = new Array(len);\r\n            sy[index] = (y0 + y1) / 2;\r\n            const size = new Array(len);\r\n            size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;\r\n            const angle = new Array(len);\r\n            angle[index] = 0; // don't attempt to match glyph angle\r\n            return { sx, sy, _size: size, _angle: angle };\r\n        }\r\n        draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index) {\r\n            const args = this._get_legend_args({ x0, x1, y0, y1 }, index);\r\n            this._render(ctx, [index], args); // XXX\r\n        }\r\n    }\r\n    exports.MarkerView = MarkerView;\r\n    MarkerView.__name__ = \"MarkerView\";\r\n    class Marker extends xy_glyph_1.XYGlyph {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Marker() {\r\n            this.mixins([property_mixins_1.LineVector, property_mixins_1.FillVector]);\r\n            this.define({\r\n                size: [p.DistanceSpec, { units: \"screen\", value: 4 }],\r\n                angle: [p.AngleSpec, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.Marker = Marker;\r\n    Marker.__name__ = \"Marker\";\r\n    Marker.init_Marker();\r\n}\r\n","/* models\\markers\\scatter.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const marker_1 = require(289) /* ./marker */;\r\n    const defs_1 = require(288) /* ./defs */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class ScatterView extends marker_1.MarkerView {\r\n        _render(ctx, indices, { sx, sy, _size, _angle, _marker }) {\r\n            for (const i of indices) {\r\n                if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i]) || _marker[i] == null)\r\n                    continue;\r\n                const r = _size[i] / 2;\r\n                ctx.beginPath();\r\n                ctx.translate(sx[i], sy[i]);\r\n                if (_angle[i])\r\n                    ctx.rotate(_angle[i]);\r\n                defs_1.marker_funcs[_marker[i]](ctx, i, r, this.visuals.line, this.visuals.fill);\r\n                if (_angle[i])\r\n                    ctx.rotate(-_angle[i]);\r\n                ctx.translate(-sx[i], -sy[i]);\r\n            }\r\n        }\r\n        draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index) {\r\n            const args = this._get_legend_args({ x0, x1, y0, y1 }, index);\r\n            const len = index + 1;\r\n            const marker = new Array(len);\r\n            marker[index] = this._marker[index];\r\n            args._marker = marker;\r\n            this._render(ctx, [index], args); // XXX\r\n        }\r\n    }\r\n    exports.ScatterView = ScatterView;\r\n    ScatterView.__name__ = \"ScatterView\";\r\n    class Scatter extends marker_1.Marker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Scatter() {\r\n            this.prototype.default_view = ScatterView;\r\n            this.define({\r\n                marker: [p.MarkerSpec, { value: \"circle\" }],\r\n            });\r\n        }\r\n    }\r\n    exports.Scatter = Scatter;\r\n    Scatter.__name__ = \"Scatter\";\r\n    Scatter.init_Scatter();\r\n}\r\n","/* models\\plots\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var gmap_plot_1 = require(292) /* ./gmap_plot */;\r\n    exports.MapOptions = gmap_plot_1.MapOptions;\r\n    var gmap_plot_2 = require(292) /* ./gmap_plot */;\r\n    exports.GMapOptions = gmap_plot_2.GMapOptions;\r\n    var gmap_plot_3 = require(292) /* ./gmap_plot */;\r\n    exports.GMapPlot = gmap_plot_3.GMapPlot;\r\n    var plot_1 = require(293) /* ./plot */;\r\n    exports.Plot = plot_1.Plot;\r\n}\r\n","/* models\\plots\\gmap_plot.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const plot_1 = require(293) /* ./plot */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const model_1 = require(81) /* ../../model */;\r\n    const range1d_1 = require(158) /* ../ranges/range1d */;\r\n    const gmap_plot_canvas_1 = require(319) /* ./gmap_plot_canvas */;\r\n    exports.GMapPlotView = gmap_plot_canvas_1.GMapPlotView;\r\n    class MapOptions extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MapOptions() {\r\n            this.define({\r\n                lat: [p.Number],\r\n                lng: [p.Number],\r\n                zoom: [p.Number, 12],\r\n            });\r\n        }\r\n    }\r\n    exports.MapOptions = MapOptions;\r\n    MapOptions.__name__ = \"MapOptions\";\r\n    MapOptions.init_MapOptions();\r\n    class GMapOptions extends MapOptions {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GMapOptions() {\r\n            this.define({\r\n                map_type: [p.String, \"roadmap\"],\r\n                scale_control: [p.Boolean, false],\r\n                styles: [p.String],\r\n                tilt: [p.Int, 45],\r\n            });\r\n        }\r\n    }\r\n    exports.GMapOptions = GMapOptions;\r\n    GMapOptions.__name__ = \"GMapOptions\";\r\n    GMapOptions.init_GMapOptions();\r\n    class GMapPlot extends plot_1.Plot {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GMapPlot() {\r\n            this.prototype.default_view = gmap_plot_canvas_1.GMapPlotView;\r\n            // This seems to be necessary so that everything can initialize.\r\n            // Feels very clumsy, but I'm not sure how the properties system wants\r\n            // to handle something like this situation.\r\n            this.define({\r\n                map_options: [p.Instance],\r\n                api_key: [p.String],\r\n            });\r\n            this.override({\r\n                x_range: () => new range1d_1.Range1d(),\r\n                y_range: () => new range1d_1.Range1d(),\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.use_map = true;\r\n            if (!this.api_key)\r\n                logging_1.logger.error(\"api_key is required. See https://developers.google.com/maps/documentation/javascript/get-api-key for more information on how to obtain your own.\");\r\n        }\r\n    }\r\n    exports.GMapPlot = GMapPlot;\r\n    GMapPlot.__name__ = \"GMapPlot\";\r\n    GMapPlot.init_GMapPlot();\r\n}\r\n","/* models\\plots\\plot.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const mixins = tslib_1.__importStar(require(28) /* ../../core/property_mixins */);\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const layout_dom_1 = require(272) /* ../layouts/layout_dom */;\r\n    const title_1 = require(169) /* ../annotations/title */;\r\n    const linear_scale_1 = require(145) /* ../scales/linear_scale */;\r\n    const toolbar_1 = require(294) /* ../tools/toolbar */;\r\n    const column_data_source_1 = require(85) /* ../sources/column_data_source */;\r\n    const glyph_renderer_1 = require(90) /* ../renderers/glyph_renderer */;\r\n    const data_range1d_1 = require(210) /* ../ranges/data_range1d */;\r\n    const plot_canvas_1 = require(312) /* ./plot_canvas */;\r\n    exports.PlotView = plot_canvas_1.PlotView;\r\n    class Plot extends layout_dom_1.LayoutDOM {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Plot() {\r\n            this.prototype.default_view = plot_canvas_1.PlotView;\r\n            this.mixins([\r\n                [\"outline_\", mixins.Line],\r\n                [\"background_\", mixins.Fill],\r\n                [\"border_\", mixins.Fill],\r\n            ]);\r\n            this.define({\r\n                toolbar: [p.Instance, () => new toolbar_1.Toolbar()],\r\n                toolbar_location: [p.Location, 'right'],\r\n                toolbar_sticky: [p.Boolean, true],\r\n                plot_width: [p.Number, 600],\r\n                plot_height: [p.Number, 600],\r\n                frame_width: [p.Number, null],\r\n                frame_height: [p.Number, null],\r\n                title: [p.Any, () => new title_1.Title({ text: \"\" })],\r\n                title_location: [p.Location, 'above'],\r\n                above: [p.Array, []],\r\n                below: [p.Array, []],\r\n                left: [p.Array, []],\r\n                right: [p.Array, []],\r\n                center: [p.Array, []],\r\n                renderers: [p.Array, []],\r\n                x_range: [p.Instance, () => new data_range1d_1.DataRange1d()],\r\n                extra_x_ranges: [p.Any, {}],\r\n                y_range: [p.Instance, () => new data_range1d_1.DataRange1d()],\r\n                extra_y_ranges: [p.Any, {}],\r\n                x_scale: [p.Instance, () => new linear_scale_1.LinearScale()],\r\n                y_scale: [p.Instance, () => new linear_scale_1.LinearScale()],\r\n                lod_factor: [p.Number, 10],\r\n                lod_interval: [p.Number, 300],\r\n                lod_threshold: [p.Number, 2000],\r\n                lod_timeout: [p.Number, 500],\r\n                hidpi: [p.Boolean, true],\r\n                output_backend: [p.OutputBackend, \"canvas\"],\r\n                min_border: [p.Number, 5],\r\n                min_border_top: [p.Number, null],\r\n                min_border_left: [p.Number, null],\r\n                min_border_bottom: [p.Number, null],\r\n                min_border_right: [p.Number, null],\r\n                inner_width: [p.Number],\r\n                inner_height: [p.Number],\r\n                outer_width: [p.Number],\r\n                outer_height: [p.Number],\r\n                match_aspect: [p.Boolean, false],\r\n                aspect_scale: [p.Number, 1],\r\n                reset_policy: [p.ResetPolicy, \"standard\"],\r\n            });\r\n            this.override({\r\n                outline_line_color: \"#e5e5e5\",\r\n                border_fill_color: \"#ffffff\",\r\n                background_fill_color: \"#ffffff\",\r\n            });\r\n        }\r\n        // TODO: change this when we drop ES5 compatibility (https://github.com/microsoft/TypeScript/issues/338)\r\n        get width() {\r\n            // const width = super.width\r\n            const width = this.properties.width.get_value();\r\n            return width != null ? width : this.plot_width;\r\n        }\r\n        set width(width) {\r\n            this.setv({ width, plot_width: width });\r\n        }\r\n        get height() {\r\n            // const height = super.height\r\n            const height = this.properties.height.get_value();\r\n            return height != null ? height : this.plot_height;\r\n        }\r\n        set height(height) {\r\n            this.setv({ height, plot_height: height });\r\n        }\r\n        _doc_attached() {\r\n            super._doc_attached();\r\n            this._push_changes([\r\n                [this.properties.inner_height, null, this.inner_height],\r\n                [this.properties.inner_width, null, this.inner_width],\r\n            ]);\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.reset = new signaling_1.Signal0(this, \"reset\");\r\n            for (const xr of object_1.values(this.extra_x_ranges).concat(this.x_range)) {\r\n                let plots = xr.plots;\r\n                if (types_1.isArray(plots)) {\r\n                    plots = plots.concat(this);\r\n                    xr.setv({ plots }, { silent: true });\r\n                }\r\n            }\r\n            for (const yr of object_1.values(this.extra_y_ranges).concat(this.y_range)) {\r\n                let plots = yr.plots;\r\n                if (types_1.isArray(plots)) {\r\n                    plots = plots.concat(this);\r\n                    yr.setv({ plots }, { silent: true });\r\n                }\r\n            }\r\n        }\r\n        add_layout(renderer, side = \"center\") {\r\n            const renderers = this.properties[side].get_value();\r\n            this.setv({ [side]: [...renderers, renderer] });\r\n        }\r\n        remove_layout(renderer) {\r\n            const del = (items) => {\r\n                array_1.remove_by(items, (item) => item == renderer);\r\n            };\r\n            del(this.left);\r\n            del(this.right);\r\n            del(this.above);\r\n            del(this.below);\r\n            del(this.center);\r\n        }\r\n        add_renderers(...renderers) {\r\n            this.renderers = this.renderers.concat(renderers);\r\n        }\r\n        add_glyph(glyph, source = new column_data_source_1.ColumnDataSource(), extra_attrs = {}) {\r\n            const attrs = Object.assign(Object.assign({}, extra_attrs), { data_source: source, glyph });\r\n            const renderer = new glyph_renderer_1.GlyphRenderer(attrs);\r\n            this.add_renderers(renderer);\r\n            return renderer;\r\n        }\r\n        add_tools(...tools) {\r\n            this.toolbar.tools = this.toolbar.tools.concat(tools);\r\n        }\r\n        get panels() {\r\n            return [...this.side_panels, ...this.center];\r\n        }\r\n        get side_panels() {\r\n            const { above, below, left, right } = this;\r\n            return array_1.concat([above, below, left, right]);\r\n        }\r\n    }\r\n    exports.Plot = Plot;\r\n    Plot.__name__ = \"Plot\";\r\n    Plot.init_Plot();\r\n}\r\n","/* models\\tools\\toolbar.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const inspect_tool_1 = require(295) /* ./inspectors/inspect_tool */;\r\n    const toolbar_base_1 = require(305) /* ./toolbar_base */;\r\n    const _get_active_attr = (et) => {\r\n        switch (et) {\r\n            case 'tap': return 'active_tap';\r\n            case 'pan': return 'active_drag';\r\n            case 'pinch':\r\n            case 'scroll': return 'active_scroll';\r\n            case 'multi': return 'active_multi';\r\n        }\r\n        return null;\r\n    };\r\n    const _supports_auto = (et) => {\r\n        return et == 'tap' || et == 'pan';\r\n    };\r\n    class Toolbar extends toolbar_base_1.ToolbarBase {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Toolbar() {\r\n            this.prototype.default_view = toolbar_base_1.ToolbarBaseView;\r\n            this.define({\r\n                active_drag: [p.Any, 'auto'],\r\n                active_inspect: [p.Any, 'auto'],\r\n                active_scroll: [p.Any, 'auto'],\r\n                active_tap: [p.Any, 'auto'],\r\n                active_multi: [p.Any, null],\r\n            });\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            const { tools, active_drag, active_inspect, active_scroll, active_tap, active_multi } = this.properties;\r\n            this.on_change([tools, active_drag, active_inspect, active_scroll, active_tap, active_multi], () => this._init_tools());\r\n        }\r\n        _init_tools() {\r\n            super._init_tools();\r\n            if (this.active_inspect == 'auto') {\r\n                // do nothing as all tools are active be default\r\n            }\r\n            else if (this.active_inspect instanceof inspect_tool_1.InspectTool) {\r\n                let found = false;\r\n                for (const inspector of this.inspectors) {\r\n                    if (inspector != this.active_inspect)\r\n                        inspector.active = false;\r\n                    else\r\n                        found = true;\r\n                }\r\n                if (!found) {\r\n                    this.active_inspect = null;\r\n                }\r\n            }\r\n            else if (types_1.isArray(this.active_inspect)) {\r\n                const active_inspect = array_1.intersection(this.active_inspect, this.inspectors);\r\n                if (active_inspect.length != this.active_inspect.length) {\r\n                    this.active_inspect = active_inspect;\r\n                }\r\n                for (const inspector of this.inspectors) {\r\n                    if (!array_1.includes(this.active_inspect, inspector))\r\n                        inspector.active = false;\r\n                }\r\n            }\r\n            else if (this.active_inspect == null) {\r\n                for (const inspector of this.inspectors)\r\n                    inspector.active = false;\r\n            }\r\n            const _activate_gesture = (tool) => {\r\n                if (tool.active) {\r\n                    // tool was activated by a proxy, but we need to finish configuration manually\r\n                    this._active_change(tool);\r\n                }\r\n                else\r\n                    tool.active = true;\r\n            };\r\n            // Connecting signals has to be done before changing the active state of the tools.\r\n            for (const gesture of object_1.values(this.gestures)) {\r\n                gesture.tools = array_1.sort_by(gesture.tools, (tool) => tool.default_order);\r\n                for (const tool of gesture.tools) {\r\n                    this.connect(tool.properties.active.change, () => this._active_change(tool));\r\n                }\r\n            }\r\n            for (const [et, gesture] of object_1.entries(this.gestures)) {\r\n                const active_attr = _get_active_attr(et);\r\n                if (active_attr) {\r\n                    const active_tool = this[active_attr];\r\n                    if (active_tool == 'auto') {\r\n                        if (gesture.tools.length != 0 && _supports_auto(et)) {\r\n                            _activate_gesture(gesture.tools[0]);\r\n                        }\r\n                    }\r\n                    else if (active_tool != null) {\r\n                        if (array_1.includes(this.tools, active_tool)) {\r\n                            _activate_gesture(active_tool);\r\n                        }\r\n                        else {\r\n                            this[active_attr] = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.Toolbar = Toolbar;\r\n    Toolbar.__name__ = \"Toolbar\";\r\n    Toolbar.init_Toolbar();\r\n}\r\n","/* models\\tools\\inspectors\\inspect_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const button_tool_1 = require(296) /* ../button_tool */;\r\n    const on_off_button_1 = require(304) /* ../on_off_button */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    class InspectToolView extends button_tool_1.ButtonToolView {\r\n    }\r\n    exports.InspectToolView = InspectToolView;\r\n    InspectToolView.__name__ = \"InspectToolView\";\r\n    class InspectTool extends button_tool_1.ButtonTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.event_type = \"move\";\r\n        }\r\n        static init_InspectTool() {\r\n            this.prototype.button_view = on_off_button_1.OnOffButtonView;\r\n            this.define({\r\n                toggleable: [p.Boolean, true],\r\n            });\r\n            this.override({\r\n                active: true,\r\n            });\r\n        }\r\n    }\r\n    exports.InspectTool = InspectTool;\r\n    InspectTool.__name__ = \"InspectTool\";\r\n    InspectTool.init_InspectTool();\r\n}\r\n","/* models\\tools\\button_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const hammerjs_1 = tslib_1.__importDefault(require(297) /* hammerjs */);\r\n    const dom_view_1 = require(78) /* ../../core/dom_view */;\r\n    const tool_1 = require(298) /* ./tool */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const string_1 = require(29) /* ../../core/util/string */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const toolbar_1 = require(299) /* ../../styles/toolbar */;\r\n    const toolbar_css_1 = tslib_1.__importDefault(require(300) /* ../../styles/toolbar.css */);\r\n    const icons_css_1 = tslib_1.__importDefault(require(301) /* ../../styles/icons.css */);\r\n    const menus_css_1 = tslib_1.__importDefault(require(284) /* ../../styles/menus.css */);\r\n    const menus_1 = require(302) /* ../../core/util/menus */;\r\n    class ButtonToolButtonView extends dom_view_1.DOMView {\r\n        initialize() {\r\n            super.initialize();\r\n            const items = this.model.menu;\r\n            if (items != null) {\r\n                const location = this.parent.model.toolbar_location;\r\n                const reverse = location == \"left\" || location == \"above\";\r\n                const orientation = this.parent.model.horizontal ? \"vertical\" : \"horizontal\";\r\n                this._menu = new menus_1.ContextMenu(!reverse ? items : array_1.reversed(items), {\r\n                    orientation,\r\n                    prevent_hide: (event) => event.target == this.el,\r\n                });\r\n            }\r\n            this._hammer = new hammerjs_1.default(this.el, {\r\n                touchAction: \"auto\",\r\n                inputClass: hammerjs_1.default.TouchMouseInput,\r\n            });\r\n            this.connect(this.model.change, () => this.render());\r\n            this._hammer.on(\"tap\", (e) => {\r\n                var _a;\r\n                if ((_a = this._menu) === null || _a === void 0 ? void 0 : _a.is_open) {\r\n                    this._menu.hide();\r\n                    return;\r\n                }\r\n                if (e.target == this.el) {\r\n                    this._clicked();\r\n                }\r\n            });\r\n            this._hammer.on(\"press\", () => this._pressed());\r\n        }\r\n        remove() {\r\n            var _a;\r\n            this._hammer.destroy();\r\n            (_a = this._menu) === null || _a === void 0 ? void 0 : _a.remove();\r\n            super.remove();\r\n        }\r\n        styles() {\r\n            return [...super.styles(), toolbar_css_1.default, icons_css_1.default, menus_css_1.default];\r\n        }\r\n        css_classes() {\r\n            return super.css_classes().concat(toolbar_1.bk_toolbar_button);\r\n        }\r\n        render() {\r\n            dom_1.empty(this.el);\r\n            const icon = this.model.computed_icon;\r\n            if (types_1.isString(icon)) {\r\n                if (string_1.startsWith(icon, \"data:image\"))\r\n                    this.el.style.backgroundImage = \"url('\" + icon + \"')\";\r\n                else\r\n                    this.el.classList.add(icon);\r\n            }\r\n            this.el.title = this.model.tooltip;\r\n            if (this._menu != null) {\r\n                this.root.el.appendChild(this._menu.el);\r\n            }\r\n        }\r\n        _pressed() {\r\n            var _a;\r\n            const { left, top, right, bottom } = this.el.getBoundingClientRect();\r\n            const at = (() => {\r\n                switch (this.parent.model.toolbar_location) {\r\n                    case \"right\":\r\n                        return { right: left, top };\r\n                    case \"left\":\r\n                        return { left: right, top };\r\n                    case \"above\":\r\n                        return { left, top: bottom };\r\n                    case \"below\":\r\n                        return { left, bottom: top };\r\n                }\r\n            })();\r\n            (_a = this._menu) === null || _a === void 0 ? void 0 : _a.toggle(at);\r\n        }\r\n    }\r\n    exports.ButtonToolButtonView = ButtonToolButtonView;\r\n    ButtonToolButtonView.__name__ = \"ButtonToolButtonView\";\r\n    class ButtonToolView extends tool_1.ToolView {\r\n    }\r\n    exports.ButtonToolView = ButtonToolView;\r\n    ButtonToolView.__name__ = \"ButtonToolView\";\r\n    class ButtonTool extends tool_1.Tool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ButtonTool() {\r\n            this.internal({\r\n                disabled: [p.Boolean, false],\r\n            });\r\n        }\r\n        get tooltip() {\r\n            return this.tool_name;\r\n        }\r\n        get computed_icon() {\r\n            return this.icon;\r\n        }\r\n        get menu() {\r\n            return null;\r\n        }\r\n    }\r\n    exports.ButtonTool = ButtonTool;\r\n    ButtonTool.__name__ = \"ButtonTool\";\r\n    ButtonTool.init_ButtonTool();\r\n}\r\n","/* hammerjs\\hammer.js */ function _(require, module, exports) {\r\n    /*! Hammer.JS - v2.0.7 - 2016-04-22\r\n     * http://hammerjs.github.io/\r\n     *\r\n     * Copyright (c) 2016 Jorik Tangelder;\r\n     * Licensed under the MIT license */\r\n    (function (window, document, exportName, undefined) {\r\n        'use strict';\r\n        var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\r\n        var TEST_ELEMENT = document.createElement('div');\r\n        var TYPE_FUNCTION = 'function';\r\n        var round = Math.round;\r\n        var abs = Math.abs;\r\n        var now = Date.now;\r\n        /**\r\n         * set a timeout with a given scope\r\n         * @param {Function} fn\r\n         * @param {Number} timeout\r\n         * @param {Object} context\r\n         * @returns {number}\r\n         */\r\n        function setTimeoutContext(fn, timeout, context) {\r\n            return setTimeout(bindFn(fn, context), timeout);\r\n        }\r\n        /**\r\n         * if the argument is an array, we want to execute the fn on each entry\r\n         * if it aint an array we don't want to do a thing.\r\n         * this is used by all the methods that accept a single and array argument.\r\n         * @param {*|Array} arg\r\n         * @param {String} fn\r\n         * @param {Object} [context]\r\n         * @returns {Boolean}\r\n         */\r\n        function invokeArrayArg(arg, fn, context) {\r\n            if (Array.isArray(arg)) {\r\n                each(arg, context[fn], context);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        /**\r\n         * walk objects and arrays\r\n         * @param {Object} obj\r\n         * @param {Function} iterator\r\n         * @param {Object} context\r\n         */\r\n        function each(obj, iterator, context) {\r\n            var i;\r\n            if (!obj) {\r\n                return;\r\n            }\r\n            if (obj.forEach) {\r\n                obj.forEach(iterator, context);\r\n            }\r\n            else if (obj.length !== undefined) {\r\n                i = 0;\r\n                while (i < obj.length) {\r\n                    iterator.call(context, obj[i], i, obj);\r\n                    i++;\r\n                }\r\n            }\r\n            else {\r\n                for (i in obj) {\r\n                    obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * wrap a method with a deprecation warning and stack trace\r\n         * @param {Function} method\r\n         * @param {String} name\r\n         * @param {String} message\r\n         * @returns {Function} A new function wrapping the supplied method.\r\n         */\r\n        function deprecate(method, name, message) {\r\n            var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\r\n            return function () {\r\n                var e = new Error('get-stack-trace');\r\n                var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\r\n                    .replace(/^\\s+at\\s+/gm, '')\r\n                    .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\r\n                var log = window.console && (window.console.warn || window.console.log);\r\n                if (log) {\r\n                    log.call(window.console, deprecationMessage, stack);\r\n                }\r\n                return method.apply(this, arguments);\r\n            };\r\n        }\r\n        /**\r\n         * extend object.\r\n         * means that properties in dest will be overwritten by the ones in src.\r\n         * @param {Object} target\r\n         * @param {...Object} objects_to_assign\r\n         * @returns {Object} target\r\n         */\r\n        var assign;\r\n        if (typeof Object.assign !== 'function') {\r\n            assign = function assign(target) {\r\n                if (target === undefined || target === null) {\r\n                    throw new TypeError('Cannot convert undefined or null to object');\r\n                }\r\n                var output = Object(target);\r\n                for (var index = 1; index < arguments.length; index++) {\r\n                    var source = arguments[index];\r\n                    if (source !== undefined && source !== null) {\r\n                        for (var nextKey in source) {\r\n                            if (source.hasOwnProperty(nextKey)) {\r\n                                output[nextKey] = source[nextKey];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return output;\r\n            };\r\n        }\r\n        else {\r\n            assign = Object.assign;\r\n        }\r\n        /**\r\n         * extend object.\r\n         * means that properties in dest will be overwritten by the ones in src.\r\n         * @param {Object} dest\r\n         * @param {Object} src\r\n         * @param {Boolean} [merge=false]\r\n         * @returns {Object} dest\r\n         */\r\n        var extend = deprecate(function extend(dest, src, merge) {\r\n            var keys = Object.keys(src);\r\n            var i = 0;\r\n            while (i < keys.length) {\r\n                if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n                    dest[keys[i]] = src[keys[i]];\r\n                }\r\n                i++;\r\n            }\r\n            return dest;\r\n        }, 'extend', 'Use `assign`.');\r\n        /**\r\n         * merge the values from src in the dest.\r\n         * means that properties that exist in dest will not be overwritten by src\r\n         * @param {Object} dest\r\n         * @param {Object} src\r\n         * @returns {Object} dest\r\n         */\r\n        var merge = deprecate(function merge(dest, src) {\r\n            return extend(dest, src, true);\r\n        }, 'merge', 'Use `assign`.');\r\n        /**\r\n         * simple class inheritance\r\n         * @param {Function} child\r\n         * @param {Function} base\r\n         * @param {Object} [properties]\r\n         */\r\n        function inherit(child, base, properties) {\r\n            var baseP = base.prototype, childP;\r\n            childP = child.prototype = Object.create(baseP);\r\n            childP.constructor = child;\r\n            childP._super = baseP;\r\n            if (properties) {\r\n                assign(childP, properties);\r\n            }\r\n        }\r\n        /**\r\n         * simple function bind\r\n         * @param {Function} fn\r\n         * @param {Object} context\r\n         * @returns {Function}\r\n         */\r\n        function bindFn(fn, context) {\r\n            return function boundFn() {\r\n                return fn.apply(context, arguments);\r\n            };\r\n        }\r\n        /**\r\n         * let a boolean value also be a function that must return a boolean\r\n         * this first item in args will be used as the context\r\n         * @param {Boolean|Function} val\r\n         * @param {Array} [args]\r\n         * @returns {Boolean}\r\n         */\r\n        function boolOrFn(val, args) {\r\n            if (typeof val == TYPE_FUNCTION) {\r\n                return val.apply(args ? args[0] || undefined : undefined, args);\r\n            }\r\n            return val;\r\n        }\r\n        /**\r\n         * use the val2 when val1 is undefined\r\n         * @param {*} val1\r\n         * @param {*} val2\r\n         * @returns {*}\r\n         */\r\n        function ifUndefined(val1, val2) {\r\n            return (val1 === undefined) ? val2 : val1;\r\n        }\r\n        /**\r\n         * addEventListener with multiple events at once\r\n         * @param {EventTarget} target\r\n         * @param {String} types\r\n         * @param {Function} handler\r\n         */\r\n        function addEventListeners(target, types, handler) {\r\n            each(splitStr(types), function (type) {\r\n                target.addEventListener(type, handler, false);\r\n            });\r\n        }\r\n        /**\r\n         * removeEventListener with multiple events at once\r\n         * @param {EventTarget} target\r\n         * @param {String} types\r\n         * @param {Function} handler\r\n         */\r\n        function removeEventListeners(target, types, handler) {\r\n            each(splitStr(types), function (type) {\r\n                target.removeEventListener(type, handler, false);\r\n            });\r\n        }\r\n        /**\r\n         * find if a node is in the given parent\r\n         * @method hasParent\r\n         * @param {HTMLElement} node\r\n         * @param {HTMLElement} parent\r\n         * @return {Boolean} found\r\n         */\r\n        function hasParent(node, parent) {\r\n            while (node) {\r\n                if (node == parent) {\r\n                    return true;\r\n                }\r\n                node = node.parentNode;\r\n            }\r\n            return false;\r\n        }\r\n        /**\r\n         * small indexOf wrapper\r\n         * @param {String} str\r\n         * @param {String} find\r\n         * @returns {Boolean} found\r\n         */\r\n        function inStr(str, find) {\r\n            return str.indexOf(find) > -1;\r\n        }\r\n        /**\r\n         * split string on whitespace\r\n         * @param {String} str\r\n         * @returns {Array} words\r\n         */\r\n        function splitStr(str) {\r\n            return str.trim().split(/\\s+/g);\r\n        }\r\n        /**\r\n         * find if a array contains the object using indexOf or a simple polyFill\r\n         * @param {Array} src\r\n         * @param {String} find\r\n         * @param {String} [findByKey]\r\n         * @return {Boolean|Number} false when not found, or the index\r\n         */\r\n        function inArray(src, find, findByKey) {\r\n            if (src.indexOf && !findByKey) {\r\n                return src.indexOf(find);\r\n            }\r\n            else {\r\n                var i = 0;\r\n                while (i < src.length) {\r\n                    if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                        return i;\r\n                    }\r\n                    i++;\r\n                }\r\n                return -1;\r\n            }\r\n        }\r\n        /**\r\n         * convert array-like objects to real arrays\r\n         * @param {Object} obj\r\n         * @returns {Array}\r\n         */\r\n        function toArray(obj) {\r\n            return Array.prototype.slice.call(obj, 0);\r\n        }\r\n        /**\r\n         * unique array with objects based on a key (like 'id') or just by the array's value\r\n         * @param {Array} src [{id:1},{id:2},{id:1}]\r\n         * @param {String} [key]\r\n         * @param {Boolean} [sort=False]\r\n         * @returns {Array} [{id:1},{id:2}]\r\n         */\r\n        function uniqueArray(src, key, sort) {\r\n            var results = [];\r\n            var values = [];\r\n            var i = 0;\r\n            while (i < src.length) {\r\n                var val = key ? src[i][key] : src[i];\r\n                if (inArray(values, val) < 0) {\r\n                    results.push(src[i]);\r\n                }\r\n                values[i] = val;\r\n                i++;\r\n            }\r\n            if (sort) {\r\n                if (!key) {\r\n                    results = results.sort();\r\n                }\r\n                else {\r\n                    results = results.sort(function sortUniqueArray(a, b) {\r\n                        return a[key] > b[key];\r\n                    });\r\n                }\r\n            }\r\n            return results;\r\n        }\r\n        /**\r\n         * get the prefixed property\r\n         * @param {Object} obj\r\n         * @param {String} property\r\n         * @returns {String|Undefined} prefixed\r\n         */\r\n        function prefixed(obj, property) {\r\n            var prefix, prop;\r\n            var camelProp = property[0].toUpperCase() + property.slice(1);\r\n            var i = 0;\r\n            while (i < VENDOR_PREFIXES.length) {\r\n                prefix = VENDOR_PREFIXES[i];\r\n                prop = (prefix) ? prefix + camelProp : property;\r\n                if (prop in obj) {\r\n                    return prop;\r\n                }\r\n                i++;\r\n            }\r\n            return undefined;\r\n        }\r\n        /**\r\n         * get a unique id\r\n         * @returns {number} uniqueId\r\n         */\r\n        var _uniqueId = 1;\r\n        function uniqueId() {\r\n            return _uniqueId++;\r\n        }\r\n        /**\r\n         * get the window object of an element\r\n         * @param {HTMLElement} element\r\n         * @returns {DocumentView|Window}\r\n         */\r\n        function getWindowForElement(element) {\r\n            var doc = element.ownerDocument || element;\r\n            return (doc.defaultView || doc.parentWindow || window);\r\n        }\r\n        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n        var SUPPORT_TOUCH = ('ontouchstart' in window);\r\n        var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\n        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n        var INPUT_TYPE_TOUCH = 'touch';\r\n        var INPUT_TYPE_PEN = 'pen';\r\n        var INPUT_TYPE_MOUSE = 'mouse';\r\n        var INPUT_TYPE_KINECT = 'kinect';\r\n        var COMPUTE_INTERVAL = 25;\r\n        var INPUT_START = 1;\r\n        var INPUT_MOVE = 2;\r\n        var INPUT_END = 4;\r\n        var INPUT_CANCEL = 8;\r\n        var DIRECTION_NONE = 1;\r\n        var DIRECTION_LEFT = 2;\r\n        var DIRECTION_RIGHT = 4;\r\n        var DIRECTION_UP = 8;\r\n        var DIRECTION_DOWN = 16;\r\n        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\n        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\n        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n        var PROPS_XY = ['x', 'y'];\r\n        var PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n        /**\r\n         * create new input type manager\r\n         * @param {Manager} manager\r\n         * @param {Function} callback\r\n         * @returns {Input}\r\n         * @constructor\r\n         */\r\n        function Input(manager, callback) {\r\n            var self = this;\r\n            this.manager = manager;\r\n            this.callback = callback;\r\n            this.element = manager.element;\r\n            this.target = manager.options.inputTarget;\r\n            // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n            // so when disabled the input events are completely bypassed.\r\n            this.domHandler = function (ev) {\r\n                if (boolOrFn(manager.options.enable, [manager])) {\r\n                    self.handler(ev);\r\n                }\r\n            };\r\n            this.init();\r\n        }\r\n        Input.prototype = {\r\n            /**\r\n             * should handle the inputEvent data and trigger the callback\r\n             * @virtual\r\n             */\r\n            handler: function () { },\r\n            /**\r\n             * bind the events\r\n             */\r\n            init: function () {\r\n                this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\r\n                this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\r\n                this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n            },\r\n            /**\r\n             * unbind the events\r\n             */\r\n            destroy: function () {\r\n                this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\r\n                this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\r\n                this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n            }\r\n        };\r\n        /**\r\n         * create new input type manager\r\n         * called by the Manager constructor\r\n         * @param {Hammer} manager\r\n         * @returns {Input}\r\n         */\r\n        function createInputInstance(manager) {\r\n            var Type;\r\n            var inputClass = manager.options.inputClass;\r\n            if (inputClass) {\r\n                Type = inputClass;\r\n            }\r\n            else if (SUPPORT_POINTER_EVENTS) {\r\n                Type = PointerEventInput;\r\n            }\r\n            else if (SUPPORT_ONLY_TOUCH) {\r\n                Type = TouchInput;\r\n            }\r\n            else if (!SUPPORT_TOUCH) {\r\n                Type = MouseInput;\r\n            }\r\n            else {\r\n                Type = TouchMouseInput;\r\n            }\r\n            return new (Type)(manager, inputHandler);\r\n        }\r\n        /**\r\n         * handle input events\r\n         * @param {Manager} manager\r\n         * @param {String} eventType\r\n         * @param {Object} input\r\n         */\r\n        function inputHandler(manager, eventType, input) {\r\n            var pointersLen = input.pointers.length;\r\n            var changedPointersLen = input.changedPointers.length;\r\n            var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n            var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\r\n            input.isFirst = !!isFirst;\r\n            input.isFinal = !!isFinal;\r\n            if (isFirst) {\r\n                manager.session = {};\r\n            }\r\n            // source event is the normalized value of the domEvents\r\n            // like 'touchstart, mouseup, pointerdown'\r\n            input.eventType = eventType;\r\n            // compute scale, rotation etc\r\n            computeInputData(manager, input);\r\n            // emit secret event\r\n            manager.emit('hammer.input', input);\r\n            manager.recognize(input);\r\n            manager.session.prevInput = input;\r\n        }\r\n        /**\r\n         * extend the data with some usable properties like scale, rotate, velocity etc\r\n         * @param {Object} manager\r\n         * @param {Object} input\r\n         */\r\n        function computeInputData(manager, input) {\r\n            var session = manager.session;\r\n            var pointers = input.pointers;\r\n            var pointersLength = pointers.length;\r\n            // store the first input to calculate the distance and direction\r\n            if (!session.firstInput) {\r\n                session.firstInput = simpleCloneInputData(input);\r\n            }\r\n            // to compute scale and rotation we need to store the multiple touches\r\n            if (pointersLength > 1 && !session.firstMultiple) {\r\n                session.firstMultiple = simpleCloneInputData(input);\r\n            }\r\n            else if (pointersLength === 1) {\r\n                session.firstMultiple = false;\r\n            }\r\n            var firstInput = session.firstInput;\r\n            var firstMultiple = session.firstMultiple;\r\n            var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n            var center = input.center = getCenter(pointers);\r\n            input.timeStamp = now();\r\n            input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n            input.angle = getAngle(offsetCenter, center);\r\n            input.distance = getDistance(offsetCenter, center);\r\n            computeDeltaXY(session, input);\r\n            input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n            var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\r\n            input.overallVelocityX = overallVelocity.x;\r\n            input.overallVelocityY = overallVelocity.y;\r\n            input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\r\n            input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n            input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n            input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\r\n                session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\r\n            computeIntervalInputData(session, input);\r\n            // find the correct target\r\n            var target = manager.element;\r\n            if (hasParent(input.srcEvent.target, target)) {\r\n                target = input.srcEvent.target;\r\n            }\r\n            input.target = target;\r\n        }\r\n        function computeDeltaXY(session, input) {\r\n            var center = input.center;\r\n            var offset = session.offsetDelta || {};\r\n            var prevDelta = session.prevDelta || {};\r\n            var prevInput = session.prevInput || {};\r\n            if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\r\n                prevDelta = session.prevDelta = {\r\n                    x: prevInput.deltaX || 0,\r\n                    y: prevInput.deltaY || 0\r\n                };\r\n                offset = session.offsetDelta = {\r\n                    x: center.x,\r\n                    y: center.y\r\n                };\r\n            }\r\n            input.deltaX = prevDelta.x + (center.x - offset.x);\r\n            input.deltaY = prevDelta.y + (center.y - offset.y);\r\n        }\r\n        /**\r\n         * velocity is calculated every x ms\r\n         * @param {Object} session\r\n         * @param {Object} input\r\n         */\r\n        function computeIntervalInputData(session, input) {\r\n            var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;\r\n            if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\r\n                var deltaX = input.deltaX - last.deltaX;\r\n                var deltaY = input.deltaY - last.deltaY;\r\n                var v = getVelocity(deltaTime, deltaX, deltaY);\r\n                velocityX = v.x;\r\n                velocityY = v.y;\r\n                velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\r\n                direction = getDirection(deltaX, deltaY);\r\n                session.lastInterval = input;\r\n            }\r\n            else {\r\n                // use latest velocity info if it doesn't overtake a minimum period\r\n                velocity = last.velocity;\r\n                velocityX = last.velocityX;\r\n                velocityY = last.velocityY;\r\n                direction = last.direction;\r\n            }\r\n            input.velocity = velocity;\r\n            input.velocityX = velocityX;\r\n            input.velocityY = velocityY;\r\n            input.direction = direction;\r\n        }\r\n        /**\r\n         * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n         * @param {Object} input\r\n         * @returns {Object} clonedInputData\r\n         */\r\n        function simpleCloneInputData(input) {\r\n            // make a simple copy of the pointers because we will get a reference if we don't\r\n            // we only need clientXY for the calculations\r\n            var pointers = [];\r\n            var i = 0;\r\n            while (i < input.pointers.length) {\r\n                pointers[i] = {\r\n                    clientX: round(input.pointers[i].clientX),\r\n                    clientY: round(input.pointers[i].clientY)\r\n                };\r\n                i++;\r\n            }\r\n            return {\r\n                timeStamp: now(),\r\n                pointers: pointers,\r\n                center: getCenter(pointers),\r\n                deltaX: input.deltaX,\r\n                deltaY: input.deltaY\r\n            };\r\n        }\r\n        /**\r\n         * get the center of all the pointers\r\n         * @param {Array} pointers\r\n         * @return {Object} center contains `x` and `y` properties\r\n         */\r\n        function getCenter(pointers) {\r\n            var pointersLength = pointers.length;\r\n            // no need to loop when only one touch\r\n            if (pointersLength === 1) {\r\n                return {\r\n                    x: round(pointers[0].clientX),\r\n                    y: round(pointers[0].clientY)\r\n                };\r\n            }\r\n            var x = 0, y = 0, i = 0;\r\n            while (i < pointersLength) {\r\n                x += pointers[i].clientX;\r\n                y += pointers[i].clientY;\r\n                i++;\r\n            }\r\n            return {\r\n                x: round(x / pointersLength),\r\n                y: round(y / pointersLength)\r\n            };\r\n        }\r\n        /**\r\n         * calculate the velocity between two points. unit is in px per ms.\r\n         * @param {Number} deltaTime\r\n         * @param {Number} x\r\n         * @param {Number} y\r\n         * @return {Object} velocity `x` and `y`\r\n         */\r\n        function getVelocity(deltaTime, x, y) {\r\n            return {\r\n                x: x / deltaTime || 0,\r\n                y: y / deltaTime || 0\r\n            };\r\n        }\r\n        /**\r\n         * get the direction between two points\r\n         * @param {Number} x\r\n         * @param {Number} y\r\n         * @return {Number} direction\r\n         */\r\n        function getDirection(x, y) {\r\n            if (x === y) {\r\n                return DIRECTION_NONE;\r\n            }\r\n            if (abs(x) >= abs(y)) {\r\n                return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n            }\r\n            return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n        }\r\n        /**\r\n         * calculate the absolute distance between two points\r\n         * @param {Object} p1 {x, y}\r\n         * @param {Object} p2 {x, y}\r\n         * @param {Array} [props] containing x and y keys\r\n         * @return {Number} distance\r\n         */\r\n        function getDistance(p1, p2, props) {\r\n            if (!props) {\r\n                props = PROPS_XY;\r\n            }\r\n            var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];\r\n            return Math.sqrt((x * x) + (y * y));\r\n        }\r\n        /**\r\n         * calculate the angle between two coordinates\r\n         * @param {Object} p1\r\n         * @param {Object} p2\r\n         * @param {Array} [props] containing x and y keys\r\n         * @return {Number} angle\r\n         */\r\n        function getAngle(p1, p2, props) {\r\n            if (!props) {\r\n                props = PROPS_XY;\r\n            }\r\n            var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];\r\n            return Math.atan2(y, x) * 180 / Math.PI;\r\n        }\r\n        /**\r\n         * calculate the rotation degrees between two pointersets\r\n         * @param {Array} start array of pointers\r\n         * @param {Array} end array of pointers\r\n         * @return {Number} rotation\r\n         */\r\n        function getRotation(start, end) {\r\n            return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n        }\r\n        /**\r\n         * calculate the scale factor between two pointersets\r\n         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n         * @param {Array} start array of pointers\r\n         * @param {Array} end array of pointers\r\n         * @return {Number} scale\r\n         */\r\n        function getScale(start, end) {\r\n            return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n        }\r\n        var MOUSE_INPUT_MAP = {\r\n            mousedown: INPUT_START,\r\n            mousemove: INPUT_MOVE,\r\n            mouseup: INPUT_END\r\n        };\r\n        var MOUSE_ELEMENT_EVENTS = 'mousedown';\r\n        var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\r\n        /**\r\n         * Mouse events input\r\n         * @constructor\r\n         * @extends Input\r\n         */\r\n        function MouseInput() {\r\n            this.evEl = MOUSE_ELEMENT_EVENTS;\r\n            this.evWin = MOUSE_WINDOW_EVENTS;\r\n            this.pressed = false; // mousedown state\r\n            Input.apply(this, arguments);\r\n        }\r\n        inherit(MouseInput, Input, {\r\n            /**\r\n             * handle mouse events\r\n             * @param {Object} ev\r\n             */\r\n            handler: function MEhandler(ev) {\r\n                var eventType = MOUSE_INPUT_MAP[ev.type];\r\n                // on start we want to have the left mouse button down\r\n                if (eventType & INPUT_START && ev.button === 0) {\r\n                    this.pressed = true;\r\n                }\r\n                if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n                    eventType = INPUT_END;\r\n                }\r\n                // mouse must be down\r\n                if (!this.pressed) {\r\n                    return;\r\n                }\r\n                if (eventType & INPUT_END) {\r\n                    this.pressed = false;\r\n                }\r\n                this.callback(this.manager, eventType, {\r\n                    pointers: [ev],\r\n                    changedPointers: [ev],\r\n                    pointerType: INPUT_TYPE_MOUSE,\r\n                    srcEvent: ev\r\n                });\r\n            }\r\n        });\r\n        var POINTER_INPUT_MAP = {\r\n            pointerdown: INPUT_START,\r\n            pointermove: INPUT_MOVE,\r\n            pointerup: INPUT_END,\r\n            pointercancel: INPUT_CANCEL,\r\n            pointerout: INPUT_CANCEL\r\n        };\r\n        // in IE10 the pointer types is defined as an enum\r\n        var IE10_POINTER_TYPE_ENUM = {\r\n            2: INPUT_TYPE_TOUCH,\r\n            3: INPUT_TYPE_PEN,\r\n            4: INPUT_TYPE_MOUSE,\r\n            5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n        };\r\n        var POINTER_ELEMENT_EVENTS = 'pointerdown';\r\n        var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\r\n        // IE10 has prefixed support, and case-sensitive\r\n        if (window.MSPointerEvent && !window.PointerEvent) {\r\n            POINTER_ELEMENT_EVENTS = 'MSPointerDown';\r\n            POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\r\n        }\r\n        /**\r\n         * Pointer events input\r\n         * @constructor\r\n         * @extends Input\r\n         */\r\n        function PointerEventInput() {\r\n            this.evEl = POINTER_ELEMENT_EVENTS;\r\n            this.evWin = POINTER_WINDOW_EVENTS;\r\n            Input.apply(this, arguments);\r\n            this.store = (this.manager.session.pointerEvents = []);\r\n        }\r\n        inherit(PointerEventInput, Input, {\r\n            /**\r\n             * handle mouse events\r\n             * @param {Object} ev\r\n             */\r\n            handler: function PEhandler(ev) {\r\n                var store = this.store;\r\n                var removePointer = false;\r\n                var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n                var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n                var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n                var isTouch = (pointerType == INPUT_TYPE_TOUCH);\r\n                // get index of the event in the store\r\n                var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n                // start and mouse must be down\r\n                if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\r\n                    if (storeIndex < 0) {\r\n                        store.push(ev);\r\n                        storeIndex = store.length - 1;\r\n                    }\r\n                }\r\n                else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n                    removePointer = true;\r\n                }\r\n                // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n                if (storeIndex < 0) {\r\n                    return;\r\n                }\r\n                // update the event in the store\r\n                store[storeIndex] = ev;\r\n                this.callback(this.manager, eventType, {\r\n                    pointers: store,\r\n                    changedPointers: [ev],\r\n                    pointerType: pointerType,\r\n                    srcEvent: ev\r\n                });\r\n                if (removePointer) {\r\n                    // remove from the store\r\n                    store.splice(storeIndex, 1);\r\n                }\r\n            }\r\n        });\r\n        var SINGLE_TOUCH_INPUT_MAP = {\r\n            touchstart: INPUT_START,\r\n            touchmove: INPUT_MOVE,\r\n            touchend: INPUT_END,\r\n            touchcancel: INPUT_CANCEL\r\n        };\r\n        var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\r\n        var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n        /**\r\n         * Touch events input\r\n         * @constructor\r\n         * @extends Input\r\n         */\r\n        function SingleTouchInput() {\r\n            this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\r\n            this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\r\n            this.started = false;\r\n            Input.apply(this, arguments);\r\n        }\r\n        inherit(SingleTouchInput, Input, {\r\n            handler: function TEhandler(ev) {\r\n                var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\r\n                // should we handle the touch events?\r\n                if (type === INPUT_START) {\r\n                    this.started = true;\r\n                }\r\n                if (!this.started) {\r\n                    return;\r\n                }\r\n                var touches = normalizeSingleTouches.call(this, ev, type);\r\n                // when done, reset the started state\r\n                if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\r\n                    this.started = false;\r\n                }\r\n                this.callback(this.manager, type, {\r\n                    pointers: touches[0],\r\n                    changedPointers: touches[1],\r\n                    pointerType: INPUT_TYPE_TOUCH,\r\n                    srcEvent: ev\r\n                });\r\n            }\r\n        });\r\n        /**\r\n         * @this {TouchInput}\r\n         * @param {Object} ev\r\n         * @param {Number} type flag\r\n         * @returns {undefined|Array} [all, changed]\r\n         */\r\n        function normalizeSingleTouches(ev, type) {\r\n            var all = toArray(ev.touches);\r\n            var changed = toArray(ev.changedTouches);\r\n            if (type & (INPUT_END | INPUT_CANCEL)) {\r\n                all = uniqueArray(all.concat(changed), 'identifier', true);\r\n            }\r\n            return [all, changed];\r\n        }\r\n        var TOUCH_INPUT_MAP = {\r\n            touchstart: INPUT_START,\r\n            touchmove: INPUT_MOVE,\r\n            touchend: INPUT_END,\r\n            touchcancel: INPUT_CANCEL\r\n        };\r\n        var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n        /**\r\n         * Multi-user touch events input\r\n         * @constructor\r\n         * @extends Input\r\n         */\r\n        function TouchInput() {\r\n            this.evTarget = TOUCH_TARGET_EVENTS;\r\n            this.targetIds = {};\r\n            Input.apply(this, arguments);\r\n        }\r\n        inherit(TouchInput, Input, {\r\n            handler: function MTEhandler(ev) {\r\n                var type = TOUCH_INPUT_MAP[ev.type];\r\n                var touches = getTouches.call(this, ev, type);\r\n                if (!touches) {\r\n                    return;\r\n                }\r\n                this.callback(this.manager, type, {\r\n                    pointers: touches[0],\r\n                    changedPointers: touches[1],\r\n                    pointerType: INPUT_TYPE_TOUCH,\r\n                    srcEvent: ev\r\n                });\r\n            }\r\n        });\r\n        /**\r\n         * @this {TouchInput}\r\n         * @param {Object} ev\r\n         * @param {Number} type flag\r\n         * @returns {undefined|Array} [all, changed]\r\n         */\r\n        function getTouches(ev, type) {\r\n            var allTouches = toArray(ev.touches);\r\n            var targetIds = this.targetIds;\r\n            // when there is only one touch, the process can be simplified\r\n            if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\r\n                targetIds[allTouches[0].identifier] = true;\r\n                return [allTouches, allTouches];\r\n            }\r\n            var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;\r\n            // get target touches from touches\r\n            targetTouches = allTouches.filter(function (touch) {\r\n                return hasParent(touch.target, target);\r\n            });\r\n            // collect touches\r\n            if (type === INPUT_START) {\r\n                i = 0;\r\n                while (i < targetTouches.length) {\r\n                    targetIds[targetTouches[i].identifier] = true;\r\n                    i++;\r\n                }\r\n            }\r\n            // filter changed touches to only contain touches that exist in the collected target ids\r\n            i = 0;\r\n            while (i < changedTouches.length) {\r\n                if (targetIds[changedTouches[i].identifier]) {\r\n                    changedTargetTouches.push(changedTouches[i]);\r\n                }\r\n                // cleanup removed touches\r\n                if (type & (INPUT_END | INPUT_CANCEL)) {\r\n                    delete targetIds[changedTouches[i].identifier];\r\n                }\r\n                i++;\r\n            }\r\n            if (!changedTargetTouches.length) {\r\n                return;\r\n            }\r\n            return [\r\n                // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n                uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\r\n                changedTargetTouches\r\n            ];\r\n        }\r\n        /**\r\n         * Combined touch and mouse input\r\n         *\r\n         * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n         * This because touch devices also emit mouse events while doing a touch.\r\n         *\r\n         * @constructor\r\n         * @extends Input\r\n         */\r\n        var DEDUP_TIMEOUT = 2500;\r\n        var DEDUP_DISTANCE = 25;\r\n        function TouchMouseInput() {\r\n            Input.apply(this, arguments);\r\n            var handler = bindFn(this.handler, this);\r\n            this.touch = new TouchInput(this.manager, handler);\r\n            this.mouse = new MouseInput(this.manager, handler);\r\n            this.primaryTouch = null;\r\n            this.lastTouches = [];\r\n        }\r\n        inherit(TouchMouseInput, Input, {\r\n            /**\r\n             * handle mouse and touch events\r\n             * @param {Hammer} manager\r\n             * @param {String} inputEvent\r\n             * @param {Object} inputData\r\n             */\r\n            handler: function TMEhandler(manager, inputEvent, inputData) {\r\n                var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH), isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n                if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\r\n                    return;\r\n                }\r\n                // when we're in a touch event, record touches to  de-dupe synthetic mouse event\r\n                if (isTouch) {\r\n                    recordTouches.call(this, inputEvent, inputData);\r\n                }\r\n                else if (isMouse && isSyntheticEvent.call(this, inputData)) {\r\n                    return;\r\n                }\r\n                this.callback(manager, inputEvent, inputData);\r\n            },\r\n            /**\r\n             * remove the event listeners\r\n             */\r\n            destroy: function destroy() {\r\n                this.touch.destroy();\r\n                this.mouse.destroy();\r\n            }\r\n        });\r\n        function recordTouches(eventType, eventData) {\r\n            if (eventType & INPUT_START) {\r\n                this.primaryTouch = eventData.changedPointers[0].identifier;\r\n                setLastTouch.call(this, eventData);\r\n            }\r\n            else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n                setLastTouch.call(this, eventData);\r\n            }\r\n        }\r\n        function setLastTouch(eventData) {\r\n            var touch = eventData.changedPointers[0];\r\n            if (touch.identifier === this.primaryTouch) {\r\n                var lastTouch = { x: touch.clientX, y: touch.clientY };\r\n                this.lastTouches.push(lastTouch);\r\n                var lts = this.lastTouches;\r\n                var removeLastTouch = function () {\r\n                    var i = lts.indexOf(lastTouch);\r\n                    if (i > -1) {\r\n                        lts.splice(i, 1);\r\n                    }\r\n                };\r\n                setTimeout(removeLastTouch, DEDUP_TIMEOUT);\r\n            }\r\n        }\r\n        function isSyntheticEvent(eventData) {\r\n            var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\r\n            for (var i = 0; i < this.lastTouches.length; i++) {\r\n                var t = this.lastTouches[i];\r\n                var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\r\n                if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\r\n        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n        // magical touchAction value\r\n        var TOUCH_ACTION_COMPUTE = 'compute';\r\n        var TOUCH_ACTION_AUTO = 'auto';\r\n        var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\r\n        var TOUCH_ACTION_NONE = 'none';\r\n        var TOUCH_ACTION_PAN_X = 'pan-x';\r\n        var TOUCH_ACTION_PAN_Y = 'pan-y';\r\n        var TOUCH_ACTION_MAP = getTouchActionProps();\r\n        /**\r\n         * Touch Action\r\n         * sets the touchAction property or uses the js alternative\r\n         * @param {Manager} manager\r\n         * @param {String} value\r\n         * @constructor\r\n         */\r\n        function TouchAction(manager, value) {\r\n            this.manager = manager;\r\n            this.set(value);\r\n        }\r\n        TouchAction.prototype = {\r\n            /**\r\n             * set the touchAction value on the element or enable the polyfill\r\n             * @param {String} value\r\n             */\r\n            set: function (value) {\r\n                // find out the touch-action by the event handlers\r\n                if (value == TOUCH_ACTION_COMPUTE) {\r\n                    value = this.compute();\r\n                }\r\n                if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\r\n                    this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n                }\r\n                this.actions = value.toLowerCase().trim();\r\n            },\r\n            /**\r\n             * just re-set the touchAction value\r\n             */\r\n            update: function () {\r\n                this.set(this.manager.options.touchAction);\r\n            },\r\n            /**\r\n             * compute the value for the touchAction property based on the recognizer's settings\r\n             * @returns {String} value\r\n             */\r\n            compute: function () {\r\n                var actions = [];\r\n                each(this.manager.recognizers, function (recognizer) {\r\n                    if (boolOrFn(recognizer.options.enable, [recognizer])) {\r\n                        actions = actions.concat(recognizer.getTouchAction());\r\n                    }\r\n                });\r\n                return cleanTouchActions(actions.join(' '));\r\n            },\r\n            /**\r\n             * this method is called on each input cycle and provides the preventing of the browser behavior\r\n             * @param {Object} input\r\n             */\r\n            preventDefaults: function (input) {\r\n                var srcEvent = input.srcEvent;\r\n                var direction = input.offsetDirection;\r\n                // if the touch action did prevented once this session\r\n                if (this.manager.session.prevented) {\r\n                    srcEvent.preventDefault();\r\n                    return;\r\n                }\r\n                var actions = this.actions;\r\n                var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\r\n                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\r\n                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\r\n                if (hasNone) {\r\n                    //do not prevent defaults if this is a tap gesture\r\n                    var isTapPointer = input.pointers.length === 1;\r\n                    var isTapMovement = input.distance < 2;\r\n                    var isTapTouchTime = input.deltaTime < 250;\r\n                    if (isTapPointer && isTapMovement && isTapTouchTime) {\r\n                        return;\r\n                    }\r\n                }\r\n                if (hasPanX && hasPanY) {\r\n                    // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\r\n                    return;\r\n                }\r\n                if (hasNone ||\r\n                    (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n                    (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n                    return this.preventSrc(srcEvent);\r\n                }\r\n            },\r\n            /**\r\n             * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n             * @param {Object} srcEvent\r\n             */\r\n            preventSrc: function (srcEvent) {\r\n                this.manager.session.prevented = true;\r\n                srcEvent.preventDefault();\r\n            }\r\n        };\r\n        /**\r\n         * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n         * @param {String} actions\r\n         * @returns {*}\r\n         */\r\n        function cleanTouchActions(actions) {\r\n            // none\r\n            if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n                return TOUCH_ACTION_NONE;\r\n            }\r\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n            // if both pan-x and pan-y are set (different recognizers\r\n            // for different directions, e.g. horizontal pan but vertical swipe?)\r\n            // we need none (as otherwise with pan-x pan-y combined none of these\r\n            // recognizers will work, since the browser would handle all panning\r\n            if (hasPanX && hasPanY) {\r\n                return TOUCH_ACTION_NONE;\r\n            }\r\n            // pan-x OR pan-y\r\n            if (hasPanX || hasPanY) {\r\n                return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\r\n            }\r\n            // manipulation\r\n            if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n                return TOUCH_ACTION_MANIPULATION;\r\n            }\r\n            return TOUCH_ACTION_AUTO;\r\n        }\r\n        function getTouchActionProps() {\r\n            if (!NATIVE_TOUCH_ACTION) {\r\n                return false;\r\n            }\r\n            var touchMap = {};\r\n            var cssSupports = window.CSS && window.CSS.supports;\r\n            ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\r\n                // If css.supports is not supported but there is native touch-action assume it supports\r\n                // all values. This is the case for IE 10 and 11.\r\n                touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\r\n            });\r\n            return touchMap;\r\n        }\r\n        /**\r\n         * Recognizer flow explained; *\r\n         * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n         * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n         * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n         *\r\n         * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n         * which determines with state it should be.\r\n         *\r\n         * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n         * POSSIBLE to give it another change on the next cycle.\r\n         *\r\n         *               Possible\r\n         *                  |\r\n         *            +-----+---------------+\r\n         *            |                     |\r\n         *      +-----+-----+               |\r\n         *      |           |               |\r\n         *   Failed      Cancelled          |\r\n         *                          +-------+------+\r\n         *                          |              |\r\n         *                      Recognized       Began\r\n         *                                         |\r\n         *                                      Changed\r\n         *                                         |\r\n         *                                  Ended/Recognized\r\n         */\r\n        var STATE_POSSIBLE = 1;\r\n        var STATE_BEGAN = 2;\r\n        var STATE_CHANGED = 4;\r\n        var STATE_ENDED = 8;\r\n        var STATE_RECOGNIZED = STATE_ENDED;\r\n        var STATE_CANCELLED = 16;\r\n        var STATE_FAILED = 32;\r\n        /**\r\n         * Recognizer\r\n         * Every recognizer needs to extend from this class.\r\n         * @constructor\r\n         * @param {Object} options\r\n         */\r\n        function Recognizer(options) {\r\n            this.options = assign({}, this.defaults, options || {});\r\n            this.id = uniqueId();\r\n            this.manager = null;\r\n            // default is enable true\r\n            this.options.enable = ifUndefined(this.options.enable, true);\r\n            this.state = STATE_POSSIBLE;\r\n            this.simultaneous = {};\r\n            this.requireFail = [];\r\n        }\r\n        Recognizer.prototype = {\r\n            /**\r\n             * @virtual\r\n             * @type {Object}\r\n             */\r\n            defaults: {},\r\n            /**\r\n             * set options\r\n             * @param {Object} options\r\n             * @return {Recognizer}\r\n             */\r\n            set: function (options) {\r\n                assign(this.options, options);\r\n                // also update the touchAction, in case something changed about the directions/enabled state\r\n                this.manager && this.manager.touchAction.update();\r\n                return this;\r\n            },\r\n            /**\r\n             * recognize simultaneous with an other recognizer.\r\n             * @param {Recognizer} otherRecognizer\r\n             * @returns {Recognizer} this\r\n             */\r\n            recognizeWith: function (otherRecognizer) {\r\n                if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\r\n                    return this;\r\n                }\r\n                var simultaneous = this.simultaneous;\r\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n                if (!simultaneous[otherRecognizer.id]) {\r\n                    simultaneous[otherRecognizer.id] = otherRecognizer;\r\n                    otherRecognizer.recognizeWith(this);\r\n                }\r\n                return this;\r\n            },\r\n            /**\r\n             * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n             * @param {Recognizer} otherRecognizer\r\n             * @returns {Recognizer} this\r\n             */\r\n            dropRecognizeWith: function (otherRecognizer) {\r\n                if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\r\n                    return this;\r\n                }\r\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n                delete this.simultaneous[otherRecognizer.id];\r\n                return this;\r\n            },\r\n            /**\r\n             * recognizer can only run when an other is failing\r\n             * @param {Recognizer} otherRecognizer\r\n             * @returns {Recognizer} this\r\n             */\r\n            requireFailure: function (otherRecognizer) {\r\n                if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\r\n                    return this;\r\n                }\r\n                var requireFail = this.requireFail;\r\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n                if (inArray(requireFail, otherRecognizer) === -1) {\r\n                    requireFail.push(otherRecognizer);\r\n                    otherRecognizer.requireFailure(this);\r\n                }\r\n                return this;\r\n            },\r\n            /**\r\n             * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n             * @param {Recognizer} otherRecognizer\r\n             * @returns {Recognizer} this\r\n             */\r\n            dropRequireFailure: function (otherRecognizer) {\r\n                if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\r\n                    return this;\r\n                }\r\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n                var index = inArray(this.requireFail, otherRecognizer);\r\n                if (index > -1) {\r\n                    this.requireFail.splice(index, 1);\r\n                }\r\n                return this;\r\n            },\r\n            /**\r\n             * has require failures boolean\r\n             * @returns {boolean}\r\n             */\r\n            hasRequireFailures: function () {\r\n                return this.requireFail.length > 0;\r\n            },\r\n            /**\r\n             * if the recognizer can recognize simultaneous with an other recognizer\r\n             * @param {Recognizer} otherRecognizer\r\n             * @returns {Boolean}\r\n             */\r\n            canRecognizeWith: function (otherRecognizer) {\r\n                return !!this.simultaneous[otherRecognizer.id];\r\n            },\r\n            /**\r\n             * You should use `tryEmit` instead of `emit` directly to check\r\n             * that all the needed recognizers has failed before emitting.\r\n             * @param {Object} input\r\n             */\r\n            emit: function (input) {\r\n                var self = this;\r\n                var state = this.state;\r\n                function emit(event) {\r\n                    self.manager.emit(event, input);\r\n                }\r\n                // 'panstart' and 'panmove'\r\n                if (state < STATE_ENDED) {\r\n                    emit(self.options.event + stateStr(state));\r\n                }\r\n                emit(self.options.event); // simple 'eventName' events\r\n                if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\r\n                    emit(input.additionalEvent);\r\n                }\r\n                // panend and pancancel\r\n                if (state >= STATE_ENDED) {\r\n                    emit(self.options.event + stateStr(state));\r\n                }\r\n            },\r\n            /**\r\n             * Check that all the require failure recognizers has failed,\r\n             * if true, it emits a gesture event,\r\n             * otherwise, setup the state to FAILED.\r\n             * @param {Object} input\r\n             */\r\n            tryEmit: function (input) {\r\n                if (this.canEmit()) {\r\n                    return this.emit(input);\r\n                }\r\n                // it's failing anyway\r\n                this.state = STATE_FAILED;\r\n            },\r\n            /**\r\n             * can we emit?\r\n             * @returns {boolean}\r\n             */\r\n            canEmit: function () {\r\n                var i = 0;\r\n                while (i < this.requireFail.length) {\r\n                    if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n                        return false;\r\n                    }\r\n                    i++;\r\n                }\r\n                return true;\r\n            },\r\n            /**\r\n             * update the recognizer\r\n             * @param {Object} inputData\r\n             */\r\n            recognize: function (inputData) {\r\n                // make a new copy of the inputData\r\n                // so we can change the inputData without messing up the other recognizers\r\n                var inputDataClone = assign({}, inputData);\r\n                // is is enabled and allow recognizing?\r\n                if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n                    this.reset();\r\n                    this.state = STATE_FAILED;\r\n                    return;\r\n                }\r\n                // reset when we've reached the end\r\n                if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n                    this.state = STATE_POSSIBLE;\r\n                }\r\n                this.state = this.process(inputDataClone);\r\n                // the recognizer has recognized a gesture\r\n                // so trigger an event\r\n                if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n                    this.tryEmit(inputDataClone);\r\n                }\r\n            },\r\n            /**\r\n             * return the state of the recognizer\r\n             * the actual recognizing happens in this method\r\n             * @virtual\r\n             * @param {Object} inputData\r\n             * @returns {Const} STATE\r\n             */\r\n            process: function (inputData) { },\r\n            /**\r\n             * return the preferred touch-action\r\n             * @virtual\r\n             * @returns {Array}\r\n             */\r\n            getTouchAction: function () { },\r\n            /**\r\n             * called when the gesture isn't allowed to recognize\r\n             * like when another is being recognized or it is disabled\r\n             * @virtual\r\n             */\r\n            reset: function () { }\r\n        };\r\n        /**\r\n         * get a usable string, used as event postfix\r\n         * @param {Const} state\r\n         * @returns {String} state\r\n         */\r\n        function stateStr(state) {\r\n            if (state & STATE_CANCELLED) {\r\n                return 'cancel';\r\n            }\r\n            else if (state & STATE_ENDED) {\r\n                return 'end';\r\n            }\r\n            else if (state & STATE_CHANGED) {\r\n                return 'move';\r\n            }\r\n            else if (state & STATE_BEGAN) {\r\n                return 'start';\r\n            }\r\n            return '';\r\n        }\r\n        /**\r\n         * direction cons to string\r\n         * @param {Const} direction\r\n         * @returns {String}\r\n         */\r\n        function directionStr(direction) {\r\n            if (direction == DIRECTION_DOWN) {\r\n                return 'down';\r\n            }\r\n            else if (direction == DIRECTION_UP) {\r\n                return 'up';\r\n            }\r\n            else if (direction == DIRECTION_LEFT) {\r\n                return 'left';\r\n            }\r\n            else if (direction == DIRECTION_RIGHT) {\r\n                return 'right';\r\n            }\r\n            return '';\r\n        }\r\n        /**\r\n         * get a recognizer by name if it is bound to a manager\r\n         * @param {Recognizer|String} otherRecognizer\r\n         * @param {Recognizer} recognizer\r\n         * @returns {Recognizer}\r\n         */\r\n        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n            var manager = recognizer.manager;\r\n            if (manager) {\r\n                return manager.get(otherRecognizer);\r\n            }\r\n            return otherRecognizer;\r\n        }\r\n        /**\r\n         * This recognizer is just used as a base for the simple attribute recognizers.\r\n         * @constructor\r\n         * @extends Recognizer\r\n         */\r\n        function AttrRecognizer() {\r\n            Recognizer.apply(this, arguments);\r\n        }\r\n        inherit(AttrRecognizer, Recognizer, {\r\n            /**\r\n             * @namespace\r\n             * @memberof AttrRecognizer\r\n             */\r\n            defaults: {\r\n                /**\r\n                 * @type {Number}\r\n                 * @default 1\r\n                 */\r\n                pointers: 1\r\n            },\r\n            /**\r\n             * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n             * @memberof AttrRecognizer\r\n             * @param {Object} input\r\n             * @returns {Boolean} recognized\r\n             */\r\n            attrTest: function (input) {\r\n                var optionPointers = this.options.pointers;\r\n                return optionPointers === 0 || input.pointers.length === optionPointers;\r\n            },\r\n            /**\r\n             * Process the input and return the state for the recognizer\r\n             * @memberof AttrRecognizer\r\n             * @param {Object} input\r\n             * @returns {*} State\r\n             */\r\n            process: function (input) {\r\n                var state = this.state;\r\n                var eventType = input.eventType;\r\n                var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n                var isValid = this.attrTest(input);\r\n                // on cancel input and we've recognized before, return STATE_CANCELLED\r\n                if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n                    return state | STATE_CANCELLED;\r\n                }\r\n                else if (isRecognized || isValid) {\r\n                    if (eventType & INPUT_END) {\r\n                        return state | STATE_ENDED;\r\n                    }\r\n                    else if (!(state & STATE_BEGAN)) {\r\n                        return STATE_BEGAN;\r\n                    }\r\n                    return state | STATE_CHANGED;\r\n                }\r\n                return STATE_FAILED;\r\n            }\r\n        });\r\n        /**\r\n         * Pan\r\n         * Recognized when the pointer is down and moved in the allowed direction.\r\n         * @constructor\r\n         * @extends AttrRecognizer\r\n         */\r\n        function PanRecognizer() {\r\n            AttrRecognizer.apply(this, arguments);\r\n            this.pX = null;\r\n            this.pY = null;\r\n        }\r\n        inherit(PanRecognizer, AttrRecognizer, {\r\n            /**\r\n             * @namespace\r\n             * @memberof PanRecognizer\r\n             */\r\n            defaults: {\r\n                event: 'pan',\r\n                threshold: 10,\r\n                pointers: 1,\r\n                direction: DIRECTION_ALL\r\n            },\r\n            getTouchAction: function () {\r\n                var direction = this.options.direction;\r\n                var actions = [];\r\n                if (direction & DIRECTION_HORIZONTAL) {\r\n                    actions.push(TOUCH_ACTION_PAN_Y);\r\n                }\r\n                if (direction & DIRECTION_VERTICAL) {\r\n                    actions.push(TOUCH_ACTION_PAN_X);\r\n                }\r\n                return actions;\r\n            },\r\n            directionTest: function (input) {\r\n                var options = this.options;\r\n                var hasMoved = true;\r\n                var distance = input.distance;\r\n                var direction = input.direction;\r\n                var x = input.deltaX;\r\n                var y = input.deltaY;\r\n                // lock to axis?\r\n                if (!(direction & options.direction)) {\r\n                    if (options.direction & DIRECTION_HORIZONTAL) {\r\n                        direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                        hasMoved = x != this.pX;\r\n                        distance = Math.abs(input.deltaX);\r\n                    }\r\n                    else {\r\n                        direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                        hasMoved = y != this.pY;\r\n                        distance = Math.abs(input.deltaY);\r\n                    }\r\n                }\r\n                input.direction = direction;\r\n                return hasMoved && distance > options.threshold && direction & options.direction;\r\n            },\r\n            attrTest: function (input) {\r\n                return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n                    (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n            },\r\n            emit: function (input) {\r\n                this.pX = input.deltaX;\r\n                this.pY = input.deltaY;\r\n                var direction = directionStr(input.direction);\r\n                if (direction) {\r\n                    input.additionalEvent = this.options.event + direction;\r\n                }\r\n                this._super.emit.call(this, input);\r\n            }\r\n        });\r\n        /**\r\n         * Pinch\r\n         * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n         * @constructor\r\n         * @extends AttrRecognizer\r\n         */\r\n        function PinchRecognizer() {\r\n            AttrRecognizer.apply(this, arguments);\r\n        }\r\n        inherit(PinchRecognizer, AttrRecognizer, {\r\n            /**\r\n             * @namespace\r\n             * @memberof PinchRecognizer\r\n             */\r\n            defaults: {\r\n                event: 'pinch',\r\n                threshold: 0,\r\n                pointers: 2\r\n            },\r\n            getTouchAction: function () {\r\n                return [TOUCH_ACTION_NONE];\r\n            },\r\n            attrTest: function (input) {\r\n                return this._super.attrTest.call(this, input) &&\r\n                    (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n            },\r\n            emit: function (input) {\r\n                if (input.scale !== 1) {\r\n                    var inOut = input.scale < 1 ? 'in' : 'out';\r\n                    input.additionalEvent = this.options.event + inOut;\r\n                }\r\n                this._super.emit.call(this, input);\r\n            }\r\n        });\r\n        /**\r\n         * Press\r\n         * Recognized when the pointer is down for x ms without any movement.\r\n         * @constructor\r\n         * @extends Recognizer\r\n         */\r\n        function PressRecognizer() {\r\n            Recognizer.apply(this, arguments);\r\n            this._timer = null;\r\n            this._input = null;\r\n        }\r\n        inherit(PressRecognizer, Recognizer, {\r\n            /**\r\n             * @namespace\r\n             * @memberof PressRecognizer\r\n             */\r\n            defaults: {\r\n                event: 'press',\r\n                pointers: 1,\r\n                time: 251,\r\n                threshold: 9 // a minimal movement is ok, but keep it low\r\n            },\r\n            getTouchAction: function () {\r\n                return [TOUCH_ACTION_AUTO];\r\n            },\r\n            process: function (input) {\r\n                var options = this.options;\r\n                var validPointers = input.pointers.length === options.pointers;\r\n                var validMovement = input.distance < options.threshold;\r\n                var validTime = input.deltaTime > options.time;\r\n                this._input = input;\r\n                // we only allow little movement\r\n                // and we've reached an end event, so a tap is possible\r\n                if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n                    this.reset();\r\n                }\r\n                else if (input.eventType & INPUT_START) {\r\n                    this.reset();\r\n                    this._timer = setTimeoutContext(function () {\r\n                        this.state = STATE_RECOGNIZED;\r\n                        this.tryEmit();\r\n                    }, options.time, this);\r\n                }\r\n                else if (input.eventType & INPUT_END) {\r\n                    return STATE_RECOGNIZED;\r\n                }\r\n                return STATE_FAILED;\r\n            },\r\n            reset: function () {\r\n                clearTimeout(this._timer);\r\n            },\r\n            emit: function (input) {\r\n                if (this.state !== STATE_RECOGNIZED) {\r\n                    return;\r\n                }\r\n                if (input && (input.eventType & INPUT_END)) {\r\n                    this.manager.emit(this.options.event + 'up', input);\r\n                }\r\n                else {\r\n                    this._input.timeStamp = now();\r\n                    this.manager.emit(this.options.event, this._input);\r\n                }\r\n            }\r\n        });\r\n        /**\r\n         * Rotate\r\n         * Recognized when two or more pointer are moving in a circular motion.\r\n         * @constructor\r\n         * @extends AttrRecognizer\r\n         */\r\n        function RotateRecognizer() {\r\n            AttrRecognizer.apply(this, arguments);\r\n        }\r\n        inherit(RotateRecognizer, AttrRecognizer, {\r\n            /**\r\n             * @namespace\r\n             * @memberof RotateRecognizer\r\n             */\r\n            defaults: {\r\n                event: 'rotate',\r\n                threshold: 0,\r\n                pointers: 2\r\n            },\r\n            getTouchAction: function () {\r\n                return [TOUCH_ACTION_NONE];\r\n            },\r\n            attrTest: function (input) {\r\n                return this._super.attrTest.call(this, input) &&\r\n                    (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n            }\r\n        });\r\n        /**\r\n         * Swipe\r\n         * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n         * @constructor\r\n         * @extends AttrRecognizer\r\n         */\r\n        function SwipeRecognizer() {\r\n            AttrRecognizer.apply(this, arguments);\r\n        }\r\n        inherit(SwipeRecognizer, AttrRecognizer, {\r\n            /**\r\n             * @namespace\r\n             * @memberof SwipeRecognizer\r\n             */\r\n            defaults: {\r\n                event: 'swipe',\r\n                threshold: 10,\r\n                velocity: 0.3,\r\n                direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n                pointers: 1\r\n            },\r\n            getTouchAction: function () {\r\n                return PanRecognizer.prototype.getTouchAction.call(this);\r\n            },\r\n            attrTest: function (input) {\r\n                var direction = this.options.direction;\r\n                var velocity;\r\n                if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n                    velocity = input.overallVelocity;\r\n                }\r\n                else if (direction & DIRECTION_HORIZONTAL) {\r\n                    velocity = input.overallVelocityX;\r\n                }\r\n                else if (direction & DIRECTION_VERTICAL) {\r\n                    velocity = input.overallVelocityY;\r\n                }\r\n                return this._super.attrTest.call(this, input) &&\r\n                    direction & input.offsetDirection &&\r\n                    input.distance > this.options.threshold &&\r\n                    input.maxPointers == this.options.pointers &&\r\n                    abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\r\n            },\r\n            emit: function (input) {\r\n                var direction = directionStr(input.offsetDirection);\r\n                if (direction) {\r\n                    this.manager.emit(this.options.event + direction, input);\r\n                }\r\n                this.manager.emit(this.options.event, input);\r\n            }\r\n        });\r\n        /**\r\n         * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n         * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n         * a single tap.\r\n         *\r\n         * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n         * multi-taps being recognized.\r\n         * @constructor\r\n         * @extends Recognizer\r\n         */\r\n        function TapRecognizer() {\r\n            Recognizer.apply(this, arguments);\r\n            // previous time and center,\r\n            // used for tap counting\r\n            this.pTime = false;\r\n            this.pCenter = false;\r\n            this._timer = null;\r\n            this._input = null;\r\n            this.count = 0;\r\n        }\r\n        inherit(TapRecognizer, Recognizer, {\r\n            /**\r\n             * @namespace\r\n             * @memberof PinchRecognizer\r\n             */\r\n            defaults: {\r\n                event: 'tap',\r\n                pointers: 1,\r\n                taps: 1,\r\n                interval: 300,\r\n                time: 250,\r\n                threshold: 9,\r\n                posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n            },\r\n            getTouchAction: function () {\r\n                return [TOUCH_ACTION_MANIPULATION];\r\n            },\r\n            process: function (input) {\r\n                var options = this.options;\r\n                var validPointers = input.pointers.length === options.pointers;\r\n                var validMovement = input.distance < options.threshold;\r\n                var validTouchTime = input.deltaTime < options.time;\r\n                this.reset();\r\n                if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n                    return this.failTimeout();\r\n                }\r\n                // we only allow little movement\r\n                // and we've reached an end event, so a tap is possible\r\n                if (validMovement && validTouchTime && validPointers) {\r\n                    if (input.eventType != INPUT_END) {\r\n                        return this.failTimeout();\r\n                    }\r\n                    var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n                    var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n                    this.pTime = input.timeStamp;\r\n                    this.pCenter = input.center;\r\n                    if (!validMultiTap || !validInterval) {\r\n                        this.count = 1;\r\n                    }\r\n                    else {\r\n                        this.count += 1;\r\n                    }\r\n                    this._input = input;\r\n                    // if tap count matches we have recognized it,\r\n                    // else it has began recognizing...\r\n                    var tapCount = this.count % options.taps;\r\n                    if (tapCount === 0) {\r\n                        // no failing requirements, immediately trigger the tap event\r\n                        // or wait as long as the multitap interval to trigger\r\n                        if (!this.hasRequireFailures()) {\r\n                            return STATE_RECOGNIZED;\r\n                        }\r\n                        else {\r\n                            this._timer = setTimeoutContext(function () {\r\n                                this.state = STATE_RECOGNIZED;\r\n                                this.tryEmit();\r\n                            }, options.interval, this);\r\n                            return STATE_BEGAN;\r\n                        }\r\n                    }\r\n                }\r\n                return STATE_FAILED;\r\n            },\r\n            failTimeout: function () {\r\n                this._timer = setTimeoutContext(function () {\r\n                    this.state = STATE_FAILED;\r\n                }, this.options.interval, this);\r\n                return STATE_FAILED;\r\n            },\r\n            reset: function () {\r\n                clearTimeout(this._timer);\r\n            },\r\n            emit: function () {\r\n                if (this.state == STATE_RECOGNIZED) {\r\n                    this._input.tapCount = this.count;\r\n                    this.manager.emit(this.options.event, this._input);\r\n                }\r\n            }\r\n        });\r\n        /**\r\n         * Simple way to create a manager with a default set of recognizers.\r\n         * @param {HTMLElement} element\r\n         * @param {Object} [options]\r\n         * @constructor\r\n         */\r\n        function Hammer(element, options) {\r\n            options = options || {};\r\n            options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\r\n            return new Manager(element, options);\r\n        }\r\n        /**\r\n         * @const {string}\r\n         */\r\n        Hammer.VERSION = '2.0.7';\r\n        /**\r\n         * default settings\r\n         * @namespace\r\n         */\r\n        Hammer.defaults = {\r\n            /**\r\n             * set if DOM events are being triggered.\r\n             * But this is slower and unused by simple implementations, so disabled by default.\r\n             * @type {Boolean}\r\n             * @default false\r\n             */\r\n            domEvents: false,\r\n            /**\r\n             * The value for the touchAction property/fallback.\r\n             * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n             * @type {String}\r\n             * @default compute\r\n             */\r\n            touchAction: TOUCH_ACTION_COMPUTE,\r\n            /**\r\n             * @type {Boolean}\r\n             * @default true\r\n             */\r\n            enable: true,\r\n            /**\r\n             * EXPERIMENTAL FEATURE -- can be removed/changed\r\n             * Change the parent input target element.\r\n             * If Null, then it is being set the to main element.\r\n             * @type {Null|EventTarget}\r\n             * @default null\r\n             */\r\n            inputTarget: null,\r\n            /**\r\n             * force an input class\r\n             * @type {Null|Function}\r\n             * @default null\r\n             */\r\n            inputClass: null,\r\n            /**\r\n             * Default recognizer setup when calling `Hammer()`\r\n             * When creating a new Manager these will be skipped.\r\n             * @type {Array}\r\n             */\r\n            preset: [\r\n                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n                [RotateRecognizer, { enable: false }],\r\n                [PinchRecognizer, { enable: false }, ['rotate']],\r\n                [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\r\n                [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n                [TapRecognizer],\r\n                [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n                [PressRecognizer]\r\n            ],\r\n            /**\r\n             * Some CSS properties can be used to improve the working of Hammer.\r\n             * Add them to this method and they will be set when creating a new Manager.\r\n             * @namespace\r\n             */\r\n            cssProps: {\r\n                /**\r\n                 * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n                 * @type {String}\r\n                 * @default 'none'\r\n                 */\r\n                userSelect: 'none',\r\n                /**\r\n                 * Disable the Windows Phone grippers when pressing an element.\r\n                 * @type {String}\r\n                 * @default 'none'\r\n                 */\r\n                touchSelect: 'none',\r\n                /**\r\n                 * Disables the default callout shown when you touch and hold a touch target.\r\n                 * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n                 * a callout containing information about the link. This property allows you to disable that callout.\r\n                 * @type {String}\r\n                 * @default 'none'\r\n                 */\r\n                touchCallout: 'none',\r\n                /**\r\n                 * Specifies whether zooming is enabled. Used by IE10>\r\n                 * @type {String}\r\n                 * @default 'none'\r\n                 */\r\n                contentZooming: 'none',\r\n                /**\r\n                 * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n                 * @type {String}\r\n                 * @default 'none'\r\n                 */\r\n                userDrag: 'none',\r\n                /**\r\n                 * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n                 * clickable element in iOS. This property obeys the alpha value, if specified.\r\n                 * @type {String}\r\n                 * @default 'rgba(0,0,0,0)'\r\n                 */\r\n                tapHighlightColor: 'rgba(0,0,0,0)'\r\n            }\r\n        };\r\n        var STOP = 1;\r\n        var FORCED_STOP = 2;\r\n        /**\r\n         * Manager\r\n         * @param {HTMLElement} element\r\n         * @param {Object} [options]\r\n         * @constructor\r\n         */\r\n        function Manager(element, options) {\r\n            this.options = assign({}, Hammer.defaults, options || {});\r\n            this.options.inputTarget = this.options.inputTarget || element;\r\n            this.handlers = {};\r\n            this.session = {};\r\n            this.recognizers = [];\r\n            this.oldCssProps = {};\r\n            this.element = element;\r\n            this.input = createInputInstance(this);\r\n            this.touchAction = new TouchAction(this, this.options.touchAction);\r\n            toggleCssProps(this, true);\r\n            each(this.options.recognizers, function (item) {\r\n                var recognizer = this.add(new (item[0])(item[1]));\r\n                item[2] && recognizer.recognizeWith(item[2]);\r\n                item[3] && recognizer.requireFailure(item[3]);\r\n            }, this);\r\n        }\r\n        Manager.prototype = {\r\n            /**\r\n             * set options\r\n             * @param {Object} options\r\n             * @returns {Manager}\r\n             */\r\n            set: function (options) {\r\n                assign(this.options, options);\r\n                // Options that need a little more setup\r\n                if (options.touchAction) {\r\n                    this.touchAction.update();\r\n                }\r\n                if (options.inputTarget) {\r\n                    // Clean up existing event listeners and reinitialize\r\n                    this.input.destroy();\r\n                    this.input.target = options.inputTarget;\r\n                    this.input.init();\r\n                }\r\n                return this;\r\n            },\r\n            /**\r\n             * stop recognizing for this session.\r\n             * This session will be discarded, when a new [input]start event is fired.\r\n             * When forced, the recognizer cycle is stopped immediately.\r\n             * @param {Boolean} [force]\r\n             */\r\n            stop: function (force) {\r\n                this.session.stopped = force ? FORCED_STOP : STOP;\r\n            },\r\n            /**\r\n             * run the recognizers!\r\n             * called by the inputHandler function on every movement of the pointers (touches)\r\n             * it walks through all the recognizers and tries to detect the gesture that is being made\r\n             * @param {Object} inputData\r\n             */\r\n            recognize: function (inputData) {\r\n                var session = this.session;\r\n                if (session.stopped) {\r\n                    return;\r\n                }\r\n                // run the touch-action polyfill\r\n                this.touchAction.preventDefaults(inputData);\r\n                var recognizer;\r\n                var recognizers = this.recognizers;\r\n                // this holds the recognizer that is being recognized.\r\n                // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n                // if no recognizer is detecting a thing, it is set to `null`\r\n                var curRecognizer = session.curRecognizer;\r\n                // reset when the last recognizer is recognized\r\n                // or when we're in a new session\r\n                if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n                    curRecognizer = session.curRecognizer = null;\r\n                }\r\n                var i = 0;\r\n                while (i < recognizers.length) {\r\n                    recognizer = recognizers[i];\r\n                    // find out if we are allowed try to recognize the input for this one.\r\n                    // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n                    // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n                    //      that is being recognized.\r\n                    // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n                    //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n                    if (session.stopped !== FORCED_STOP && ( // 1\r\n                    !curRecognizer || recognizer == curRecognizer || // 2\r\n                        recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n                        recognizer.recognize(inputData);\r\n                    }\r\n                    else {\r\n                        recognizer.reset();\r\n                    }\r\n                    // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n                    // current active recognizer. but only if we don't already have an active recognizer\r\n                    if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                        curRecognizer = session.curRecognizer = recognizer;\r\n                    }\r\n                    i++;\r\n                }\r\n            },\r\n            /**\r\n             * get a recognizer by its event name.\r\n             * @param {Recognizer|String} recognizer\r\n             * @returns {Recognizer|Null}\r\n             */\r\n            get: function (recognizer) {\r\n                if (recognizer instanceof Recognizer) {\r\n                    return recognizer;\r\n                }\r\n                var recognizers = this.recognizers;\r\n                for (var i = 0; i < recognizers.length; i++) {\r\n                    if (recognizers[i].options.event == recognizer) {\r\n                        return recognizers[i];\r\n                    }\r\n                }\r\n                return null;\r\n            },\r\n            /**\r\n             * add a recognizer to the manager\r\n             * existing recognizers with the same event name will be removed\r\n             * @param {Recognizer} recognizer\r\n             * @returns {Recognizer|Manager}\r\n             */\r\n            add: function (recognizer) {\r\n                if (invokeArrayArg(recognizer, 'add', this)) {\r\n                    return this;\r\n                }\r\n                // remove existing\r\n                var existing = this.get(recognizer.options.event);\r\n                if (existing) {\r\n                    this.remove(existing);\r\n                }\r\n                this.recognizers.push(recognizer);\r\n                recognizer.manager = this;\r\n                this.touchAction.update();\r\n                return recognizer;\r\n            },\r\n            /**\r\n             * remove a recognizer by name or instance\r\n             * @param {Recognizer|String} recognizer\r\n             * @returns {Manager}\r\n             */\r\n            remove: function (recognizer) {\r\n                if (invokeArrayArg(recognizer, 'remove', this)) {\r\n                    return this;\r\n                }\r\n                recognizer = this.get(recognizer);\r\n                // let's make sure this recognizer exists\r\n                if (recognizer) {\r\n                    var recognizers = this.recognizers;\r\n                    var index = inArray(recognizers, recognizer);\r\n                    if (index !== -1) {\r\n                        recognizers.splice(index, 1);\r\n                        this.touchAction.update();\r\n                    }\r\n                }\r\n                return this;\r\n            },\r\n            /**\r\n             * bind event\r\n             * @param {String} events\r\n             * @param {Function} handler\r\n             * @returns {EventEmitter} this\r\n             */\r\n            on: function (events, handler) {\r\n                if (events === undefined) {\r\n                    return;\r\n                }\r\n                if (handler === undefined) {\r\n                    return;\r\n                }\r\n                var handlers = this.handlers;\r\n                each(splitStr(events), function (event) {\r\n                    handlers[event] = handlers[event] || [];\r\n                    handlers[event].push(handler);\r\n                });\r\n                return this;\r\n            },\r\n            /**\r\n             * unbind event, leave emit blank to remove all handlers\r\n             * @param {String} events\r\n             * @param {Function} [handler]\r\n             * @returns {EventEmitter} this\r\n             */\r\n            off: function (events, handler) {\r\n                if (events === undefined) {\r\n                    return;\r\n                }\r\n                var handlers = this.handlers;\r\n                each(splitStr(events), function (event) {\r\n                    if (!handler) {\r\n                        delete handlers[event];\r\n                    }\r\n                    else {\r\n                        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\r\n                    }\r\n                });\r\n                return this;\r\n            },\r\n            /**\r\n             * emit event to the listeners\r\n             * @param {String} event\r\n             * @param {Object} data\r\n             */\r\n            emit: function (event, data) {\r\n                // we also want to trigger dom events\r\n                if (this.options.domEvents) {\r\n                    triggerDomEvent(event, data);\r\n                }\r\n                // no handlers, so skip it all\r\n                var handlers = this.handlers[event] && this.handlers[event].slice();\r\n                if (!handlers || !handlers.length) {\r\n                    return;\r\n                }\r\n                data.type = event;\r\n                data.preventDefault = function () {\r\n                    data.srcEvent.preventDefault();\r\n                };\r\n                var i = 0;\r\n                while (i < handlers.length) {\r\n                    handlers[i](data);\r\n                    i++;\r\n                }\r\n            },\r\n            /**\r\n             * destroy the manager and unbinds all events\r\n             * it doesn't unbind dom events, that is the user own responsibility\r\n             */\r\n            destroy: function () {\r\n                this.element && toggleCssProps(this, false);\r\n                this.handlers = {};\r\n                this.session = {};\r\n                this.input.destroy();\r\n                this.element = null;\r\n            }\r\n        };\r\n        /**\r\n         * add/remove the css properties as defined in manager.options.cssProps\r\n         * @param {Manager} manager\r\n         * @param {Boolean} add\r\n         */\r\n        function toggleCssProps(manager, add) {\r\n            var element = manager.element;\r\n            if (!element.style) {\r\n                return;\r\n            }\r\n            var prop;\r\n            each(manager.options.cssProps, function (value, name) {\r\n                prop = prefixed(element.style, name);\r\n                if (add) {\r\n                    manager.oldCssProps[prop] = element.style[prop];\r\n                    element.style[prop] = value;\r\n                }\r\n                else {\r\n                    element.style[prop] = manager.oldCssProps[prop] || '';\r\n                }\r\n            });\r\n            if (!add) {\r\n                manager.oldCssProps = {};\r\n            }\r\n        }\r\n        /**\r\n         * trigger dom event\r\n         * @param {String} event\r\n         * @param {Object} data\r\n         */\r\n        function triggerDomEvent(event, data) {\r\n            var gestureEvent = document.createEvent('Event');\r\n            gestureEvent.initEvent(event, true, true);\r\n            gestureEvent.gesture = data;\r\n            data.target.dispatchEvent(gestureEvent);\r\n        }\r\n        assign(Hammer, {\r\n            INPUT_START: INPUT_START,\r\n            INPUT_MOVE: INPUT_MOVE,\r\n            INPUT_END: INPUT_END,\r\n            INPUT_CANCEL: INPUT_CANCEL,\r\n            STATE_POSSIBLE: STATE_POSSIBLE,\r\n            STATE_BEGAN: STATE_BEGAN,\r\n            STATE_CHANGED: STATE_CHANGED,\r\n            STATE_ENDED: STATE_ENDED,\r\n            STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n            STATE_CANCELLED: STATE_CANCELLED,\r\n            STATE_FAILED: STATE_FAILED,\r\n            DIRECTION_NONE: DIRECTION_NONE,\r\n            DIRECTION_LEFT: DIRECTION_LEFT,\r\n            DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n            DIRECTION_UP: DIRECTION_UP,\r\n            DIRECTION_DOWN: DIRECTION_DOWN,\r\n            DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n            DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n            DIRECTION_ALL: DIRECTION_ALL,\r\n            Manager: Manager,\r\n            Input: Input,\r\n            TouchAction: TouchAction,\r\n            TouchInput: TouchInput,\r\n            MouseInput: MouseInput,\r\n            PointerEventInput: PointerEventInput,\r\n            TouchMouseInput: TouchMouseInput,\r\n            SingleTouchInput: SingleTouchInput,\r\n            Recognizer: Recognizer,\r\n            AttrRecognizer: AttrRecognizer,\r\n            Tap: TapRecognizer,\r\n            Pan: PanRecognizer,\r\n            Swipe: SwipeRecognizer,\r\n            Pinch: PinchRecognizer,\r\n            Rotate: RotateRecognizer,\r\n            Press: PressRecognizer,\r\n            on: addEventListeners,\r\n            off: removeEventListeners,\r\n            each: each,\r\n            merge: merge,\r\n            extend: extend,\r\n            assign: assign,\r\n            inherit: inherit,\r\n            bindFn: bindFn,\r\n            prefixed: prefixed\r\n        });\r\n        // this prevents errors when Hammer is loaded in the presence of an AMD\r\n        //  style loader but by script tag, not by the loader.\r\n        var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\r\n        freeGlobal.Hammer = Hammer;\r\n        if (typeof define === 'function' && define.amd) {\r\n            define(function () {\r\n                return Hammer;\r\n            });\r\n        }\r\n        else if (typeof module != 'undefined' && module.exports) {\r\n            module.exports = Hammer;\r\n        }\r\n        else {\r\n            window[exportName] = Hammer;\r\n        }\r\n    })(window, document, 'Hammer');\r\n}\r\n","/* models\\tools\\tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const view_1 = require(71) /* ../../core/view */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    class ToolView extends view_1.View {\r\n        get plot_view() {\r\n            return this.parent;\r\n        }\r\n        get plot_model() {\r\n            return this.parent.model;\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.active.change, () => {\r\n                if (this.model.active)\r\n                    this.activate();\r\n                else\r\n                    this.deactivate();\r\n            });\r\n        }\r\n        // activate is triggered by toolbar ui actions\r\n        activate() { }\r\n        // deactivate is triggered by toolbar ui actions\r\n        deactivate() { }\r\n    }\r\n    exports.ToolView = ToolView;\r\n    ToolView.__name__ = \"ToolView\";\r\n    class Tool extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Tool() {\r\n            this.prototype._known_aliases = new Map();\r\n            this.internal({\r\n                active: [p.Boolean, false],\r\n            });\r\n        }\r\n        get synthetic_renderers() {\r\n            return [];\r\n        }\r\n        // utility function to return a tool name, modified\r\n        // by the active dimensions. Used by tools that have dimensions\r\n        _get_dim_tooltip(name, dims) {\r\n            switch (dims) {\r\n                case \"width\": return `${name} (x-axis)`;\r\n                case \"height\": return `${name} (y-axis)`;\r\n                case \"both\": return name;\r\n            }\r\n        }\r\n        // utility function to get limits along both dimensions, given\r\n        // optional dimensional constraints\r\n        _get_dim_limits([sx0, sy0], [sx1, sy1], frame, dims) {\r\n            const hr = frame.bbox.h_range;\r\n            let sxlim;\r\n            if (dims == 'width' || dims == 'both') {\r\n                sxlim = [array_1.min([sx0, sx1]), array_1.max([sx0, sx1])];\r\n                sxlim = [array_1.max([sxlim[0], hr.start]), array_1.min([sxlim[1], hr.end])];\r\n            }\r\n            else\r\n                sxlim = [hr.start, hr.end];\r\n            const vr = frame.bbox.v_range;\r\n            let sylim;\r\n            if (dims == 'height' || dims == 'both') {\r\n                sylim = [array_1.min([sy0, sy1]), array_1.max([sy0, sy1])];\r\n                sylim = [array_1.max([sylim[0], vr.start]), array_1.min([sylim[1], vr.end])];\r\n            }\r\n            else\r\n                sylim = [vr.start, vr.end];\r\n            return [sxlim, sylim];\r\n        }\r\n        static register_alias(name, fn) {\r\n            this.prototype._known_aliases.set(name, fn);\r\n        }\r\n        static from_string(name) {\r\n            const fn = this.prototype._known_aliases.get(name);\r\n            if (fn != null)\r\n                return fn();\r\n            else {\r\n                const names = [...this.prototype._known_aliases.keys()];\r\n                throw new Error(`unexpected tool name '${name}', possible tools are ${names.join(\", \")}`);\r\n            }\r\n        }\r\n    }\r\n    exports.Tool = Tool;\r\n    Tool.__name__ = \"Tool\";\r\n    Tool.init_Tool();\r\n}\r\n","/* styles\\toolbar.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_toolbar = \"bk-toolbar\";\r\n    exports.bk_toolbar_hidden = \"bk-toolbar-hidden\";\r\n    exports.bk_toolbar_button = \"bk-toolbar-button\";\r\n    exports.bk_button_bar = \"bk-button-bar\";\r\n    exports.bk_toolbar_button_custom_action = \"bk-toolbar-button-custom-action\";\r\n}\r\n","/* styles\\toolbar.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root .bk-toolbar-hidden {\n  visibility: hidden;\n  opacity: 0;\n  transition: visibility 0.3s linear, opacity 0.3s linear;\n}\n.bk-root .bk-toolbar,\n.bk-root .bk-button-bar {\n  display: flex;\n  display: -webkit-flex;\n  flex-wrap: nowrap;\n  -webkit-flex-wrap: nowrap;\n  align-items: center;\n  -webkit-align-items: center;\n  user-select: none;\n  -ms-user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n}\n.bk-root .bk-toolbar .bk-logo {\n  flex-shrink: 0;\n  -webkit-flex-shrink: 0;\n}\n.bk-root .bk-toolbar.bk-above,\n.bk-root .bk-toolbar.bk-below {\n  flex-direction: row;\n  -webkit-flex-direction: row;\n  justify-content: flex-end;\n  -webkit-justify-content: flex-end;\n}\n.bk-root .bk-toolbar.bk-above .bk-button-bar,\n.bk-root .bk-toolbar.bk-below .bk-button-bar {\n  display: flex;\n  display: -webkit-flex;\n  flex-direction: row;\n  -webkit-flex-direction: row;\n}\n.bk-root .bk-toolbar.bk-above .bk-logo,\n.bk-root .bk-toolbar.bk-below .bk-logo {\n  order: 1;\n  -webkit-order: 1;\n  margin-left: 5px;\n  margin-right: 0px;\n}\n.bk-root .bk-toolbar.bk-left,\n.bk-root .bk-toolbar.bk-right {\n  flex-direction: column;\n  -webkit-flex-direction: column;\n  justify-content: flex-start;\n  -webkit-justify-content: flex-start;\n}\n.bk-root .bk-toolbar.bk-left .bk-button-bar,\n.bk-root .bk-toolbar.bk-right .bk-button-bar {\n  display: flex;\n  display: -webkit-flex;\n  flex-direction: column;\n  -webkit-flex-direction: column;\n}\n.bk-root .bk-toolbar.bk-left .bk-logo,\n.bk-root .bk-toolbar.bk-right .bk-logo {\n  order: 0;\n  -webkit-order: 0;\n  margin-bottom: 5px;\n  margin-top: 0px;\n}\n.bk-root .bk-toolbar-button {\n  width: 30px;\n  height: 30px;\n  cursor: pointer;\n  background-size: 60% 60%;\n  background-origin: border-box;\n  background-color: transparent;\n  background-repeat: no-repeat;\n  background-position: center center;\n}\n.bk-root .bk-toolbar-button:hover {\n  background-color: rgba(192, 192, 192, 0.15);\n}\n.bk-root .bk-toolbar-button:focus {\n  outline: none;\n}\n.bk-root .bk-toolbar-button::-moz-focus-inner {\n  border: 0;\n}\n.bk-root .bk-toolbar.bk-above .bk-toolbar-button {\n  border-bottom: 2px solid transparent;\n}\n.bk-root .bk-toolbar.bk-above .bk-toolbar-button.bk-active {\n  border-bottom-color: #26aae1;\n}\n.bk-root .bk-toolbar.bk-below .bk-toolbar-button {\n  border-top: 2px solid transparent;\n}\n.bk-root .bk-toolbar.bk-below .bk-toolbar-button.bk-active {\n  border-top-color: #26aae1;\n}\n.bk-root .bk-toolbar.bk-right .bk-toolbar-button {\n  border-left: 2px solid transparent;\n}\n.bk-root .bk-toolbar.bk-right .bk-toolbar-button.bk-active {\n  border-left-color: #26aae1;\n}\n.bk-root .bk-toolbar.bk-left .bk-toolbar-button {\n  border-right: 2px solid transparent;\n}\n.bk-root .bk-toolbar.bk-left .bk-toolbar-button.bk-active {\n  border-right-color: #26aae1;\n}\n.bk-root .bk-button-bar + .bk-button-bar:before {\n  content: \" \";\n  display: inline-block;\n  background-color: lightgray;\n}\n.bk-root .bk-toolbar.bk-above .bk-button-bar + .bk-button-bar:before,\n.bk-root .bk-toolbar.bk-below .bk-button-bar + .bk-button-bar:before {\n  height: 10px;\n  width: 1px;\n}\n.bk-root .bk-toolbar.bk-left .bk-button-bar + .bk-button-bar:before,\n.bk-root .bk-toolbar.bk-right .bk-button-bar + .bk-button-bar:before {\n  height: 1px;\n  width: 10px;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* styles\\icons.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root .bk-tool-icon-copy-to-clipboard {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5AUSDBoBvcHQeQAAAG9JREFUWMNjXLhsJcNAAiaGAQYwB/xHwh/Q+ITEkfHQCwEWND4jmeb8H/JpgBwfI6cNBhLSEkqaGXRpgFRAcZoZsmlg1AGjDhh1wKgDRh0w6gCaVcf/R2wIkNqw+D9s0wADvUNiyIYA47BJAwPuAAAj/Cjd0TCN6wAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-replace-mode {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5AUFFxokK3gniQAAAHpJREFUWMNjXLhsJcNAAiaGAQajDhhwB7DgEP+PxmeksvjgDwFcLmYkUh2hkBj8IcBIZXsYh1w2/I8v3sgAOM0bLYhGc8GgrwuICgldfQO88pcvXvg/aOuCUQeM5oLRuoCFCJcTbOMh5XOiW0JDNhdQS3y0IBp1ABwAAF8KGrhC1Eg6AAAAAElFTkSuQmCC\");\n}\n.bk-root .bk-tool-icon-append-mode {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5AUFFxkZWD04WwAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAoUlEQVRYw+1WQQ6AIAwrhO8Y/bIXEz9jIMSDr8ETCUEPQzA4pMeFLKNbu4l5WR0CDOMEALBGIzMuQIBEZQjPgP9JLjwTfBjY9sO9lZsFA9IafZng3BlIyVefgd8XQFZBAWe8jfNxwsDhir6rzoCiPiy1K+J8/FRQemv2XfAdFcQ9znU4Viqg9ta1qYJ+D1BnAIBrkgGVOrXNqUA9rbyZm/AEzFh4jEeY/soAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-intersect-mode {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5AUFFxkrkOpp2wAAAPhJREFUWMPtV1EKwjAMTUavI3oawR/vtn5srJdREfzwMvHHQlcT2mpdMzFfWxiP5r2+JMN+mAiCOB72CABgR1cln4oOGocJnuMTSxWk8jMm7OggYkYXA9gPE3uyd8NXHONJ+eYMdE/NqCJmEZ5ZqlJJ4sUksKN7cYSaPoCZFWR1QI+Xm1fBACU63Cw22x0AAJxudwrffVwvZ+JmQdAHZkw0d4EpAMCw8k87pMdbnwtizQumJYv3nwV6XOA1qbUT/oQLUJgFRbsiNwFVucBIlyR3p0tdMp+XmFjfLKi1LatyAXtCRjPWBdL3Ke3VuACJKFfDr/xFN2fgAR/Go0qaLlmEAAAAAElFTkSuQmCC\");\n}\n.bk-root .bk-tool-icon-subtract-mode {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5AUFFxgsF5XNOQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABFUlEQVRYw9VWUQqDMAxNpWfxQxD1MoP97G7zQ5mH2RTZYLtM9lWoMbXtxLXNX4OG9r28l4hrd0PQoqxqAACYpxH25C/nkwCHyCBwSPoS09k1T5Fo+4EiExcC4v584xGFmyIXHBLRISAVZyZufUPVa4rcrwmPDgr93ylo+2GliLRUYHK6th/o/6r7nfLpqaCsagEA8Hh9FmcNKeRmgeYDC+SCq0B6FFi8/BcV6BdR9cL3gCv3ijPKOacsn3rBEcjmaVxpfGcg4wHxzgJJnc6241Hn23DERFRAu1bNcWa3Q0uXi62XR6sCaWoSejbtdLYmU3kTEunNgj0bUbQqYG/IcMaqwPS9jftoVCAQ0ZVDJwf0zQdH4AsyW6fpQu4YegAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-clear-selection {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5AUGEhcuan3d3wAAAoRJREFUWMPtlzFP3EAQhd+b3TNSzg0N5TWXLkJQUUaKhIQ4fgP/g5ArrriE/I3opEgRrZtIVJR0FJQ010SioUmEZHtnUpwN9gWHGA5BJCy58MraffvmfZ41v3z9hqe8BE98vQh4cgG+Ydzmnrng8efvQJNi/uN7dznx/B3ggtfhf4ehNdUttRzBDIm/2VTiiWCG1HK0nc+3UWtq8BQIiEEakEQOADBIA4QCQmBqoHBhFNR27ikQSmGdYCdTqCpEHMDZmEKRWUBEv1gBDg5SzRJnpopILWICgWuRYflLamuzxB2BmtYqSRIka5VWU8QduXO+1hRc5YZu5GAwmP2ZJzND0IBu5HCV2+NQcAhAVRsnC2IbPzPdSjzd6to6VtfWkXi6YLaVWr7xoAwkfpb8MnC3SH7rKSMBe4M0jA/OTicFIbtCGRIyNbURhcf3ErCd6YwA1m0HgAxhw1NGQnlXBHG4kylVlSJuH0RfIP2CkL2I/qS1gIAAQiBl1QwFggIHtyxgrxK5PgyfC0JWKoT0HLh8LwoietB4TYKaIl7yeNURxB05UtMxDOcVQlZIrlRKdK6m47gjR/fuBRQihyLArtNeJD50Izcx2Eczu7iFkIug4VM3cpOr3MKDekFED0fWUHv9Zq0kpLnridjhY3XDg7NTN0jDrhO3X7O9Wg7wwyANu4mnayNg3gmbu0tCNoUyBNGv2l4rB9EXynA7082FOxAQLhU6rQVO9T2AvWowFToNCJcPORGxIRcnpjZSKATSU9NxvOQnAPArDSaQoUKnNI4iufkGtD4P3EHIcWZhz4HLceSOyrR3Izf5memPAL2cX3yhAkonysZVaWLBkd9dw1Ivv2a/AYPkK+ty1U1DAAAAAElFTkSuQmCC\");\n}\n.bk-root .bk-tool-icon-box-select {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg0kduFrowAAAIdJREFUWMPtVtEKwCAI9KL//4e9DPZ3+wP3KgOjNZouFYI4C8q7s7DtB1lGIeMoRMRinCLXg/ML3EcFqpjjloOyZxRntxpwQ8HsgHYARKFAtSFrCg3TCdMFCE1BuuALEXJLjC4qENsFVXCESZw38/kWLOkC/K4PcOc/Hj03WkoDT3EaWW9egQul6CUbq90JTwAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-box-zoom {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg82t254aQAAAkBJREFUWMPN11+E1FEUB/DPTFn2qaeIpcSwr5NlUyJiKWVXWUqvlUh/iE3RY9mUekkPPURtLKNRrFJEeuphGfUUaVliiX1aVjGs6aG7+XX9ZnZ+d2fTl2vmnHvPPfeee/79Sk+may2/UQq/q7Qu+bAJoxjHIKqB/wlfUMcMVqI9bLZ+DGIKwzlzQ2GcxCx2xwvKOUKlaHTiX8bHNspjDONHkOmJBW5jIof/FvPh/06MZOb6cRc7cGn1AKUE5cdzlM/gAr5F/O24H3xkFRfxAbVygvK+cIsspjGWo1zgjeFpxL+BvnLw7laBA4xjIFJwrgu52DoVjKdY4HBEX8dSF3JLYe1fe6UcYCii3xWQjdfuSTnAtoheKCC7GNED5Zx4L4qt61jbTLHA94geKSC7P7ZeShQ0Inoi1IJuEOeORooFXkV0FZNdZs5qvFfKAeqYy7nZ6yg//HG0MBfffh71lFrQDCW2EvEP4mt4okZUDftz9rmGZkotmMxJRtlisy+MTniAWrty3AlXw0hFM2TD89l+oNsoOJXjbIs4EpqNtTCLXbiZ0g+M4mFObj8U3vsNjoZCVcmk60ZwthpepLZkB/AsivWfOJZxtpUQHfWib7KWDwzjeegBZJSdKFiE2qJTFFTwElsi/unQ/awXrU4WGMD7nOJxBY/1EO2iYConq93CHT1GOwucjdqnRyFz+VcHmMNefMY9nNkA3SWUOoXhQviSWQ4huLIRFlirFixnQq/XaKXUgg2xQNGv4V7x/RcW+AXPB3h7H1PaiQAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-zoom-in {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgsUBmL8iQAAA2JJREFUWMO9l12IlFUYx3//MzPrLpSjkm5oN4FFIWVEl66IQlFYwtLOzozsjHdGRSCRF0sfBEXRVV0FQuQiLm5CZNBFgRRaRLVFhbJ2EdiN5gbK7toObTPn6eYdPTvNzPvOBz5Xh/ec5/n/n89zXtEHmZqeSXSuXBz/3zfdKvBWJHQrwZuRcP0El+QkbQXeBX6WZEgm6TtJk5lM5o4Lc+cV6qpf4Ga20Tm338zeATItVK9Ker6yvPzp4NDQ3+XieGsCU9MzTYumGbhz7m4ze9/MHgvBgItACrgfGAj2jgAvAYs3wlEujjc13kii8YyZrXXOfWhmo9GnFUlvOOemarVapVqtkslksmb2KjARqL62ecuWN9NxbRInzrldAXhV0uFSIfdew7G/gNLU9MwS8CwSmE3Oz88fcXG5blfpqVRq0Ix8VIAAX0XgrVL7HDCHGcCaWrV60LUBN8Dae58aQIxEqcA592I9M610JL0cpG/U9TIHJNKY3RV5z0R+7Nd4HZ0P1g/2RMBuegLAsRMnb4vT8d5vqKfMzOgtAlADrkmqGywmiMBTwfr3dC9j1Xv/r6Tvg/5/5ejxE6cO7M9faVbQZrYNOFSPmqQvVo9FKexvi5uWX58943aM7DwAfBDY+FbSCxP5sdkGx55GeguzrUEXPaSo2pFkAbiSZQCAzZJOmdkjwd6SpB/M7KykQTPbA2wDhoIzRzcNDx9MJwGNIXdJ0mEzmwbujL7dbma7gd03A7lKfnTOvf74nl0r6bonTUbujRSUCrm2d4L3/kvn3JPe+8+BDW2i9o+kT7z3kxP5sYsA6W47oE64TsR7P9tQL4vA2mh9WdIscKxUyJ0M7aR7acOGzikD65EQLEjaa2ZXzMwDFeB6qZBbbLTRE4EGeSaozNOZgYFf8qP7lmIvs354n0qlHpB0T7B9Ogl4IgJJrmjv/SiQjbrkD+BMUkfSbYATPdckrTOzkciWAXOlQu5cYgLdPEIapud9wMOR9zVJH3ViKx333mtHMJvNuoWFhZ3A+ojMcja77njXBEKwJJfTcqUyCIQ34Mf7nnh0paMnXacFuGoC1mr3AtuDfLzd8Zuyl+rfuGn4HLAD+Az4qZQf+61TAj0Noj8vX6oC35SL43u7teG6rf5+iXppwW7/JUL5D03qaFRvvUe+AAAAAElFTkSuQmCC\");\n}\n.bk-root .bk-tool-icon-zoom-out {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgsHgty9VwAAA0FJREFUWMO9l09oXFUUxn/fmXlpItppi22k7UJBRSlVkCytSAuKUloIdjKT0El3FXVXdVFKRVAQV7qQohsNwdA0UFvBhYtqUVyIVlRaogtFQVq7qSTVjA3z3nHzBq/jvPmTN/Ss7rv3nvN99/y794kByMzcfE/7picn/jenmwWeRUI3E7wdCRskuCSTdDfwBvCtJEdySV9KOhpF0e0/LF5SqKtBgbv7ZjObcvfXgShD9Zqk5+orKx8Oj4z8NT05kU1gZm6+bdK0Azezu9z9hLs/HoIBvwAF4H5gKFh7B3gBWFY3460kWve4+3oze9fdx9OpVUmvmNlMHMf1RqNBFEUldz8OHAxUX9q6bduryut+Sfvc/Wz62ZD0fK1afjND9y3gGSRwv1GMojstTxUUCoVhdyopEYDzKXjWwZ4FFnEHWBc3Goet00m7lZlZYQixKw0FZnakGZksHUnHgvCN5/KARBH37enpOVg58H13HV0Kxg/kIuD/ngSA2ZMLt3bTSZJkUzNk7k4+D0AM/CGpaXCyBw/sC8Y/qZd2GpZiuL9YLN4Sx/HpoP5/c/exQ1OVq+1yyt13SLoArEsJnMjlgfOffvK3u58Kprab2QezJxfG2iTzUzI70wRPG9jbmpmb95SNB9mpzp7/j2yVdNbdx4K565K+cvfPJQ27+x5gBzAS7Hlvy+jo4WIvoC3kWpcvS3rR3eeAO9K529x9N7C7zX6AC2b28hN7Hl1Vt44niVq13LUjmtlYkiQfA5s6eO+GpDNJkhw9NFX5ueNt2ARodyF1IHIN2JiOl4H16fiKpK+B2Vq1vBAqFAf4IJkGNiIhWJK0192vunsC1IE/a9XycquNXARa5OnApeeioaHvKuP7r3dTGsiLqFAo7JR0T7B8rhfwXARa2us4UEqr5Ffgs151i/08oTNKdIO770ptObBYq5Yv5ibQq/sl3Qc8lJ4+lnSqH1vFfp9koZRKJVtaWnqkWXqSVkqlDe+vmUDWpZMlK/X6MBDegKf3P/nYaj8ErN9fqZBYEsf3Ag8G8Xit33BaniTcvGX0IvAw8BHwTa1y4Md+CeRqRL9fudwAvpienNi7Vhu21uwflOT+L+i1X2TJP57iUvUFtHWsAAAAAElFTkSuQmCC\");\n}\n.bk-root .bk-tool-icon-help {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAABltpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPHRpZmY6Q29tcHJlc3Npb24+NTwvdGlmZjpDb21wcmVzc2lvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzI8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MzI8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MzI8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDpBODVDNDBDMzIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpBODVDNDBDNDIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDpBODVDNDBDMTIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpBODVDNDBDMjIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPGRjOnN1YmplY3Q+CiAgICAgICAgICAgIDxyZGY6U2VxLz4KICAgICAgICAgPC9kYzpzdWJqZWN0PgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNjoxMToyOCAxMToxMTo4MjwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+UGl4ZWxtYXRvciAzLjY8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cphjt2AAAAT7SURBVFgJxRdbaFxFdGb2bhui227BWrsVKYgf2kJUbP9EUPuzEB803WTXJjH61Q/7Ya1+CMYKEVTsh4J/EpvY7BoabUiNiA8s1p+4KIhpoUUEselHqyS76TbZ3HuP58ydc3d2u4+IkQxczpz3mZkzZ86VYpXjvenpjZsLhUcliE4AuUuASAgptmt1EFdwPiclzIIUUwubNn17OJlcXo1p2UpodHRiux9xB1Eug1+slbzhFxGOKc851tu7/0oznYYBDA8Pt0U2tL8KQryIq2tvZqQhD0QJHRz3yqWhgYGBpXpydQMwqz6NCnurleCSADkJEfgKfOePqL80R/wV1ZaQyr1LenKfkPCkEPKeaj0xg7vxVL3duCmA0Vyuw/fl52hgBxsBED+h4Cv9z3R/zbRm8MTJTx7HQN7GQB6w5C4L4SX7M5lfLBpurjXMyvNIShiyi0l1pL8n9b7EDGPR8fHxzSsQ6XDB3618/xqo6Pk25V5MpVJllgHM1BO58RdQ612kOYZ+GXdij70TYQB05mpj+1kU5G2fB+l3PZtOf8NGx6ambnMXb3yAxg8wjSEG6OKKR9oicBQD+ZvpH2Wzj0lQpxCPG9qMv1x6hHNCsSAlHM7ZOa682vlI9tRDbvHGbD3nZAPpDoD/3JIrLpAs26UFkC3EMUA99hpfGtEBfJjNJnS2Gwnadnvl+Xw+iuc3DAJuNyIaSCHpilVldyDjjUxj3WDZIAhxhHHyRcdNuA7AAfUaXzVKODpzFiZ4/uLvh5G+m2no+C/pyIf7MqlEJB7bpqR6nXkEUfbeawuLaZsW2ISfNQ2vtaktQlGFQyIVGT0o2+2EC4iQNGwjBIN9qdQ5Qg4mk4X4rW3vCClLtowE2FOFUxKDfNmiZci3ovKKRFPh4FK9q4Zbdr+lKKJiA13TcHR2dmLBgdmQ0GAS2MZaEowY+XbAk09IvgtYZGp16SyvFhaHcIUh645t8T9DBCcnz5zZ4hZLu3DzK2QlL1QQa0Y+pHiJKPSuOGj3PmZTheM5w2TwqBxnvBZOTk7G5gvXJ5Aelms8wnJURL+olSWcfEhf6gDoUXPMq6ZlqbzWU2pE+3hi4s6F68tfIj9cBMlikr7Z0/P0b/X0yIcUXsDCF1WhtL4OROHaXk+xlkbV0Cu732Nmhc4peaWSg73pA8dq5RkvO37ldUTfXCKZv2q45MkhvG87WQEzpCCUSvV1d9GONBy3lMvgKSwrZig8gjAietWY0QriylO2jIo4yVbOSb7KB/qmI9BPKjHpSSXYauRyn92Nq9/Kcrj13x3s3v8D481glQ/0raiNYgX9njPSBOImbrHZePl+tfFmc9sH+Xaoh8NjOKSVdDMhjjYzQLy+dFceH5+IJQf9VYXX4tROg4ZFU8m31M3mfPEqUoJqCGJfvWpo2xnNfdrhC28n06SCeSzNZxlvBINGRXCtKS7EY1uV6V7HWAm38y1cXaXsMcOCvr9ySPj+af7A1U2HJXHzVNvUXVLIGyPf+jV0pf8GHoN+TLAyPkidTCi2RpPApmnR0Bd1zGRaB/B8Oj2HSw7LLbVR1MmskW8RdEWVXSJf3JbpAMgRtc4IZoxTh9qotQjCasm46M0YX9pV1VmbpvRH5OwwgdRtSg2vKaAz/1dNKVtb17Y8DCL4HVufHxMOYl1/zTgIgiYvBnFKfaNp3YjTdPz3n9Na8//X7/k/O1tdwopcZlcAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-hover {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4oVHp0SwAAAQJJREFUWMPtlsENgzAMRb8RQ5VJItFDOgaZAMaAA0iZpN3KPZSoEEHSQBCViI/G8pfNt/KAFFcPshPdoAGgZkYVVYjQAFCyFLN8tlAbXRwAxp61nc9XCkGERpZCxRDvBl0zoxp7K98GAACxxH29srNNmPsK2l7zHoHHXZDr+/9vwDfB3kgeSB5IHkgeOH0DmesJjSXi6pUvkYt5u9teVy6aWREDM0D0BRvmGRV5N6DsQkMzI64FidtI5t3AOKWaFhuioY8dlYf9TO1PREUh/9HVeAqzIThHgWZ6MuNmC1jiL1mK4pAzlKUojEmNsxcmL0J60tazWjLZFpClPbd9BMJfL95145YajN5RHQAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-crosshair {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADEUlEQVRYR81XXVIaQRCeHqug8CXmBNETaE4gniDwIgpVspxAbxC9ATkBkCpQ8gKeQDiB5AQxNyAvUlrldr7eHxyGXZi1rMJ5opbp7m++7un+htSGF204vsoMoNXrlzSpfWa1oxQfhAegCZGaEtPorHo8znIoJwCt6+td8uk7ApUQCIHTF4BNAWzImq8ap6cP68CsBdDp9i9ZqXM7ML79g/EnCWD+jgMKENKqWT+tXK0CkQqgNRjs0OxpQIqKhoMxaG6/6JeRnK7T6yO2UvVqhYSlLX+ryORfgKn9ORDFIy7ky41yGcwsr0QAQfDH5zucOswx819fs4egI9OFCcD8DjBF7VNbEX0JzdWEt3NHSSASAcCxBDqMgt/623kvyTgNgNjJIfTjk4D4FqaJR1715MjmYAmA5Bx3AwUXQL+t105KaTlcBSC26XRvhjEIoLiq1yqXpr8FAGG16/ug4IT27fxBWu7EiQuAiImJpEMKE6nYM30uAIDDttSUOPfJP7JzbjPhAiBIh9QE67vIvoOi9WJfCwDavf40ulpjbCqmUf+W753ezURuh7Dg1SqflwAEHU6pgfyBq9Y4qx0LG++2fnZ/eUzcstmdM2AWH+jfc+liWdBJfSENf8Lifi3GVwC9mybOfi5dzatWVrbbLIHNva8p5h/16gkaFiLGGxbufkoE6XguwePiXLF3XmMfCUCUAqtKXU7sumd1CowOuJEi3Pg1FBpjitIGhyvVSfvmjci6ZR+rFQfDiPVE2jFYeICQ+PoewwjC5h7CZld6DBdyu6nDSKgzOyIMhmhK5TTqXYbRorZYM46TmpKAAOrGWwSJJekSB1yqJNOzp1Gs7YJ0EDeySDIMtJbQHh6Kf/uFfNFZkolJICRmz0P8DKWZuIG2g1hpok+Mk0Qphs0h9lzMtWRoNvYLuVImUWrmPJDlBKeRBDfATGOpHkhw670QSHWGLLckmF1PTsMlYqMJpyUbiO0weiMMceqLVTcotnMCYAYJJbcuQrVgZFP0NOOJYpr62pf3AmrHfWUG4O7abefGAfwH7EXSMJafOlYAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-lasso-select {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgwlGP1qdAAABMBJREFUWMO9V1uIVVUY/r61z57ZMx4DnbzgkbQXL5iCJphlWdpIGY4jpFBkEiU9ZNaDRRcITcIwMwgxoQtU2IMXdAZfMjFvpERXYiSbysyBEXFmyuHMnLP32uvrwT2xnY5nxvHQ93Jg7fWv71/r//7L4a59TRgqJk+Z6v3a+sv0OI5nk5wu6VaSVZImAThHsgjgrKTvM5nMUWvtmf5n8HodCIKgOgzDhc65pSTrJQWDsSNpJX1ljHnDOfdT37oZLLHv+8OMMasKhcIJ59xHAJYMlhwAJGUAzJfUTHLFuFzOG5QDU6dNMyQfs9Yedc5tBpAD4IYYNQGoBrDtQnt7/b0LFrJsCHzfn2itfQfAnZLiazytA3AaQAuAiwDaEgeNpGkkswAWSBqRONB38b88z5uTKePt6iiKXkk8jq+iJC5LOmiMaTLGHLPWhmWeHr7vV0dRtATAapAzIVmSo51zyzIlbm2stesFPA6pKk0r6Ryg93y/ek8YFvPOOTg3cDSiKCoC2OP7/rEoirYm4rUkF12lAWNM1lr7lqQn0+QA8gI2jBg5cj6Aj8OwmB+KAKIoukhyp6SRJAUgl0ndPLDWPi9pJQCbuviXvu+/GIZhW1dnJ24UJFuTjCCA2ADA8sYGWmsXS3qmL94kDYAtkh4Nw7ANlQJ5U6INT1KrAYC9zQdykl7nFSj5fXp5Y8NWVBhy7mUAjqShMYdMXV2dJ2klyRwAJ8lIeuGWCRMP7N7frEqSG2OmAFhKshNAp5wrmO7u7jEAngPQm1S2z2pqapr+OPt7XEly0oxwzq2RdFmSD2AMgKKJouhhAL4kA+Cs53l7e3t7uytJHgRBreTWkXwkKVJnJD0B4GAGwIJE9R6AFufc6UqSZ7PZbD6ff5dkA4CQZEHSqwAOISmXtwGIE+F1SeqqIP8d+Xz+C0mLJYWSAODteXffczjdDQNJ0BWMCoLg5gqIbRTJNwHsljQhUb0luWPM2LE7Thw/9m/5NCT/TByxAOYWi8X6/gdWV1dnfN8fNRBxJpMZTXKdc+6IpFVJWAEgkvSJpA0X2tvtVTaSjgOYBCAEEADYSHK87/sfhmEYA9gShuEDkgzJHyWtB/B1irQ2juP7ADxkrX0wOUOpzmdpzEY590HJ7Ni1r2kSyZOSiv2+hSRjSTXp/QAukzySNJOJkmalyNIl10hqMcasdc61XDNcQRD8BnITgNp+36r6kfcNFMMlLQGwTNLMEuQGQBfJl2bdPru+HDkAZAqFQux53jZHEsC6aw0eg2gylNRBcqcx5v04ji999+03AwsWAOI4Lsy9a94WkisAnE5a5WCJYwCfA1g7LJudI2lTHMeXBm1faiQzxkyRtF3S5CTupeAB+KG2tnZFT0/P30NO2VKLzrmfAbwGMipjG5Oc0dPTc0Md05SZ5U4Q2FxChErtEYD7jTGNQ3UgM8Asv90Yc9I5LSKRlXSI5CxJa0jWSALJjKRnAewfkniT+vwf7N7fXHK9rq7O7+jo+BTA/NRrdBpjnnLOnUrvXd7YMPQXSBunneno6IhIHgYwW1JtkgmBpBkATlVMAwOk3nFJ+VSoqgCMr6gIy2FcLtdKspAedyQN/98caDt/3kpyabUmf8WvG/8A1vODTBVE/0MAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-pan {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4lKssI9gAAAOtJREFUWMPVll0KwyAMgNPgoc0JzDX2Mtgp3csKErSamGabIEUo/T6bHz0ezxdsjPJ5kvUDaROem7VJAp3gufkbtwtI+JYEOsHNEugIN0mgM1wtsVoF1MnyKtZHZBW4DVxoMh6jaAW0MTfnBAbALyUwCD6UwEB4VyJN4FXx4aqUAACgFLjzrsRP9AECAP4Cm88QtJeJrGivdeNdPpko+j1H7XzUB+6WYHmo4eDk4wj41XFMEfBZGXpK0F/eB+QhVcXslVo7i6eANjF5NYSojCN7wi05MJNgbfKiMaPZA75TBVKCrWWbnGrb3DPePZ9Bcbe/QecAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-xpan {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4X4hxZdgAAAMpJREFUWMPtlsEKwjAMhr/pwOOedINJe/PobWXCfAIvgo/nA4heOiilZQqN2yE5lpD/I38SWt3uD9aMHSuHAiiAAmwaYCqoM/0KMABtQYDW11wEaHyiEei28bWb8LGOkk5C4iEEgE11YBQWDyHGuAMD0CeS30IQPfACbC3o+Vd2bOIOWMCtoO1mC+ap3CfmoCokFs/SZd6E0ILjnzrhvFbyEJ2FIZzXyB6iZ3AkjITn8WOdSbbAoaD4NSW+tIZdQYBOPyQKoAAKkIsPv0se4A/1UC0AAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-ypan {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4anK0lywAAAMVJREFUWMPtlzEKwzAMRX/S7rlpIMXeOnaLaME36FLo8XqCdNFghGljyc4kgQi2Q/SUj0F/eL7eMMTKz6j9wNlYPGRrFcSoLH4XxQPvdQeYuPOlcLbw2dRTgqvoXEaolWM0aP4LYm0NkHYWzyFSSwlmzjw2sR6OvAXNwgEcwAEcwAEcwAEcoGYk20SiMCHlmVoCzACoojEqjHBmCeJOCOo1lgPA7Q8E8TvdjMmHuzsV3NFD4w+1t+Ai/gTx3qHuOFqdMQB8ASMwJX0IEHOeAAAAAElFTkSuQmCC\");\n}\n.bk-root .bk-tool-icon-range {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAABCJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjU8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjMyPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4zMjwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgICAgIDxkYzpzdWJqZWN0PgogICAgICAgICAgICA8cmRmOkJhZy8+CiAgICAgICAgIDwvZGM6c3ViamVjdD4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTgtMDQtMjhUMTQ6MDQ6NDk8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPlBpeGVsbWF0b3IgMy43PC94bXA6Q3JlYXRvclRvb2w+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgrsrWBhAAAD60lEQVRYCcVWv2scRxSemZ097SHbSeWkcYwwclDhzr1Q5T6QE1LghP6BGNIYJGRWNlaZItiFK1mr+JAu4HQu0kjpU8sgF3ITAsaFg0hOvt2Zyfvmdsa7a610Unx44Zgf773vvfneezPHNzrbhn3CT3xC3wPXYOC8LDzqdi8YY/gwh4BeknS/2th6dr2kf94AOp3OFyWgMyziOPbMDxV9FTtJnl1ut795Xd0/YQ0/vtYQwMT1KXWCfr2IjOWwtNehwN4xL9ykTrm6Pzl58yLn3J+mKh9mXbT3uRjGEDph+O8/TjfP5dBp7Ha7AX7O3o5nZeD/0E/OGyXntDgzA0X6qmCnrVutVlrUWV9f/3xo+pwhGDhvEPHOjoxnZjJggXmMHzBQ7NGNp9vxk61fr0HR7e/u7pZzCGHlc7qwBYYTT7tJYSx1AQzppyFPft5apta9w7SKcn0b7P7+/jCsDQ5mbc0dCmIJGDN0ehdcjsmkm6A6KUeKFOTE11PLxrC7Ukqh3ylL2fT0NAP9q6ur6rRCJJYsbKB0JsbCKMuy+xREePDyxQPCz+Crlw062QcA5wBOOt1l6vIl2WiI9F1fN6Q+BBqit6hEC4Hk08GQJMn4myjSP7RavVxgdaVUh/3U6HCMsPr9pYnJKRziHtWQ+un58+hGs6nsjQSjpuTyKGN3CX+FBwHXSiEVgjP+O8X6N12kIePES+GzTKAkGbNp8yJsGUMVzz8jPKReiyAQRimy5/cjye5RpF8utFp/+nwmT7d/NMzcFkS7yjJNGDaPURQxIQThEQy0SyF4l5WJYYhBa816vZ6dU7A6CAhbZVow/pDe0O9hVOoCi13r4BgBAvJHqMSQL2vE/iH6IAXEwgrRVUmBoRRwnwJQT98xEeVeSUyB4dJ5nwJBKdCFFGRmUCcu7rwIYypCTblaChuNBhWODrman5ub+4v0rMNBt8z6Ezh7GksJQpCbm79cMQE7QBFm/X6f0rjWnv8WRYg/QdbUpwDAEBy8vPyA8rNGzg3a8MiElwiM7dAtRqNoNptjGPM1laVxP9umWEMGLOKhKUOJDtBwDmzsw9fC/CzHr9SGuCTi2LbbKvVtmqXpCjMihBFa79Wrt5fGx9PDzc3fmu32Lf8qFliwU9emKhBSp+kRKn/hu9k1COEDbFdt/BoKWOAkuEbdVYyoIXv8+I/QK9dMHEb1Knb7MHOv8LFFOsjzCVHWOD7Ltn+MXCRF4729vWMDK+p8rLkvwjLg4N4v741m5YuwCI9CvHp1Ha8gFdBoPnQAkGsYYGxxcfEI7QQlFCTGUXwjAz4tWF+EpymOWu7fglE7qsOvrYE6g4+9/x/vhRbMdLOCFgAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-polygon-select {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEjc1OfiVKAAAAe1JREFUWMPt1r9rU1EUB/DPK0XbqphFHETo4OCiFhwF0V1KHbRSROLqon+AUMVRRFBwEbRFMBiV+mMW/wIxi5OD1kERRVKRJHUwLvfBTZrU5OWBGXLgQu7Jfe98z/ec7z0vKa88b2q1BDtRHdAPBaylm1NzsxsOjPnPNt6WSWprbft+/c3I3zOAjhT1Y4+fvcjEQJIXnVECSa+AhqIHqlHH5lWCZoe+Gk4GRgDG86j9SAUdlDBSQaZhlOkuHyoVdJmsw98D1S5fM4NYM1LCpqM+Lwa240oLgmZzpVZvzKT75VLZcqksSZKWlQeAy/iORVwIvh31xvotvK7VG3Px4aWHj3Jl4C2uYSvq+Bn8v6LLbaVWb9zsBiKLCvbiNG7gLm7jAYqbPHMJMziZ9lsKoh8GtqCEVVzHftwJn+TFHp4/hg8BSCYVfMOZoPEv2NZGdy9WCGUr9toDR3E2/H4V6nwRe/BmgN65H1ZhvMuB3XiKIyFoGefwO6ysVkUlrNUNsyAK/jli533Q+Y8cJFvAeXyMS1CI/jiMr/gUtD2LQwMGr4R3p7bY3oQHQ5b38CT4D2AXXg6YcQXHpyYnlqKsi5iOAVSwL9zd7zJ09r+Cpwq72omFMazjT9Dnibym0dTkRDUKrrgwH7MwXVyYB38BstaGDfLUTsgAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-redo {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4itK+dVQAAAaFJREFUWMPt1L1rFFEUBfDfJDaBBSslIFjbaSFp1FJQFMVCHkzhKIqdUYOCoBgErVz8rCwiTDMwBCIKipDWyip/gxAIWAmBgBC0eYFh2Gx2l9lFcA5M8e59782Zc84dWrT435Hs1siLchqn43MS0zgW22vYxjesYjVLw3YjBPKinMUTBOwf8J5fKLGYpWFjJAJ5Uc7gIW6jM6Kim3iNZ1katgYmEL/6I+YasvY7Lg6iRpIX5VF8wuEe/XV8wGf8jN6LWTiAc7iEQ7ucPZ+lYW0vAtfwvlbfwCKW9gpXDOv1mJvZHiSO91MiyYsyiQSuxtpXXM7SsDmM5nlRdrCMMz3sOJWl4Xevc/vwBzdwAl+yNNwZxfRI+GxelK9ikHcwh8d4NNR/YFRES1ZwoTYdR7I0rNf3TzVNIGbmSvR/Bx08mIgCFSVu4l2ltIWD9WxNGR+W8KOynqnZ0rwCeVG+wa0hjrxtWoF5dAfc28V8Mib/n+Nev5dnabg/zgw87aNEN/bHOwVRiRe4Wym9zNKwMKkpgIWKEt24njxiJlq0aPFv4i9ZWXMSPPhE/QAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-reset {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4gWqH8eQAABLdJREFUWMPtlktsVGUUx3/nfvfOlLQaY2IiRRMQIRpI0PjamJhoVASDvNpCpYw1vJQYSVwZwIVQF6wwRHmkAUof9ElrI6VqDAXcID4TF0IiYQMkSlTokNCZ+b7jove2t+NMH7rQBWd3v+989/zP+Z8X3Jb/WGQySvUNTQBJESkNguAVYIWqzhaRhwBU9WcR+QXoymazn6jqzUQiMQSQzWZRVdal1vwzAI2tHQBPOuc2AbWTdOyQ53n7nHNfRwee51GzqoIQMCLDpr3x/tLQ0oZzrk5Vj0/BOEBt+KYuOlBVGlrahr0Wob27t3gEjnZ2AyQzmUwHsDgP6J/AYRE553neDwDOuUdU9QngNeCumK4TkRMhZUORcYC1qysLA6iuSQHIwkWLD6lqapQsuSmwTVV3h99I7EcAR462A2xR2Ilq6ehTaejvO1774kuLNALR33eclsaGsQDe3fYegHl43vyNwEeqGl1963mm2jl7YZRTQ82qlWP4HM6ZToC5ztkW4LHQoALru7s6Di5dvlIj/e6ujrEAWoZDn8hmMjXATMACGaAVuBjXTVVXFc/AxhaA+4zvn1DV+eHxVWPMAmvtb5GeMWZyZVhI2rt7qVy2pOh9U1snwIPW2vMi4oWJuBPYHkVAVScPoKmtkzVVK6cEMsyJraHhiCqJqJUwj/JRz7TW1iSSyR2rVyylqa0Ta+24Ic8vXaAEmDFc/l5Z2A/80OibuVyuz/f9ElUdHCmvw82t5HK5h6y1PYhsz2YyGw43t2KtBZHIGwB6+j4rCkBVUdV7gXrggnPuu8h4eP+xMeZS2D0rJYZ6AdAMzAt1b4nI26p6IFZOY8pugijcKSIHVLUK0LyST4vnrVfnWr3mjmP4QTATaERkXkypRFX3isjmuHdRJEK6Ckqquopp06bdKCkp2Sgi7XnGLcg7gzeutwNIiPYc8HixqIrIOlU9ONVIhHPEd851icgSVXUiskVV94gIqoonIt0i8gfQCfwae38e6BWRXuBZz5jZ8VbaOE4EIqlZVUEQBLlkMplS1QER2RwkEnsSyaREDUzyeNsvIhvCMqkH1kdIJ2o+k8iJB1LVVRfjZ6nqqlEAIbdVQGto8Lrv+/dbawcjAL7vc+6bs+zetetfLSHxniIFGofGGsU2oC7eOCbDfZ7nQawBOSAX74SF9oEPImOq+r7nmVmxb5raukZa8UReGmNmhbMkAwwBH467EYVZe49z7kdgenj8k7V2oTHm8kgdWcvrNdVFjR8cHkYzjDH9wLjDaEwEzpwa4MypgWvAjtjxfGNMj4jMiT+M+kFsZI/Q6Pv+HGNMT8w4wI7TAyevxXVPD5z8+zD64tRXAMHVK1eaVLUyVvuDqroV2BOnJF4ZIedviUidqt4Re9s+vbx8zZXLl7PR2+nl5Tz/zNOFp2FzxzGAklw22wUsLLaSKXwf8vhosZUM6PeDYEUum70VHfpBwKsVyyfeikOP6oBNwN1TrLbfgX3A1kKLzKeff8nLLzw38T5wZDgxn1LnNk5lLRfP26/OnR2hwfNYW2Atn9RCsrf+EECyrKysDFimqhXhyjY3VLkAXBKRDqA7nU6nS0tLhyIj6XSaN9bVclv+l/IXAmkwvZc+jNUAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-save {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4UexUIzAAAAIRJREFUWMNjXLhs5X+GAQRMDAMMWJDYjGhyf7CoIQf8x2H+f0KGM9M7BBio5FNcITo408CoA0YdQM1cwEhtB/ylgqMkCJmFLwrOQguj/xTg50hmkeyARAYGhlNUCIXjDAwM0eREwTUGBgbz0Ww46oBRB4w6YNQBow4YdcCIahP+H5EhAAAH2R8hH3Rg0QAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-tap-select {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzIwRUFGMDYyMjE2ODExOTdBNUNBNjVEQTY5OTRDRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCOTJBQzE0RDQ0RDUxMUU0QTE0ODk2NTE1M0M0MkZENCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCOTJBQzE0QzQ0RDUxMUU0QTE0ODk2NTE1M0M0MkZENCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTQ0QzIwMUM1RjIxNjgxMUE3QkFFMzhGRjc2NTI3MjgiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzcyMEVBRjA2MjIxNjgxMTk3QTVDQTY1REE2OTk0Q0UiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6eYZ88AAADLklEQVR42rSXf2TUYRzHv7tuGcfE6Vwb5zLSSjEj7Y9KWqfEmFZJP+yPMdKKmUrrn0iUfjhWlLFi6YfNrF+StBoTo39iYkTGco4xxxG59P7k/T2PT8/37nu3bx9ezvPj+zyf5/PreS78bGLS8SmrwE6yje3NHJsDBTALpknBz6JhH3NiYAB0gHqPOVv52wJ6QQ48BzdAttTioRJjdeA8mAHHS2xuk3p+M8M16ipVQE49Ds6CiFO9RLjGONf05QLx6wPQaBlbBlPgJVgkP0ETiIJ2sB/E1XfimjfgBOOlKDUqCGOcqBcQnw6BYW5YTo4wbvQhMmCfGRemC2rBiGXzWUb+kM/NRZ6CHWBM9ce5R61NgX6ayhSJ5EPlItlDRNkz4JbFHf06BkSzHjXxM+gDv1S/mPUo2AXWgt9UUHL/IVhS8yUV1/EbV3o4N+NaoE9Fu/i827K5pNYHnqAVJECShWmAaddpscYFFXwR7vnXBRGlnUN/L6kqKJlxnRUuDbaDBiL+vst5d4gpcpBrqk/2jIgCKVUolhntplzivHmwh4stGOPfwBWwl/2dpp8p7xjQZqFLiQJtauKkivYm+kzccpK57yXfOUe+P23JqAnVbhMFmlXntCWnxbT31am9ZJ4BJifsUmNTqt0cYhA5ypympPg7VkEKunPbVb8cIG+0kyHLJZNR7fUMooUKFHAPkfQo58VLK+RzwRDd4FdWG9mjpaAXzqkJa1R7kQttqEABWXMjOOxxVRfnhRm5URX1prk/0pQHwNcKlchZ+jdpC+hFdVqO0my9Hj5dkYgCn1Rfh/KdlNDHrJhPqlDih+IfBd6qwpOgEqYMsorJ2HtWxtagLJDn/W3KRfPOZhoeBJfZPgVeGKeKrkQBh5dLXl25Ny3pc4/1fkTdbvFqFQgbxWeYD0hXulhQ0pYiM1jG547fcbMQpVnHTZEn9W3ljsCzwHxCdVteNHIZvQa7/7cC7nV6zHIfyFP9EXjFa7YxKAVqPP4bxhhoLWW+z9JyCb6M/MREg59/RlmmXbmneIybB+YC/ay+yrffqEddDzwGvKxxDmzhc0tc80XVgblqFfgjwAAPubcGjAOl1wAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-undo {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4em8Dh0gAAAatJREFUWMPt1rFrFFEQBvDfGhACASshkL/ALpWVrSAKEQV5sIULWlgZNSgIFkGIVQ412gkBt1lYLERREFJqJRaW1oHAoZUQsDqwecWy7N3tbe6C4H2wxc682Zn3zTfvLXPM8b8j6RqYF+UCzsfnHBawGt3fMcAX7GEvS8NgKgXkRbmMxwg41TLsN0psZmnodyogL8pFPMIdLHUk7hA7eJKl4U/rAuKu3+HslFr/FZezNPSTFslX8QErDe4DvMVH/Iq9F7VwGpdwZUjsPtaSFjv/1vCBPjaxO0xcNbHejLpZrrlvJCMCT+JzA+2fcC1Lw+GE4l3CG1yIptfjCtiKoqtiJ0vD3aM0Py/K57iIMxgkQxat4EdN7e9xdRzlk+LEEPvDWvIDXJ928sYxjL36icWK+VaWhlezOIqbGFirJd/H7szugrwoX+D2BDEvszSsT5OBdfRaru/F9dPXQF6U27g/KnmWhgctxqyzBrZGMNGL/rHI0nDkKXiKexXTsywNGx0OnFbFNk3BRoWJXnw//j+ivCi32/S8CxPVNiWOAdUiJtXITIqYY45/Cn8B2D97FYW2H+IAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-wheel-pan {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgswOmEYWAAABddJREFUWMO9l09oXNcVxn/n3vc0fzRjj2RHyIZ6ERuy6CarxJtS0pQSCsXNpqGFWK5tTHAwyqIGN7VdEts1LV04BEoxdlJnUbfNogtDCYWQRZOSxtAUCoFiJY0pWJVUjeTKM9LMe+9+Xcyb8ZMychuofeHCffeee7/vnXvOuefYlV/+mv932//tb91z/Y2rvxmMHQ+4FcEfOIGN4A+UwDDwoQScc7vM7AIwB8yZ2QXn3K77Ab6OgJnVgeOSbkqaBiaACUnTkm4Cx3OZzwf+qzcRQup1zNZ9RwDe+0YI4YKZTUn6zCGSMLOfAF/03r+QZdnyfwO+ePEiI6N1nPMgMDMkETLRbd2mXG8gCbd9YiIKIUxLKoLfBN7I+80+CUlTIYTp7RMT0b3Af37p8kh5y9gZcy4Fzt+5szqSaxkzUR7dwtrKMmaGW242d0t6vrD/He/90865o865o977p4F3Ctp4frnZ3L0Z+OryUrVSrZ0z8ZxhHjhcq1XPrS43q/0flDlK9XpPA2ma7gMeyvfPx3H8TJZlH4YQWiGEVpZlH8Zx/Awwn8s8lKbpvmq1ahvB641SXNk6dhLskNA2MIBtwKHK1vGTW8bKMRbAMgyPqWeETxUM8VSSJAv52JmZA0iSZMHMThWwnipXKp8hsLLcSaIR92oU8xjSayCQXotiHotG3Ku3m+0EOQwPQCDggMf7BzQajSs5eAk4B5zLx4O1vD2eJMmAQKliscgASJMw21pansFs1swQ/DNLmUmTMNuXX+taXHTDaj5OW612R1JZ0nFJJ/J+XFJ5aWmpA6S5bHV8fHsPHFU6q3pJCjtFxtrKMuXRLUUXXxdrRLazFOtUolZlsGhmACsgnHPTwJnCnjP5HMBKLotzxsTE9rgDL0t6LoriKsDIaB31ZEK+JxQJRHFUBR2NqLw8OTkZR0OC0ntm9k1JWU7OA4vD/mZ+YfElsANmNEKi75vztzB5M8uAr+bx48me88g757PQ1U5zNg52YH7hX8l6f+4Fi3c3BqHNmkI4YQOV2MGCNu9qHPYCewfzbrC+XSGcWEcgTRKA3wFfyzdDz5d+D3x9CIcfA4eBbQS9LscskgfLnHNPAnslvS/pbZDHLLPADpx9N9fqpSIBH8cxWZY9m6bpb4Ev5fN/iKLo2TRNgdx/eo8Wk5O7Ts/N/SOSdMjHdj4kmgkIEJLJzPZKetvMTkIvFLsR25Ml2gfuF5M7vnA66sdooJYkCSGERe/9VAjhzRxoKk3Tvg3U8nulVqvx8cyNpER2umM+SdOkbc5B8JhpqBdIgTRR24h+lpKen731aRIN7thscH9Zlv0d2F8YD2TIX7F2uw3A7ZWV1a0TYz9ca8cJZHRbuRuaDfUCw9/qJHamPOKToAwHtHN6lMvlSkH2o7wDMDo6WuGuQbbn5+YAKNcb3J5fSvrhtTY+vsOPuD1IOyRhMOkj9kSx29HfXB5RUnS964NT2+3vbGbxG9auO2cDNuV6A8NTb5TitBuOpQkfYD2vwOxgmvBB2g3Hto5X42EJyVsFlztbKpXGNgqVSqUxSWcLU2+tdToa9hasLjfPYlwGa+bTi8Dl1dvNsyvNtQQL9MO2w+HM7BqwlAtPdrvdq9773WAVsIr3fne3270KTOYyS2Z2bbXdHhogKmPj7YWF+VOSXs/v/9KdO+0fVBrjbRkgB/KIDBnYu9f/7D+ZmfmRxPd6qwB8YmZXcq1MAQ/nJhTM+OnDe/a8+PGNG9lm19V/D1Qw7HXZlcRa69+U6w38l5/4ipxzf5X0CPBILjcGPJH34pVcc8692FxcXLlXRnTwwH7+9P4f8aWe3fY59LIqo1NMyQBCCHNmdgx4BegUWefjDvCKmR0LIcz9L8nokSNH+PRvH4HC3YQ098pSbevg24qlmZmNmtmjkg4D3+j/tZldkvQXSa3PW5ptlpL3ZaIN99OS9F7+IgKUgSyEkNyv2nHT7DZX0dr9rpjua2l2r4rogRAYVqZvnPsPqVnpEXjEaB4AAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-wheel-zoom {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgskILvMJQAABTtJREFUWMPdl1+MXVUVxn/fPvf2zrSFmUKnoBCUdjRoVaIxEpO2JhilMYBCtBQS2hejpg1Uo2NUrIFAoyGmtiE+GHwQGtvQJhqDmKYRBv+URFsFDNCSptH60DJTO3dKnX/33rM/H7rvsDu9M20fDMaVnGTvtb69z7fWXmvtc/TEzqd4OyXwNsv/FwFJQVI/sA14SZKRLOlPkr5TrVYXHz70quYkEEK4TtI2YAgYkrQthHDdhV5uuw+43/ZrwCbgRttgY/tjtrc0m83X3/f+D6ydnJhYcB4BSZcBA7aP2d4ELAGW2N5k+xgwkDB0IH19CGGH7R8B1aQeAf4KvAw0ku4K2zu7uru3ApdPEyiKohd4TNKjtjt5h6RHgccSNrddbvuHtm9Jqoak7xVF8WFgdavV+pSk5cCObNmXgK++85prCj3z28HKqZMnH7D9YAY4BvwujT8BvCuL1INX9vVt+dfwcCvNb7f9q2RuSfrGvWu/sL2Nf3LX7pzvj4ENSGBPVarVd4fRkZFltjdmoMGiKO4IIWwIIWwoiuIOYDDzeOPoyMiyFLkum7WJCMDztrcrTTrIRuAQZ6NcK1utL4dWq/VZoC8BhqvV6l1lWb4YYxyLMY6VZflitVq9CxhOmL60hhCKeYiV7WMKIXw9jT1HpXw3c+bOAKzOjJubzebJrKQCQLPZPClpc7bP6rMYKtjXth2OMf7tIkr11Wz8oQDc1Fb09vY+kQw1YAuwJY2nbUluAnCWpKkaFl6IQIzxivaR2SYA89sJVK/Xp2x32R6w/a30DNjuqtfrU0ArYecDCEqgLqm94T0dEm9mBG7PxkdDlkBnkhebgIezNQ8nHcCZPL9ijE1Jf/bZZoPtzbavmqNZLbf9tSxq+yoduuJ+SZ+zXSZyBXCqU+d8fvC5yRUrV+0G2j3g2hDCLyXd/+Su3QdnvP/zCuH72LWsgf2k0oHlH2c2odlkxcpVEdgr6aDtjyb8x20/J+mA7T9I6rL9SWA5dne2/GdXLl58qNJh398An85yTMA+4DOz8Dgu6Zu2dwJXJ91ltm8Gbp7Fgb+EEB4aHhpq5CEtACqVyr3AC0AlPS8k3TSmQ2YPhhBuS/1/LpmS9JTtNTHGfwBU2uUALARotVqniqJYH2Pck85pfavVaufAwnQvnHc0McaDKVptebN94QAnJB0EdtjekydyZXqjs/0ZgLIs/w6sy8bnYGYJ63pgERKC05JutT1kOwITwL9tvzlzUQUYB+Zjs2DBgu6xsbGJZHstByZbezregcBXeCsEz1bnzXt5anLyzLq71zDLxTRdVgemdx0fv2e2w5thO5DbiqL4oKT3ZKpnpyYnz+SY2ZpTAPZmJfdIrVZbNBNUq9UW2X4kU+2dcf53Aj1pj2PA7y/6m1DS00A9za9uNBq7iqJYBuoGdRdFsazRaOzKSqye1rTbaa/tlbYrqXQP2X4FIA9/J1l39xrC0v7+w5IeB8XkwS1lWe6TGJAYKMty31tfO4qSHl/a3384I3CDpI+kzC4lnRfrue6GytEjR8oQwlY73gC0L4qlth/q0M1/LYWtR48cKQF6enrC6dOnVwGLEpnxnp7en4+O1i/tszzGOCTpPmB7ahb57QUwBWyXdF+McWg6MScmuoA8OX8xOlpvXGz422XYTsB/SnpA0h7bX5R0WzI9HUL4qe2XbI+dk3xl+V7gxoztD5jRI+YK/zkEEokx2/uB/RdzIfUtueqVN04cXwF8G3iHY3z9Urw/j8ClyhsnjrcS2Vv/J/8NLxT+/zqBTkcxU/cfEkyEAu3kmjAAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-box-edit {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4QfHjM1QAAAGRJREFUWMNjXLhsJcNAAiaGAQYsDAwM/+lsJ+OgCwGsLqMB+D8o08CoA0YdMOqAUQewDFQdMBoFIyoN/B/U7YFRB7DQIc7xyo9GwbBMA4xDqhxgISH1klXbDYk0QOseEeOgDgEAIS0JQleje6IAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-freehand-draw {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADTElEQVRYCeWWTWwMYRjH/88721X1lZJIGxJxcEE4OOiBgzjXWh8TJKR76kWacOBGxdEJIdk4VChZI/phidRBHMRRIr7DSUiaSCRFRM3u88gz+o7Z6bBTdjmYZPf9eJ55fv/5zzvvDPC/H9QsA66Olo9Ga+/MdR+Ljm2/KQIULsz9FqItGdOfJKLhApLgVkiSCGODjWit7QpKWy+TNrFeXvzKVUT8NiTVaIgDcbiCFJ7GiT8WkARXAdYBK0Lbhi/CenArRNskuM7/tgNp4ArQ42dwjf3WY5gWTqC7O/NbNn2Xkfw/YwdSw/We14HP2IEZwX+y9cZ9SH0LmgFP7UCz4KkENBNeV0Cz4b8U8DfgKiDxMWwUXETqLvJpCQpXZfawbzS7t9v5pL19cHBwfja7YA0y/lyCM0+E5hv5+piZXwKYcF23as+37bTXsQVqgkL0p/34fHR7DcBtbetFsBmGDwMOJCggYG55yw7dMlk6DuC1Bdu2RsCU9TYWQq2IoGbsreZ5NzvEqfSBsIsIy8OTbcdgiRHeh4o8AFAEwDakbY2AaCCpH7V9aGhoUUUy3UyVbkPYFuYLDlUZH8XBpwxkK0Dbgxg5HcVi0ent7a0RULMIozaHBSMfF9b2SzdutFcFB2FkwMIJOG6qfteXOa1nHZ48tyefuwyfT9s6wtzZ3t7eZse2DR2I228TtHXzuWCx9g8MtK5cuHCZTH4tiHEOa4xFngvTyS8f35d6enomiCi4/foEXBkZaQuukChL4FYA2Whd7YcC4gEdW3CpdL3LtGAVCVYJywEyTpAuJKeMOKXZs/Bw947C50KhUFOG4cwz35cjWNBlHGeD53n3xsfHP/T19U1qciggar8Fa4I3PHobIotBWBtc2hSiChyZxVzM53Pv7FVH6Tp3uVy+g0r1ImD2GjIrQGYIxjnfuXTZGICS5k/bBwJoubwEFX4TLah9EXomJGMA3za+f9913Yl4TnzsDQ+vE6YTZOjHh4ngibstt1pzQwd04F0bPStEBpXqRoBeQ/AKghfBnOEKgS+Q7z91Xfdz/HGKg8Ox7z8iYD9z6wqTkZFgnvhMGP9VZ2or1XVkPM9z0mytSfVsHa1RLBZbLoyNzUnK+ydz3wC6I9x+lwbngwAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-poly-draw {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEjglo9eZgwAAAc5JREFUWMPt1zFrU1EUB/DfS4OmVTGDIChCP4BgnQXRxVHqIJUupp9AB8VBQcRBQUXIB9DWQoMRiXZzcnQSA34A7aAuHSJKkgo2LvfBrU3aJnlYkBy4vHcP557zP/9z3r33JdXa647N0kHSZd5Nn0rSxc8G3cXp85sMcnZZ8vge3osZ+l3vB8CWFA0iL14t79h210swAjACMAIwAjACkB90D/8/GchI9ve4nPwTBh5E9ws7OepzGWb9EddSn51Op9ZstadSg4VK1UKlKkmSDSMLALewiuNh/hVJq71Wxttmqz0dG88vPc+MgWP4grvYG3SLOBrZFFFrttqPe4HIDxh4GSei+98iSlusuYopXEAjBtEPA3tQwUpwluAbDm4TPJUz+BTW9l2Ce6G7L0X/Bw8D3T/7SKKIDzHg7QCcxjvcQAEtXAnrrg/RP0/DKPbqgcN4iVOR7gcO4dcQgRuoh7HSqwlP4n20m63jJu5n8MkWMYfP3UowhzdR8FU8w9iQwevBdyq3/27CMRzAE5yLuvsRLg+ZcR1nJ8YL81HWJUzGAPaFZwe/Q5MdyYDyNHgjzO90YyGHtVDncuiJchaHw8R4oREFV5qdiVmYLM3OgD9k5209/atmIAAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-point-draw {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEiERGWPELgAAA4RJREFUWMO1lr1uG1cQhb9ztdRSP7AF1QxgwKlcuZSqRC9gWUUUINWqTh5AnaFOnVPEteQmRuhCURqWsSqqc9IolREXdEvQBElxtdw7KURSFEVKu4w8wAKLxdw9Z+bMnRmZGXfZ29//II8th4WwGVNyIoQLYB5vxA9Caq04iUd9A+7ZlsNC2I7TdSd2hZXMJKlnTqp9jtl/GBaqoyQ0noFKpUIzBicYYc+DEFpxkglc4oVJa5gvDn8v1xV2irG3FM4NSVwjUKlUaMcpJhCGmSEJQ6QGD8M5WnHCd8+f3QCXpPLx8WNwv0j6Bm9FMK7FJ3WBE+R/2t7c/GBmFvSBrzRTCsyTDjXrxUgEMtpxynJYmJoBJ4VAybwVARgvL7Oik0okCodnKpVKX7P0leiVMb0VvbJT+upznK4vh0GIeQwwQStJkHQD3MwsCALTJRG7Qrdrj5m/djgYaIa0hlkRdJk26XEgC9txurccBtVW3IudBImmZuACUP+ZlIDBt9FKcubYNTcAH/X0RYM1E7utJPlqe+uZzPxUcEkiSS4sTT95n15Mud0xWC0o2PAWOCdK3KYZlFxfM+tHOcnMzNr1es18ug+cgsVjP4yBU/Ppfrter1m/+l0+zYygML1xRVHU7TSb1cSzBzoBzszsH+AMdJJ49jrNZjWKou6wBnwOzcyndBpNbuueURR1Dw8Pq35p9cc5p/Dy9Dypt7jXrtdGwQECS9NPhr6Gq6txUzNigE6zydLK6lTw12/KT4FGFEUfJX2YJNONq5tVs4ODA7sD/DnwJ/BoADZuE3tHFs12dna6d4C/BI6AlbyzI8ii2TTw12/KK33gb2cdXsNZoAntbZC2SeO4c9592k/5eNQbiwvFd1kJuFGwLJr1wSPg/SwpvyFBHufOeXcFeAlE97U/uCxOY+P3b+Bn4B3Q+L8EdJfD4a+/AbC4UBzPxiPg3wlHZquB28Cn2IuR9x3gr3uV4DbwfvSDOvi4uFA8BDZmIRHkjHpS9Ht9iRqd8+5G3g05mAGcQbsdiX5QJ428G7Kygo8XYdb1/K4NWVmjzkNge2sz84bs+ELmpDDLtqWsNZBXgvmw8CTtpWVMT7x5YWBjLARnwZfKQNYN2U2LPvrh+5nBt7c2M2/It9bArCTKR8eZN+SJ13AScPnoODeRdqNenH+wul5w2gUr2WUjMFAt8bZ/0axX/wNnv4H8vTFb1QAAAABJRU5ErkJggg==\");\n}\n.bk-root .bk-tool-icon-poly-edit {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gELFi46qJmxxAAABV9JREFUWMOdl19vFFUYxn9n9u9sCyylUIzWUoMQBAWCMdEEIt6xIRQSLIEKtvHe6AcA4yeQb7CAUNJy0daLeomJN8SEULAC2kBBapBKoLvbmdl/c14vdmY7u91tF95kknPOnHmf95znPc97Ro2OTeBbdjFDT3c32ZxVHUOE9kSMB0/m6ExuoJn1H+ur6Y+OTfD50SMN5168OgrAlyf7CfuD+z7+iDs3p8hkLUQ0iFQ/yFl5Nm/qonfHVva+s32Zw9GxCYILsZ08tpNfBhbs+1YN4OH9+7huGdECSBVfqUosbsllfmauBqiR+cCNwOr7AEo8pPHJnymXykhg5fUWjoQpl0vVvhZhbSzGoUOHqgBlt6B6uruj2Zy1E9jo0fhfeyL2x4Mnc8VErK0KUEOB64JSyptfG4RSytsJjUJVxw2lsFy3urL9nx1Qd25ObctkrVMi+jQivd7U2ZyV/3Hzpq7h3h1b/7p9Y0o8v8rwAbTWrGpSocN/FGDlbAI0Rl23PCBan0Ok158H9Ipwzi25A/Mzc9Gl/BYx/E4kYqC1NKRARNAaDCNUM27Z+Zr+ouXs0q4+LSLBHPYCFkTkC6uU39kwCdsS7WRKmaYUiAhdnZ3MPX2K4+QjQI+C94A93rMzm8ltMwyDeDzWjMZeEb2pYQDdW3vITU2jtUZ5QThOPgm8C7wP7J15OPsBsB3oWpGnVWisCeDS1VHj4vBI92+/3tgB7Ab2AruAXiDBK5oIOkhtkEYRNRuJhObrd8Dl9ewf4D5wG7hVLpen29vb5wzD+BrkbBMaL3d1dk5nsrnlFDTTFWAWmAZueWD3gCemGde2k2fw1Al1YXhEvjozoO49eczdqekrWmsc2zlrmvEKOGoW1GUjFLqSk2KpJrCLwyMCPAP+BO54QL8DM6YZX/ClsP9YnwKkXnIBP4jdIpJRpdJTCYdMwwi98KU0Hjc/dDILNyUcwTCWdOSMJ0TRmBktGRhLugu0xyLk7CIqVNm+0bGJptl1YXikD0grpY4Rjc4a8Fbgdab/6OGbAJeCUuyJnnHmZH9pbSyGuBXV8NUwlUpR1EWyixmSyTWEwqGlJ2Swbo2JXbAAfgDGgGQA9I1A9t1tlq0AxrXxn0ilUpw4fhQqYkH/sT41OTnJJwf2s6FjI5mshdYa7bqVR2uezr9MJmJt14FvGrh/O9D+e6UkM/xyCuCqEKCYnJyUTKFQrZDHjxzGshwWLQcRsOz8Hi85P23id0ug/XilAMLBmm4tPGdoaKjSH5+oAGrhwvBI9SjZTn4QSK9yenoD7dlrExPoJlXW8G8ytpNHxRKk02lGxsdRKFwXLNvx5yY94HQLGhGk4LFCYQSqaE0AwWM1eOoEbR0dKBSW7bC4mKuffxs4D/wCLKwQQPAUzIkslfp6cVomROWSolh0GjldAM4nzDi2k9/i5UAzC9aKfwNJ3zgJg9YEvN6+C7SHgKm69+sD7RfNnKTTaZRPQfAut4oFV//IS7gkcB34VlVo8kGzphlfB+DU+TfNGBpZtRastvrvARJmfMF28ge9sc2B9/PNnCilMIDwK6y8/ow/Ai4kvILTljAXvDvEvrqKSUs60KolzPjBxspavQD2tKqCAGF/Ba+xE/Wbilu54wZV8NEKF5fXzQHl/bh4hUsE0WAXSlDMYcQSrQXgCmsTseXHsJkNnjqBFGwKJaHsKlxtUHYVhbLCzr1kaOA4bcn1y1Swmb+iLpJKpVrfgdpfsiVVCYcgluwgnU7jEgJ4s5UkLFtWYyHyEg0/N1q1tmQH+YXnAMFr97Nmv3p+0QsHQRsF8qpBOE5+rb9Nkaj50tVQKjqh4OU3GNL/1/So3vuUgbAAAAAASUVORK5CYII=\");\n}\n.bk-root .bk-tool-icon-line-edit {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAG/3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarVdpknSpDfzPKXwEJBDLccQW4Rv4+E4BtXR198znCdeLLijgQUoppWg3//Pv5f6FDwefXJRcUk3J4xNrrKzoFH8+pyUf9/f+8J3C7y/j7jnBGApow/mZ5l2vGJfXCzne8fZ13OV+9yl3ozvx2DDYyXbauCDvRoHPON3frl5Imt7MuX8hH0seiz9/xwxnDMFgYMczUPD7m89J4fwp/iK+OVRbiMf6gm8K4bv/3NN1Pzjw2fvwn+93PLzccTZ6mJU+/HTHSX723/bSOyLi58n8jmiqz/798+a/tUZZax7rNCKOakzXqIcpu4eFDe483kh4Mv4E/byfiqd49R2OHzC1Od/woxLD44siDVJaNHfbqQNi5MkZLXPnsMdKyFy5gwwCHXhocXahhhEK+OhgLmCYn1hon1vtPBxWcPIgrGTCZrR5fHvc58A/fb5stJaFOZEvT18BF1t8AYYxZ99YBUJoXZ/K9i+50/jPjxEbwKBsNxcYqL6dLZrQK7bC5jl4cVga/Ql5yuNuABfhbAEYCmDAJwpCiXxmzkTwYwE/CuQcIjcwQOKEB1ByDCGBnMJ2Nt7JtNey8BmGvIAICSlkUFODgqwYJSbkW0EIqZMgUUSSZClSRVNIMUlKKSfTKc0hxyw55ZxLrllLKLFISSWXUmrRyjVAxsTVVHMttVZVHKpRsZdivWKgcQstNmmp5VZabdoRPj126annXnrtOniEAQlwI408yqhDJ02E0oxTZpp5llmnLsTaCisuWWnlVVZd+mTtsvqVtU/m/po1uqzxJsrW5RdrGM75sQWZnIhxBsY4EhjPxgACmo0zXyhGNuaMM185uBCEgVKMnEHGGBiMk1gWPbl7Mfcrbw7e/V9545+Yc0bd/4M5Z9S9Mfedtx9YG7rlNmyCLAvhUyhkQPrNhvO5AJFnrZIR0plaLL5liQYdDi5TubaIokFDkmoFEB8CzxZVxemssDqthPhUblPgW1iQU5g6XwNwyVI7bUFRm035iNziMkgWvEso2SXnsJfveR0Y4SlVF8YWC1pVQhJiQa8JwDvlMNIxAfq3F7GDObHU1LlhzlZaWwNp6BvACxAgInGXlllMGZCpEnZHrGA6GM2718xuFcz7YdUQxzEEfjdWz4GlkcwaonT0pgA6mB25grPILtnSMhuCpsGhmMU6uJbixJs4lbKHqh+wos1jW2rchyGRCIvN9MXu+KAmMSfAlIKVvi/tybhCPJZCu2Ow9pLdyo427+X2ovMBmKNu8PA0zgl3fS0PB1DWWkVYB47bkyiJHhkFPzTzCjzn4Dq1mqoIWzCmcDGsHQmQAQdEHsixK1IXESd5rLU7THVJNV8obHS8sZeN0G5Jdt5pQTVKCCbgK1hItTS8o92iEZpuWJ/oC2r/0+zTmhvFXoaMVKRe27altDtid6OvG1hENVwBnC61KKugNoemOiPCCNb3GoHAZOFuDxxPsD+07nbSPcr/o1Zmc4jARhotrA5F5ZcjP9rPk90vR8A+k028A+8+5wKlHVID542sMzMCuXktkRzUCpE+xCBZywjNcJITx0II9x5948CekBl4XaC5OCX2nCyObdwN3HwQh5DWL/BBEkhDYHn/vpXNgZkVTZs8rj+HO8JFC6qvDVhgAEQSYCDyC86rMhG1WPzAVB9ZldDWG6EzDcFiqJBDvFS8mXDv3SK2LPoguVB2kwUx7UL5KqZWiEzocsbvSjNnaYDNtcYJuA5cDcsrvHd6yCxGjqvl9+wh3Qh8Kc9py8sNW8ncU8qwxdPj1qIGfrPqlXeoS4/JLa/LwRLTCtxuSoZUT+2Su6kXW3QNacYQbId6NUKVbROpviybFSPQQL9lhB2MamEnFyB9Y+hrG1+xBg+L0QG2TZdTdlcsBdq9oHdt9Bu5/IM9+Nfh1AwrSqlboTA6Bgq568A7UfbaMrZjoQZhQphofvNw93+bN+5X7FYKBgLmRid+tSdV6c02A4R0cHwKobmoMt5+6WI9XNISFIywpf6RMd5/a91vE78FzVHIFmxud4woyJx76OMTCa4yhgN3iJO2VfRPFMv9sYTxFzU+1eWeYS52pwOoSJldZY6koib4P1O427rbeUrNZfu44hWjz5ZSuu/vKPpimoXbLkfxWSPetvxDWG5jQSaZCxA3ad+p6rlttDhK+YwwK1LHVe0drDtorc5vnQ1247g58vewDtU7L3DRwrG4dhCUDRKKOtYr2dXHtpt+33d1WZmfkAHdl7Q8ENF+CNgB+nOw29n5F7SeNo/ckbu4laLTCdqJLHjmhJbKzmrCEX7zULrhefuHmu0V/1nbP1pnb6FaT7sOxn4pvWkfrYhYtCeJ4Xv+kOXrroIs1eHWXN1/AfzaY94ms5vaAAABg2lDQ1BJQ0MgcHJvZmlsZQAAeJx9kT1Iw0AcxV/TSkUqDnYQUchQnSyIijhqFYpQIdQKrTqYXPoFTRqSFBdHwbXg4Mdi1cHFWVcHV0EQ/ABxcnRSdJES/5cUWsR4cNyPd/ced+8AoVFhmhUaBzTdNtPJhJjNrYrhV4QwjAgGIMrMMuYkKQXf8XWPAF/v4jzL/9yfo1fNWwwIiMSzzDBt4g3i6U3b4LxPHGUlWSU+Jx4z6YLEj1xXPH7jXHRZ4JlRM5OeJ44Si8UOVjqYlUyNeIo4pmo65QtZj1XOW5y1So217slfGMnrK8tcpzmEJBaxBAkiFNRQRgU24rTqpFhI037Cxz/o+iVyKeQqg5FjAVVokF0/+B/87tYqTE54SZEE0PXiOB8jQHgXaNYd5/vYcZonQPAZuNLb/moDmPkkvd7WYkdA3zZwcd3WlD3gcgcYeDJkU3alIE2hUADez+ibckD/LdCz5vXW2sfpA5ChrlI3wMEhMFqk7HWfd3d39vbvmVZ/P2aecqIM1FFZAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5AQdDBkQmV+argAABM5JREFUWMOtl9trHFUcxz9n9jYzm7Tb9JIWGtqUllLwVgRBQWl90S6lTaGmF6E2/4H+A4r+A0offdlWodL4kEZw9bG+iC9iKqLF0os0EBq02dtcdmdnfj7szGZ2M5vulv5g4JwzZ873+7ufUfMLi0RSa1TZNzVFrW511xBhzMxx79EyOwrbGSSzZ073zOcXFnlv5lTi3mvfzAPwwYVZ0tHiq6+/xu+/LlGtWYgEINL9oG657N41yfSRgxw9cHjDgfMLi8QVsR0X23E3gMXnkXQJ3L9zB99vI4EA0sVXqsPF93xW7y73ACVJBJwE1j8HUBIi3Sz/QNtrIzHN+yWdSdNue915IMKWXI4TJ050Adp+U+2bmkrV6tZeYAXwEJExMyf3Hi0rM5fvAvS4wPdBKRW6vZeEUiq0RIBCddddpymu0+rRbPvEzkPVmmWLBA1EdGAbYNctt7V712QwfeSgd/uXJQnPVVoEEAQBTxXpuEMELNtNNFW1WrsrQdBCRImQEeE/wBUh53v+7tW7y5n1+BZRIoJSioXvy3itdgclURSZTBrP87AdV57G1TT0d4GPgC+Bw8Ca7bifATsTgzBvjlH1qgNdICJM7tjB8soKw4jtuD+Gw3c229e1wF+P/uHPpT86rhBBRHActwAcAl4EjgIvAYcFJnlOoq5dv6EBU8AR4OUQ6AVgGjATwuC5YUdZ4A+z+1mBTUM/AKwqpZSIpPfu2VP7+/6DYEMMPE9N83lzq23ZWwxDd4GaQnmgUloqperSCpKC8HGCXz8G7NANU8CWUKPzsUDbyLPVyjYC39e0VMZx3Ccoha4b4lQqbUlnsBqNWCXpEMgKfA38DNSBcdPQr4zlMtTtFiqlulmQmJv9ks2idUZGZMjZmZMAfBUvxWHR0y5dmPV2FcbPG9ncFdPQS3nTuAJQLBZpBS1qjSqFwjipdGr9SWlsHTewm9ZmnngMKAaV9nBd+/bmdxSLRc6dnemm3+yZ06pcLvPGW2+yfWIn1ZpFEAQEvt95goCV1TXMXH4zAt4woaRF7RTAVylAUS6Xpdpsdjvk2VMnsSyHhuVEZTh+xgywBhwLfZIdKRfj7dWqPGFubq7T428ukslkaHttLNsZ9P3nwIfh+DhwS4EO9DA0zByBCE2n1fPxpQuznSCaX1js9nFp2pjbtqGhobQ0jUY9CbgALERah3IM+El1rNqTaqaph5W1uYGAFrfA5YvnyE9MoFBYtjMI/BXgQR/4pqVDZL3V9/cYrX+x7SnsXh/H5TLwW2iBQbVLNgn65CDsrSPOIJOXwmdQ4fRHrZilUqmXwNXrNzbbfxv4ArgFVBLeJ95oDEMHwHHcvvUcRqEwuBf0SSUEB9gfxsAgAkO1kcj/WvwKPaR8EhvPAUvRtdIMtR1FtBH37w8DEeChaehXw/xfAnzHcVOjEkhHrIe0Qlz7T8PuWLEd9+2w9KphgUUgQJ7JAgAPDT13NTrJyOYqIilrlEwQv/NPMTSByxfPIU37eCqtq2zWmPYDjbavaLYVdn2NuffPjqRJK2hRLBaHzoK+X7L1QE+nIFeYoFQqkTVMaTn2UOe1LWtwEJqGzqgRnS9M4Fb+3XBJGfSrFzW9dBw0icioJBzHzUXdMJM18APwWo6Kmy1O6X+V8UHDotBqogAAAABJRU5ErkJggg==\");\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* core\\util\\menus.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const dom_1 = require(72) /* ../dom */;\r\n    const iterator_1 = require(303) /* ./iterator */;\r\n    //import menus_css from \"styles/menus.css\"\r\n    const styles = tslib_1.__importStar(require(282) /* ../../styles/menus */);\r\n    class ContextMenu {\r\n        constructor(items, options = {}) {\r\n            this.items = items;\r\n            this.options = options;\r\n            this.el = dom_1.div();\r\n            this._open = false;\r\n            this._item_click = (i) => {\r\n                var _a;\r\n                (_a = this.items[i]) === null || _a === void 0 ? void 0 : _a.handler();\r\n                this.hide();\r\n            };\r\n            this._on_mousedown = (event) => {\r\n                var _a, _b;\r\n                const { target } = event;\r\n                if (target instanceof Node && this.el.contains(target))\r\n                    return;\r\n                if ((_b = (_a = this.options).prevent_hide) === null || _b === void 0 ? void 0 : _b.call(_a, event))\r\n                    return;\r\n                this.hide();\r\n            };\r\n            this._on_keydown = (event) => {\r\n                if (event.keyCode == dom_1.Keys.Esc)\r\n                    this.hide();\r\n            };\r\n            this._on_blur = () => {\r\n                this.hide();\r\n            };\r\n            dom_1.undisplay(this.el);\r\n        }\r\n        get is_open() {\r\n            return this._open;\r\n        }\r\n        get can_open() {\r\n            return this.items.length != 0;\r\n        }\r\n        remove() {\r\n            dom_1.remove(this.el);\r\n            this._unlisten();\r\n        }\r\n        _listen() {\r\n            document.addEventListener(\"mousedown\", this._on_mousedown);\r\n            document.addEventListener(\"keydown\", this._on_keydown);\r\n            window.addEventListener(\"blur\", this._on_blur);\r\n        }\r\n        _unlisten() {\r\n            document.removeEventListener(\"mousedown\", this._on_mousedown);\r\n            document.removeEventListener(\"keydown\", this._on_keydown);\r\n            window.removeEventListener(\"blur\", this._on_blur);\r\n        }\r\n        _position(at) {\r\n            const parent_el = this.el.parentElement;\r\n            if (parent_el != null) {\r\n                const parent = parent_el.getBoundingClientRect();\r\n                this.el.style.left = at.left != null ? `${at.left - parent.left}px` : \"\";\r\n                this.el.style.top = at.top != null ? `${at.top - parent.top}px` : \"\";\r\n                this.el.style.right = at.right != null ? `${parent.right - at.right}px` : \"\";\r\n                this.el.style.bottom = at.bottom != null ? `${parent.bottom - at.bottom}px` : \"\";\r\n            }\r\n        }\r\n        /*\r\n        styles(): string[] {\r\n          return [...super.styles(), menus_css]\r\n        }\r\n        */\r\n        render() {\r\n            var _a, _b;\r\n            dom_1.empty(this.el, true);\r\n            const orientation = (_a = this.options.orientation) !== null && _a !== void 0 ? _a : \"vertical\";\r\n            dom_1.classes(this.el).add(\"bk-context-menu\", `bk-${orientation}`);\r\n            for (const [item, i] of iterator_1.enumerate(this.items)) {\r\n                let el;\r\n                if (item == null) {\r\n                    el = dom_1.div({ class: styles.bk_divider });\r\n                }\r\n                else if (item.if != null && !item.if()) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    const icon = item.icon != null ? dom_1.div({ class: [\"bk-menu-icon\", item.icon] }) : null;\r\n                    el = dom_1.div({ class: ((_b = item.active) === null || _b === void 0 ? void 0 : _b.call(item)) ? \"bk-active\" : null, title: item.tooltip }, icon, item.label);\r\n                }\r\n                el.addEventListener(\"click\", () => this._item_click(i));\r\n                this.el.appendChild(el);\r\n            }\r\n        }\r\n        show(at) {\r\n            if (this.items.length == 0)\r\n                return;\r\n            if (!this._open) {\r\n                this.render();\r\n                if (this.el.children.length == 0)\r\n                    return;\r\n                this._position(at !== null && at !== void 0 ? at : { left: 0, top: 0 });\r\n                dom_1.display(this.el);\r\n                this._listen();\r\n                this._open = true;\r\n            }\r\n        }\r\n        hide() {\r\n            if (this._open) {\r\n                this._open = false;\r\n                this._unlisten();\r\n                dom_1.undisplay(this.el);\r\n            }\r\n        }\r\n        toggle(at) {\r\n            this._open ? this.hide() : this.show(at);\r\n        }\r\n    }\r\n    exports.ContextMenu = ContextMenu;\r\n    ContextMenu.__name__ = \"ContextMenu\";\r\n}\r\n","/* core\\util\\iterator.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const array_1 = require(9) /* ./array */;\r\n    function* enumerate(seq) {\r\n        let i = 0;\r\n        for (const item of seq) {\r\n            yield [item, i++];\r\n        }\r\n    }\r\n    exports.enumerate = enumerate;\r\n    // https://docs.python.org/3.8/library/itertools.html#itertools.combinations\r\n    function* combinations(seq, r) {\r\n        const n = seq.length;\r\n        if (r > n)\r\n            return;\r\n        const indices = array_1.range(r);\r\n        yield indices.map((i) => seq[i]);\r\n        while (true) {\r\n            let k;\r\n            for (const i of array_1.reversed(array_1.range(r))) {\r\n                if (indices[i] != i + n - r) {\r\n                    k = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (k == null)\r\n                return;\r\n            indices[k] += 1;\r\n            for (const j of array_1.range(k + 1, r)) {\r\n                indices[j] = indices[j - 1] + 1;\r\n            }\r\n            yield indices.map((i) => seq[i]);\r\n        }\r\n    }\r\n    exports.combinations = combinations;\r\n    function* subsets(seq) {\r\n        for (const k of array_1.range(seq.length + 1)) {\r\n            yield* combinations(seq, k);\r\n        }\r\n    }\r\n    exports.subsets = subsets;\r\n}\r\n","/* models\\tools\\on_off_button.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const button_tool_1 = require(296) /* ./button_tool */;\r\n    const mixins_1 = require(173) /* ../../styles/mixins */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    class OnOffButtonView extends button_tool_1.ButtonToolButtonView {\r\n        render() {\r\n            super.render();\r\n            dom_1.classes(this.el).toggle(mixins_1.bk_active, this.model.active);\r\n        }\r\n        _clicked() {\r\n            const { active } = this.model;\r\n            this.model.active = !active;\r\n        }\r\n    }\r\n    exports.OnOffButtonView = OnOffButtonView;\r\n    OnOffButtonView.__name__ = \"OnOffButtonView\";\r\n}\r\n","/* models\\tools\\toolbar_base.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const build_views_1 = require(115) /* ../../core/build_views */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const dom_view_1 = require(78) /* ../../core/dom_view */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const gesture_tool_1 = require(306) /* ./gestures/gesture_tool */;\r\n    const action_tool_1 = require(307) /* ./actions/action_tool */;\r\n    const help_tool_1 = require(308) /* ./actions/help_tool */;\r\n    const inspect_tool_1 = require(295) /* ./inspectors/inspect_tool */;\r\n    const toolbar_1 = require(299) /* ../../styles/toolbar */;\r\n    const logo_1 = require(310) /* ../../styles/logo */;\r\n    const mixins_1 = require(173) /* ../../styles/mixins */;\r\n    const toolbar_css_1 = tslib_1.__importDefault(require(300) /* ../../styles/toolbar.css */);\r\n    const logo_css_1 = tslib_1.__importDefault(require(311) /* ../../styles/logo.css */);\r\n    class ToolbarViewModel extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ToolbarViewModel() {\r\n            this.define({\r\n                _visible: [p.Any, null],\r\n                autohide: [p.Boolean, false],\r\n            });\r\n        }\r\n        get visible() {\r\n            return (!this.autohide) ? true : (this._visible == null) ? false : this._visible;\r\n        }\r\n    }\r\n    exports.ToolbarViewModel = ToolbarViewModel;\r\n    ToolbarViewModel.__name__ = \"ToolbarViewModel\";\r\n    ToolbarViewModel.init_ToolbarViewModel();\r\n    class ToolbarBaseView extends dom_view_1.DOMView {\r\n        initialize() {\r\n            super.initialize();\r\n            this._tool_button_views = new Map();\r\n            this._toolbar_view_model = new ToolbarViewModel({ autohide: this.model.autohide });\r\n        }\r\n        async lazy_initialize() {\r\n            await this._build_tool_button_views();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.tools.change, async () => {\r\n                await this._build_tool_button_views();\r\n                this.render();\r\n            });\r\n            this.connect(this.model.properties.autohide.change, () => {\r\n                this._toolbar_view_model.autohide = this.model.autohide;\r\n                this._on_visible_change();\r\n            });\r\n            this.connect(this._toolbar_view_model.properties._visible.change, () => this._on_visible_change());\r\n        }\r\n        styles() {\r\n            return [...super.styles(), toolbar_css_1.default, logo_css_1.default];\r\n        }\r\n        remove() {\r\n            build_views_1.remove_views(this._tool_button_views);\r\n            super.remove();\r\n        }\r\n        async _build_tool_button_views() {\r\n            const tools = (this.model._proxied_tools != null ? this.model._proxied_tools : this.model.tools); // XXX\r\n            await build_views_1.build_views(this._tool_button_views, tools, { parent: this }, (tool) => tool.button_view); // XXX: no ButtonToolButton model\r\n        }\r\n        set_visibility(visible) {\r\n            if (visible != this._toolbar_view_model._visible) {\r\n                this._toolbar_view_model._visible = visible;\r\n            }\r\n        }\r\n        _on_visible_change() {\r\n            const visible = this._toolbar_view_model.visible;\r\n            const hidden_class = toolbar_1.bk_toolbar_hidden;\r\n            if (this.el.classList.contains(hidden_class) && visible) {\r\n                this.el.classList.remove(hidden_class);\r\n            }\r\n            else if (!visible) {\r\n                this.el.classList.add(hidden_class);\r\n            }\r\n        }\r\n        render() {\r\n            dom_1.empty(this.el);\r\n            this.el.classList.add(toolbar_1.bk_toolbar);\r\n            this.el.classList.add(mixins_1.bk_side(this.model.toolbar_location));\r\n            this._toolbar_view_model.autohide = this.model.autohide;\r\n            this._on_visible_change();\r\n            if (this.model.logo != null) {\r\n                const gray = this.model.logo === \"grey\" ? logo_1.bk_grey : null;\r\n                const logo = dom_1.a({ href: \"https://bokeh.org/\", target: \"_blank\", class: [logo_1.bk_logo, logo_1.bk_logo_small, gray] });\r\n                this.el.appendChild(logo);\r\n            }\r\n            for (const [, button_view] of this._tool_button_views) {\r\n                button_view.render();\r\n            }\r\n            const bars = [];\r\n            const el = (tool) => {\r\n                return this._tool_button_views.get(tool).el;\r\n            };\r\n            const { gestures } = this.model;\r\n            for (const gesture of object_1.values(gestures)) {\r\n                bars.push(gesture.tools.map(el));\r\n            }\r\n            bars.push(this.model.actions.map(el));\r\n            bars.push(this.model.inspectors.filter((tool) => tool.toggleable).map(el));\r\n            for (const bar of bars) {\r\n                if (bar.length !== 0) {\r\n                    const el = dom_1.div({ class: toolbar_1.bk_button_bar }, bar);\r\n                    this.el.appendChild(el);\r\n                }\r\n            }\r\n        }\r\n        update_layout() { }\r\n        update_position() { }\r\n        after_layout() {\r\n            this._has_finished = true;\r\n        }\r\n    }\r\n    exports.ToolbarBaseView = ToolbarBaseView;\r\n    ToolbarBaseView.__name__ = \"ToolbarBaseView\";\r\n    function createGestureMap() {\r\n        return {\r\n            pan: { tools: [], active: null },\r\n            scroll: { tools: [], active: null },\r\n            pinch: { tools: [], active: null },\r\n            tap: { tools: [], active: null },\r\n            doubletap: { tools: [], active: null },\r\n            press: { tools: [], active: null },\r\n            pressup: { tools: [], active: null },\r\n            rotate: { tools: [], active: null },\r\n            move: { tools: [], active: null },\r\n            multi: { tools: [], active: null },\r\n        };\r\n    }\r\n    class ToolbarBase extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ToolbarBase() {\r\n            this.prototype.default_view = ToolbarBaseView;\r\n            this.define({\r\n                tools: [p.Array, []],\r\n                logo: [p.Logo, 'normal'],\r\n                autohide: [p.Boolean, false],\r\n            });\r\n            this.internal({\r\n                gestures: [p.Any, createGestureMap],\r\n                actions: [p.Array, []],\r\n                inspectors: [p.Array, []],\r\n                help: [p.Array, []],\r\n                toolbar_location: [p.Location, 'right'],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._init_tools();\r\n        }\r\n        _init_tools() {\r\n            // The only purpose of this function is to avoid unnecessary property churning.\r\n            const tools_changed = function (old_tools, new_tools) {\r\n                if (old_tools.length != new_tools.length) {\r\n                    return true;\r\n                }\r\n                const new_ids = new Set(new_tools.map(t => t.id));\r\n                return array_1.some(old_tools, t => !new_ids.has(t.id));\r\n            };\r\n            const new_inspectors = this.tools.filter(t => t instanceof inspect_tool_1.InspectTool);\r\n            if (tools_changed(this.inspectors, new_inspectors)) {\r\n                this.inspectors = new_inspectors;\r\n            }\r\n            const new_help = this.tools.filter(t => t instanceof help_tool_1.HelpTool);\r\n            if (tools_changed(this.help, new_help)) {\r\n                this.help = new_help;\r\n            }\r\n            const new_actions = this.tools.filter(t => t instanceof action_tool_1.ActionTool);\r\n            if (tools_changed(this.actions, new_actions)) {\r\n                this.actions = new_actions;\r\n            }\r\n            const check_event_type = (et, tool) => {\r\n                if (!(et in this.gestures)) {\r\n                    logging_1.logger.warn(`Toolbar: unknown event type '${et}' for tool: ${tool}`);\r\n                }\r\n            };\r\n            const new_gestures = createGestureMap();\r\n            for (const tool of this.tools) {\r\n                if (tool instanceof gesture_tool_1.GestureTool && tool.event_type) {\r\n                    if (types_1.isString(tool.event_type)) {\r\n                        new_gestures[tool.event_type].tools.push(tool);\r\n                        check_event_type(tool.event_type, tool);\r\n                    }\r\n                    else {\r\n                        new_gestures.multi.tools.push(tool);\r\n                        for (const et of tool.event_type) {\r\n                            check_event_type(et, tool);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (const et of Object.keys(new_gestures)) {\r\n                const gm = this.gestures[et];\r\n                if (tools_changed(gm.tools, new_gestures[et].tools)) {\r\n                    gm.tools = new_gestures[et].tools;\r\n                }\r\n                if (gm.active && array_1.every(gm.tools, t => t.id != gm.active.id)) {\r\n                    gm.active = null;\r\n                }\r\n            }\r\n        }\r\n        get horizontal() {\r\n            return this.toolbar_location === \"above\" || this.toolbar_location === \"below\";\r\n        }\r\n        get vertical() {\r\n            return this.toolbar_location === \"left\" || this.toolbar_location === \"right\";\r\n        }\r\n        _active_change(tool) {\r\n            const { event_type } = tool;\r\n            if (event_type == null)\r\n                return;\r\n            const event_types = types_1.isString(event_type) ? [event_type] : event_type;\r\n            for (const et of event_types) {\r\n                if (tool.active) {\r\n                    const currently_active_tool = this.gestures[et].active;\r\n                    if (currently_active_tool != null && tool != currently_active_tool) {\r\n                        logging_1.logger.debug(`Toolbar: deactivating tool: ${currently_active_tool} for event type '${et}'`);\r\n                        currently_active_tool.active = false;\r\n                    }\r\n                    this.gestures[et].active = tool;\r\n                    logging_1.logger.debug(`Toolbar: activating tool: ${tool} for event type '${et}'`);\r\n                }\r\n                else\r\n                    this.gestures[et].active = null;\r\n            }\r\n        }\r\n    }\r\n    exports.ToolbarBase = ToolbarBase;\r\n    ToolbarBase.__name__ = \"ToolbarBase\";\r\n    ToolbarBase.init_ToolbarBase();\r\n}\r\n","/* models\\tools\\gestures\\gesture_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const button_tool_1 = require(296) /* ../button_tool */;\r\n    const on_off_button_1 = require(304) /* ../on_off_button */;\r\n    class GestureToolView extends button_tool_1.ButtonToolView {\r\n    }\r\n    exports.GestureToolView = GestureToolView;\r\n    GestureToolView.__name__ = \"GestureToolView\";\r\n    class GestureTool extends button_tool_1.ButtonTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.button_view = on_off_button_1.OnOffButtonView;\r\n        }\r\n    }\r\n    exports.GestureTool = GestureTool;\r\n    GestureTool.__name__ = \"GestureTool\";\r\n}\r\n","/* models\\tools\\actions\\action_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const button_tool_1 = require(296) /* ../button_tool */;\r\n    const signaling_1 = require(15) /* ../../../core/signaling */;\r\n    class ActionToolButtonView extends button_tool_1.ButtonToolButtonView {\r\n        _clicked() {\r\n            this.model.do.emit(undefined);\r\n        }\r\n    }\r\n    exports.ActionToolButtonView = ActionToolButtonView;\r\n    ActionToolButtonView.__name__ = \"ActionToolButtonView\";\r\n    class ActionToolView extends button_tool_1.ButtonToolView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.do, (arg) => this.doit(arg));\r\n        }\r\n    }\r\n    exports.ActionToolView = ActionToolView;\r\n    ActionToolView.__name__ = \"ActionToolView\";\r\n    class ActionTool extends button_tool_1.ButtonTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.button_view = ActionToolButtonView;\r\n            this.do = new signaling_1.Signal(this, \"do\");\r\n        }\r\n    }\r\n    exports.ActionTool = ActionTool;\r\n    ActionTool.__name__ = \"ActionTool\";\r\n}\r\n","/* models\\tools\\actions\\help_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const action_tool_1 = require(307) /* ./action_tool */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class HelpToolView extends action_tool_1.ActionToolView {\r\n        doit() {\r\n            window.open(this.model.redirect);\r\n        }\r\n    }\r\n    exports.HelpToolView = HelpToolView;\r\n    HelpToolView.__name__ = \"HelpToolView\";\r\n    class HelpTool extends action_tool_1.ActionTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Help\";\r\n            this.icon = icons_1.bk_tool_icon_help;\r\n        }\r\n        static init_HelpTool() {\r\n            this.prototype.default_view = HelpToolView;\r\n            this.define({\r\n                help_tooltip: [p.String, 'Click the question mark to learn more about Bokeh plot tools.'],\r\n                redirect: [p.String, 'https://docs.bokeh.org/en/latest/docs/user_guide/tools.html'],\r\n            });\r\n            this.register_alias(\"help\", () => new HelpTool());\r\n        }\r\n        get tooltip() {\r\n            return this.help_tooltip;\r\n        }\r\n    }\r\n    exports.HelpTool = HelpTool;\r\n    HelpTool.__name__ = \"HelpTool\";\r\n    HelpTool.init_HelpTool();\r\n}\r\n","/* styles\\icons.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_tool_icon_box_select = \"bk-tool-icon-box-select\";\r\n    exports.bk_tool_icon_box_zoom = \"bk-tool-icon-box-zoom\";\r\n    exports.bk_tool_icon_zoom_in = \"bk-tool-icon-zoom-in\";\r\n    exports.bk_tool_icon_zoom_out = \"bk-tool-icon-zoom-out\";\r\n    exports.bk_tool_icon_help = \"bk-tool-icon-help\";\r\n    exports.bk_tool_icon_hover = \"bk-tool-icon-hover\";\r\n    exports.bk_tool_icon_crosshair = \"bk-tool-icon-crosshair\";\r\n    exports.bk_tool_icon_lasso_select = \"bk-tool-icon-lasso-select\";\r\n    exports.bk_tool_icon_pan = \"bk-tool-icon-pan\";\r\n    exports.bk_tool_icon_xpan = \"bk-tool-icon-xpan\";\r\n    exports.bk_tool_icon_ypan = \"bk-tool-icon-ypan\";\r\n    exports.bk_tool_icon_range = \"bk-tool-icon-range\";\r\n    exports.bk_tool_icon_polygon_select = \"bk-tool-icon-polygon-select\";\r\n    exports.bk_tool_icon_redo = \"bk-tool-icon-redo\";\r\n    exports.bk_tool_icon_reset = \"bk-tool-icon-reset\";\r\n    exports.bk_tool_icon_save = \"bk-tool-icon-save\";\r\n    exports.bk_tool_icon_tap_select = \"bk-tool-icon-tap-select\";\r\n    exports.bk_tool_icon_undo = \"bk-tool-icon-undo\";\r\n    exports.bk_tool_icon_wheel_pan = \"bk-tool-icon-wheel-pan\";\r\n    exports.bk_tool_icon_wheel_zoom = \"bk-tool-icon-wheel-zoom\";\r\n    exports.bk_tool_icon_box_edit = \"bk-tool-icon-box-edit\";\r\n    exports.bk_tool_icon_freehand_draw = \"bk-tool-icon-freehand-draw\";\r\n    exports.bk_tool_icon_poly_draw = \"bk-tool-icon-poly-draw\";\r\n    exports.bk_tool_icon_point_draw = \"bk-tool-icon-point-draw\";\r\n    exports.bk_tool_icon_poly_edit = \"bk-tool-icon-poly-edit\";\r\n    exports.bk_tool_icon_line_edit = \"bk-tool-icon-line-edit\";\r\n}\r\n","/* styles\\logo.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_logo = \"bk-logo\";\r\n    exports.bk_logo_notebook = \"bk-logo-notebook\";\r\n    exports.bk_logo_small = \"bk-logo-small\";\r\n    exports.bk_grey = \"bk-grey\";\r\n}\r\n","/* styles\\logo.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root .bk-logo {\n  margin: 5px;\n  position: relative;\n  display: block;\n  background-repeat: no-repeat;\n}\n.bk-root .bk-logo.bk-grey {\n  filter: url(\"data:image/svg+xml;utf8,<svg xmlns=\\'http://www.w3.org/2000/svg\\'><filter id=\\'grayscale\\'><feColorMatrix type=\\'matrix\\' values=\\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\\'/></filter></svg>#grayscale\");\n  /* Firefox 10+, Firefox on Android */\n  filter: gray;\n  /* IE6-9 */\n  -webkit-filter: grayscale(100%);\n  /* Chrome 19+, Safari 6+, Safari 6+ iOS */\n}\n.bk-root .bk-logo-small {\n  width: 20px;\n  height: 20px;\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAOkSURBVDiNjZRtaJVlGMd/1/08zzln5zjP1LWcU9N0NkN8m2CYjpgQYQXqSs0I84OLIC0hkEKoPtiH3gmKoiJDU7QpLgoLjLIQCpEsNJ1vqUOdO7ppbuec5+V+rj4ctwzd8IIbbi6u+8f1539dt3A78eXC7QizUF7gyV1fD1Yqg4JWz84yffhm0qkFqBogB9rM8tZdtwVsPUhWhGcFJngGeWrPzHm5oaMmkfEg1usvLFyc8jLRqDOMru7AyC8saQr7GG7f5fvDeH7Ej8CM66nIF+8yngt6HWaKh7k49Soy9nXurCi1o3qUbS3zWfrYeQDTB/Qj6kX6Ybhw4B+bOYoLKCC9H3Nu/leUTZ1JdRWkkn2ldcCamzrcf47KKXdAJllSlxAOkRgyHsGC/zRday5Qld9DyoM4/q/rUoy/CXh3jzOu3bHUVZeU+DEn8FInkPBFlu3+nW3Nw0mk6vCDiWg8CeJaxEwuHS3+z5RgY+YBR6V1Z1nxSOfoaPa4LASWxxdNp+VWTk7+4vzaou8v8PN+xo+KY2xsw6une2frhw05CTYOmQvsEhjhWjn0bmXPjpE1+kplmmkP3suftwTubK9Vq22qKmrBhpY4jvd5afdRA3wGjFAgcnTK2s4hY0/GPNIb0nErGMCRxWOOX64Z8RAC4oCXdklmEvcL8o0BfkNK4lUg9HTl+oPlQxdNo3Mg4Nv175e/1LDGzZen30MEjRUtmXSfiTVu1kK8W4txyV6BMKlbgk3lMwYCiusNy9fVfvvwMxv8Ynl6vxoByANLTWplvuj/nF9m2+PDtt1eiHPBr1oIfhCChQMBw6Aw0UulqTKZdfVvfG7VcfIqLG9bcldL/+pdWTLxLUy8Qq38heUIjh4XlzZxzQm19lLFlr8vdQ97rjZVOLf8nclzckbcD4wxXMidpX30sFd37Fv/GtwwhzhxGVAprjbg0gCAEeIgwCZyTV2Z1REEW8O4py0wsjeloKoMr6iCY6dP92H6Vw/oTyICIthibxjm/DfN9lVz8IqtqKYLUXfoKVMVQVVJOElGjrnnUt9T9wbgp8AyYKaGlqingHZU/uG2NTZSVqwHQTWkx9hxjkpWDaCg6Ckj5qebgBVbT3V3NNXMSiWSDdGV3hrtzla7J+duwPOToIg42ChPQOQjspnSlp1V+Gjdged7+8UN5CRAV7a5EdFNwCjEaBR27b3W890TE7g24NAP/mMDXRWrGoFPQI9ls/MWO2dWFAar/xcOIImbbpA3zgAAAABJRU5ErkJggg==);\n}\n.bk-root .bk-logo-notebook {\n  display: inline-block;\n  vertical-align: middle;\n  margin-right: 5px;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* models\\plots\\plot_canvas.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var __rest = (this && this.__rest) || function (s, e) {\r\n        var t = {};\r\n        for (var p in s)\r\n            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n                t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n    const cartesian_frame_1 = require(208) /* ../canvas/cartesian_frame */;\r\n    const canvas_1 = require(77) /* ../canvas/canvas */;\r\n    const data_range1d_1 = require(210) /* ../ranges/data_range1d */;\r\n    const glyph_renderer_1 = require(90) /* ../renderers/glyph_renderer */;\r\n    const layout_dom_1 = require(272) /* ../layouts/layout_dom */;\r\n    const title_1 = require(169) /* ../annotations/title */;\r\n    const axis_1 = require(177) /* ../axes/axis */;\r\n    const toolbar_panel_1 = require(170) /* ../annotations/toolbar_panel */;\r\n    const bokeh_events_1 = require(313) /* ../../core/bokeh_events */;\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const build_views_1 = require(115) /* ../../core/build_views */;\r\n    const ui_events_1 = require(314) /* ../../core/ui_events */;\r\n    const visuals_1 = require(74) /* ../../core/visuals */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const throttle_1 = require(316) /* ../../core/util/throttle */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const alignments_1 = require(215) /* ../../core/layout/alignments */;\r\n    const border_1 = require(317) /* ../../core/layout/border */;\r\n    const side_panel_1 = require(318) /* ../../core/layout/side_panel */;\r\n    const grid_1 = require(216) /* ../../core/layout/grid */;\r\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\r\n    class PlotView extends layout_dom_1.LayoutDOMView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._outer_bbox = new bbox_1.BBox();\r\n            this._inner_bbox = new bbox_1.BBox();\r\n            this._needs_paint = true;\r\n            this._needs_layout = false;\r\n            this._invalidated_painters = new Set();\r\n            this._invalidate_all = true;\r\n        }\r\n        get is_paused() {\r\n            return this._is_paused != null && this._is_paused !== 0;\r\n        }\r\n        get child_models() {\r\n            return [];\r\n        }\r\n        pause() {\r\n            if (this._is_paused == null)\r\n                this._is_paused = 1;\r\n            else\r\n                this._is_paused += 1;\r\n        }\r\n        unpause(no_render = false) {\r\n            if (this._is_paused == null)\r\n                throw new Error(\"wasn't paused\");\r\n            this._is_paused -= 1;\r\n            if (this._is_paused == 0 && !no_render)\r\n                this.request_paint();\r\n        }\r\n        // TODO: this needs to be removed\r\n        request_render() {\r\n            this.request_paint();\r\n        }\r\n        request_paint(to_invalidate) {\r\n            if (to_invalidate != null) {\r\n                this._invalidated_painters.add(to_invalidate);\r\n            }\r\n            else {\r\n                this._invalidate_all = true;\r\n            }\r\n            if (!this.is_paused) {\r\n                const promise = this.throttled_paint();\r\n                this._ready = this._ready.then(() => promise);\r\n            }\r\n        }\r\n        request_layout() {\r\n            this._needs_layout = true;\r\n            this.request_paint();\r\n        }\r\n        reset() {\r\n            if (this.model.reset_policy == \"standard\") {\r\n                this.clear_state();\r\n                this.reset_range();\r\n                this.reset_selection();\r\n            }\r\n            this.model.trigger_event(new bokeh_events_1.Reset());\r\n        }\r\n        remove() {\r\n            this.ui_event_bus.destroy();\r\n            build_views_1.remove_views(this.renderer_views);\r\n            build_views_1.remove_views(this.tool_views);\r\n            this.canvas_view.remove();\r\n            super.remove();\r\n        }\r\n        render() {\r\n            super.render();\r\n            this.el.appendChild(this.canvas_view.el);\r\n            this.canvas_view.render();\r\n        }\r\n        initialize() {\r\n            this.pause();\r\n            super.initialize();\r\n            this.state_changed = new signaling_1.Signal0(this, \"state_changed\");\r\n            this.lod_started = false;\r\n            this.visuals = new visuals_1.Visuals(this.model); // XXX\r\n            this._initial_state_info = {\r\n                selection: new Map(),\r\n                dimensions: { width: 0, height: 0 },\r\n            };\r\n            this.visibility_callbacks = [];\r\n            this.state = { history: [], index: -1 };\r\n            const { hidpi, output_backend } = this.model;\r\n            this.canvas = new canvas_1.Canvas({ hidpi, output_backend });\r\n            this.frame = new cartesian_frame_1.CartesianFrame(this.model.x_scale, this.model.y_scale, this.model.x_range, this.model.y_range, this.model.extra_x_ranges, this.model.extra_y_ranges);\r\n            this.throttled_paint = throttle_1.throttle(() => this.repaint(), 1000 / 60);\r\n            const { title_location, title } = this.model;\r\n            if (title_location != null && title != null) {\r\n                this._title = title instanceof title_1.Title ? title : new title_1.Title({ text: title });\r\n            }\r\n            const { toolbar_location, toolbar } = this.model;\r\n            if (toolbar_location != null && toolbar != null) {\r\n                this._toolbar = new toolbar_panel_1.ToolbarPanel({ toolbar });\r\n                toolbar.toolbar_location = toolbar_location;\r\n            }\r\n            this.renderer_views = new Map();\r\n            this.tool_views = new Map();\r\n        }\r\n        async lazy_initialize() {\r\n            this.canvas_view = await build_views_1.build_view(this.canvas, { parent: this });\r\n            this.ui_event_bus = new ui_events_1.UIEvents(this, this.model.toolbar, this.canvas_view.events_el);\r\n            await this.build_renderer_views();\r\n            await this.build_tool_views();\r\n            this.update_dataranges();\r\n            this.unpause(true);\r\n            logging_1.logger.debug(\"PlotView initialized\");\r\n        }\r\n        _width_policy() {\r\n            return this.model.frame_width == null ? super._width_policy() : \"min\";\r\n        }\r\n        _height_policy() {\r\n            return this.model.frame_height == null ? super._height_policy() : \"min\";\r\n        }\r\n        _update_layout() {\r\n            this.layout = new border_1.BorderLayout();\r\n            this.layout.set_sizing(this.box_sizing());\r\n            const { frame_width, frame_height } = this.model;\r\n            this.layout.center_panel = this.frame;\r\n            this.layout.center_panel.set_sizing(Object.assign(Object.assign({}, (frame_width != null ? { width_policy: \"fixed\", width: frame_width } : { width_policy: \"fit\" })), (frame_height != null ? { height_policy: \"fixed\", height: frame_height } : { height_policy: \"fit\" })));\r\n            const above = array_1.copy(this.model.above);\r\n            const below = array_1.copy(this.model.below);\r\n            const left = array_1.copy(this.model.left);\r\n            const right = array_1.copy(this.model.right);\r\n            const get_side = (side) => {\r\n                switch (side) {\r\n                    case \"above\": return above;\r\n                    case \"below\": return below;\r\n                    case \"left\": return left;\r\n                    case \"right\": return right;\r\n                }\r\n            };\r\n            const { title_location, title } = this.model;\r\n            if (title_location != null && title != null) {\r\n                get_side(title_location).push(this._title);\r\n            }\r\n            const { toolbar_location, toolbar } = this.model;\r\n            if (toolbar_location != null && toolbar != null) {\r\n                const panels = get_side(toolbar_location);\r\n                let push_toolbar = true;\r\n                if (this.model.toolbar_sticky) {\r\n                    for (let i = 0; i < panels.length; i++) {\r\n                        const panel = panels[i];\r\n                        if (panel instanceof title_1.Title) {\r\n                            if (toolbar_location == \"above\" || toolbar_location == \"below\")\r\n                                panels[i] = [panel, this._toolbar];\r\n                            else\r\n                                panels[i] = [this._toolbar, panel];\r\n                            push_toolbar = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (push_toolbar)\r\n                    panels.push(this._toolbar);\r\n            }\r\n            const set_layout = (side, model) => {\r\n                const view = this.renderer_views.get(model);\r\n                return view.layout = new side_panel_1.SidePanel(side, view);\r\n            };\r\n            const set_layouts = (side, panels) => {\r\n                const horizontal = side == \"above\" || side == \"below\";\r\n                const layouts = [];\r\n                for (const panel of panels) {\r\n                    if (types_1.isArray(panel)) {\r\n                        const items = panel.map((subpanel) => {\r\n                            const item = set_layout(side, subpanel);\r\n                            if (subpanel instanceof toolbar_panel_1.ToolbarPanel) {\r\n                                const dim = horizontal ? \"width_policy\" : \"height_policy\";\r\n                                item.set_sizing(Object.assign(Object.assign({}, item.sizing), { [dim]: \"min\" }));\r\n                            }\r\n                            return item;\r\n                        });\r\n                        let layout;\r\n                        if (horizontal) {\r\n                            layout = new grid_1.Row(items);\r\n                            layout.set_sizing({ width_policy: \"max\", height_policy: \"min\" });\r\n                        }\r\n                        else {\r\n                            layout = new grid_1.Column(items);\r\n                            layout.set_sizing({ width_policy: \"min\", height_policy: \"max\" });\r\n                        }\r\n                        layout.absolute = true;\r\n                        layouts.push(layout);\r\n                    }\r\n                    else\r\n                        layouts.push(set_layout(side, panel));\r\n                }\r\n                return layouts;\r\n            };\r\n            const min_border = this.model.min_border != null ? this.model.min_border : 0;\r\n            this.layout.min_border = {\r\n                left: this.model.min_border_left != null ? this.model.min_border_left : min_border,\r\n                top: this.model.min_border_top != null ? this.model.min_border_top : min_border,\r\n                right: this.model.min_border_right != null ? this.model.min_border_right : min_border,\r\n                bottom: this.model.min_border_bottom != null ? this.model.min_border_bottom : min_border,\r\n            };\r\n            const top_panel = new alignments_1.VStack();\r\n            const bottom_panel = new alignments_1.VStack();\r\n            const left_panel = new alignments_1.HStack();\r\n            const right_panel = new alignments_1.HStack();\r\n            top_panel.children = array_1.reversed(set_layouts(\"above\", above));\r\n            bottom_panel.children = set_layouts(\"below\", below);\r\n            left_panel.children = array_1.reversed(set_layouts(\"left\", left));\r\n            right_panel.children = set_layouts(\"right\", right);\r\n            top_panel.set_sizing({ width_policy: \"fit\", height_policy: \"min\" /*, min_height: this.layout.min_border.top*/ });\r\n            bottom_panel.set_sizing({ width_policy: \"fit\", height_policy: \"min\" /*, min_height: this.layout.min_width.bottom*/ });\r\n            left_panel.set_sizing({ width_policy: \"min\", height_policy: \"fit\" /*, min_width: this.layout.min_width.left*/ });\r\n            right_panel.set_sizing({ width_policy: \"min\", height_policy: \"fit\" /*, min_width: this.layout.min_width.right*/ });\r\n            this.layout.top_panel = top_panel;\r\n            this.layout.bottom_panel = bottom_panel;\r\n            this.layout.left_panel = left_panel;\r\n            this.layout.right_panel = right_panel;\r\n        }\r\n        get axis_views() {\r\n            const views = [];\r\n            for (const [, renderer_view] of this.renderer_views) {\r\n                if (renderer_view instanceof axis_1.AxisView)\r\n                    views.push(renderer_view);\r\n            }\r\n            return views;\r\n        }\r\n        set_cursor(cursor = \"default\") {\r\n            this.canvas_view.el.style.cursor = cursor;\r\n        }\r\n        set_toolbar_visibility(visible) {\r\n            for (const callback of this.visibility_callbacks)\r\n                callback(visible);\r\n        }\r\n        update_dataranges() {\r\n            // Update any DataRange1ds here\r\n            const bounds = new Map();\r\n            const log_bounds = new Map();\r\n            let calculate_log_bounds = false;\r\n            for (const [, xr] of this.frame.x_ranges) {\r\n                if (xr instanceof data_range1d_1.DataRange1d && xr.scale_hint == \"log\")\r\n                    calculate_log_bounds = true;\r\n            }\r\n            for (const [, yr] of this.frame.y_ranges) {\r\n                if (yr instanceof data_range1d_1.DataRange1d && yr.scale_hint == \"log\")\r\n                    calculate_log_bounds = true;\r\n            }\r\n            for (const [renderer, renderer_view] of this.renderer_views) {\r\n                if (renderer_view instanceof glyph_renderer_1.GlyphRendererView) {\r\n                    const bds = renderer_view.glyph.bounds();\r\n                    if (bds != null)\r\n                        bounds.set(renderer, bds);\r\n                    if (calculate_log_bounds) {\r\n                        const log_bds = renderer_view.glyph.log_bounds();\r\n                        if (log_bds != null)\r\n                            log_bounds.set(renderer, log_bds);\r\n                    }\r\n                }\r\n            }\r\n            let follow_enabled = false;\r\n            let has_bounds = false;\r\n            const { width, height } = this.frame.bbox;\r\n            let r;\r\n            if (this.model.match_aspect !== false && width != 0 && height != 0)\r\n                r = (1 / this.model.aspect_scale) * (width / height);\r\n            for (const [, xr] of this.frame.x_ranges) {\r\n                if (xr instanceof data_range1d_1.DataRange1d) {\r\n                    const bounds_to_use = xr.scale_hint == \"log\" ? log_bounds : bounds;\r\n                    xr.update(bounds_to_use, 0, this.model, r);\r\n                    if (xr.follow) {\r\n                        follow_enabled = true;\r\n                    }\r\n                }\r\n                if (xr.bounds != null)\r\n                    has_bounds = true;\r\n            }\r\n            for (const [, yr] of this.frame.y_ranges) {\r\n                if (yr instanceof data_range1d_1.DataRange1d) {\r\n                    const bounds_to_use = yr.scale_hint == \"log\" ? log_bounds : bounds;\r\n                    yr.update(bounds_to_use, 1, this.model, r);\r\n                    if (yr.follow) {\r\n                        follow_enabled = true;\r\n                    }\r\n                }\r\n                if (yr.bounds != null)\r\n                    has_bounds = true;\r\n            }\r\n            if (follow_enabled && has_bounds) {\r\n                logging_1.logger.warn('Follow enabled so bounds are unset.');\r\n                for (const [, xr] of this.frame.x_ranges) {\r\n                    xr.bounds = null;\r\n                }\r\n                for (const [, yr] of this.frame.y_ranges) {\r\n                    yr.bounds = null;\r\n                }\r\n            }\r\n            this.range_update_timestamp = Date.now();\r\n        }\r\n        push_state(type, new_info) {\r\n            const { history, index } = this.state;\r\n            const prev_info = history[index] != null ? history[index].info : {};\r\n            const info = Object.assign(Object.assign(Object.assign({}, this._initial_state_info), prev_info), new_info);\r\n            this.state.history = this.state.history.slice(0, this.state.index + 1);\r\n            this.state.history.push({ type, info });\r\n            this.state.index = this.state.history.length - 1;\r\n            this.state_changed.emit();\r\n        }\r\n        clear_state() {\r\n            this.state = { history: [], index: -1 };\r\n            this.state_changed.emit();\r\n        }\r\n        can_undo() {\r\n            return this.state.index >= 0;\r\n        }\r\n        can_redo() {\r\n            return this.state.index < this.state.history.length - 1;\r\n        }\r\n        undo() {\r\n            if (this.can_undo()) {\r\n                this.state.index -= 1;\r\n                this._do_state_change(this.state.index);\r\n                this.state_changed.emit();\r\n            }\r\n        }\r\n        redo() {\r\n            if (this.can_redo()) {\r\n                this.state.index += 1;\r\n                this._do_state_change(this.state.index);\r\n                this.state_changed.emit();\r\n            }\r\n        }\r\n        _do_state_change(index) {\r\n            const info = this.state.history[index] != null ? this.state.history[index].info : this._initial_state_info;\r\n            if (info.range != null)\r\n                this.update_range(info.range);\r\n            if (info.selection != null)\r\n                this.update_selection(info.selection);\r\n        }\r\n        get_selection() {\r\n            const selection = new Map();\r\n            for (const renderer of this.model.renderers) {\r\n                if (renderer instanceof glyph_renderer_1.GlyphRenderer) {\r\n                    const { selected } = renderer.data_source;\r\n                    selection.set(renderer, selected);\r\n                }\r\n            }\r\n            return selection;\r\n        }\r\n        update_selection(selections) {\r\n            for (const renderer of this.model.renderers) {\r\n                if (!(renderer instanceof glyph_renderer_1.GlyphRenderer))\r\n                    continue;\r\n                const ds = renderer.data_source;\r\n                if (selections != null) {\r\n                    const selection = selections.get(renderer);\r\n                    if (selection != null) {\r\n                        ds.selected.update(selection, true);\r\n                    }\r\n                }\r\n                else\r\n                    ds.selection_manager.clear();\r\n            }\r\n        }\r\n        reset_selection() {\r\n            this.update_selection(null);\r\n        }\r\n        _update_ranges_together(range_info_iter) {\r\n            // Get weight needed to scale the diff of the range to honor interval limits\r\n            let weight = 1.0;\r\n            for (const [rng, range_info] of range_info_iter) {\r\n                weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));\r\n            }\r\n            // Apply shared weight to all ranges\r\n            if (weight < 1) {\r\n                for (const [rng, range_info] of range_info_iter) {\r\n                    range_info.start = weight * range_info.start + (1 - weight) * rng.start;\r\n                    range_info.end = weight * range_info.end + (1 - weight) * rng.end;\r\n                }\r\n            }\r\n        }\r\n        _update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus) {\r\n            let hit_bound = false;\r\n            for (const [rng, range_info] of range_info_iter) {\r\n                // Limit range interval first. Note that for scroll events,\r\n                // the interval has already been limited for all ranges simultaneously\r\n                if (!is_scrolling) {\r\n                    const weight = this._get_weight_to_constrain_interval(rng, range_info);\r\n                    if (weight < 1) {\r\n                        range_info.start = weight * range_info.start + (1 - weight) * rng.start;\r\n                        range_info.end = weight * range_info.end + (1 - weight) * rng.end;\r\n                    }\r\n                }\r\n                // Prevent range from going outside limits\r\n                // Also ensure that range keeps the same delta when panning/scrolling\r\n                if (rng.bounds != null && rng.bounds != \"auto\") { // check `auto` for type-checking purpose\r\n                    const [min, max] = rng.bounds;\r\n                    const new_interval = Math.abs(range_info.end - range_info.start);\r\n                    if (rng.is_reversed) {\r\n                        if (min != null) {\r\n                            if (min >= range_info.end) {\r\n                                hit_bound = true;\r\n                                range_info.end = min;\r\n                                if (is_panning || is_scrolling) {\r\n                                    range_info.start = min + new_interval;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (max != null) {\r\n                            if (max <= range_info.start) {\r\n                                hit_bound = true;\r\n                                range_info.start = max;\r\n                                if (is_panning || is_scrolling) {\r\n                                    range_info.end = max - new_interval;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (min != null) {\r\n                            if (min >= range_info.start) {\r\n                                hit_bound = true;\r\n                                range_info.start = min;\r\n                                if (is_panning || is_scrolling) {\r\n                                    range_info.end = min + new_interval;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (max != null) {\r\n                            if (max <= range_info.end) {\r\n                                hit_bound = true;\r\n                                range_info.end = max;\r\n                                if (is_panning || is_scrolling) {\r\n                                    range_info.start = max - new_interval;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Cancel the event when hitting a bound while scrolling. This ensures that\r\n            // the scroll-zoom tool maintains its focus position. Setting `maintain_focus`\r\n            // to false results in a more \"gliding\" behavior, allowing one to\r\n            // zoom out more smoothly, at the cost of losing the focus position.\r\n            if (is_scrolling && hit_bound && maintain_focus)\r\n                return;\r\n            for (const [rng, range_info] of range_info_iter) {\r\n                rng.have_updated_interactively = true;\r\n                if (rng.start != range_info.start || rng.end != range_info.end)\r\n                    rng.setv(range_info);\r\n            }\r\n        }\r\n        _get_weight_to_constrain_interval(rng, range_info) {\r\n            // Get the weight by which a range-update can be applied\r\n            // to still honor the interval limits (including the implicit\r\n            // max interval imposed by the bounds)\r\n            const { min_interval } = rng;\r\n            let { max_interval } = rng;\r\n            // Express bounds as a max_interval. By doing this, the application of\r\n            // bounds and interval limits can be applied independent from each-other.\r\n            if (rng.bounds != null && rng.bounds != \"auto\") { // check `auto` for type-checking purpose\r\n                const [min, max] = rng.bounds;\r\n                if (min != null && max != null) {\r\n                    const max_interval2 = Math.abs(max - min);\r\n                    max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;\r\n                }\r\n            }\r\n            let weight = 1.0;\r\n            if (min_interval != null || max_interval != null) {\r\n                const old_interval = Math.abs(rng.end - rng.start);\r\n                const new_interval = Math.abs(range_info.end - range_info.start);\r\n                if (min_interval > 0 && new_interval < min_interval) {\r\n                    weight = (old_interval - min_interval) / (old_interval - new_interval);\r\n                }\r\n                if (max_interval > 0 && new_interval > max_interval) {\r\n                    weight = (max_interval - old_interval) / (new_interval - old_interval);\r\n                }\r\n                weight = Math.max(0.0, Math.min(1.0, weight));\r\n            }\r\n            return weight;\r\n        }\r\n        update_range(range_info, is_panning = false, is_scrolling = false, maintain_focus = true) {\r\n            this.pause();\r\n            const { x_ranges, y_ranges } = this.frame;\r\n            if (range_info == null) {\r\n                for (const [, range] of x_ranges) {\r\n                    range.reset();\r\n                }\r\n                for (const [, range] of y_ranges) {\r\n                    range.reset();\r\n                }\r\n                this.update_dataranges();\r\n            }\r\n            else {\r\n                const range_info_iter = [];\r\n                for (const [name, range] of x_ranges) {\r\n                    range_info_iter.push([range, range_info.xrs.get(name)]);\r\n                }\r\n                for (const [name, range] of y_ranges) {\r\n                    range_info_iter.push([range, range_info.yrs.get(name)]);\r\n                }\r\n                if (is_scrolling) {\r\n                    this._update_ranges_together(range_info_iter); // apply interval bounds while keeping aspect\r\n                }\r\n                this._update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus);\r\n            }\r\n            this.unpause();\r\n        }\r\n        reset_range() {\r\n            this.update_range(null);\r\n        }\r\n        _invalidate_layout() {\r\n            const needs_layout = () => {\r\n                for (const panel of this.model.side_panels) {\r\n                    const view = this.renderer_views.get(panel);\r\n                    if (view.layout.has_size_changed())\r\n                        return true;\r\n                }\r\n                return false;\r\n            };\r\n            if (needs_layout())\r\n                this.root.compute_layout();\r\n        }\r\n        get_renderer_views() {\r\n            return this.computed_renderers.map((r) => this.renderer_views.get(r));\r\n        }\r\n        async build_renderer_views() {\r\n            this.computed_renderers = [];\r\n            const { above, below, left, right, center, renderers } = this.model;\r\n            this.computed_renderers.push(...above, ...below, ...left, ...right, ...center, ...renderers);\r\n            if (this._title != null)\r\n                this.computed_renderers.push(this._title);\r\n            if (this._toolbar != null)\r\n                this.computed_renderers.push(this._toolbar);\r\n            for (const tool of this.model.toolbar.tools) {\r\n                if (tool.overlay != null)\r\n                    this.computed_renderers.push(tool.overlay);\r\n                this.computed_renderers.push(...tool.synthetic_renderers);\r\n            }\r\n            await build_views_1.build_views(this.renderer_views, this.computed_renderers, { parent: this });\r\n        }\r\n        async build_tool_views() {\r\n            const tool_models = this.model.toolbar.tools;\r\n            const new_tool_views = await build_views_1.build_views(this.tool_views, tool_models, { parent: this });\r\n            new_tool_views.map((tool_view) => this.ui_event_bus.register_tool(tool_view));\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            const { x_ranges, y_ranges } = this.frame;\r\n            for (const [, range] of x_ranges) {\r\n                this.connect(range.change, () => { this._needs_layout = true; this.request_paint(); });\r\n            }\r\n            for (const [, range] of y_ranges) {\r\n                this.connect(range.change, () => { this._needs_layout = true; this.request_paint(); });\r\n            }\r\n            const { plot_width, plot_height } = this.model.properties;\r\n            this.on_change([plot_width, plot_height], () => this.invalidate_layout());\r\n            const { above, below, left, right, center, renderers } = this.model.properties;\r\n            this.on_change([above, below, left, right, center, renderers], async () => await this.build_renderer_views());\r\n            this.connect(this.model.toolbar.properties.tools.change, async () => {\r\n                await this.build_renderer_views();\r\n                await this.build_tool_views();\r\n            });\r\n            this.connect(this.model.change, () => this.request_paint());\r\n            this.connect(this.model.reset, () => this.reset());\r\n        }\r\n        set_initial_range() {\r\n            // check for good values for ranges before setting initial range\r\n            let good_vals = true;\r\n            const { x_ranges, y_ranges } = this.frame;\r\n            const xrs = new Map();\r\n            const yrs = new Map();\r\n            for (const [name, range] of x_ranges) {\r\n                const { start, end } = range;\r\n                if (start == null || end == null || isNaN(start + end)) {\r\n                    good_vals = false;\r\n                    break;\r\n                }\r\n                xrs.set(name, { start, end });\r\n            }\r\n            if (good_vals) {\r\n                for (const [name, range] of y_ranges) {\r\n                    const { start, end } = range;\r\n                    if (start == null || end == null || isNaN(start + end)) {\r\n                        good_vals = false;\r\n                        break;\r\n                    }\r\n                    yrs.set(name, { start, end });\r\n                }\r\n            }\r\n            if (good_vals) {\r\n                this._initial_state_info.range = { xrs, yrs };\r\n                logging_1.logger.debug(\"initial ranges set\");\r\n            }\r\n            else\r\n                logging_1.logger.warn('could not set initial ranges');\r\n        }\r\n        has_finished() {\r\n            if (!super.has_finished())\r\n                return false;\r\n            if (this.model.visible) {\r\n                for (const [, renderer_view] of this.renderer_views) {\r\n                    if (!renderer_view.has_finished())\r\n                        return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        after_layout() {\r\n            super.after_layout();\r\n            this._needs_layout = false;\r\n            this.model.setv({\r\n                inner_width: Math.round(this.frame.bbox.width),\r\n                inner_height: Math.round(this.frame.bbox.height),\r\n                outer_width: Math.round(this.layout.bbox.width),\r\n                outer_height: Math.round(this.layout.bbox.height),\r\n            }, { no_change: true });\r\n            if (this.model.match_aspect !== false) {\r\n                this.pause();\r\n                this.update_dataranges();\r\n                this.unpause(true);\r\n            }\r\n            if (!this._outer_bbox.equals(this.layout.bbox)) {\r\n                const { width, height } = this.layout.bbox;\r\n                this.canvas_view.resize(width, height);\r\n                this._outer_bbox = this.layout.bbox;\r\n                this._invalidate_all = true;\r\n                this._needs_paint = true;\r\n            }\r\n            if (!this._inner_bbox.equals(this.frame.inner_bbox)) {\r\n                this._inner_bbox = this.layout.inner_bbox;\r\n                this._needs_paint = true;\r\n            }\r\n            if (this._needs_paint) {\r\n                // XXX: can't be this.request_paint(), because it would trigger back-and-forth\r\n                // layout recomputing feedback loop between plots. Plots are also much more\r\n                // responsive this way, especially in interactive mode.\r\n                this.paint();\r\n            }\r\n        }\r\n        repaint() {\r\n            if (this._needs_layout)\r\n                this._invalidate_layout();\r\n            this.paint();\r\n        }\r\n        paint() {\r\n            if (this.is_paused || !this.model.visible)\r\n                return;\r\n            logging_1.logger.trace(`PlotView.paint() for ${this.model.id}`);\r\n            const { document } = this.model;\r\n            if (document != null) {\r\n                const interactive_duration = document.interactive_duration();\r\n                if (interactive_duration >= 0 && interactive_duration < this.model.lod_interval) {\r\n                    setTimeout(() => {\r\n                        if (document.interactive_duration() > this.model.lod_timeout) {\r\n                            document.interactive_stop();\r\n                        }\r\n                        this.request_paint();\r\n                    }, this.model.lod_timeout);\r\n                }\r\n                else\r\n                    document.interactive_stop();\r\n            }\r\n            for (const [, renderer_view] of this.renderer_views) {\r\n                if (this.range_update_timestamp == null ||\r\n                    (renderer_view instanceof glyph_renderer_1.GlyphRendererView && renderer_view.set_data_timestamp > this.range_update_timestamp)) {\r\n                    this.update_dataranges();\r\n                    break;\r\n                }\r\n            }\r\n            let do_primary = false;\r\n            let do_overlays = false;\r\n            if (this._invalidate_all) {\r\n                do_primary = true;\r\n                do_overlays = true;\r\n            }\r\n            else {\r\n                for (const painter of this._invalidated_painters) {\r\n                    const { level } = painter.model;\r\n                    if (level != \"overlay\")\r\n                        do_primary = true;\r\n                    else\r\n                        do_overlays = true;\r\n                    if (do_primary && do_overlays)\r\n                        break;\r\n                }\r\n            }\r\n            this._invalidated_painters.clear();\r\n            this._invalidate_all = false;\r\n            const frame_box = [\r\n                this.frame.bbox.left,\r\n                this.frame.bbox.top,\r\n                this.frame.bbox.width,\r\n                this.frame.bbox.height,\r\n            ];\r\n            const { primary, overlays } = this.canvas_view;\r\n            if (do_primary) {\r\n                primary.prepare();\r\n                this.canvas_view.prepare_webgl(frame_box);\r\n                this.canvas_view.clear_webgl();\r\n                this._map_hook(primary.ctx, frame_box);\r\n                this._paint_empty(primary.ctx, frame_box);\r\n                this._paint_outline(primary.ctx, frame_box);\r\n                this._paint_levels(primary.ctx, \"image\", frame_box, true);\r\n                this._paint_levels(primary.ctx, \"underlay\", frame_box, true);\r\n                this._paint_levels(primary.ctx, \"glyph\", frame_box, true);\r\n                this._paint_levels(primary.ctx, \"guide\", frame_box, false);\r\n                this._paint_levels(primary.ctx, \"annotation\", frame_box, false);\r\n                primary.finish();\r\n            }\r\n            if (do_overlays) {\r\n                overlays.prepare();\r\n                this._paint_levels(overlays.ctx, \"overlay\", frame_box, false);\r\n                overlays.finish();\r\n            }\r\n            if (this._initial_state_info.range == null)\r\n                this.set_initial_range();\r\n            this._needs_paint = false;\r\n        }\r\n        _paint_levels(ctx, level, clip_region, global_clip) {\r\n            for (const renderer of this.computed_renderers) {\r\n                if (renderer.level != level)\r\n                    continue;\r\n                const renderer_view = this.renderer_views.get(renderer);\r\n                ctx.save();\r\n                if (global_clip || renderer_view.needs_clip) {\r\n                    ctx.beginPath();\r\n                    ctx.rect(...clip_region);\r\n                    ctx.clip();\r\n                }\r\n                renderer_view.render();\r\n                ctx.restore();\r\n                if (renderer_view.has_webgl && renderer_view.needs_webgl_blit) {\r\n                    this.canvas_view.blit_webgl(ctx);\r\n                    this.canvas_view.clear_webgl();\r\n                }\r\n            }\r\n        }\r\n        _map_hook(_ctx, _frame_box) { }\r\n        _paint_empty(ctx, frame_box) {\r\n            const [cx, cy, cw, ch] = [0, 0, this.layout.bbox.width, this.layout.bbox.height];\r\n            const [fx, fy, fw, fh] = frame_box;\r\n            if (this.visuals.border_fill.doit) {\r\n                this.visuals.border_fill.set_value(ctx);\r\n                ctx.fillRect(cx, cy, cw, ch);\r\n                ctx.clearRect(fx, fy, fw, fh);\r\n            }\r\n            if (this.visuals.background_fill.doit) {\r\n                this.visuals.background_fill.set_value(ctx);\r\n                ctx.fillRect(fx, fy, fw, fh);\r\n            }\r\n        }\r\n        _paint_outline(ctx, frame_box) {\r\n            if (this.visuals.outline_line.doit) {\r\n                ctx.save();\r\n                this.visuals.outline_line.set_value(ctx);\r\n                let [x0, y0, w, h] = frame_box;\r\n                // XXX: shrink outline region by 1px to make right and bottom lines visible\r\n                // if they are on the edge of the canvas.\r\n                if (x0 + w == this.layout.bbox.width) {\r\n                    w -= 1;\r\n                }\r\n                if (y0 + h == this.layout.bbox.height) {\r\n                    h -= 1;\r\n                }\r\n                ctx.strokeRect(x0, y0, w, h);\r\n                ctx.restore();\r\n            }\r\n        }\r\n        to_blob() {\r\n            return this.canvas_view.to_blob();\r\n        }\r\n        export(type, hidpi = true) {\r\n            const output_backend = type == \"png\" ? \"canvas\" : \"svg\";\r\n            const composite = new canvas_1.CanvasLayer(output_backend, hidpi);\r\n            const { width, height } = this.layout.bbox;\r\n            composite.resize(width, height);\r\n            const { canvas } = this.canvas_view.compose();\r\n            composite.ctx.drawImage(canvas, 0, 0);\r\n            return composite;\r\n        }\r\n        serializable_state() {\r\n            const _a = super.serializable_state(), { children } = _a, state = __rest(_a, [\"children\"]);\r\n            const renderers = this.get_renderer_views()\r\n                .map((view) => view.serializable_state())\r\n                .filter((item) => \"bbox\" in item);\r\n            return Object.assign(Object.assign({}, state), { children: [...children, ...renderers] }); // XXX\r\n        }\r\n    }\r\n    exports.PlotView = PlotView;\r\n    PlotView.__name__ = \"PlotView\";\r\n}\r\n","/* core\\bokeh_events.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\r\n            r = Reflect.decorate(decorators, target, key, desc);\r\n        else\r\n            for (var i = decorators.length - 1; i >= 0; i--)\r\n                if (d = decorators[i])\r\n                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n    function event(event_name) {\r\n        return function (cls) {\r\n            cls.prototype.event_name = event_name;\r\n        };\r\n    }\r\n    class BokehEvent {\r\n        to_json() {\r\n            const { event_name } = this;\r\n            return { event_name, event_values: this._to_json() };\r\n        }\r\n    }\r\n    exports.BokehEvent = BokehEvent;\r\n    BokehEvent.__name__ = \"BokehEvent\";\r\n    class ModelEvent extends BokehEvent {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.origin = null;\r\n        }\r\n        _to_json() {\r\n            return { model: this.origin };\r\n        }\r\n    }\r\n    exports.ModelEvent = ModelEvent;\r\n    ModelEvent.__name__ = \"ModelEvent\";\r\n    let DocumentReady = class DocumentReady extends BokehEvent {\r\n        _to_json() {\r\n            return {};\r\n        }\r\n    };\r\n    exports.DocumentReady = DocumentReady;\r\n    DocumentReady.__name__ = \"DocumentReady\";\r\n    exports.DocumentReady = DocumentReady = __decorate([\r\n        event(\"document_ready\")\r\n    ], DocumentReady);\r\n    let ButtonClick = class ButtonClick extends ModelEvent {\r\n    };\r\n    exports.ButtonClick = ButtonClick;\r\n    ButtonClick.__name__ = \"ButtonClick\";\r\n    exports.ButtonClick = ButtonClick = __decorate([\r\n        event(\"button_click\")\r\n    ], ButtonClick);\r\n    let MenuItemClick = class MenuItemClick extends ModelEvent {\r\n        constructor(item) {\r\n            super();\r\n            this.item = item;\r\n        }\r\n        _to_json() {\r\n            const { item } = this;\r\n            return Object.assign(Object.assign({}, super._to_json()), { item });\r\n        }\r\n    };\r\n    exports.MenuItemClick = MenuItemClick;\r\n    MenuItemClick.__name__ = \"MenuItemClick\";\r\n    exports.MenuItemClick = MenuItemClick = __decorate([\r\n        event(\"menu_item_click\")\r\n    ], MenuItemClick);\r\n    // A UIEvent is an event originating on a canvas this includes.\r\n    // DOM events such as keystrokes as well as hammer events and LOD events.\r\n    class UIEvent extends ModelEvent {\r\n    }\r\n    exports.UIEvent = UIEvent;\r\n    UIEvent.__name__ = \"UIEvent\";\r\n    let LODStart = class LODStart extends UIEvent {\r\n    };\r\n    exports.LODStart = LODStart;\r\n    LODStart.__name__ = \"LODStart\";\r\n    exports.LODStart = LODStart = __decorate([\r\n        event(\"lodstart\")\r\n    ], LODStart);\r\n    let LODEnd = class LODEnd extends UIEvent {\r\n    };\r\n    exports.LODEnd = LODEnd;\r\n    LODEnd.__name__ = \"LODEnd\";\r\n    exports.LODEnd = LODEnd = __decorate([\r\n        event(\"lodend\")\r\n    ], LODEnd);\r\n    let SelectionGeometry = class SelectionGeometry extends UIEvent {\r\n        constructor(geometry, final) {\r\n            super();\r\n            this.geometry = geometry;\r\n            this.final = final;\r\n        }\r\n        _to_json() {\r\n            const { geometry, final } = this;\r\n            return Object.assign(Object.assign({}, super._to_json()), { geometry, final });\r\n        }\r\n    };\r\n    exports.SelectionGeometry = SelectionGeometry;\r\n    SelectionGeometry.__name__ = \"SelectionGeometry\";\r\n    exports.SelectionGeometry = SelectionGeometry = __decorate([\r\n        event(\"selectiongeometry\")\r\n    ], SelectionGeometry);\r\n    let Reset = class Reset extends UIEvent {\r\n    };\r\n    exports.Reset = Reset;\r\n    Reset.__name__ = \"Reset\";\r\n    exports.Reset = Reset = __decorate([\r\n        event(\"reset\")\r\n    ], Reset);\r\n    class PointEvent extends UIEvent {\r\n        constructor(sx, sy, x, y) {\r\n            super();\r\n            this.sx = sx;\r\n            this.sy = sy;\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n        _to_json() {\r\n            const { sx, sy, x, y } = this;\r\n            return Object.assign(Object.assign({}, super._to_json()), { sx, sy, x, y });\r\n        }\r\n    }\r\n    exports.PointEvent = PointEvent;\r\n    PointEvent.__name__ = \"PointEvent\";\r\n    let Pan = class Pan extends PointEvent {\r\n        /* TODO: direction: -1 | 1 */\r\n        constructor(sx, sy, x, y, delta_x, delta_y) {\r\n            super(sx, sy, x, y);\r\n            this.sx = sx;\r\n            this.sy = sy;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.delta_x = delta_x;\r\n            this.delta_y = delta_y;\r\n        }\r\n        _to_json() {\r\n            const { delta_x, delta_y /*, direction*/ } = this;\r\n            return Object.assign(Object.assign({}, super._to_json()), { delta_x, delta_y /*, direction*/ });\r\n        }\r\n    };\r\n    exports.Pan = Pan;\r\n    Pan.__name__ = \"Pan\";\r\n    exports.Pan = Pan = __decorate([\r\n        event(\"pan\")\r\n    ], Pan);\r\n    let Pinch = class Pinch extends PointEvent {\r\n        constructor(sx, sy, x, y, scale) {\r\n            super(sx, sy, x, y);\r\n            this.sx = sx;\r\n            this.sy = sy;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.scale = scale;\r\n        }\r\n        _to_json() {\r\n            const { scale } = this;\r\n            return Object.assign(Object.assign({}, super._to_json()), { scale });\r\n        }\r\n    };\r\n    exports.Pinch = Pinch;\r\n    Pinch.__name__ = \"Pinch\";\r\n    exports.Pinch = Pinch = __decorate([\r\n        event(\"pinch\")\r\n    ], Pinch);\r\n    let Rotate = class Rotate extends PointEvent {\r\n        constructor(sx, sy, x, y, rotation) {\r\n            super(sx, sy, x, y);\r\n            this.sx = sx;\r\n            this.sy = sy;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.rotation = rotation;\r\n        }\r\n        _to_json() {\r\n            const { rotation } = this;\r\n            return Object.assign(Object.assign({}, super._to_json()), { rotation });\r\n        }\r\n    };\r\n    exports.Rotate = Rotate;\r\n    Rotate.__name__ = \"Rotate\";\r\n    exports.Rotate = Rotate = __decorate([\r\n        event(\"rotate\")\r\n    ], Rotate);\r\n    let MouseWheel = class MouseWheel extends PointEvent {\r\n        constructor(sx, sy, x, y, delta) {\r\n            super(sx, sy, x, y);\r\n            this.sx = sx;\r\n            this.sy = sy;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.delta = delta;\r\n        }\r\n        _to_json() {\r\n            const { delta } = this;\r\n            return Object.assign(Object.assign({}, super._to_json()), { delta });\r\n        }\r\n    };\r\n    exports.MouseWheel = MouseWheel;\r\n    MouseWheel.__name__ = \"MouseWheel\";\r\n    exports.MouseWheel = MouseWheel = __decorate([\r\n        event(\"wheel\")\r\n    ], MouseWheel);\r\n    let MouseMove = class MouseMove extends PointEvent {\r\n    };\r\n    exports.MouseMove = MouseMove;\r\n    MouseMove.__name__ = \"MouseMove\";\r\n    exports.MouseMove = MouseMove = __decorate([\r\n        event(\"mousemove\")\r\n    ], MouseMove);\r\n    let MouseEnter = class MouseEnter extends PointEvent {\r\n    };\r\n    exports.MouseEnter = MouseEnter;\r\n    MouseEnter.__name__ = \"MouseEnter\";\r\n    exports.MouseEnter = MouseEnter = __decorate([\r\n        event(\"mouseenter\")\r\n    ], MouseEnter);\r\n    let MouseLeave = class MouseLeave extends PointEvent {\r\n    };\r\n    exports.MouseLeave = MouseLeave;\r\n    MouseLeave.__name__ = \"MouseLeave\";\r\n    exports.MouseLeave = MouseLeave = __decorate([\r\n        event(\"mouseleave\")\r\n    ], MouseLeave);\r\n    let Tap = class Tap extends PointEvent {\r\n    };\r\n    exports.Tap = Tap;\r\n    Tap.__name__ = \"Tap\";\r\n    exports.Tap = Tap = __decorate([\r\n        event(\"tap\")\r\n    ], Tap);\r\n    let DoubleTap = class DoubleTap extends PointEvent {\r\n    };\r\n    exports.DoubleTap = DoubleTap;\r\n    DoubleTap.__name__ = \"DoubleTap\";\r\n    exports.DoubleTap = DoubleTap = __decorate([\r\n        event(\"doubletap\")\r\n    ], DoubleTap);\r\n    let Press = class Press extends PointEvent {\r\n    };\r\n    exports.Press = Press;\r\n    Press.__name__ = \"Press\";\r\n    exports.Press = Press = __decorate([\r\n        event(\"press\")\r\n    ], Press);\r\n    let PressUp = class PressUp extends PointEvent {\r\n    };\r\n    exports.PressUp = PressUp;\r\n    PressUp.__name__ = \"PressUp\";\r\n    exports.PressUp = PressUp = __decorate([\r\n        event(\"pressup\")\r\n    ], PressUp);\r\n    let PanStart = class PanStart extends PointEvent {\r\n    };\r\n    exports.PanStart = PanStart;\r\n    PanStart.__name__ = \"PanStart\";\r\n    exports.PanStart = PanStart = __decorate([\r\n        event(\"panstart\")\r\n    ], PanStart);\r\n    let PanEnd = class PanEnd extends PointEvent {\r\n    };\r\n    exports.PanEnd = PanEnd;\r\n    PanEnd.__name__ = \"PanEnd\";\r\n    exports.PanEnd = PanEnd = __decorate([\r\n        event(\"panend\")\r\n    ], PanEnd);\r\n    let PinchStart = class PinchStart extends PointEvent {\r\n    };\r\n    exports.PinchStart = PinchStart;\r\n    PinchStart.__name__ = \"PinchStart\";\r\n    exports.PinchStart = PinchStart = __decorate([\r\n        event(\"pinchstart\")\r\n    ], PinchStart);\r\n    let PinchEnd = class PinchEnd extends PointEvent {\r\n    };\r\n    exports.PinchEnd = PinchEnd;\r\n    PinchEnd.__name__ = \"PinchEnd\";\r\n    exports.PinchEnd = PinchEnd = __decorate([\r\n        event(\"pinchend\")\r\n    ], PinchEnd);\r\n    let RotateStart = class RotateStart extends PointEvent {\r\n    };\r\n    exports.RotateStart = RotateStart;\r\n    RotateStart.__name__ = \"RotateStart\";\r\n    exports.RotateStart = RotateStart = __decorate([\r\n        event(\"rotatestart\")\r\n    ], RotateStart);\r\n    let RotateEnd = class RotateEnd extends PointEvent {\r\n    };\r\n    exports.RotateEnd = RotateEnd;\r\n    RotateEnd.__name__ = \"RotateEnd\";\r\n    exports.RotateEnd = RotateEnd = __decorate([\r\n        event(\"rotateend\")\r\n    ], RotateEnd);\r\n}\r\n","/* core\\ui_events.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const hammerjs_1 = tslib_1.__importDefault(require(297) /* hammerjs */);\r\n    const signaling_1 = require(15) /* ./signaling */;\r\n    const logging_1 = require(19) /* ./logging */;\r\n    const dom_1 = require(72) /* ./dom */;\r\n    const events = tslib_1.__importStar(require(313) /* ./bokeh_events */);\r\n    const wheel_1 = require(315) /* ./util/wheel */;\r\n    const array_1 = require(9) /* ./util/array */;\r\n    const types_1 = require(8) /* ./util/types */;\r\n    const compat_1 = require(32) /* ./util/compat */;\r\n    const menus_1 = require(302) /* ./util/menus */;\r\n    function is_touch(event) {\r\n        return typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent;\r\n    }\r\n    class UIEvents {\r\n        constructor(plot_view, toolbar, hit_area) {\r\n            this.plot_view = plot_view;\r\n            this.toolbar = toolbar;\r\n            this.hit_area = hit_area;\r\n            this.pan_start = new signaling_1.Signal(this, 'pan:start');\r\n            this.pan = new signaling_1.Signal(this, 'pan');\r\n            this.pan_end = new signaling_1.Signal(this, 'pan:end');\r\n            this.pinch_start = new signaling_1.Signal(this, 'pinch:start');\r\n            this.pinch = new signaling_1.Signal(this, 'pinch');\r\n            this.pinch_end = new signaling_1.Signal(this, 'pinch:end');\r\n            this.rotate_start = new signaling_1.Signal(this, 'rotate:start');\r\n            this.rotate = new signaling_1.Signal(this, 'rotate');\r\n            this.rotate_end = new signaling_1.Signal(this, 'rotate:end');\r\n            this.tap = new signaling_1.Signal(this, 'tap');\r\n            this.doubletap = new signaling_1.Signal(this, 'doubletap');\r\n            this.press = new signaling_1.Signal(this, 'press');\r\n            this.pressup = new signaling_1.Signal(this, 'pressup');\r\n            this.move_enter = new signaling_1.Signal(this, 'move:enter');\r\n            this.move = new signaling_1.Signal(this, 'move');\r\n            this.move_exit = new signaling_1.Signal(this, 'move:exit');\r\n            this.scroll = new signaling_1.Signal(this, 'scroll');\r\n            this.keydown = new signaling_1.Signal(this, 'keydown');\r\n            this.keyup = new signaling_1.Signal(this, 'keyup');\r\n            this.hammer = new hammerjs_1.default(this.hit_area, {\r\n                touchAction: 'auto',\r\n                inputClass: hammerjs_1.default.TouchMouseInput,\r\n            });\r\n            this._configure_hammerjs();\r\n            // Mouse & keyboard events not handled through hammerjs\r\n            // We can 'add and forget' these event listeners because this.hit_area is a DOM element\r\n            // that will be thrown away when the view is removed\r\n            this.hit_area.addEventListener(\"mousemove\", (e) => this._mouse_move(e));\r\n            this.hit_area.addEventListener(\"mouseenter\", (e) => this._mouse_enter(e));\r\n            this.hit_area.addEventListener(\"mouseleave\", (e) => this._mouse_exit(e));\r\n            this.hit_area.addEventListener(\"contextmenu\", (e) => this._context_menu(e));\r\n            this.hit_area.addEventListener(\"wheel\", (e) => this._mouse_wheel(e));\r\n            // But we MUST remove listeners registered on document or we'll leak memory: register\r\n            // 'this' as the listener (it implements the event listener interface, i.e. handleEvent)\r\n            // instead of an anonymous function so we can easily refer back to it for removing\r\n            document.addEventListener(\"keydown\", this);\r\n            document.addEventListener(\"keyup\", this);\r\n            this.menu = new menus_1.ContextMenu([], {\r\n                prevent_hide: (event) => event.button == 2 && event.target == this.hit_area,\r\n            });\r\n            this.hit_area.appendChild(this.menu.el);\r\n        }\r\n        destroy() {\r\n            this.menu.remove();\r\n            this.hammer.destroy();\r\n            document.removeEventListener(\"keydown\", this);\r\n            document.removeEventListener(\"keyup\", this);\r\n        }\r\n        handleEvent(e) {\r\n            if (e.type == \"keydown\")\r\n                this._key_down(e);\r\n            else if (e.type == \"keyup\")\r\n                this._key_up(e);\r\n        }\r\n        _configure_hammerjs() {\r\n            // This is to be able to distinguish double taps from single taps\r\n            this.hammer.get('doubletap').recognizeWith('tap');\r\n            this.hammer.get('tap').requireFailure('doubletap');\r\n            this.hammer.get('doubletap').dropRequireFailure('tap');\r\n            this.hammer.on('doubletap', (e) => this._doubletap(e));\r\n            this.hammer.on('tap', (e) => this._tap(e));\r\n            this.hammer.on('press', (e) => this._press(e));\r\n            this.hammer.on('pressup', (e) => this._pressup(e));\r\n            this.hammer.get('pan').set({ direction: hammerjs_1.default.DIRECTION_ALL });\r\n            this.hammer.on('panstart', (e) => this._pan_start(e));\r\n            this.hammer.on('pan', (e) => this._pan(e));\r\n            this.hammer.on('panend', (e) => this._pan_end(e));\r\n            this.hammer.get('pinch').set({ enable: true });\r\n            this.hammer.on('pinchstart', (e) => this._pinch_start(e));\r\n            this.hammer.on('pinch', (e) => this._pinch(e));\r\n            this.hammer.on('pinchend', (e) => this._pinch_end(e));\r\n            this.hammer.get('rotate').set({ enable: true });\r\n            this.hammer.on('rotatestart', (e) => this._rotate_start(e));\r\n            this.hammer.on('rotate', (e) => this._rotate(e));\r\n            this.hammer.on('rotateend', (e) => this._rotate_end(e));\r\n        }\r\n        register_tool(tool_view) {\r\n            const et = tool_view.model.event_type;\r\n            if (et != null) {\r\n                if (types_1.isString(et))\r\n                    this._register_tool(tool_view, et);\r\n                else {\r\n                    // Multi-tools should only registered shared events once\r\n                    et.forEach((e, index) => this._register_tool(tool_view, e, index < 1));\r\n                }\r\n            }\r\n        }\r\n        _register_tool(tool_view, et, shared = true) {\r\n            const v = tool_view;\r\n            const { id } = v.model;\r\n            const conditionally = (fn) => (arg) => {\r\n                if (arg.id == id)\r\n                    fn(arg.e);\r\n            };\r\n            const unconditionally = (fn) => (arg) => {\r\n                fn(arg.e);\r\n            };\r\n            switch (et) {\r\n                case \"pan\": {\r\n                    if (v._pan_start != null)\r\n                        v.connect(this.pan_start, conditionally(v._pan_start.bind(v)));\r\n                    if (v._pan != null)\r\n                        v.connect(this.pan, conditionally(v._pan.bind(v)));\r\n                    if (v._pan_end != null)\r\n                        v.connect(this.pan_end, conditionally(v._pan_end.bind(v)));\r\n                    break;\r\n                }\r\n                case \"pinch\": {\r\n                    if (v._pinch_start != null)\r\n                        v.connect(this.pinch_start, conditionally(v._pinch_start.bind(v)));\r\n                    if (v._pinch != null)\r\n                        v.connect(this.pinch, conditionally(v._pinch.bind(v)));\r\n                    if (v._pinch_end != null)\r\n                        v.connect(this.pinch_end, conditionally(v._pinch_end.bind(v)));\r\n                    break;\r\n                }\r\n                case \"rotate\": {\r\n                    if (v._rotate_start != null)\r\n                        v.connect(this.rotate_start, conditionally(v._rotate_start.bind(v)));\r\n                    if (v._rotate != null)\r\n                        v.connect(this.rotate, conditionally(v._rotate.bind(v)));\r\n                    if (v._rotate_end != null)\r\n                        v.connect(this.rotate_end, conditionally(v._rotate_end.bind(v)));\r\n                    break;\r\n                }\r\n                case \"move\": {\r\n                    if (v._move_enter != null)\r\n                        v.connect(this.move_enter, conditionally(v._move_enter.bind(v)));\r\n                    if (v._move != null)\r\n                        v.connect(this.move, conditionally(v._move.bind(v)));\r\n                    if (v._move_exit != null)\r\n                        v.connect(this.move_exit, conditionally(v._move_exit.bind(v)));\r\n                    break;\r\n                }\r\n                case \"tap\": {\r\n                    if (v._tap != null)\r\n                        v.connect(this.tap, conditionally(v._tap.bind(v)));\r\n                    break;\r\n                }\r\n                case \"press\": {\r\n                    if (v._press != null)\r\n                        v.connect(this.press, conditionally(v._press.bind(v)));\r\n                    if (v._pressup != null)\r\n                        v.connect(this.pressup, conditionally(v._pressup.bind(v)));\r\n                    break;\r\n                }\r\n                case \"scroll\": {\r\n                    if (v._scroll != null)\r\n                        v.connect(this.scroll, conditionally(v._scroll.bind(v)));\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new Error(`unsupported event_type: ${et}`);\r\n            }\r\n            // Skip shared events if registering multi-tool\r\n            if (!shared)\r\n                return;\r\n            if (v._doubletap != null)\r\n                v.connect(this.doubletap, unconditionally(v._doubletap.bind(v)));\r\n            if (v._keydown != null)\r\n                v.connect(this.keydown, unconditionally(v._keydown.bind(v)));\r\n            if (v._keyup != null)\r\n                v.connect(this.keyup, unconditionally(v._keyup.bind(v)));\r\n            // Dual touch hack part 1/2\r\n            // This is a hack for laptops with touch screen who may be pinching or scrolling\r\n            // in order to use the wheel zoom tool. If it's a touch screen the WheelZoomTool event\r\n            // will be linked to pinch. But we also want to trigger in the case of a scroll.\r\n            if (compat_1.is_mobile && v._scroll != null && et == 'pinch') {\r\n                logging_1.logger.debug(\"Registering scroll on touch screen\");\r\n                v.connect(this.scroll, conditionally(v._scroll.bind(v)));\r\n            }\r\n        }\r\n        _hit_test_renderers(sx, sy) {\r\n            const views = this.plot_view.get_renderer_views();\r\n            for (const view of array_1.reversed(views)) {\r\n                const { level } = view.model;\r\n                if ((level == 'annotation' || level == 'overlay') && view.interactive_hit != null) {\r\n                    if (view.interactive_hit(sx, sy))\r\n                        return view;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        _hit_test_frame(sx, sy) {\r\n            return this.plot_view.frame.bbox.contains(sx, sy);\r\n        }\r\n        _hit_test_canvas(sx, sy) {\r\n            return this.plot_view.layout.bbox.contains(sx, sy);\r\n        }\r\n        _trigger(signal, e, srcEvent) {\r\n            const gestures = this.toolbar.gestures;\r\n            const event_type = signal.name;\r\n            const base_type = event_type.split(\":\")[0];\r\n            const view = this._hit_test_renderers(e.sx, e.sy);\r\n            const on_canvas = this._hit_test_canvas(e.sx, e.sy);\r\n            switch (base_type) {\r\n                case \"move\": {\r\n                    const active_gesture = gestures[base_type].active;\r\n                    if (active_gesture != null)\r\n                        this.trigger(signal, e, active_gesture.id);\r\n                    const active_inspectors = this.toolbar.inspectors.filter(t => t.active);\r\n                    let cursor = \"default\";\r\n                    // the event happened on a renderer\r\n                    if (view != null) {\r\n                        cursor = view.cursor(e.sx, e.sy) || cursor;\r\n                        if (!array_1.is_empty(active_inspectors)) {\r\n                            // override event_type to cause inspectors to clear overlays\r\n                            signal = this.move_exit; // XXX\r\n                        }\r\n                        // the event happened on the plot frame but off a renderer\r\n                    }\r\n                    else if (this._hit_test_frame(e.sx, e.sy)) {\r\n                        if (!array_1.is_empty(active_inspectors)) {\r\n                            cursor = \"crosshair\";\r\n                        }\r\n                    }\r\n                    this.plot_view.set_cursor(cursor);\r\n                    this.plot_view.set_toolbar_visibility(on_canvas);\r\n                    active_inspectors.map((inspector) => this.trigger(signal, e, inspector.id));\r\n                    break;\r\n                }\r\n                case \"tap\": {\r\n                    const { target } = srcEvent;\r\n                    if (target != null && target != this.hit_area)\r\n                        return; // don't trigger bokeh events\r\n                    if (view != null && view.on_hit != null)\r\n                        view.on_hit(e.sx, e.sy);\r\n                    const active_gesture = gestures[base_type].active;\r\n                    if (active_gesture != null)\r\n                        this.trigger(signal, e, active_gesture.id);\r\n                    break;\r\n                }\r\n                case \"scroll\": {\r\n                    // Dual touch hack part 2/2\r\n                    // This is a hack for laptops with touch screen who may be pinching or scrolling\r\n                    // in order to use the wheel zoom tool. If it's a touch screen the WheelZoomTool event\r\n                    // will be linked to pinch. But we also want to trigger in the case of a scroll.\r\n                    const base = compat_1.is_mobile ? \"pinch\" : \"scroll\";\r\n                    const active_gesture = gestures[base].active;\r\n                    if (active_gesture != null) {\r\n                        srcEvent.preventDefault();\r\n                        srcEvent.stopPropagation();\r\n                        this.trigger(signal, e, active_gesture.id);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"pan\": {\r\n                    const active_gesture = gestures[base_type].active;\r\n                    if (active_gesture != null) {\r\n                        srcEvent.preventDefault();\r\n                        this.trigger(signal, e, active_gesture.id);\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    const active_gesture = gestures[base_type].active;\r\n                    if (active_gesture != null)\r\n                        this.trigger(signal, e, active_gesture.id);\r\n                }\r\n            }\r\n            this._trigger_bokeh_event(e);\r\n        }\r\n        trigger(signal, e, id = null) {\r\n            signal.emit({ id, e });\r\n        }\r\n        _trigger_bokeh_event(e) {\r\n            const ev = (() => {\r\n                const { sx, sy } = e;\r\n                const x = this.plot_view.frame.x_scale.invert(sx);\r\n                const y = this.plot_view.frame.y_scale.invert(sy);\r\n                switch (e.type) {\r\n                    case \"wheel\":\r\n                        return new events.MouseWheel(sx, sy, x, y, e.delta);\r\n                    case \"mousemove\":\r\n                        return new events.MouseMove(sx, sy, x, y);\r\n                    case \"mouseenter\":\r\n                        return new events.MouseEnter(sx, sy, x, y);\r\n                    case \"mouseleave\":\r\n                        return new events.MouseLeave(sx, sy, x, y);\r\n                    case \"tap\":\r\n                        return new events.Tap(sx, sy, x, y);\r\n                    case \"doubletap\":\r\n                        return new events.DoubleTap(sx, sy, x, y);\r\n                    case \"press\":\r\n                        return new events.Press(sx, sy, x, y);\r\n                    case \"pressup\":\r\n                        return new events.PressUp(sx, sy, x, y);\r\n                    case \"pan\":\r\n                        return new events.Pan(sx, sy, x, y, e.deltaX, e.deltaY);\r\n                    case \"panstart\":\r\n                        return new events.PanStart(sx, sy, x, y);\r\n                    case \"panend\":\r\n                        return new events.PanEnd(sx, sy, x, y);\r\n                    case \"pinch\":\r\n                        return new events.Pinch(sx, sy, x, y, e.scale);\r\n                    case \"pinchstart\":\r\n                        return new events.PinchStart(sx, sy, x, y);\r\n                    case \"pinchend\":\r\n                        return new events.PinchEnd(sx, sy, x, y);\r\n                    case \"rotate\":\r\n                        return new events.Rotate(sx, sy, x, y, e.rotation);\r\n                    case \"rotatestart\":\r\n                        return new events.RotateStart(sx, sy, x, y);\r\n                    case \"rotateend\":\r\n                        return new events.RotateEnd(sx, sy, x, y);\r\n                    default:\r\n                        return undefined;\r\n                }\r\n            })();\r\n            if (ev != null)\r\n                this.plot_view.model.trigger_event(ev);\r\n        }\r\n        _get_sxy(event) {\r\n            const { pageX, pageY } = is_touch(event) ? (event.touches.length != 0 ? event.touches : event.changedTouches)[0] : event;\r\n            const { left, top } = dom_1.offset(this.hit_area);\r\n            return {\r\n                sx: pageX - left,\r\n                sy: pageY - top,\r\n            };\r\n        }\r\n        _pan_event(e) {\r\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { deltaX: e.deltaX, deltaY: e.deltaY, shiftKey: e.srcEvent.shiftKey, ctrlKey: e.srcEvent.ctrlKey });\r\n        }\r\n        _pinch_event(e) {\r\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { scale: e.scale, shiftKey: e.srcEvent.shiftKey, ctrlKey: e.srcEvent.ctrlKey });\r\n        }\r\n        _rotate_event(e) {\r\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { rotation: e.rotation, shiftKey: e.srcEvent.shiftKey, ctrlKey: e.srcEvent.ctrlKey });\r\n        }\r\n        _tap_event(e) {\r\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { shiftKey: e.srcEvent.shiftKey, ctrlKey: e.srcEvent.ctrlKey });\r\n        }\r\n        _move_event(e) {\r\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e)), { shiftKey: e.shiftKey, ctrlKey: e.ctrlKey });\r\n        }\r\n        _scroll_event(e) {\r\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e)), { delta: wheel_1.getDeltaY(e), shiftKey: e.shiftKey, ctrlKey: e.ctrlKey });\r\n        }\r\n        _key_event(e) {\r\n            return {\r\n                type: e.type,\r\n                keyCode: e.keyCode,\r\n            };\r\n        }\r\n        _pan_start(e) {\r\n            const ev = this._pan_event(e);\r\n            // back out delta to get original center point\r\n            ev.sx -= e.deltaX;\r\n            ev.sy -= e.deltaY;\r\n            this._trigger(this.pan_start, ev, e.srcEvent);\r\n        }\r\n        _pan(e) {\r\n            this._trigger(this.pan, this._pan_event(e), e.srcEvent);\r\n        }\r\n        _pan_end(e) {\r\n            this._trigger(this.pan_end, this._pan_event(e), e.srcEvent);\r\n        }\r\n        _pinch_start(e) {\r\n            this._trigger(this.pinch_start, this._pinch_event(e), e.srcEvent);\r\n        }\r\n        _pinch(e) {\r\n            this._trigger(this.pinch, this._pinch_event(e), e.srcEvent);\r\n        }\r\n        _pinch_end(e) {\r\n            this._trigger(this.pinch_end, this._pinch_event(e), e.srcEvent);\r\n        }\r\n        _rotate_start(e) {\r\n            this._trigger(this.rotate_start, this._rotate_event(e), e.srcEvent);\r\n        }\r\n        _rotate(e) {\r\n            this._trigger(this.rotate, this._rotate_event(e), e.srcEvent);\r\n        }\r\n        _rotate_end(e) {\r\n            this._trigger(this.rotate_end, this._rotate_event(e), e.srcEvent);\r\n        }\r\n        _tap(e) {\r\n            this._trigger(this.tap, this._tap_event(e), e.srcEvent);\r\n        }\r\n        _doubletap(e) {\r\n            // NOTE: doubletap event triggered unconditionally\r\n            const ev = this._tap_event(e);\r\n            this._trigger_bokeh_event(ev);\r\n            this.trigger(this.doubletap, ev);\r\n        }\r\n        _press(e) {\r\n            this._trigger(this.press, this._tap_event(e), e.srcEvent);\r\n        }\r\n        _pressup(e) {\r\n            this._trigger(this.pressup, this._tap_event(e), e.srcEvent);\r\n        }\r\n        _mouse_enter(e) {\r\n            this._trigger(this.move_enter, this._move_event(e), e);\r\n        }\r\n        _mouse_move(e) {\r\n            this._trigger(this.move, this._move_event(e), e);\r\n        }\r\n        _mouse_exit(e) {\r\n            this._trigger(this.move_exit, this._move_event(e), e);\r\n        }\r\n        _mouse_wheel(e) {\r\n            this._trigger(this.scroll, this._scroll_event(e), e);\r\n        }\r\n        _context_menu(e) {\r\n            if (!this.menu.is_open && this.menu.can_open) {\r\n                e.preventDefault();\r\n            }\r\n            const { sx, sy } = this._get_sxy(e);\r\n            this.menu.toggle({ left: sx, top: sy });\r\n        }\r\n        _key_down(e) {\r\n            // NOTE: keyup event triggered unconditionally\r\n            this.trigger(this.keydown, this._key_event(e));\r\n        }\r\n        _key_up(e) {\r\n            // NOTE: keyup event triggered unconditionally\r\n            this.trigger(this.keyup, this._key_event(e));\r\n        }\r\n    }\r\n    exports.UIEvents = UIEvents;\r\n    UIEvents.__name__ = \"UIEvents\";\r\n}\r\n","/* core\\util\\wheel.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    /*!\r\n     * jQuery Mousewheel 3.1.13\r\n     *\r\n     * Copyright jQuery Foundation and other contributors\r\n     * Released under the MIT license\r\n     * http://jquery.org/license\r\n     */\r\n    function fontSize(element) {\r\n        const value = getComputedStyle(element).fontSize;\r\n        if (value != null)\r\n            return parseInt(value, 10);\r\n        return null;\r\n    }\r\n    function lineHeight(element) {\r\n        const parent = element.offsetParent || document.body;\r\n        return fontSize(parent) || fontSize(element) || 16;\r\n    }\r\n    function pageHeight(element) {\r\n        return element.clientHeight; // XXX: should be content height?\r\n    }\r\n    function getDeltaY(event) {\r\n        let deltaY = -event.deltaY;\r\n        if (event.target instanceof HTMLElement) {\r\n            switch (event.deltaMode) {\r\n                case event.DOM_DELTA_LINE:\r\n                    deltaY *= lineHeight(event.target);\r\n                    break;\r\n                case event.DOM_DELTA_PAGE:\r\n                    deltaY *= pageHeight(event.target);\r\n                    break;\r\n            }\r\n        }\r\n        return deltaY;\r\n    }\r\n    exports.getDeltaY = getDeltaY;\r\n}\r\n","/* core\\util\\throttle.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    function _delay_animation(callback) {\r\n        callback(Date.now()); // XXX: performance.now()\r\n        return -1;\r\n    }\r\n    const delay_animation = (typeof window !== 'undefined' ? window.requestAnimationFrame : undefined) ||\r\n        (typeof window !== 'undefined' ? window.webkitRequestAnimationFrame : undefined) ||\r\n        (typeof window !== 'undefined' ? window.mozRequestAnimationFrame : undefined) ||\r\n        (typeof window !== 'undefined' ? window.msRequestAnimationFrame : undefined) || _delay_animation;\r\n    // Returns a function, that, when invoked, will only be triggered at\r\n    // most once during a given window of time.\r\n    //\r\n    // In addition, if the browser supports requestAnimationFrame, the\r\n    // throttled function will be run no more frequently than request\r\n    // animation frame allows.\r\n    //\r\n    // @param func [function] the function to throttle\r\n    // @param wait [number] time in milliseconds to use for window\r\n    // @return [function] throttled function\r\n    //\r\n    function throttle(func, wait) {\r\n        let timeout = null;\r\n        let previous = 0;\r\n        let pending = false;\r\n        return function () {\r\n            return new Promise((resolve, reject) => {\r\n                const later = function () {\r\n                    previous = Date.now();\r\n                    timeout = null;\r\n                    pending = false;\r\n                    try {\r\n                        func();\r\n                        resolve();\r\n                    }\r\n                    catch (error) {\r\n                        reject(error);\r\n                    }\r\n                };\r\n                const now = Date.now();\r\n                const remaining = wait - (now - previous);\r\n                if (remaining <= 0 && !pending) {\r\n                    if (timeout != null) {\r\n                        clearTimeout(timeout);\r\n                    }\r\n                    pending = true;\r\n                    delay_animation(later);\r\n                }\r\n                else if (!timeout && !pending) {\r\n                    timeout = setTimeout(() => delay_animation(later), remaining);\r\n                }\r\n                else {\r\n                    resolve();\r\n                }\r\n            });\r\n        };\r\n    }\r\n    exports.throttle = throttle;\r\n}\r\n","/* core\\layout\\border.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(213) /* ./types */;\r\n    const layoutable_1 = require(214) /* ./layoutable */;\r\n    const bbox_1 = require(79) /* ../util/bbox */;\r\n    class BorderLayout extends layoutable_1.Layoutable {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.min_border = { left: 0, top: 0, right: 0, bottom: 0 };\r\n        }\r\n        _measure(viewport) {\r\n            viewport = new types_1.Sizeable(viewport).bounded_to(this.sizing.size);\r\n            const left_hint = this.left_panel.measure({ width: 0, height: viewport.height });\r\n            const left = Math.max(left_hint.width, this.min_border.left);\r\n            const right_hint = this.right_panel.measure({ width: 0, height: viewport.height });\r\n            const right = Math.max(right_hint.width, this.min_border.right);\r\n            const top_hint = this.top_panel.measure({ width: viewport.width, height: 0 });\r\n            const top = Math.max(top_hint.height, this.min_border.top);\r\n            const bottom_hint = this.bottom_panel.measure({ width: viewport.width, height: 0 });\r\n            const bottom = Math.max(bottom_hint.height, this.min_border.bottom);\r\n            const center_viewport = new types_1.Sizeable(viewport).shrink_by({ left, right, top, bottom });\r\n            const center = this.center_panel.measure(center_viewport);\r\n            const width = left + center.width + right;\r\n            const height = top + center.height + bottom;\r\n            const align = (() => {\r\n                const { width_policy, height_policy } = this.center_panel.sizing;\r\n                return width_policy != \"fixed\" && height_policy != \"fixed\";\r\n            })();\r\n            return { width, height, inner: { left, right, top, bottom }, align };\r\n        }\r\n        _set_geometry(outer, inner) {\r\n            super._set_geometry(outer, inner);\r\n            this.center_panel.set_geometry(inner);\r\n            const left_hint = this.left_panel.measure({ width: 0, height: outer.height });\r\n            const right_hint = this.right_panel.measure({ width: 0, height: outer.height });\r\n            const top_hint = this.top_panel.measure({ width: outer.width, height: 0 });\r\n            const bottom_hint = this.bottom_panel.measure({ width: outer.width, height: 0 });\r\n            const { left, top, right, bottom } = inner;\r\n            this.top_panel.set_geometry(new bbox_1.BBox({ left, right, bottom: top, height: top_hint.height }));\r\n            this.bottom_panel.set_geometry(new bbox_1.BBox({ left, right, top: bottom, height: bottom_hint.height }));\r\n            this.left_panel.set_geometry(new bbox_1.BBox({ top, bottom, right: left, width: left_hint.width }));\r\n            this.right_panel.set_geometry(new bbox_1.BBox({ top, bottom, left: right, width: right_hint.width }));\r\n        }\r\n    }\r\n    exports.BorderLayout = BorderLayout;\r\n    BorderLayout.__name__ = \"BorderLayout\";\r\n}\r\n","/* core\\layout\\side_panel.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const types_1 = require(213) /* ./types */;\r\n    const layoutable_1 = require(214) /* ./layoutable */;\r\n    const types_2 = require(8) /* ../util/types */;\r\n    // This table lays out the rules for configuring the baseline, alignment, etc. of\r\n    // title text, based on it's location and orientation\r\n    //\r\n    // side    orient        baseline   align     angle   normal-dist\r\n    // ------------------------------------------------------------------------------\r\n    // above   parallel      bottom     center    0       height\r\n    //         normal        middle     left      -90     width\r\n    //         horizontal    bottom     center    0       height\r\n    //         [angle > 0]   middle     left              width * sin + height * cos\r\n    //         [angle < 0]   middle     right             width * sin + height * cos\r\n    //\r\n    // below   parallel      top        center    0       height\r\n    //         normal        middle     right     90      width\r\n    //         horizontal    top        center    0       height\r\n    //         [angle > 0]   middle     right             width * sin + height * cos\r\n    //         [angle < 0]   middle     left              width * sin + height * cos\r\n    //\r\n    // left    parallel      bottom     center    90      height\r\n    //         normal        middle     right     0       width\r\n    //         horizontal    middle     right     0       width\r\n    //         [angle > 0]   middle     right             width * cos + height * sin\r\n    //         [angle < 0]   middle     right             width * cos + height + sin\r\n    //\r\n    // right   parallel      bottom     center   -90      height\r\n    //         normal        middle     left     0        width\r\n    //         horizontal    middle     left     0        width\r\n    //         [angle > 0]   middle     left              width * cos + height * sin\r\n    //         [angle < 0]   middle     left              width * cos + height + sin\r\n    const pi2 = Math.PI / 2;\r\n    const ALPHABETIC = 'alphabetic';\r\n    const TOP = 'top';\r\n    const BOTTOM = 'bottom';\r\n    const MIDDLE = 'middle';\r\n    const HANGING = 'hanging';\r\n    const LEFT = 'left';\r\n    const RIGHT = 'right';\r\n    const CENTER = 'center';\r\n    const _angle_lookup = {\r\n        above: {\r\n            parallel: 0,\r\n            normal: -pi2,\r\n            horizontal: 0,\r\n            vertical: -pi2,\r\n        },\r\n        below: {\r\n            parallel: 0,\r\n            normal: pi2,\r\n            horizontal: 0,\r\n            vertical: pi2,\r\n        },\r\n        left: {\r\n            parallel: -pi2,\r\n            normal: 0,\r\n            horizontal: 0,\r\n            vertical: -pi2,\r\n        },\r\n        right: {\r\n            parallel: pi2,\r\n            normal: 0,\r\n            horizontal: 0,\r\n            vertical: pi2,\r\n        },\r\n    };\r\n    const _baseline_lookup = {\r\n        above: {\r\n            justified: TOP,\r\n            parallel: ALPHABETIC,\r\n            normal: MIDDLE,\r\n            horizontal: ALPHABETIC,\r\n            vertical: MIDDLE,\r\n        },\r\n        below: {\r\n            justified: BOTTOM,\r\n            parallel: HANGING,\r\n            normal: MIDDLE,\r\n            horizontal: HANGING,\r\n            vertical: MIDDLE,\r\n        },\r\n        left: {\r\n            justified: TOP,\r\n            parallel: ALPHABETIC,\r\n            normal: MIDDLE,\r\n            horizontal: MIDDLE,\r\n            vertical: ALPHABETIC,\r\n        },\r\n        right: {\r\n            justified: TOP,\r\n            parallel: ALPHABETIC,\r\n            normal: MIDDLE,\r\n            horizontal: MIDDLE,\r\n            vertical: ALPHABETIC,\r\n        },\r\n    };\r\n    const _align_lookup = {\r\n        above: {\r\n            justified: CENTER,\r\n            parallel: CENTER,\r\n            normal: LEFT,\r\n            horizontal: CENTER,\r\n            vertical: LEFT,\r\n        },\r\n        below: {\r\n            justified: CENTER,\r\n            parallel: CENTER,\r\n            normal: LEFT,\r\n            horizontal: CENTER,\r\n            vertical: LEFT,\r\n        },\r\n        left: {\r\n            justified: CENTER,\r\n            parallel: CENTER,\r\n            normal: RIGHT,\r\n            horizontal: RIGHT,\r\n            vertical: CENTER,\r\n        },\r\n        right: {\r\n            justified: CENTER,\r\n            parallel: CENTER,\r\n            normal: LEFT,\r\n            horizontal: LEFT,\r\n            vertical: CENTER,\r\n        },\r\n    };\r\n    const _align_lookup_negative = {\r\n        above: RIGHT,\r\n        below: LEFT,\r\n        left: RIGHT,\r\n        right: LEFT,\r\n    };\r\n    const _align_lookup_positive = {\r\n        above: LEFT,\r\n        below: RIGHT,\r\n        left: RIGHT,\r\n        right: LEFT,\r\n    };\r\n    class SidePanel extends layoutable_1.ContentLayoutable {\r\n        constructor(side, obj) {\r\n            super();\r\n            this.side = side;\r\n            this.obj = obj;\r\n            switch (this.side) {\r\n                case \"above\":\r\n                    this._dim = 0;\r\n                    this._normals = [0, -1];\r\n                    break;\r\n                case \"below\":\r\n                    this._dim = 0;\r\n                    this._normals = [0, 1];\r\n                    break;\r\n                case \"left\":\r\n                    this._dim = 1;\r\n                    this._normals = [-1, 0];\r\n                    break;\r\n                case \"right\":\r\n                    this._dim = 1;\r\n                    this._normals = [1, 0];\r\n                    break;\r\n            }\r\n            if (this.is_horizontal)\r\n                this.set_sizing({ width_policy: \"max\", height_policy: \"fixed\" });\r\n            else\r\n                this.set_sizing({ width_policy: \"fixed\", height_policy: \"max\" });\r\n        }\r\n        _content_size() {\r\n            return new types_1.Sizeable(this.get_oriented_size());\r\n        }\r\n        get_oriented_size() {\r\n            const { width, height } = this.obj.get_size();\r\n            if (!this.obj.rotate || this.is_horizontal)\r\n                return { width, height };\r\n            else\r\n                return { width: height, height: width };\r\n        }\r\n        has_size_changed() {\r\n            const { width, height } = this.get_oriented_size();\r\n            if (this.is_horizontal)\r\n                return this.bbox.height != height;\r\n            else\r\n                return this.bbox.width != width;\r\n        }\r\n        get dimension() {\r\n            return this._dim;\r\n        }\r\n        get normals() {\r\n            return this._normals;\r\n        }\r\n        get is_horizontal() {\r\n            return this._dim == 0;\r\n        }\r\n        get is_vertical() {\r\n            return this._dim == 1;\r\n        }\r\n        apply_label_text_heuristics(ctx, orient) {\r\n            const side = this.side;\r\n            let baseline;\r\n            let align;\r\n            if (types_2.isString(orient)) {\r\n                baseline = _baseline_lookup[side][orient];\r\n                align = _align_lookup[side][orient];\r\n            }\r\n            else {\r\n                if (orient < 0) {\r\n                    baseline = 'middle';\r\n                    align = _align_lookup_negative[side];\r\n                }\r\n                else {\r\n                    baseline = 'middle';\r\n                    align = _align_lookup_positive[side];\r\n                }\r\n            }\r\n            ctx.textBaseline = baseline;\r\n            ctx.textAlign = align;\r\n        }\r\n        get_label_angle_heuristic(orient) {\r\n            return _angle_lookup[this.side][orient];\r\n        }\r\n    }\r\n    exports.SidePanel = SidePanel;\r\n    SidePanel.__name__ = \"SidePanel\";\r\n}\r\n","/* models\\plots\\gmap_plot_canvas.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    const plot_canvas_1 = require(312) /* ./plot_canvas */;\r\n    const gmaps_ready = new signaling_1.Signal0({}, \"gmaps_ready\");\r\n    const load_google_api = function (api_key) {\r\n        window._bokeh_gmaps_callback = () => gmaps_ready.emit();\r\n        const script = document.createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.src = `https://maps.googleapis.com/maps/api/js?v=3.36&key=${api_key}&callback=_bokeh_gmaps_callback`;\r\n        document.body.appendChild(script);\r\n    };\r\n    class GMapPlotView extends plot_canvas_1.PlotView {\r\n        initialize() {\r\n            this.pause();\r\n            super.initialize();\r\n            this._tiles_loaded = false;\r\n            this.zoom_count = 0;\r\n            const { zoom, lat, lng } = this.model.map_options;\r\n            this.initial_zoom = zoom;\r\n            this.initial_lat = lat;\r\n            this.initial_lng = lng;\r\n            if (typeof google === \"undefined\" || google.maps == null) {\r\n                if (typeof window._bokeh_gmaps_callback === \"undefined\") {\r\n                    const decoded_api_key = atob(this.model.api_key);\r\n                    load_google_api(decoded_api_key);\r\n                }\r\n                gmaps_ready.connect(() => this.request_render());\r\n            }\r\n            this.unpause();\r\n        }\r\n        remove() {\r\n            dom_1.remove(this.map_el);\r\n            super.remove();\r\n        }\r\n        update_range(range_info) {\r\n            // RESET -------------------------\r\n            if (range_info == null) {\r\n                this.map.setCenter({ lat: this.initial_lat, lng: this.initial_lng });\r\n                this.map.setOptions({ zoom: this.initial_zoom });\r\n                super.update_range(null);\r\n                // PAN ----------------------------\r\n            }\r\n            else if (range_info.sdx != null || range_info.sdy != null) {\r\n                this.map.panBy(range_info.sdx || 0, range_info.sdy || 0);\r\n                super.update_range(range_info);\r\n                // ZOOM ---------------------------\r\n            }\r\n            else if (range_info.factor != null) {\r\n                // The zoom count decreases the sensitivity of the zoom. (We could make this user configurable)\r\n                if (this.zoom_count !== 10) {\r\n                    this.zoom_count += 1;\r\n                    return;\r\n                }\r\n                this.zoom_count = 0;\r\n                this.pause();\r\n                super.update_range(range_info);\r\n                const zoom_change = range_info.factor < 0 ? -1 : 1;\r\n                const old_map_zoom = this.map.getZoom();\r\n                const new_map_zoom = old_map_zoom + zoom_change;\r\n                // Zooming out too far causes problems\r\n                if (new_map_zoom >= 2) {\r\n                    this.map.setZoom(new_map_zoom);\r\n                    // Check we haven't gone out of bounds, and if we have undo the zoom\r\n                    const [proj_xstart, proj_xend, ,] = this._get_projected_bounds();\r\n                    if (proj_xend - proj_xstart < 0) {\r\n                        this.map.setZoom(old_map_zoom);\r\n                    }\r\n                }\r\n                this.unpause();\r\n            }\r\n            // Finally re-center\r\n            this._set_bokeh_ranges();\r\n        }\r\n        _build_map() {\r\n            const { maps } = google;\r\n            this.map_types = {\r\n                satellite: maps.MapTypeId.SATELLITE,\r\n                terrain: maps.MapTypeId.TERRAIN,\r\n                roadmap: maps.MapTypeId.ROADMAP,\r\n                hybrid: maps.MapTypeId.HYBRID,\r\n            };\r\n            const mo = this.model.map_options;\r\n            const map_options = {\r\n                center: new maps.LatLng(mo.lat, mo.lng),\r\n                zoom: mo.zoom,\r\n                disableDefaultUI: true,\r\n                mapTypeId: this.map_types[mo.map_type],\r\n                scaleControl: mo.scale_control,\r\n                tilt: mo.tilt,\r\n            };\r\n            if (mo.styles != null)\r\n                map_options.styles = JSON.parse(mo.styles);\r\n            // create the map with above options in div\r\n            this.map_el = dom_1.div({ style: { position: \"absolute\" } });\r\n            this.canvas_view.add_underlay(this.map_el);\r\n            this.map = new maps.Map(this.map_el, map_options);\r\n            // update bokeh ranges whenever the map idles, which should be after most UI action\r\n            maps.event.addListener(this.map, 'idle', () => this._set_bokeh_ranges());\r\n            // also need an event when bounds change so that map resizes trigger renders too\r\n            maps.event.addListener(this.map, 'bounds_changed', () => this._set_bokeh_ranges());\r\n            maps.event.addListenerOnce(this.map, 'tilesloaded', () => this._render_finished());\r\n            // wire up listeners so that changes to properties are reflected\r\n            this.connect(this.model.properties.map_options.change, () => this._update_options());\r\n            this.connect(this.model.map_options.properties.styles.change, () => this._update_styles());\r\n            this.connect(this.model.map_options.properties.lat.change, () => this._update_center('lat'));\r\n            this.connect(this.model.map_options.properties.lng.change, () => this._update_center('lng'));\r\n            this.connect(this.model.map_options.properties.zoom.change, () => this._update_zoom());\r\n            this.connect(this.model.map_options.properties.map_type.change, () => this._update_map_type());\r\n            this.connect(this.model.map_options.properties.scale_control.change, () => this._update_scale_control());\r\n            this.connect(this.model.map_options.properties.tilt.change, () => this._update_tilt());\r\n        }\r\n        _render_finished() {\r\n            this._tiles_loaded = true;\r\n            this.notify_finished();\r\n        }\r\n        has_finished() {\r\n            return super.has_finished() && this._tiles_loaded === true;\r\n        }\r\n        _get_latlon_bounds() {\r\n            const bounds = this.map.getBounds();\r\n            const top_right = bounds.getNorthEast();\r\n            const bottom_left = bounds.getSouthWest();\r\n            const xstart = bottom_left.lng();\r\n            const xend = top_right.lng();\r\n            const ystart = bottom_left.lat();\r\n            const yend = top_right.lat();\r\n            return [xstart, xend, ystart, yend];\r\n        }\r\n        _get_projected_bounds() {\r\n            const [xstart, xend, ystart, yend] = this._get_latlon_bounds();\r\n            const [proj_xstart, proj_ystart] = projections_1.wgs84_mercator.compute(xstart, ystart);\r\n            const [proj_xend, proj_yend] = projections_1.wgs84_mercator.compute(xend, yend);\r\n            return [proj_xstart, proj_xend, proj_ystart, proj_yend];\r\n        }\r\n        _set_bokeh_ranges() {\r\n            const [proj_xstart, proj_xend, proj_ystart, proj_yend] = this._get_projected_bounds();\r\n            this.frame.x_range.setv({ start: proj_xstart, end: proj_xend });\r\n            this.frame.y_range.setv({ start: proj_ystart, end: proj_yend });\r\n        }\r\n        _update_center(fld) {\r\n            const c = this.map.getCenter().toJSON();\r\n            c[fld] = this.model.map_options[fld];\r\n            this.map.setCenter(c);\r\n            this._set_bokeh_ranges();\r\n        }\r\n        _update_map_type() {\r\n            this.map.setOptions({ mapTypeId: this.map_types[this.model.map_options.map_type] });\r\n        }\r\n        _update_scale_control() {\r\n            this.map.setOptions({ scaleControl: this.model.map_options.scale_control });\r\n        }\r\n        _update_tilt() {\r\n            this.map.setOptions({ tilt: this.model.map_options.tilt });\r\n        }\r\n        _update_options() {\r\n            this._update_styles();\r\n            this._update_center('lat');\r\n            this._update_center('lng');\r\n            this._update_zoom();\r\n            this._update_map_type();\r\n        }\r\n        _update_styles() {\r\n            this.map.setOptions({ styles: JSON.parse(this.model.map_options.styles) });\r\n        }\r\n        _update_zoom() {\r\n            this.map.setOptions({ zoom: this.model.map_options.zoom });\r\n            this._set_bokeh_ranges();\r\n        }\r\n        // this method is expected and called by PlotView.render\r\n        _map_hook(_ctx, frame_box) {\r\n            if (this.map == null && typeof google !== \"undefined\" && google.maps != null)\r\n                this._build_map();\r\n            if (this.map_el != null) {\r\n                const [left, top, width, height] = frame_box;\r\n                this.map_el.style.top = `${top}px`;\r\n                this.map_el.style.left = `${left}px`;\r\n                this.map_el.style.width = `${width}px`;\r\n                this.map_el.style.height = `${height}px`;\r\n            }\r\n        }\r\n        // this overrides the standard _paint_empty to make the inner canvas transparent\r\n        _paint_empty(ctx, frame_box) {\r\n            const ow = this.layout.bbox.width;\r\n            const oh = this.layout.bbox.height;\r\n            const [left, top, iw, ih] = frame_box;\r\n            ctx.clearRect(0, 0, ow, oh);\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, 0);\r\n            ctx.lineTo(0, oh);\r\n            ctx.lineTo(ow, oh);\r\n            ctx.lineTo(ow, 0);\r\n            ctx.lineTo(0, 0);\r\n            ctx.moveTo(left, top);\r\n            ctx.lineTo(left + iw, top);\r\n            ctx.lineTo(left + iw, top + ih);\r\n            ctx.lineTo(left, top + ih);\r\n            ctx.lineTo(left, top);\r\n            ctx.closePath();\r\n            if (this.model.border_fill_color != null) {\r\n                ctx.fillStyle = this.model.border_fill_color;\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n    exports.GMapPlotView = GMapPlotView;\r\n    GMapPlotView.__name__ = \"GMapPlotView\";\r\n}\r\n","/* models\\ranges\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var data_range_1 = require(211) /* ./data_range */;\r\n    exports.DataRange = data_range_1.DataRange;\r\n    var data_range1d_1 = require(210) /* ./data_range1d */;\r\n    exports.DataRange1d = data_range1d_1.DataRange1d;\r\n    var factor_range_1 = require(98) /* ./factor_range */;\r\n    exports.FactorRange = factor_range_1.FactorRange;\r\n    var range_1 = require(99) /* ./range */;\r\n    exports.Range = range_1.Range;\r\n    var range1d_1 = require(158) /* ./range1d */;\r\n    exports.Range1d = range1d_1.Range1d;\r\n}\r\n","/* models\\renderers\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var glyph_renderer_1 = require(90) /* ./glyph_renderer */;\r\n    exports.GlyphRenderer = glyph_renderer_1.GlyphRenderer;\r\n    var graph_renderer_1 = require(116) /* ./graph_renderer */;\r\n    exports.GraphRenderer = graph_renderer_1.GraphRenderer;\r\n    var guide_renderer_1 = require(178) /* ./guide_renderer */;\r\n    exports.GuideRenderer = guide_renderer_1.GuideRenderer;\r\n    var renderer_1 = require(70) /* ./renderer */;\r\n    exports.Renderer = renderer_1.Renderer;\r\n}\r\n","/* models\\scales\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var categorical_scale_1 = require(209) /* ./categorical_scale */;\r\n    exports.CategoricalScale = categorical_scale_1.CategoricalScale;\r\n    var continuous_scale_1 = require(146) /* ./continuous_scale */;\r\n    exports.ContinuousScale = continuous_scale_1.ContinuousScale;\r\n    var linear_scale_1 = require(145) /* ./linear_scale */;\r\n    exports.LinearScale = linear_scale_1.LinearScale;\r\n    var linear_interpolation_scale_1 = require(156) /* ./linear_interpolation_scale */;\r\n    exports.LinearInterpolationScale = linear_interpolation_scale_1.LinearInterpolationScale;\r\n    var log_scale_1 = require(157) /* ./log_scale */;\r\n    exports.LogScale = log_scale_1.LogScale;\r\n    var scale_1 = require(147) /* ./scale */;\r\n    exports.Scale = scale_1.Scale;\r\n}\r\n","/* models\\selections\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    tslib_1.__exportStar(require(118) /* ./interaction_policy */, exports);\r\n    var selection_1 = require(88) /* ./selection */;\r\n    exports.Selection = selection_1.Selection;\r\n}\r\n","/* models\\sources\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var server_sent_data_source_1 = require(325) /* ./server_sent_data_source */;\r\n    exports.ServerSentDataSource = server_sent_data_source_1.ServerSentDataSource;\r\n    var ajax_data_source_1 = require(327) /* ./ajax_data_source */;\r\n    exports.AjaxDataSource = ajax_data_source_1.AjaxDataSource;\r\n    var column_data_source_1 = require(85) /* ./column_data_source */;\r\n    exports.ColumnDataSource = column_data_source_1.ColumnDataSource;\r\n    var columnar_data_source_1 = require(86) /* ./columnar_data_source */;\r\n    exports.ColumnarDataSource = columnar_data_source_1.ColumnarDataSource;\r\n    var cds_view_1 = require(114) /* ./cds_view */;\r\n    exports.CDSView = cds_view_1.CDSView;\r\n    var data_source_1 = require(87) /* ./data_source */;\r\n    exports.DataSource = data_source_1.DataSource;\r\n    var geojson_data_source_1 = require(328) /* ./geojson_data_source */;\r\n    exports.GeoJSONDataSource = geojson_data_source_1.GeoJSONDataSource;\r\n    var web_data_source_1 = require(326) /* ./web_data_source */;\r\n    exports.WebDataSource = web_data_source_1.WebDataSource;\r\n}\r\n","/* models\\sources\\server_sent_data_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const web_data_source_1 = require(326) /* ./web_data_source */;\r\n    class ServerSentDataSource extends web_data_source_1.WebDataSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.initialized = false;\r\n        }\r\n        destroy() {\r\n            super.destroy();\r\n        }\r\n        setup() {\r\n            if (!this.initialized) {\r\n                this.initialized = true;\r\n                const source = new EventSource(this.data_url);\r\n                source.onmessage = (event) => {\r\n                    this.load_data(JSON.parse(event.data), this.mode, this.max_size);\r\n                };\r\n            }\r\n        }\r\n    }\r\n    exports.ServerSentDataSource = ServerSentDataSource;\r\n    ServerSentDataSource.__name__ = \"ServerSentDataSource\";\r\n}\r\n","/* models\\sources\\web_data_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const column_data_source_1 = require(85) /* ./column_data_source */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class WebDataSource extends column_data_source_1.ColumnDataSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        get_column(colname) {\r\n            const column = this.data[colname];\r\n            return column != null ? column : [];\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.setup();\r\n        }\r\n        load_data(raw_data, mode, max_size) {\r\n            const { adapter } = this;\r\n            let data;\r\n            if (adapter != null)\r\n                data = adapter.execute(this, { response: raw_data });\r\n            else\r\n                data = raw_data;\r\n            switch (mode) {\r\n                case \"replace\": {\r\n                    this.data = data;\r\n                    break;\r\n                }\r\n                case \"append\": {\r\n                    const original_data = this.data;\r\n                    for (const column of this.columns()) {\r\n                        // XXX: support typed arrays\r\n                        const old_col = Array.from(original_data[column]);\r\n                        const new_col = Array.from(data[column]);\r\n                        data[column] = old_col.concat(new_col).slice(-max_size);\r\n                    }\r\n                    this.data = data;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        static init_WebDataSource() {\r\n            this.define({\r\n                mode: [p.UpdateMode, 'replace'],\r\n                max_size: [p.Number],\r\n                adapter: [p.Any, null],\r\n                data_url: [p.String],\r\n            });\r\n        }\r\n    }\r\n    exports.WebDataSource = WebDataSource;\r\n    WebDataSource.__name__ = \"WebDataSource\";\r\n    WebDataSource.init_WebDataSource();\r\n}\r\n","/* models\\sources\\ajax_data_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const web_data_source_1 = require(326) /* ./web_data_source */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    class AjaxDataSource extends web_data_source_1.WebDataSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.initialized = false;\r\n        }\r\n        static init_AjaxDataSource() {\r\n            this.define({\r\n                polling_interval: [p.Number],\r\n                content_type: [p.String, 'application/json'],\r\n                http_headers: [p.Any, {}],\r\n                method: [p.HTTPMethod, 'POST'],\r\n                if_modified: [p.Boolean, false],\r\n            });\r\n        }\r\n        destroy() {\r\n            if (this.interval != null)\r\n                clearInterval(this.interval);\r\n            super.destroy();\r\n        }\r\n        setup() {\r\n            if (!this.initialized) {\r\n                this.initialized = true;\r\n                this.get_data(this.mode);\r\n                if (this.polling_interval) {\r\n                    const callback = () => this.get_data(this.mode, this.max_size, this.if_modified);\r\n                    this.interval = setInterval(callback, this.polling_interval);\r\n                }\r\n            }\r\n        }\r\n        get_data(mode, max_size = 0, _if_modified = false) {\r\n            const xhr = this.prepare_request();\r\n            // TODO: if_modified\r\n            xhr.addEventListener(\"load\", () => this.do_load(xhr, mode, max_size));\r\n            xhr.addEventListener(\"error\", () => this.do_error(xhr));\r\n            xhr.send();\r\n        }\r\n        prepare_request() {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(this.method, this.data_url, true);\r\n            xhr.withCredentials = false;\r\n            xhr.setRequestHeader(\"Content-Type\", this.content_type);\r\n            const http_headers = this.http_headers;\r\n            for (const [name, value] of object_1.entries(http_headers)) {\r\n                xhr.setRequestHeader(name, value);\r\n            }\r\n            return xhr;\r\n        }\r\n        do_load(xhr, mode, max_size) {\r\n            if (xhr.status === 200) {\r\n                const raw_data = JSON.parse(xhr.responseText);\r\n                this.load_data(raw_data, mode, max_size);\r\n            }\r\n        }\r\n        do_error(xhr) {\r\n            logging_1.logger.error(`Failed to fetch JSON from ${this.data_url} with code ${xhr.status}`);\r\n        }\r\n    }\r\n    exports.AjaxDataSource = AjaxDataSource;\r\n    AjaxDataSource.__name__ = \"AjaxDataSource\";\r\n    AjaxDataSource.init_AjaxDataSource();\r\n}\r\n","/* models\\sources\\geojson_data_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const columnar_data_source_1 = require(86) /* ./columnar_data_source */;\r\n    const logging_1 = require(19) /* ../../core/logging */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    function orNaN(v) {\r\n        return v != null ? v : NaN;\r\n    }\r\n    class GeoJSONDataSource extends columnar_data_source_1.ColumnarDataSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_GeoJSONDataSource() {\r\n            this.define({\r\n                geojson: [p.Any],\r\n            });\r\n            this.internal({\r\n                data: [p.Any, {}],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._update_data();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.properties.geojson.change, () => this._update_data());\r\n        }\r\n        _update_data() {\r\n            this.data = this.geojson_to_column_data();\r\n        }\r\n        _get_new_list_array(length) {\r\n            return array_1.range(0, length).map((_i) => []);\r\n        }\r\n        _get_new_nan_array(length) {\r\n            return array_1.range(0, length).map((_i) => NaN);\r\n        }\r\n        _add_properties(item, data, i, item_count) {\r\n            var _a;\r\n            const properties = (_a = item.properties) !== null && _a !== void 0 ? _a : {};\r\n            for (const [property, value] of object_1.entries(properties)) {\r\n                if (!data.hasOwnProperty(property))\r\n                    data[property] = this._get_new_nan_array(item_count);\r\n                // orNaN necessary here to prevent null values from ending up in the column\r\n                data[property][i] = orNaN(value);\r\n            }\r\n        }\r\n        _add_geometry(geometry, data, i) {\r\n            function flatten(acc, item) {\r\n                return acc.concat([[NaN, NaN, NaN]]).concat(item);\r\n            }\r\n            switch (geometry.type) {\r\n                case \"Point\": {\r\n                    const [x, y, z] = geometry.coordinates;\r\n                    data.x[i] = x;\r\n                    data.y[i] = y;\r\n                    data.z[i] = orNaN(z);\r\n                    break;\r\n                }\r\n                case \"LineString\": {\r\n                    const { coordinates } = geometry;\r\n                    for (let j = 0; j < coordinates.length; j++) {\r\n                        const [x, y, z] = coordinates[j];\r\n                        data.xs[i][j] = x;\r\n                        data.ys[i][j] = y;\r\n                        data.zs[i][j] = orNaN(z);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"Polygon\": {\r\n                    if (geometry.coordinates.length > 1)\r\n                        logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\r\n                    const exterior_ring = geometry.coordinates[0];\r\n                    for (let j = 0; j < exterior_ring.length; j++) {\r\n                        const [x, y, z] = exterior_ring[j];\r\n                        data.xs[i][j] = x;\r\n                        data.ys[i][j] = y;\r\n                        data.zs[i][j] = orNaN(z);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"MultiPoint\": {\r\n                    logging_1.logger.warn('MultiPoint not supported in Bokeh');\r\n                    break;\r\n                }\r\n                case \"MultiLineString\": {\r\n                    const coordinates = geometry.coordinates.reduce(flatten);\r\n                    for (let j = 0; j < coordinates.length; j++) {\r\n                        const [x, y, z] = coordinates[j];\r\n                        data.xs[i][j] = x;\r\n                        data.ys[i][j] = y;\r\n                        data.zs[i][j] = orNaN(z);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"MultiPolygon\": {\r\n                    const exterior_rings = [];\r\n                    for (const polygon of geometry.coordinates) {\r\n                        if (polygon.length > 1)\r\n                            logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\r\n                        exterior_rings.push(polygon[0]);\r\n                    }\r\n                    const coordinates = exterior_rings.reduce(flatten);\r\n                    for (let j = 0; j < coordinates.length; j++) {\r\n                        const [x, y, z] = coordinates[j];\r\n                        data.xs[i][j] = x;\r\n                        data.ys[i][j] = y;\r\n                        data.zs[i][j] = orNaN(z);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new Error(`Invalid GeoJSON geometry type: ${geometry.type}`);\r\n            }\r\n        }\r\n        geojson_to_column_data() {\r\n            const geojson = JSON.parse(this.geojson);\r\n            let items;\r\n            switch (geojson.type) {\r\n                case \"GeometryCollection\": {\r\n                    if (geojson.geometries == null)\r\n                        throw new Error('No geometries found in GeometryCollection');\r\n                    if (geojson.geometries.length === 0)\r\n                        throw new Error('geojson.geometries must have one or more items');\r\n                    items = geojson.geometries;\r\n                    break;\r\n                }\r\n                case \"FeatureCollection\": {\r\n                    if (geojson.features == null)\r\n                        throw new Error('No features found in FeaturesCollection');\r\n                    if (geojson.features.length == 0)\r\n                        throw new Error('geojson.features must have one or more items');\r\n                    items = geojson.features;\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');\r\n            }\r\n            let item_count = 0;\r\n            for (const item of items) {\r\n                const geometry = item.type === 'Feature' ? item.geometry : item;\r\n                if (geometry.type == 'GeometryCollection')\r\n                    item_count += geometry.geometries.length;\r\n                else\r\n                    item_count += 1;\r\n            }\r\n            const data = {\r\n                x: this._get_new_nan_array(item_count),\r\n                y: this._get_new_nan_array(item_count),\r\n                z: this._get_new_nan_array(item_count),\r\n                xs: this._get_new_list_array(item_count),\r\n                ys: this._get_new_list_array(item_count),\r\n                zs: this._get_new_list_array(item_count),\r\n            };\r\n            let arr_index = 0;\r\n            for (const item of items) {\r\n                const geometry = item.type == 'Feature' ? item.geometry : item;\r\n                if (geometry.type == \"GeometryCollection\") {\r\n                    for (const g of geometry.geometries) {\r\n                        this._add_geometry(g, data, arr_index);\r\n                        if (item.type === 'Feature')\r\n                            this._add_properties(item, data, arr_index, item_count);\r\n                        arr_index += 1;\r\n                    }\r\n                }\r\n                else {\r\n                    this._add_geometry(geometry, data, arr_index);\r\n                    if (item.type === 'Feature')\r\n                        this._add_properties(item, data, arr_index, item_count);\r\n                    arr_index += 1;\r\n                }\r\n            }\r\n            return data;\r\n        }\r\n    }\r\n    exports.GeoJSONDataSource = GeoJSONDataSource;\r\n    GeoJSONDataSource.__name__ = \"GeoJSONDataSource\";\r\n    GeoJSONDataSource.init_GeoJSONDataSource();\r\n}\r\n","/* models\\tickers\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var adaptive_ticker_1 = require(127) /* ./adaptive_ticker */;\r\n    exports.AdaptiveTicker = adaptive_ticker_1.AdaptiveTicker;\r\n    var basic_ticker_1 = require(126) /* ./basic_ticker */;\r\n    exports.BasicTicker = basic_ticker_1.BasicTicker;\r\n    var categorical_ticker_1 = require(180) /* ./categorical_ticker */;\r\n    exports.CategoricalTicker = categorical_ticker_1.CategoricalTicker;\r\n    var composite_ticker_1 = require(191) /* ./composite_ticker */;\r\n    exports.CompositeTicker = composite_ticker_1.CompositeTicker;\r\n    var continuous_ticker_1 = require(128) /* ./continuous_ticker */;\r\n    exports.ContinuousTicker = continuous_ticker_1.ContinuousTicker;\r\n    var datetime_ticker_1 = require(190) /* ./datetime_ticker */;\r\n    exports.DatetimeTicker = datetime_ticker_1.DatetimeTicker;\r\n    var days_ticker_1 = require(192) /* ./days_ticker */;\r\n    exports.DaysTicker = days_ticker_1.DaysTicker;\r\n    var fixed_ticker_1 = require(330) /* ./fixed_ticker */;\r\n    exports.FixedTicker = fixed_ticker_1.FixedTicker;\r\n    var log_ticker_1 = require(199) /* ./log_ticker */;\r\n    exports.LogTicker = log_ticker_1.LogTicker;\r\n    var mercator_ticker_1 = require(202) /* ./mercator_ticker */;\r\n    exports.MercatorTicker = mercator_ticker_1.MercatorTicker;\r\n    var months_ticker_1 = require(195) /* ./months_ticker */;\r\n    exports.MonthsTicker = months_ticker_1.MonthsTicker;\r\n    var single_interval_ticker_1 = require(193) /* ./single_interval_ticker */;\r\n    exports.SingleIntervalTicker = single_interval_ticker_1.SingleIntervalTicker;\r\n    var ticker_1 = require(129) /* ./ticker */;\r\n    exports.Ticker = ticker_1.Ticker;\r\n    var years_ticker_1 = require(196) /* ./years_ticker */;\r\n    exports.YearsTicker = years_ticker_1.YearsTicker;\r\n}\r\n","/* models\\tickers\\fixed_ticker.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const continuous_ticker_1 = require(128) /* ./continuous_ticker */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class FixedTicker extends continuous_ticker_1.ContinuousTicker {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.min_interval = 0;\r\n            this.max_interval = 0;\r\n        }\r\n        static init_FixedTicker() {\r\n            this.define({\r\n                ticks: [p.Array, []],\r\n                minor_ticks: [p.Array, []],\r\n            });\r\n        }\r\n        get_ticks_no_defaults(_data_low, _data_high, _cross_loc, _desired_n_ticks) {\r\n            return {\r\n                major: this.ticks,\r\n                minor: this.minor_ticks,\r\n            };\r\n        }\r\n        // XXX: whatever, because FixedTicker needs to fulfill the interface somehow\r\n        get_interval(_data_low, _data_high, _desired_n_ticks) {\r\n            return 0;\r\n        }\r\n    }\r\n    exports.FixedTicker = FixedTicker;\r\n    FixedTicker.__name__ = \"FixedTicker\";\r\n    FixedTicker.init_FixedTicker();\r\n}\r\n","/* models\\tiles\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var bbox_tile_source_1 = require(332) /* ./bbox_tile_source */;\r\n    exports.BBoxTileSource = bbox_tile_source_1.BBoxTileSource;\r\n    var mercator_tile_source_1 = require(333) /* ./mercator_tile_source */;\r\n    exports.MercatorTileSource = mercator_tile_source_1.MercatorTileSource;\r\n    var quadkey_tile_source_1 = require(336) /* ./quadkey_tile_source */;\r\n    exports.QUADKEYTileSource = quadkey_tile_source_1.QUADKEYTileSource;\r\n    var tile_renderer_1 = require(337) /* ./tile_renderer */;\r\n    exports.TileRenderer = tile_renderer_1.TileRenderer;\r\n    var tile_source_1 = require(334) /* ./tile_source */;\r\n    exports.TileSource = tile_source_1.TileSource;\r\n    var tms_tile_source_1 = require(341) /* ./tms_tile_source */;\r\n    exports.TMSTileSource = tms_tile_source_1.TMSTileSource;\r\n    var wmts_tile_source_1 = require(338) /* ./wmts_tile_source */;\r\n    exports.WMTSTileSource = wmts_tile_source_1.WMTSTileSource;\r\n}\r\n","/* models\\tiles\\bbox_tile_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const mercator_tile_source_1 = require(333) /* ./mercator_tile_source */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class BBoxTileSource extends mercator_tile_source_1.MercatorTileSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_BBoxTileSource() {\r\n            this.define({\r\n                use_latlon: [p.Boolean, false],\r\n            });\r\n        }\r\n        get_image_url(x, y, z) {\r\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\r\n            let xmax, xmin, ymax, ymin;\r\n            if (this.use_latlon)\r\n                [xmin, ymin, xmax, ymax] = this.get_tile_geographic_bounds(x, y, z);\r\n            else\r\n                [xmin, ymin, xmax, ymax] = this.get_tile_meter_bounds(x, y, z);\r\n            return image_url\r\n                .replace(\"{XMIN}\", xmin.toString())\r\n                .replace(\"{YMIN}\", ymin.toString())\r\n                .replace(\"{XMAX}\", xmax.toString())\r\n                .replace(\"{YMAX}\", ymax.toString());\r\n        }\r\n    }\r\n    exports.BBoxTileSource = BBoxTileSource;\r\n    BBoxTileSource.__name__ = \"BBoxTileSource\";\r\n    BBoxTileSource.init_BBoxTileSource();\r\n}\r\n","/* models\\tiles\\mercator_tile_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const tile_source_1 = require(334) /* ./tile_source */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const tile_utils_1 = require(335) /* ./tile_utils */;\r\n    class MercatorTileSource extends tile_source_1.TileSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_MercatorTileSource() {\r\n            this.define({\r\n                snap_to_zoom: [p.Boolean, false],\r\n                wrap_around: [p.Boolean, true],\r\n            });\r\n            this.override({\r\n                x_origin_offset: 20037508.34,\r\n                y_origin_offset: 20037508.34,\r\n                initial_resolution: 156543.03392804097,\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._resolutions = array_1.range(this.min_zoom, this.max_zoom + 1).map((z) => this.get_resolution(z));\r\n        }\r\n        _computed_initial_resolution() {\r\n            if (this.initial_resolution != null)\r\n                return this.initial_resolution;\r\n            else {\r\n                // TODO testing 2015-11-17, if this codepath is used it seems\r\n                // to use 100% cpu and wedge Chrome\r\n                return (2 * Math.PI * 6378137) / this.tile_size;\r\n            }\r\n        }\r\n        is_valid_tile(x, y, z) {\r\n            if (!this.wrap_around) {\r\n                if (x < 0 || x >= 2 ** z)\r\n                    return false;\r\n            }\r\n            if (y < 0 || y >= 2 ** z)\r\n                return false;\r\n            return true;\r\n        }\r\n        parent_by_tile_xyz(x, y, z) {\r\n            const quadkey = this.tile_xyz_to_quadkey(x, y, z);\r\n            const parent_quadkey = quadkey.substring(0, quadkey.length - 1);\r\n            return this.quadkey_to_tile_xyz(parent_quadkey);\r\n        }\r\n        get_resolution(level) {\r\n            return this._computed_initial_resolution() / 2 ** level;\r\n        }\r\n        get_resolution_by_extent(extent, height, width) {\r\n            const x_rs = (extent[2] - extent[0]) / width;\r\n            const y_rs = (extent[3] - extent[1]) / height;\r\n            return [x_rs, y_rs];\r\n        }\r\n        get_level_by_extent(extent, height, width) {\r\n            const x_rs = (extent[2] - extent[0]) / width;\r\n            const y_rs = (extent[3] - extent[1]) / height;\r\n            const resolution = Math.max(x_rs, y_rs);\r\n            let i = 0;\r\n            for (const r of this._resolutions) {\r\n                if (resolution > r) {\r\n                    if (i == 0)\r\n                        return 0;\r\n                    if (i > 0)\r\n                        return i - 1;\r\n                }\r\n                i += 1;\r\n            }\r\n            // otherwise return the highest available resolution\r\n            return (i - 1);\r\n        }\r\n        get_closest_level_by_extent(extent, height, width) {\r\n            const x_rs = (extent[2] - extent[0]) / width;\r\n            const y_rs = (extent[3] - extent[1]) / height;\r\n            const resolution = Math.max(x_rs, y_rs);\r\n            const closest = this._resolutions.reduce(function (previous, current) {\r\n                if (Math.abs(current - resolution) < Math.abs(previous - resolution))\r\n                    return current;\r\n                else\r\n                    return previous;\r\n            });\r\n            return this._resolutions.indexOf(closest);\r\n        }\r\n        snap_to_zoom_level(extent, height, width, level) {\r\n            const [xmin, ymin, xmax, ymax] = extent;\r\n            const desired_res = this._resolutions[level];\r\n            let desired_x_delta = width * desired_res;\r\n            let desired_y_delta = height * desired_res;\r\n            if (!this.snap_to_zoom) {\r\n                const xscale = (xmax - xmin) / desired_x_delta;\r\n                const yscale = (ymax - ymin) / desired_y_delta;\r\n                if (xscale > yscale) {\r\n                    desired_x_delta = (xmax - xmin);\r\n                    desired_y_delta = desired_y_delta * xscale;\r\n                }\r\n                else {\r\n                    desired_x_delta = desired_x_delta * yscale;\r\n                    desired_y_delta = (ymax - ymin);\r\n                }\r\n            }\r\n            const x_adjust = (desired_x_delta - (xmax - xmin)) / 2;\r\n            const y_adjust = (desired_y_delta - (ymax - ymin)) / 2;\r\n            return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];\r\n        }\r\n        tms_to_wmts(x, y, z) {\r\n            // Note this works both ways\r\n            return [x, 2 ** z - 1 - y, z];\r\n        }\r\n        wmts_to_tms(x, y, z) {\r\n            // Note this works both ways\r\n            return [x, 2 ** z - 1 - y, z];\r\n        }\r\n        pixels_to_meters(px, py, level) {\r\n            const res = this.get_resolution(level);\r\n            const mx = (px * res) - this.x_origin_offset;\r\n            const my = (py * res) - this.y_origin_offset;\r\n            return [mx, my];\r\n        }\r\n        meters_to_pixels(mx, my, level) {\r\n            const res = this.get_resolution(level);\r\n            const px = (mx + this.x_origin_offset) / res;\r\n            const py = (my + this.y_origin_offset) / res;\r\n            return [px, py];\r\n        }\r\n        pixels_to_tile(px, py) {\r\n            let tx = Math.ceil(px / this.tile_size);\r\n            tx = tx === 0 ? tx : tx - 1;\r\n            const ty = Math.max(Math.ceil(py / this.tile_size) - 1, 0);\r\n            return [tx, ty];\r\n        }\r\n        pixels_to_raster(px, py, level) {\r\n            const mapSize = this.tile_size << level;\r\n            return [px, mapSize - py];\r\n        }\r\n        meters_to_tile(mx, my, level) {\r\n            const [px, py] = this.meters_to_pixels(mx, my, level);\r\n            return this.pixels_to_tile(px, py);\r\n        }\r\n        get_tile_meter_bounds(tx, ty, level) {\r\n            // expects tms styles coordinates (bottom-left origin)\r\n            const [xmin, ymin] = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level);\r\n            const [xmax, ymax] = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level);\r\n            return [xmin, ymin, xmax, ymax];\r\n        }\r\n        get_tile_geographic_bounds(tx, ty, level) {\r\n            const bounds = this.get_tile_meter_bounds(tx, ty, level);\r\n            const [minLon, minLat, maxLon, maxLat] = tile_utils_1.meters_extent_to_geographic(bounds);\r\n            return [minLon, minLat, maxLon, maxLat];\r\n        }\r\n        get_tiles_by_extent(extent, level, tile_border = 1) {\r\n            // unpack extent and convert to tile coordinates\r\n            const [xmin, ymin, xmax, ymax] = extent;\r\n            let [txmin, tymin] = this.meters_to_tile(xmin, ymin, level);\r\n            let [txmax, tymax] = this.meters_to_tile(xmax, ymax, level);\r\n            // add tiles which border\r\n            txmin -= tile_border;\r\n            tymin -= tile_border;\r\n            txmax += tile_border;\r\n            tymax += tile_border;\r\n            const tiles = [];\r\n            for (let ty = tymax; ty >= tymin; ty--) {\r\n                for (let tx = txmin; tx <= txmax; tx++) {\r\n                    if (this.is_valid_tile(tx, ty, level))\r\n                        tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);\r\n                }\r\n            }\r\n            this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);\r\n            return tiles;\r\n        }\r\n        quadkey_to_tile_xyz(quadKey) {\r\n            /**\r\n             * Computes tile x, y and z values based on quadKey.\r\n             */\r\n            let tileX = 0;\r\n            let tileY = 0;\r\n            const tileZ = quadKey.length;\r\n            for (let i = tileZ; i > 0; i--) {\r\n                const value = quadKey.charAt(tileZ - i);\r\n                const mask = 1 << (i - 1);\r\n                switch (value) {\r\n                    case '0':\r\n                        continue;\r\n                    case '1':\r\n                        tileX |= mask;\r\n                        break;\r\n                    case '2':\r\n                        tileY |= mask;\r\n                        break;\r\n                    case '3':\r\n                        tileX |= mask;\r\n                        tileY |= mask;\r\n                        break;\r\n                    default:\r\n                        throw new TypeError(`Invalid Quadkey: ${quadKey}`);\r\n                }\r\n            }\r\n            return [tileX, tileY, tileZ];\r\n        }\r\n        tile_xyz_to_quadkey(x, y, z) {\r\n            /*\r\n             * Computes quadkey value based on tile x, y and z values.\r\n             */\r\n            let quadkey = \"\";\r\n            for (let i = z; i > 0; i--) {\r\n                const mask = 1 << (i - 1);\r\n                let digit = 0;\r\n                if ((x & mask) !== 0) {\r\n                    digit += 1;\r\n                }\r\n                if ((y & mask) !== 0) {\r\n                    digit += 2;\r\n                }\r\n                quadkey += digit.toString();\r\n            }\r\n            return quadkey;\r\n        }\r\n        children_by_tile_xyz(x, y, z) {\r\n            const quadkey = this.tile_xyz_to_quadkey(x, y, z);\r\n            const child_tile_xyz = [];\r\n            for (let i = 0; i <= 3; i++) {\r\n                const [x, y, z] = this.quadkey_to_tile_xyz(quadkey + i.toString());\r\n                const b = this.get_tile_meter_bounds(x, y, z);\r\n                child_tile_xyz.push([x, y, z, b]);\r\n            }\r\n            return child_tile_xyz;\r\n        }\r\n        get_closest_parent_by_tile_xyz(x, y, z) {\r\n            const world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\r\n            [x, y, z] = this.normalize_xyz(x, y, z);\r\n            let quadkey = this.tile_xyz_to_quadkey(x, y, z);\r\n            while (quadkey.length > 0) {\r\n                quadkey = quadkey.substring(0, quadkey.length - 1);\r\n                [x, y, z] = this.quadkey_to_tile_xyz(quadkey);\r\n                [x, y, z] = this.denormalize_xyz(x, y, z, world_x);\r\n                if (this.tiles.has(this.tile_xyz_to_key(x, y, z)))\r\n                    return [x, y, z];\r\n            }\r\n            return [0, 0, 0];\r\n        }\r\n        normalize_xyz(x, y, z) {\r\n            if (this.wrap_around) {\r\n                const tile_count = 2 ** z;\r\n                return [((x % tile_count) + tile_count) % tile_count, y, z];\r\n            }\r\n            else {\r\n                return [x, y, z];\r\n            }\r\n        }\r\n        denormalize_xyz(x, y, z, world_x) {\r\n            return [x + (world_x * 2 ** z), y, z];\r\n        }\r\n        denormalize_meters(meters_x, meters_y, _level, world_x) {\r\n            return [meters_x + (world_x * 2 * Math.PI * 6378137), meters_y];\r\n        }\r\n        calculate_world_x_by_tile_xyz(x, _y, z) {\r\n            return Math.floor(x / 2 ** z);\r\n        }\r\n    }\r\n    exports.MercatorTileSource = MercatorTileSource;\r\n    MercatorTileSource.__name__ = \"MercatorTileSource\";\r\n    MercatorTileSource.init_MercatorTileSource();\r\n}\r\n","/* models\\tiles\\tile_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class TileSource extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_TileSource() {\r\n            this.define({\r\n                url: [p.String, ''],\r\n                tile_size: [p.Number, 256],\r\n                max_zoom: [p.Number, 30],\r\n                min_zoom: [p.Number, 0],\r\n                extra_url_vars: [p.Any, {}],\r\n                attribution: [p.String, ''],\r\n                x_origin_offset: [p.Number],\r\n                y_origin_offset: [p.Number],\r\n                initial_resolution: [p.Number],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.tiles = new Map();\r\n            this._normalize_case();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.change, () => this._clear_cache());\r\n        }\r\n        string_lookup_replace(str, lookup) {\r\n            let result_str = str;\r\n            for (const [key, value] of object_1.entries(lookup)) {\r\n                result_str = result_str.replace(`{${key}}`, value);\r\n            }\r\n            return result_str;\r\n        }\r\n        _normalize_case() {\r\n            /*\r\n             * Note: should probably be refactored into subclasses.\r\n             */\r\n            const url = this.url\r\n                .replace('{x}', '{X}')\r\n                .replace('{y}', '{Y}')\r\n                .replace('{z}', '{Z}')\r\n                .replace('{q}', '{Q}')\r\n                .replace('{xmin}', '{XMIN}')\r\n                .replace('{ymin}', '{YMIN}')\r\n                .replace('{xmax}', '{XMAX}')\r\n                .replace('{ymax}', '{YMAX}');\r\n            this.url = url;\r\n        }\r\n        _clear_cache() {\r\n            this.tiles = new Map();\r\n        }\r\n        tile_xyz_to_key(x, y, z) {\r\n            return `${x}:${y}:${z}`;\r\n        }\r\n        key_to_tile_xyz(key) {\r\n            const [x, y, z] = key.split(':').map((c) => parseInt(c));\r\n            return [x, y, z];\r\n        }\r\n        sort_tiles_from_center(tiles, tile_extent) {\r\n            const [txmin, tymin, txmax, tymax] = tile_extent;\r\n            const center_x = ((txmax - txmin) / 2) + txmin;\r\n            const center_y = ((tymax - tymin) / 2) + tymin;\r\n            tiles.sort(function (a, b) {\r\n                const a_distance = Math.sqrt((center_x - a[0]) ** 2 + (center_y - a[1]) ** 2);\r\n                const b_distance = Math.sqrt((center_x - b[0]) ** 2 + (center_y - b[1]) ** 2);\r\n                return a_distance - b_distance;\r\n            });\r\n        }\r\n        get_image_url(x, y, z) {\r\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\r\n            return image_url\r\n                .replace(\"{X}\", x.toString())\r\n                .replace('{Y}', y.toString())\r\n                .replace(\"{Z}\", z.toString());\r\n        }\r\n    }\r\n    exports.TileSource = TileSource;\r\n    TileSource.__name__ = \"TileSource\";\r\n    TileSource.init_TileSource();\r\n}\r\n","/* models\\tiles\\tile_utils.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const projections_1 = require(37) /* ../../core/util/projections */;\r\n    function geographic_to_meters(x_lon, y_lat) {\r\n        return projections_1.wgs84_mercator.compute(x_lon, y_lat);\r\n    }\r\n    exports.geographic_to_meters = geographic_to_meters;\r\n    function meters_to_geographic(mx, my) {\r\n        return projections_1.wgs84_mercator.invert(mx, my);\r\n    }\r\n    exports.meters_to_geographic = meters_to_geographic;\r\n    function geographic_extent_to_meters(extent) {\r\n        const [g_xmin, g_ymin, g_xmax, g_ymax] = extent;\r\n        const [m_xmin, m_ymin] = geographic_to_meters(g_xmin, g_ymin);\r\n        const [m_xmax, m_ymax] = geographic_to_meters(g_xmax, g_ymax);\r\n        return [m_xmin, m_ymin, m_xmax, m_ymax];\r\n    }\r\n    exports.geographic_extent_to_meters = geographic_extent_to_meters;\r\n    function meters_extent_to_geographic(extent) {\r\n        const [m_xmin, m_ymin, m_xmax, m_ymax] = extent;\r\n        const [g_xmin, g_ymin] = meters_to_geographic(m_xmin, m_ymin);\r\n        const [g_xmax, g_ymax] = meters_to_geographic(m_xmax, m_ymax);\r\n        return [g_xmin, g_ymin, g_xmax, g_ymax];\r\n    }\r\n    exports.meters_extent_to_geographic = meters_extent_to_geographic;\r\n}\r\n","/* models\\tiles\\quadkey_tile_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const mercator_tile_source_1 = require(333) /* ./mercator_tile_source */;\r\n    class QUADKEYTileSource extends mercator_tile_source_1.MercatorTileSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        get_image_url(x, y, z) {\r\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\r\n            const [wx, wy, wz] = this.tms_to_wmts(x, y, z);\r\n            const quadKey = this.tile_xyz_to_quadkey(wx, wy, wz);\r\n            return image_url.replace(\"{Q}\", quadKey);\r\n        }\r\n    }\r\n    exports.QUADKEYTileSource = QUADKEYTileSource;\r\n    QUADKEYTileSource.__name__ = \"QUADKEYTileSource\";\r\n}\r\n","/* models\\tiles\\tile_renderer.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const wmts_tile_source_1 = require(338) /* ./wmts_tile_source */;\r\n    const data_renderer_1 = require(91) /* ../renderers/data_renderer */;\r\n    const range1d_1 = require(158) /* ../ranges/range1d */;\r\n    const dom_1 = require(72) /* ../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const image_1 = require(251) /* ../../core/util/image */;\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const types_1 = require(8) /* ../../core/util/types */;\r\n    const selection_manager_1 = require(89) /* ../../core/selection_manager */;\r\n    const column_data_source_1 = require(85) /* ../sources/column_data_source */;\r\n    const tiles_1 = require(339) /* ../../styles/tiles */;\r\n    const tiles_css_1 = tslib_1.__importDefault(require(340) /* ../../styles/tiles.css */);\r\n    class TileRendererView extends data_renderer_1.DataRendererView {\r\n        initialize() {\r\n            this._tiles = [];\r\n            super.initialize();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.change, () => this.request_render());\r\n            this.connect(this.model.tile_source.change, () => this.request_render());\r\n        }\r\n        styles() {\r\n            return [...super.styles(), tiles_css_1.default];\r\n        }\r\n        get_extent() {\r\n            return [this.x_range.start, this.y_range.start, this.x_range.end, this.y_range.end];\r\n        }\r\n        get map_plot() {\r\n            return this.plot_model;\r\n        }\r\n        get map_canvas() {\r\n            return this.layer.ctx;\r\n        }\r\n        get map_frame() {\r\n            return this.plot_view.frame;\r\n        }\r\n        get x_range() {\r\n            return this.map_plot.x_range;\r\n        }\r\n        get y_range() {\r\n            return this.map_plot.y_range;\r\n        }\r\n        _set_data() {\r\n            this.extent = this.get_extent();\r\n            this._last_height = undefined;\r\n            this._last_width = undefined;\r\n        }\r\n        _update_attribution() {\r\n            if (this.attribution_el != null)\r\n                dom_1.removeElement(this.attribution_el);\r\n            const { attribution } = this.model.tile_source;\r\n            if (types_1.isString(attribution) && attribution.length > 0) {\r\n                const { layout, frame } = this.plot_view;\r\n                const offset_right = layout.bbox.width - frame.bbox.right;\r\n                const offset_bottom = layout.bbox.height - frame.bbox.bottom;\r\n                const max_width = frame.bbox.width;\r\n                this.attribution_el = dom_1.div({\r\n                    class: tiles_1.bk_tile_attribution,\r\n                    style: {\r\n                        position: \"absolute\",\r\n                        right: `${offset_right}px`,\r\n                        bottom: `${offset_bottom}px`,\r\n                        'max-width': `${max_width - 4 /*padding*/}px`,\r\n                        padding: \"2px\",\r\n                        'background-color': 'rgba(255,255,255,0.5)',\r\n                        'font-size': '9px',\r\n                        'line-height': '1.05',\r\n                        'white-space': 'nowrap',\r\n                        overflow: 'hidden',\r\n                        'text-overflow': 'ellipsis',\r\n                    },\r\n                });\r\n                this.plot_view.canvas_view.add_event(this.attribution_el);\r\n                this.attribution_el.innerHTML = attribution;\r\n                this.attribution_el.title = this.attribution_el.textContent.replace(/\\s*\\n\\s*/g, \" \");\r\n            }\r\n        }\r\n        _map_data() {\r\n            this.initial_extent = this.get_extent();\r\n            const zoom_level = this.model.tile_source.get_level_by_extent(this.initial_extent, this.map_frame.bbox.height, this.map_frame.bbox.width);\r\n            const new_extent = this.model.tile_source.snap_to_zoom_level(this.initial_extent, this.map_frame.bbox.height, this.map_frame.bbox.width, zoom_level);\r\n            this.x_range.start = new_extent[0];\r\n            this.y_range.start = new_extent[1];\r\n            this.x_range.end = new_extent[2];\r\n            this.y_range.end = new_extent[3];\r\n            if (this.x_range instanceof range1d_1.Range1d) {\r\n                this.x_range.reset_start = new_extent[0];\r\n                this.x_range.reset_end = new_extent[2];\r\n            }\r\n            if (this.y_range instanceof range1d_1.Range1d) {\r\n                this.y_range.reset_start = new_extent[1];\r\n                this.y_range.reset_end = new_extent[3];\r\n            }\r\n            this._update_attribution();\r\n        }\r\n        _create_tile(x, y, z, bounds, cache_only = false) {\r\n            const [nx, ny, nz] = this.model.tile_source.normalize_xyz(x, y, z);\r\n            const tile = {\r\n                img: undefined,\r\n                tile_coords: [x, y, z],\r\n                normalized_coords: [nx, ny, nz],\r\n                quadkey: this.model.tile_source.tile_xyz_to_quadkey(x, y, z),\r\n                cache_key: this.model.tile_source.tile_xyz_to_key(x, y, z),\r\n                bounds,\r\n                loaded: false,\r\n                finished: false,\r\n                x_coord: bounds[0],\r\n                y_coord: bounds[3],\r\n            };\r\n            const src = this.model.tile_source.get_image_url(nx, ny, nz);\r\n            new image_1.ImageLoader(src, {\r\n                loaded: (img) => {\r\n                    Object.assign(tile, { img, loaded: true });\r\n                    if (cache_only) {\r\n                        tile.finished = true;\r\n                        this.notify_finished();\r\n                    }\r\n                    else\r\n                        this.request_render();\r\n                },\r\n                failed() {\r\n                    tile.finished = true;\r\n                },\r\n            });\r\n            this.model.tile_source.tiles.set(tile.cache_key, tile);\r\n            this._tiles.push(tile);\r\n        }\r\n        _enforce_aspect_ratio() {\r\n            // brute force way of handling resize or sizing_mode event -------------------------------------------------------------\r\n            if ((this._last_height !== this.map_frame.bbox.height) || (this._last_width !== this.map_frame.bbox.width)) {\r\n                const extent = this.get_extent();\r\n                const zoom_level = this.model.tile_source.get_level_by_extent(extent, this.map_frame.bbox.height, this.map_frame.bbox.width);\r\n                const new_extent = this.model.tile_source.snap_to_zoom_level(extent, this.map_frame.bbox.height, this.map_frame.bbox.width, zoom_level);\r\n                this.x_range.setv({ start: new_extent[0], end: new_extent[2] });\r\n                this.y_range.setv({ start: new_extent[1], end: new_extent[3] });\r\n                this.extent = new_extent;\r\n                this._last_height = this.map_frame.bbox.height;\r\n                this._last_width = this.map_frame.bbox.width;\r\n            }\r\n        }\r\n        has_finished() {\r\n            if (!super.has_finished()) {\r\n                return false;\r\n            }\r\n            if (this._tiles.length === 0) {\r\n                return false;\r\n            }\r\n            for (const tile of this._tiles) {\r\n                if (!tile.finished) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        _render() {\r\n            if (this.map_initialized == null) {\r\n                this._set_data();\r\n                this._map_data();\r\n                this.map_initialized = true;\r\n            }\r\n            this._enforce_aspect_ratio();\r\n            this._update();\r\n            if (this.prefetch_timer != null) {\r\n                clearTimeout(this.prefetch_timer);\r\n            }\r\n            this.prefetch_timer = setTimeout(this._prefetch_tiles.bind(this), 500);\r\n            if (this.has_finished()) {\r\n                this.notify_finished();\r\n            }\r\n        }\r\n        _draw_tile(tile_key) {\r\n            const tile_data = this.model.tile_source.tiles.get(tile_key);\r\n            if (tile_data != null && tile_data.loaded) {\r\n                const [[sxmin], [symin]] = this.coordinates.map_to_screen([tile_data.bounds[0]], [tile_data.bounds[3]]);\r\n                const [[sxmax], [symax]] = this.coordinates.map_to_screen([tile_data.bounds[2]], [tile_data.bounds[1]]);\r\n                const sw = sxmax - sxmin;\r\n                const sh = symax - symin;\r\n                const sx = sxmin;\r\n                const sy = symin;\r\n                const old_smoothing = this.map_canvas.getImageSmoothingEnabled();\r\n                this.map_canvas.setImageSmoothingEnabled(this.model.smoothing);\r\n                this.map_canvas.drawImage(tile_data.img, sx, sy, sw, sh);\r\n                this.map_canvas.setImageSmoothingEnabled(old_smoothing);\r\n                tile_data.finished = true;\r\n            }\r\n        }\r\n        _set_rect() {\r\n            const outline_width = this.plot_model.properties.outline_line_width.value();\r\n            const l = this.map_frame.bbox.left + (outline_width / 2);\r\n            const t = this.map_frame.bbox.top + (outline_width / 2);\r\n            const w = this.map_frame.bbox.width - outline_width;\r\n            const h = this.map_frame.bbox.height - outline_width;\r\n            this.map_canvas.rect(l, t, w, h);\r\n            this.map_canvas.clip();\r\n        }\r\n        _render_tiles(tile_keys) {\r\n            this.map_canvas.save();\r\n            this._set_rect();\r\n            this.map_canvas.globalAlpha = this.model.alpha;\r\n            for (const tile_key of tile_keys) {\r\n                this._draw_tile(tile_key);\r\n            }\r\n            this.map_canvas.restore();\r\n        }\r\n        _prefetch_tiles() {\r\n            const { tile_source } = this.model;\r\n            const extent = this.get_extent();\r\n            const h = this.map_frame.bbox.height;\r\n            const w = this.map_frame.bbox.width;\r\n            const zoom_level = this.model.tile_source.get_level_by_extent(extent, h, w);\r\n            const tiles = this.model.tile_source.get_tiles_by_extent(extent, zoom_level);\r\n            for (let t = 0, end = Math.min(10, tiles.length); t < end; t++) {\r\n                const [x, y, z] = tiles[t];\r\n                const children = this.model.tile_source.children_by_tile_xyz(x, y, z);\r\n                for (const c of children) {\r\n                    const [cx, cy, cz, cbounds] = c;\r\n                    if (tile_source.tiles.has(tile_source.tile_xyz_to_key(cx, cy, cz))) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        this._create_tile(cx, cy, cz, cbounds, true);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _fetch_tiles(tiles) {\r\n            for (const tile of tiles) {\r\n                const [x, y, z, bounds] = tile;\r\n                this._create_tile(x, y, z, bounds);\r\n            }\r\n        }\r\n        _update() {\r\n            const { tile_source } = this.model;\r\n            const { min_zoom } = tile_source;\r\n            const { max_zoom } = tile_source;\r\n            let extent = this.get_extent();\r\n            const zooming_out = (this.extent[2] - this.extent[0]) < (extent[2] - extent[0]);\r\n            const h = this.map_frame.bbox.height;\r\n            const w = this.map_frame.bbox.width;\r\n            let zoom_level = tile_source.get_level_by_extent(extent, h, w);\r\n            let snap_back = false;\r\n            if (zoom_level < min_zoom) {\r\n                extent = this.extent;\r\n                zoom_level = min_zoom;\r\n                snap_back = true;\r\n            }\r\n            else if (zoom_level > max_zoom) {\r\n                extent = this.extent;\r\n                zoom_level = max_zoom;\r\n                snap_back = true;\r\n            }\r\n            if (snap_back) {\r\n                this.x_range.setv({ x_range: { start: extent[0], end: extent[2] } });\r\n                this.y_range.setv({ start: extent[1], end: extent[3] });\r\n            }\r\n            this.extent = extent;\r\n            const tiles = tile_source.get_tiles_by_extent(extent, zoom_level);\r\n            const need_load = [];\r\n            const cached = [];\r\n            const parents = [];\r\n            const children = [];\r\n            for (const t of tiles) {\r\n                const [x, y, z] = t;\r\n                const key = tile_source.tile_xyz_to_key(x, y, z);\r\n                const tile = tile_source.tiles.get(key);\r\n                if (tile != null && tile.loaded) {\r\n                    cached.push(key);\r\n                }\r\n                else {\r\n                    if (this.model.render_parents) {\r\n                        const [px, py, pz] = tile_source.get_closest_parent_by_tile_xyz(x, y, z);\r\n                        const parent_key = tile_source.tile_xyz_to_key(px, py, pz);\r\n                        const parent_tile = tile_source.tiles.get(parent_key);\r\n                        if ((parent_tile != null) && parent_tile.loaded && !array_1.includes(parents, parent_key)) {\r\n                            parents.push(parent_key);\r\n                        }\r\n                        if (zooming_out) {\r\n                            const child_tiles = tile_source.children_by_tile_xyz(x, y, z);\r\n                            for (const [cx, cy, cz] of child_tiles) {\r\n                                const child_key = tile_source.tile_xyz_to_key(cx, cy, cz);\r\n                                if (tile_source.tiles.has(child_key))\r\n                                    children.push(child_key);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (tile == null)\r\n                    need_load.push(t);\r\n            }\r\n            // draw stand-in parents ----------\r\n            this._render_tiles(parents);\r\n            this._render_tiles(children);\r\n            // draw cached ----------\r\n            this._render_tiles(cached);\r\n            // fetch missing -------\r\n            if (this.render_timer != null) {\r\n                clearTimeout(this.render_timer);\r\n            }\r\n            this.render_timer = setTimeout((() => this._fetch_tiles(need_load)), 65);\r\n        }\r\n    }\r\n    exports.TileRendererView = TileRendererView;\r\n    TileRendererView.__name__ = \"TileRendererView\";\r\n    class TileRenderer extends data_renderer_1.DataRenderer {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            // XXX: tile renderer doesn't allow selection, but needs to fulfil the APIs\r\n            this._selection_manager = new selection_manager_1.SelectionManager({\r\n                source: new column_data_source_1.ColumnDataSource(),\r\n            });\r\n        }\r\n        static init_TileRenderer() {\r\n            this.prototype.default_view = TileRendererView;\r\n            this.define({\r\n                alpha: [p.Number, 1.0],\r\n                smoothing: [p.Boolean, true],\r\n                tile_source: [p.Instance, () => new wmts_tile_source_1.WMTSTileSource()],\r\n                render_parents: [p.Boolean, true],\r\n            });\r\n        }\r\n        get_selection_manager() {\r\n            return this._selection_manager;\r\n        }\r\n    }\r\n    exports.TileRenderer = TileRenderer;\r\n    TileRenderer.__name__ = \"TileRenderer\";\r\n    TileRenderer.init_TileRenderer();\r\n}\r\n","/* models\\tiles\\wmts_tile_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const mercator_tile_source_1 = require(333) /* ./mercator_tile_source */;\r\n    class WMTSTileSource extends mercator_tile_source_1.MercatorTileSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        get_image_url(x, y, z) {\r\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\r\n            const [wx, wy, wz] = this.tms_to_wmts(x, y, z);\r\n            return image_url\r\n                .replace(\"{X}\", wx.toString())\r\n                .replace(\"{Y}\", wy.toString())\r\n                .replace(\"{Z}\", wz.toString());\r\n        }\r\n    }\r\n    exports.WMTSTileSource = WMTSTileSource;\r\n    WMTSTileSource.__name__ = \"WMTSTileSource\";\r\n}\r\n","/* styles\\tiles.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.bk_tile_attribution = \"bk-tile-attribution\";\r\n}\r\n","/* styles\\tiles.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n.bk-root .bk-tile-attribution a {\n  color: black;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* models\\tiles\\tms_tile_source.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const mercator_tile_source_1 = require(333) /* ./mercator_tile_source */;\r\n    class TMSTileSource extends mercator_tile_source_1.MercatorTileSource {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        get_image_url(x, y, z) {\r\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\r\n            return image_url\r\n                .replace(\"{X}\", x.toString())\r\n                .replace('{Y}', y.toString())\r\n                .replace(\"{Z}\", z.toString());\r\n        }\r\n    }\r\n    exports.TMSTileSource = TMSTileSource;\r\n    TMSTileSource.__name__ = \"TMSTileSource\";\r\n}\r\n","/* models\\textures\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var canvas_texture_1 = require(343) /* ./canvas_texture */;\r\n    exports.CanvasTexture = canvas_texture_1.CanvasTexture;\r\n    var image_url_texture_1 = require(345) /* ./image_url_texture */;\r\n    exports.ImageURLTexture = image_url_texture_1.ImageURLTexture;\r\n    var texture_1 = require(344) /* ./texture */;\r\n    exports.Texture = texture_1.Texture;\r\n}\r\n","/* models\\textures\\canvas_texture.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const texture_1 = require(344) /* ./texture */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const string_1 = require(29) /* ../../core/util/string */;\r\n    class CanvasTexture extends texture_1.Texture {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CanvasTexture() {\r\n            this.define({\r\n                code: [p.String],\r\n            });\r\n        }\r\n        get func() {\r\n            const code = string_1.use_strict(this.code);\r\n            return new Function(\"ctx\", \"color\", \"scale\", \"weight\", code);\r\n        }\r\n        get_pattern(color, scale, weight) {\r\n            return (ctx) => {\r\n                const canvas = document.createElement('canvas');\r\n                canvas.width = scale;\r\n                canvas.height = scale;\r\n                const pattern_ctx = canvas.getContext('2d');\r\n                this.func.call(this, pattern_ctx, color, scale, weight);\r\n                return ctx.createPattern(canvas, this.repetition);\r\n            };\r\n        }\r\n    }\r\n    exports.CanvasTexture = CanvasTexture;\r\n    CanvasTexture.__name__ = \"CanvasTexture\";\r\n    CanvasTexture.init_CanvasTexture();\r\n}\r\n","/* models\\textures\\texture.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    class Texture extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_Texture() {\r\n            this.define({\r\n                repetition: [p.TextureRepetition, \"repeat\"],\r\n            });\r\n        }\r\n        onload(defer_func) {\r\n            defer_func();\r\n        }\r\n    }\r\n    exports.Texture = Texture;\r\n    Texture.__name__ = \"Texture\";\r\n    Texture.init_Texture();\r\n}\r\n","/* models\\textures\\image_url_texture.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const texture_1 = require(344) /* ./texture */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const image_1 = require(251) /* ../../core/util/image */;\r\n    class ImageURLTexture extends texture_1.Texture {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ImageURLTexture() {\r\n            this.define({\r\n                url: [p.String],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._loader = new image_1.ImageLoader(this.url);\r\n        }\r\n        get_pattern(_color, _scale, _weight) {\r\n            return (ctx) => {\r\n                if (!this._loader.finished) {\r\n                    return null;\r\n                }\r\n                return ctx.createPattern(this._loader.image, this.repetition);\r\n            };\r\n        }\r\n        onload(defer_func) {\r\n            this._loader.promise.then(() => defer_func());\r\n        }\r\n    }\r\n    exports.ImageURLTexture = ImageURLTexture;\r\n    ImageURLTexture.__name__ = \"ImageURLTexture\";\r\n    ImageURLTexture.init_ImageURLTexture();\r\n}\r\n","/* models\\tools\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var action_tool_1 = require(307) /* ./actions/action_tool */;\r\n    exports.ActionTool = action_tool_1.ActionTool;\r\n    var custom_action_1 = require(347) /* ./actions/custom_action */;\r\n    exports.CustomAction = custom_action_1.CustomAction;\r\n    var help_tool_1 = require(308) /* ./actions/help_tool */;\r\n    exports.HelpTool = help_tool_1.HelpTool;\r\n    var redo_tool_1 = require(348) /* ./actions/redo_tool */;\r\n    exports.RedoTool = redo_tool_1.RedoTool;\r\n    var reset_tool_1 = require(349) /* ./actions/reset_tool */;\r\n    exports.ResetTool = reset_tool_1.ResetTool;\r\n    var save_tool_1 = require(350) /* ./actions/save_tool */;\r\n    exports.SaveTool = save_tool_1.SaveTool;\r\n    var undo_tool_1 = require(351) /* ./actions/undo_tool */;\r\n    exports.UndoTool = undo_tool_1.UndoTool;\r\n    var zoom_in_tool_1 = require(352) /* ./actions/zoom_in_tool */;\r\n    exports.ZoomInTool = zoom_in_tool_1.ZoomInTool;\r\n    var zoom_out_tool_1 = require(355) /* ./actions/zoom_out_tool */;\r\n    exports.ZoomOutTool = zoom_out_tool_1.ZoomOutTool;\r\n    var button_tool_1 = require(296) /* ./button_tool */;\r\n    exports.ButtonTool = button_tool_1.ButtonTool;\r\n    var edit_tool_1 = require(356) /* ./edit/edit_tool */;\r\n    exports.EditTool = edit_tool_1.EditTool;\r\n    var box_edit_tool_1 = require(357) /* ./edit/box_edit_tool */;\r\n    exports.BoxEditTool = box_edit_tool_1.BoxEditTool;\r\n    var freehand_draw_tool_1 = require(358) /* ./edit/freehand_draw_tool */;\r\n    exports.FreehandDrawTool = freehand_draw_tool_1.FreehandDrawTool;\r\n    var point_draw_tool_1 = require(359) /* ./edit/point_draw_tool */;\r\n    exports.PointDrawTool = point_draw_tool_1.PointDrawTool;\r\n    var poly_draw_tool_1 = require(360) /* ./edit/poly_draw_tool */;\r\n    exports.PolyDrawTool = poly_draw_tool_1.PolyDrawTool;\r\n    var poly_tool_1 = require(361) /* ./edit/poly_tool */;\r\n    exports.PolyTool = poly_tool_1.PolyTool;\r\n    var poly_edit_tool_1 = require(362) /* ./edit/poly_edit_tool */;\r\n    exports.PolyEditTool = poly_edit_tool_1.PolyEditTool;\r\n    var box_select_tool_1 = require(363) /* ./gestures/box_select_tool */;\r\n    exports.BoxSelectTool = box_select_tool_1.BoxSelectTool;\r\n    var box_zoom_tool_1 = require(366) /* ./gestures/box_zoom_tool */;\r\n    exports.BoxZoomTool = box_zoom_tool_1.BoxZoomTool;\r\n    var gesture_tool_1 = require(306) /* ./gestures/gesture_tool */;\r\n    exports.GestureTool = gesture_tool_1.GestureTool;\r\n    var lasso_select_tool_1 = require(367) /* ./gestures/lasso_select_tool */;\r\n    exports.LassoSelectTool = lasso_select_tool_1.LassoSelectTool;\r\n    var line_edit_tool_1 = require(369) /* ./edit/line_edit_tool */;\r\n    exports.LineEditTool = line_edit_tool_1.LineEditTool;\r\n    var pan_tool_1 = require(371) /* ./gestures/pan_tool */;\r\n    exports.PanTool = pan_tool_1.PanTool;\r\n    var poly_select_tool_1 = require(368) /* ./gestures/poly_select_tool */;\r\n    exports.PolySelectTool = poly_select_tool_1.PolySelectTool;\r\n    var range_tool_1 = require(372) /* ./gestures/range_tool */;\r\n    exports.RangeTool = range_tool_1.RangeTool;\r\n    var select_tool_1 = require(364) /* ./gestures/select_tool */;\r\n    exports.SelectTool = select_tool_1.SelectTool;\r\n    var tap_tool_1 = require(373) /* ./gestures/tap_tool */;\r\n    exports.TapTool = tap_tool_1.TapTool;\r\n    var wheel_pan_tool_1 = require(374) /* ./gestures/wheel_pan_tool */;\r\n    exports.WheelPanTool = wheel_pan_tool_1.WheelPanTool;\r\n    var wheel_zoom_tool_1 = require(375) /* ./gestures/wheel_zoom_tool */;\r\n    exports.WheelZoomTool = wheel_zoom_tool_1.WheelZoomTool;\r\n    var crosshair_tool_1 = require(376) /* ./inspectors/crosshair_tool */;\r\n    exports.CrosshairTool = crosshair_tool_1.CrosshairTool;\r\n    var customjs_hover_1 = require(377) /* ./inspectors/customjs_hover */;\r\n    exports.CustomJSHover = customjs_hover_1.CustomJSHover;\r\n    var hover_tool_1 = require(378) /* ./inspectors/hover_tool */;\r\n    exports.HoverTool = hover_tool_1.HoverTool;\r\n    var inspect_tool_1 = require(295) /* ./inspectors/inspect_tool */;\r\n    exports.InspectTool = inspect_tool_1.InspectTool;\r\n    var tool_1 = require(298) /* ./tool */;\r\n    exports.Tool = tool_1.Tool;\r\n    var tool_proxy_1 = require(379) /* ./tool_proxy */;\r\n    exports.ToolProxy = tool_proxy_1.ToolProxy;\r\n    var toolbar_1 = require(294) /* ./toolbar */;\r\n    exports.Toolbar = toolbar_1.Toolbar;\r\n    var toolbar_base_1 = require(305) /* ./toolbar_base */;\r\n    exports.ToolbarBase = toolbar_base_1.ToolbarBase;\r\n    var toolbar_box_1 = require(380) /* ./toolbar_box */;\r\n    exports.ProxyToolbar = toolbar_box_1.ProxyToolbar;\r\n    var toolbar_box_2 = require(380) /* ./toolbar_box */;\r\n    exports.ToolbarBox = toolbar_box_2.ToolbarBox;\r\n}\r\n","/* models\\tools\\actions\\custom_action.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const action_tool_1 = require(307) /* ./action_tool */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const toolbar_1 = require(299) /* ../../../styles/toolbar */;\r\n    class CustomActionButtonView extends action_tool_1.ActionToolButtonView {\r\n        css_classes() {\r\n            return super.css_classes().concat(toolbar_1.bk_toolbar_button_custom_action);\r\n        }\r\n    }\r\n    exports.CustomActionButtonView = CustomActionButtonView;\r\n    CustomActionButtonView.__name__ = \"CustomActionButtonView\";\r\n    class CustomActionView extends action_tool_1.ActionToolView {\r\n        doit() {\r\n            if (this.model.callback != null)\r\n                this.model.callback.execute(this.model);\r\n        }\r\n    }\r\n    exports.CustomActionView = CustomActionView;\r\n    CustomActionView.__name__ = \"CustomActionView\";\r\n    class CustomAction extends action_tool_1.ActionTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Custom Action\";\r\n            this.button_view = CustomActionButtonView;\r\n        }\r\n        static init_CustomAction() {\r\n            this.prototype.default_view = CustomActionView;\r\n            this.define({\r\n                action_tooltip: [p.String, 'Perform a Custom Action'],\r\n                callback: [p.Any],\r\n                icon: [p.String],\r\n            });\r\n        }\r\n        get tooltip() {\r\n            return this.action_tooltip;\r\n        }\r\n    }\r\n    exports.CustomAction = CustomAction;\r\n    CustomAction.__name__ = \"CustomAction\";\r\n    CustomAction.init_CustomAction();\r\n}\r\n","/* models\\tools\\actions\\redo_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const action_tool_1 = require(307) /* ./action_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class RedoToolView extends action_tool_1.ActionToolView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.plot_view.state_changed, () => this.model.disabled = !this.plot_view.can_redo());\r\n        }\r\n        doit() {\r\n            this.plot_view.redo();\r\n        }\r\n    }\r\n    exports.RedoToolView = RedoToolView;\r\n    RedoToolView.__name__ = \"RedoToolView\";\r\n    class RedoTool extends action_tool_1.ActionTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Redo\";\r\n            this.icon = icons_1.bk_tool_icon_redo;\r\n        }\r\n        static init_RedoTool() {\r\n            this.prototype.default_view = RedoToolView;\r\n            this.override({\r\n                disabled: true,\r\n            });\r\n            this.register_alias(\"redo\", () => new RedoTool());\r\n        }\r\n    }\r\n    exports.RedoTool = RedoTool;\r\n    RedoTool.__name__ = \"RedoTool\";\r\n    RedoTool.init_RedoTool();\r\n}\r\n","/* models\\tools\\actions\\reset_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const action_tool_1 = require(307) /* ./action_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class ResetToolView extends action_tool_1.ActionToolView {\r\n        doit() {\r\n            this.plot_view.reset();\r\n        }\r\n    }\r\n    exports.ResetToolView = ResetToolView;\r\n    ResetToolView.__name__ = \"ResetToolView\";\r\n    class ResetTool extends action_tool_1.ActionTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Reset\";\r\n            this.icon = icons_1.bk_tool_icon_reset;\r\n        }\r\n        static init_ResetTool() {\r\n            this.prototype.default_view = ResetToolView;\r\n            this.register_alias(\"reset\", () => new ResetTool());\r\n        }\r\n    }\r\n    exports.ResetTool = ResetTool;\r\n    ResetTool.__name__ = \"ResetTool\";\r\n    ResetTool.init_ResetTool();\r\n}\r\n","/* models\\tools\\actions\\save_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const action_tool_1 = require(307) /* ./action_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class SaveToolView extends action_tool_1.ActionToolView {\r\n        async copy() {\r\n            const blob = await this.plot_view.to_blob();\r\n            const item = new ClipboardItem({ [blob.type]: blob });\r\n            await navigator.clipboard.write([item]);\r\n        }\r\n        async save(name) {\r\n            const blob = await this.plot_view.to_blob();\r\n            const link = document.createElement(\"a\");\r\n            link.href = URL.createObjectURL(blob);\r\n            link.download = name; // + \".png\" | \"svg\" (inferred from MIME type)\r\n            link.target = \"_blank\";\r\n            link.dispatchEvent(new MouseEvent(\"click\"));\r\n        }\r\n        doit(action = \"save\") {\r\n            switch (action) {\r\n                case \"save\":\r\n                    this.save(\"bokeh_plot\");\r\n                    break;\r\n                case \"copy\":\r\n                    this.copy();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    exports.SaveToolView = SaveToolView;\r\n    SaveToolView.__name__ = \"SaveToolView\";\r\n    class SaveTool extends action_tool_1.ActionTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Save\";\r\n            this.icon = icons_1.bk_tool_icon_save;\r\n        }\r\n        static init_SaveTool() {\r\n            this.prototype.default_view = SaveToolView;\r\n            this.register_alias(\"save\", () => new SaveTool());\r\n        }\r\n        get menu() {\r\n            return [\r\n                {\r\n                    icon: \"bk-tool-icon-copy-to-clipboard\",\r\n                    tooltip: \"Copy image to clipboard\",\r\n                    if: () => typeof ClipboardItem !== \"undefined\",\r\n                    handler: () => {\r\n                        this.do.emit(\"copy\");\r\n                    },\r\n                },\r\n            ];\r\n        }\r\n    }\r\n    exports.SaveTool = SaveTool;\r\n    SaveTool.__name__ = \"SaveTool\";\r\n    SaveTool.init_SaveTool();\r\n}\r\n","/* models\\tools\\actions\\undo_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const action_tool_1 = require(307) /* ./action_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class UndoToolView extends action_tool_1.ActionToolView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.plot_view.state_changed, () => this.model.disabled = !this.plot_view.can_undo());\r\n        }\r\n        doit() {\r\n            this.plot_view.undo();\r\n        }\r\n    }\r\n    exports.UndoToolView = UndoToolView;\r\n    UndoToolView.__name__ = \"UndoToolView\";\r\n    class UndoTool extends action_tool_1.ActionTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Undo\";\r\n            this.icon = icons_1.bk_tool_icon_undo;\r\n        }\r\n        static init_UndoTool() {\r\n            this.prototype.default_view = UndoToolView;\r\n            this.override({\r\n                disabled: true,\r\n            });\r\n            this.register_alias(\"undo\", () => new UndoTool());\r\n        }\r\n    }\r\n    exports.UndoTool = UndoTool;\r\n    UndoTool.__name__ = \"UndoTool\";\r\n    UndoTool.init_UndoTool();\r\n}\r\n","/* models\\tools\\actions\\zoom_in_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const zoom_base_tool_1 = require(353) /* ./zoom_base_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class ZoomInTool extends zoom_base_tool_1.ZoomBaseTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.sign = 1;\r\n            this.tool_name = \"Zoom In\";\r\n            this.icon = icons_1.bk_tool_icon_zoom_in;\r\n        }\r\n        static init_ZoomInTool() {\r\n            this.prototype.default_view = zoom_base_tool_1.ZoomBaseToolView;\r\n            this.register_alias(\"zoom_in\", () => new ZoomInTool({ dimensions: 'both' }));\r\n            this.register_alias(\"xzoom_in\", () => new ZoomInTool({ dimensions: 'width' }));\r\n            this.register_alias(\"yzoom_in\", () => new ZoomInTool({ dimensions: 'height' }));\r\n        }\r\n    }\r\n    exports.ZoomInTool = ZoomInTool;\r\n    ZoomInTool.__name__ = \"ZoomInTool\";\r\n    ZoomInTool.init_ZoomInTool();\r\n}\r\n","/* models\\tools\\actions\\zoom_base_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const action_tool_1 = require(307) /* ./action_tool */;\r\n    const zoom_1 = require(354) /* ../../../core/util/zoom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    class ZoomBaseToolView extends action_tool_1.ActionToolView {\r\n        doit() {\r\n            const frame = this.plot_view.frame;\r\n            const dims = this.model.dimensions;\r\n            // restrict to axis configured in tool's dimensions property\r\n            const h_axis = dims == 'width' || dims == 'both';\r\n            const v_axis = dims == 'height' || dims == 'both';\r\n            const zoom_info = zoom_1.scale_range(frame, this.model.sign * this.model.factor, h_axis, v_axis);\r\n            this.plot_view.push_state('zoom_out', { range: zoom_info });\r\n            this.plot_view.update_range(zoom_info, false, true);\r\n            if (this.model.document)\r\n                this.model.document.interactive_start(this.plot_model);\r\n        }\r\n    }\r\n    exports.ZoomBaseToolView = ZoomBaseToolView;\r\n    ZoomBaseToolView.__name__ = \"ZoomBaseToolView\";\r\n    class ZoomBaseTool extends action_tool_1.ActionTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ZoomBaseTool() {\r\n            this.prototype.default_view = ZoomBaseToolView;\r\n            this.define({\r\n                factor: [p.Percent, 0.1],\r\n                dimensions: [p.Dimensions, \"both\"],\r\n            });\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\r\n        }\r\n    }\r\n    exports.ZoomBaseTool = ZoomBaseTool;\r\n    ZoomBaseTool.__name__ = \"ZoomBaseTool\";\r\n    ZoomBaseTool.init_ZoomBaseTool();\r\n}\r\n","/* core\\util\\zoom.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const math_1 = require(10) /* ./math */;\r\n    // Module for zoom-related functions\r\n    function scale_highlow(range, factor, center) {\r\n        const [low, high] = [range.start, range.end];\r\n        const x = center != null ? center : (high + low) / 2.0;\r\n        const x0 = low - (low - x) * factor;\r\n        const x1 = high - (high - x) * factor;\r\n        return [x0, x1];\r\n    }\r\n    exports.scale_highlow = scale_highlow;\r\n    function get_info(scales, [sxy0, sxy1]) {\r\n        const info = new Map();\r\n        for (const [name, scale] of scales) {\r\n            const [start, end] = scale.r_invert(sxy0, sxy1);\r\n            info.set(name, { start, end });\r\n        }\r\n        return info;\r\n    }\r\n    exports.get_info = get_info;\r\n    function scale_range(frame, factor, h_axis = true, v_axis = true, center) {\r\n        /*\r\n         * Utility function for zoom tools to calculate/create the zoom_info object\r\n         * of the form required by ``PlotView.update_range``\r\n         *\r\n         * Parameters:\r\n         *   frame : CartesianFrame\r\n         *   factor : Number\r\n         *   h_axis : Boolean, optional\r\n         *     whether to zoom the horizontal axis (default = true)\r\n         *   v_axis : Boolean, optional\r\n         *     whether to zoom the horizontal axis (default = true)\r\n         *   center : object, optional\r\n         *     of form {'x': Number, 'y', Number}\r\n         *\r\n         * Returns:\r\n         *   object:\r\n         */\r\n        // clamp the  magnitude of factor, if it is > 1 bad things happen\r\n        factor = math_1.clamp(factor, -0.9, 0.9);\r\n        const hfactor = h_axis ? factor : 0;\r\n        const [sx0, sx1] = scale_highlow(frame.bbox.h_range, hfactor, center != null ? center.x : undefined);\r\n        const xrs = get_info(frame.x_scales, [sx0, sx1]);\r\n        const vfactor = v_axis ? factor : 0;\r\n        const [sy0, sy1] = scale_highlow(frame.bbox.v_range, vfactor, center != null ? center.y : undefined);\r\n        const yrs = get_info(frame.y_scales, [sy0, sy1]);\r\n        // OK this sucks we can't set factor independently in each direction. It is used\r\n        // for GMap plots, and GMap plots always preserve aspect, so effective the value\r\n        // of 'dimensions' is ignored.\r\n        return { xrs, yrs, factor };\r\n    }\r\n    exports.scale_range = scale_range;\r\n}\r\n","/* models\\tools\\actions\\zoom_out_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const zoom_base_tool_1 = require(353) /* ./zoom_base_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class ZoomOutTool extends zoom_base_tool_1.ZoomBaseTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.sign = -1;\r\n            this.tool_name = \"Zoom Out\";\r\n            this.icon = icons_1.bk_tool_icon_zoom_out;\r\n        }\r\n        static init_ZoomOutTool() {\r\n            this.prototype.default_view = zoom_base_tool_1.ZoomBaseToolView;\r\n            this.register_alias(\"zoom_out\", () => new ZoomOutTool({ dimensions: 'both' }));\r\n            this.register_alias(\"xzoom_out\", () => new ZoomOutTool({ dimensions: 'width' }));\r\n            this.register_alias(\"yzoom_out\", () => new ZoomOutTool({ dimensions: 'height' }));\r\n        }\r\n    }\r\n    exports.ZoomOutTool = ZoomOutTool;\r\n    ZoomOutTool.__name__ = \"ZoomOutTool\";\r\n    ZoomOutTool.init_ZoomOutTool();\r\n}\r\n","/* models\\tools\\edit\\edit_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const array_1 = require(9) /* ../../../core/util/array */;\r\n    const types_1 = require(8) /* ../../../core/util/types */;\r\n    const assert_1 = require(11) /* ../../../core/util/assert */;\r\n    const gesture_tool_1 = require(306) /* ../gestures/gesture_tool */;\r\n    class EditToolView extends gesture_tool_1.GestureToolView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._mouse_in_frame = true;\r\n        }\r\n        _select_mode(ev) {\r\n            const { shiftKey, ctrlKey } = ev;\r\n            if (!shiftKey && !ctrlKey)\r\n                return \"replace\";\r\n            else if (shiftKey && !ctrlKey)\r\n                return \"append\";\r\n            else if (!shiftKey && ctrlKey)\r\n                return \"intersect\";\r\n            else if (shiftKey && ctrlKey)\r\n                return \"subtract\";\r\n            else\r\n                assert_1.unreachable();\r\n        }\r\n        _move_enter(_e) {\r\n            this._mouse_in_frame = true;\r\n        }\r\n        _move_exit(_e) {\r\n            this._mouse_in_frame = false;\r\n        }\r\n        _map_drag(sx, sy, renderer) {\r\n            // Maps screen to data coordinates\r\n            const frame = this.plot_view.frame;\r\n            if (!frame.bbox.contains(sx, sy)) {\r\n                return null;\r\n            }\r\n            const renderer_view = this.plot_view.renderer_views.get(renderer);\r\n            const x = renderer_view.coordinates.x_scale.invert(sx);\r\n            const y = renderer_view.coordinates.y_scale.invert(sy);\r\n            return [x, y];\r\n        }\r\n        _delete_selected(renderer) {\r\n            // Deletes all selected rows in the ColumnDataSource\r\n            const cds = renderer.data_source;\r\n            const indices = cds.selected.indices;\r\n            indices.sort();\r\n            for (const column of cds.columns()) {\r\n                const values = cds.get_array(column);\r\n                for (let index = 0; index < indices.length; index++) {\r\n                    const ind = indices[index];\r\n                    values.splice(ind - index, 1);\r\n                }\r\n            }\r\n            this._emit_cds_changes(cds);\r\n        }\r\n        _pop_glyphs(cds, num_objects) {\r\n            // Pops rows in the CDS until only num_objects are left\r\n            const columns = cds.columns();\r\n            if (!num_objects || !columns.length)\r\n                return;\r\n            for (const column of columns) {\r\n                let array = cds.get_array(column);\r\n                const drop = array.length - num_objects + 1;\r\n                if (drop < 1)\r\n                    continue;\r\n                if (!types_1.isArray(array)) {\r\n                    array = Array.from(array);\r\n                    cds.data[column] = array;\r\n                }\r\n                array.splice(0, drop);\r\n            }\r\n        }\r\n        _emit_cds_changes(cds, redraw = true, clear = true, emit = true) {\r\n            if (clear)\r\n                cds.selection_manager.clear();\r\n            if (redraw)\r\n                cds.change.emit();\r\n            if (emit) {\r\n                cds.data = cds.data;\r\n                cds.properties.data.change.emit();\r\n            }\r\n        }\r\n        _drag_points(ev, renderers, dim = \"both\") {\r\n            if (this._basepoint == null)\r\n                return;\r\n            const [bx, by] = this._basepoint;\r\n            for (const renderer of renderers) {\r\n                const basepoint = this._map_drag(bx, by, renderer);\r\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n                if (point == null || basepoint == null) {\r\n                    continue;\r\n                }\r\n                const [x, y] = point;\r\n                const [px, py] = basepoint;\r\n                const [dx, dy] = [x - px, y - py];\r\n                // Type once dataspecs are typed\r\n                const glyph = renderer.glyph;\r\n                const cds = renderer.data_source;\r\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\r\n                for (const index of cds.selected.indices) {\r\n                    if (xkey && (dim == \"width\" || dim == \"both\")) {\r\n                        cds.data[xkey][index] += dx;\r\n                    }\r\n                    if (ykey && (dim == \"height\" || dim == \"both\")) {\r\n                        cds.data[ykey][index] += dy;\r\n                    }\r\n                }\r\n                cds.change.emit();\r\n            }\r\n            this._basepoint = [ev.sx, ev.sy];\r\n        }\r\n        _pad_empty_columns(cds, coord_columns) {\r\n            // Pad ColumnDataSource non-coordinate columns with empty_value\r\n            for (const column of cds.columns()) {\r\n                if (!array_1.includes(coord_columns, column))\r\n                    cds.get_array(column).push(this.model.empty_value);\r\n            }\r\n        }\r\n        _select_event(ev, mode, renderers) {\r\n            // Process selection event on the supplied renderers and return selected renderers\r\n            const frame = this.plot_view.frame;\r\n            const { sx, sy } = ev;\r\n            if (!frame.bbox.contains(sx, sy)) {\r\n                return [];\r\n            }\r\n            const geometry = { type: 'point', sx, sy };\r\n            const selected = [];\r\n            for (const renderer of renderers) {\r\n                const sm = renderer.get_selection_manager();\r\n                const cds = renderer.data_source;\r\n                const views = [this.plot_view.renderer_views.get(renderer)];\r\n                const did_hit = sm.select(views, geometry, true, mode);\r\n                if (did_hit) {\r\n                    selected.push(renderer);\r\n                }\r\n                cds.properties.selected.change.emit();\r\n            }\r\n            return selected;\r\n        }\r\n    }\r\n    exports.EditToolView = EditToolView;\r\n    EditToolView.__name__ = \"EditToolView\";\r\n    class EditTool extends gesture_tool_1.GestureTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_EditTool() {\r\n            this.define({\r\n                custom_icon: [p.String],\r\n                custom_tooltip: [p.String],\r\n                empty_value: [p.Any],\r\n                renderers: [p.Array, []],\r\n            });\r\n        }\r\n        get tooltip() {\r\n            return this.custom_tooltip || this.tool_name;\r\n        }\r\n        get computed_icon() {\r\n            return this.custom_icon || this.icon;\r\n        }\r\n    }\r\n    exports.EditTool = EditTool;\r\n    EditTool.__name__ = \"EditTool\";\r\n    EditTool.init_EditTool();\r\n}\r\n","/* models\\tools\\edit\\box_edit_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const edit_tool_1 = require(356) /* ./edit_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class BoxEditToolView extends edit_tool_1.EditToolView {\r\n        _tap(ev) {\r\n            if ((this._draw_basepoint != null) || (this._basepoint != null))\r\n                return;\r\n            this._select_event(ev, this._select_mode(ev), this.model.renderers);\r\n        }\r\n        _keyup(ev) {\r\n            if (!this.model.active || !this._mouse_in_frame)\r\n                return;\r\n            for (const renderer of this.model.renderers) {\r\n                if (ev.keyCode === dom_1.Keys.Backspace) {\r\n                    this._delete_selected(renderer);\r\n                }\r\n                else if (ev.keyCode == dom_1.Keys.Esc) {\r\n                    // Type properly once selection_manager is typed\r\n                    const cds = renderer.data_source;\r\n                    cds.selection_manager.clear();\r\n                }\r\n            }\r\n        }\r\n        _set_extent([sx0, sx1], [sy0, sy1], append, emit = false) {\r\n            const renderer = this.model.renderers[0];\r\n            const renderer_view = this.plot_view.renderer_views.get(renderer);\r\n            // Type once dataspecs are typed\r\n            const glyph = renderer.glyph;\r\n            const cds = renderer.data_source;\r\n            const [x0, x1] = renderer_view.coordinates.x_scale.r_invert(sx0, sx1);\r\n            const [y0, y1] = renderer_view.coordinates.y_scale.r_invert(sy0, sy1);\r\n            const [x, y] = [(x0 + x1) / 2, (y0 + y1) / 2];\r\n            const [w, h] = [x1 - x0, y1 - y0];\r\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\r\n            const [wkey, hkey] = [glyph.width.field, glyph.height.field];\r\n            if (append) {\r\n                this._pop_glyphs(cds, this.model.num_objects);\r\n                if (xkey)\r\n                    cds.get_array(xkey).push(x);\r\n                if (ykey)\r\n                    cds.get_array(ykey).push(y);\r\n                if (wkey)\r\n                    cds.get_array(wkey).push(w);\r\n                if (hkey)\r\n                    cds.get_array(hkey).push(h);\r\n                this._pad_empty_columns(cds, [xkey, ykey, wkey, hkey]);\r\n            }\r\n            else {\r\n                const index = cds.data[xkey].length - 1;\r\n                if (xkey)\r\n                    cds.data[xkey][index] = x;\r\n                if (ykey)\r\n                    cds.data[ykey][index] = y;\r\n                if (wkey)\r\n                    cds.data[wkey][index] = w;\r\n                if (hkey)\r\n                    cds.data[hkey][index] = h;\r\n            }\r\n            this._emit_cds_changes(cds, true, false, emit);\r\n        }\r\n        _update_box(ev, append = false, emit = false) {\r\n            if (this._draw_basepoint == null)\r\n                return;\r\n            const curpoint = [ev.sx, ev.sy];\r\n            const frame = this.plot_view.frame;\r\n            const dims = this.model.dimensions;\r\n            const limits = this.model._get_dim_limits(this._draw_basepoint, curpoint, frame, dims);\r\n            if (limits != null) {\r\n                const [sxlim, sylim] = limits;\r\n                this._set_extent(sxlim, sylim, append, emit);\r\n            }\r\n        }\r\n        _doubletap(ev) {\r\n            if (!this.model.active)\r\n                return;\r\n            if (this._draw_basepoint != null) {\r\n                this._update_box(ev, false, true);\r\n                this._draw_basepoint = null;\r\n            }\r\n            else {\r\n                this._draw_basepoint = [ev.sx, ev.sy];\r\n                this._select_event(ev, \"append\", this.model.renderers);\r\n                this._update_box(ev, true, false);\r\n            }\r\n        }\r\n        _move(ev) {\r\n            this._update_box(ev, false, false);\r\n        }\r\n        _pan_start(ev) {\r\n            if (ev.shiftKey) {\r\n                if (this._draw_basepoint != null)\r\n                    return;\r\n                this._draw_basepoint = [ev.sx, ev.sy];\r\n                this._update_box(ev, true, false);\r\n            }\r\n            else {\r\n                if (this._basepoint != null)\r\n                    return;\r\n                this._select_event(ev, \"append\", this.model.renderers);\r\n                this._basepoint = [ev.sx, ev.sy];\r\n            }\r\n        }\r\n        _pan(ev, append = false, emit = false) {\r\n            if (ev.shiftKey) {\r\n                if (this._draw_basepoint == null)\r\n                    return;\r\n                this._update_box(ev, append, emit);\r\n            }\r\n            else {\r\n                if (this._basepoint == null)\r\n                    return;\r\n                this._drag_points(ev, this.model.renderers);\r\n            }\r\n        }\r\n        _pan_end(ev) {\r\n            this._pan(ev, false, true);\r\n            if (ev.shiftKey) {\r\n                this._draw_basepoint = null;\r\n            }\r\n            else {\r\n                this._basepoint = null;\r\n                for (const renderer of this.model.renderers)\r\n                    this._emit_cds_changes(renderer.data_source, false, true, true);\r\n            }\r\n        }\r\n    }\r\n    exports.BoxEditToolView = BoxEditToolView;\r\n    BoxEditToolView.__name__ = \"BoxEditToolView\";\r\n    class BoxEditTool extends edit_tool_1.EditTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Box Edit Tool\";\r\n            this.icon = icons_1.bk_tool_icon_box_edit;\r\n            this.event_type = [\"tap\", \"pan\", \"move\"];\r\n            this.default_order = 1;\r\n        }\r\n        static init_BoxEditTool() {\r\n            this.prototype.default_view = BoxEditToolView;\r\n            this.define({\r\n                dimensions: [p.Dimensions, \"both\"],\r\n                num_objects: [p.Int, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.BoxEditTool = BoxEditTool;\r\n    BoxEditTool.__name__ = \"BoxEditTool\";\r\n    BoxEditTool.init_BoxEditTool();\r\n}\r\n","/* models\\tools\\edit\\freehand_draw_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const types_1 = require(8) /* ../../../core/util/types */;\r\n    const edit_tool_1 = require(356) /* ./edit_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class FreehandDrawToolView extends edit_tool_1.EditToolView {\r\n        _draw(ev, mode, emit = false) {\r\n            if (!this.model.active)\r\n                return;\r\n            const renderer = this.model.renderers[0];\r\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n            if (point == null)\r\n                return;\r\n            const [x, y] = point;\r\n            const cds = renderer.data_source;\r\n            const glyph = renderer.glyph;\r\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\r\n            if (mode == 'new') {\r\n                this._pop_glyphs(cds, this.model.num_objects);\r\n                if (xkey)\r\n                    cds.get_array(xkey).push([x]);\r\n                if (ykey)\r\n                    cds.get_array(ykey).push([y]);\r\n                this._pad_empty_columns(cds, [xkey, ykey]);\r\n            }\r\n            else if (mode == 'add') {\r\n                if (xkey) {\r\n                    const xidx = cds.data[xkey].length - 1;\r\n                    let xs = cds.get_array(xkey)[xidx];\r\n                    if (!types_1.isArray(xs)) {\r\n                        xs = Array.from(xs);\r\n                        cds.data[xkey][xidx] = xs;\r\n                    }\r\n                    xs.push(x);\r\n                }\r\n                if (ykey) {\r\n                    const yidx = cds.data[ykey].length - 1;\r\n                    let ys = cds.get_array(ykey)[yidx];\r\n                    if (!types_1.isArray(ys)) {\r\n                        ys = Array.from(ys);\r\n                        cds.data[ykey][yidx] = ys;\r\n                    }\r\n                    ys.push(y);\r\n                }\r\n            }\r\n            this._emit_cds_changes(cds, true, true, emit);\r\n        }\r\n        _pan_start(ev) {\r\n            this._draw(ev, 'new');\r\n        }\r\n        _pan(ev) {\r\n            this._draw(ev, 'add');\r\n        }\r\n        _pan_end(ev) {\r\n            this._draw(ev, 'add', true);\r\n        }\r\n        _tap(ev) {\r\n            this._select_event(ev, this._select_mode(ev), this.model.renderers);\r\n        }\r\n        _keyup(ev) {\r\n            if (!this.model.active || !this._mouse_in_frame)\r\n                return;\r\n            for (const renderer of this.model.renderers) {\r\n                if (ev.keyCode === dom_1.Keys.Esc) {\r\n                    renderer.data_source.selection_manager.clear();\r\n                }\r\n                else if (ev.keyCode === dom_1.Keys.Backspace) {\r\n                    this._delete_selected(renderer);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.FreehandDrawToolView = FreehandDrawToolView;\r\n    FreehandDrawToolView.__name__ = \"FreehandDrawToolView\";\r\n    class FreehandDrawTool extends edit_tool_1.EditTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Freehand Draw Tool\";\r\n            this.icon = icons_1.bk_tool_icon_freehand_draw;\r\n            this.event_type = [\"pan\", \"tap\"];\r\n            this.default_order = 3;\r\n        }\r\n        static init_FreehandDrawTool() {\r\n            this.prototype.default_view = FreehandDrawToolView;\r\n            this.define({\r\n                num_objects: [p.Int, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.FreehandDrawTool = FreehandDrawTool;\r\n    FreehandDrawTool.__name__ = \"FreehandDrawTool\";\r\n    FreehandDrawTool.init_FreehandDrawTool();\r\n}\r\n","/* models\\tools\\edit\\point_draw_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const edit_tool_1 = require(356) /* ./edit_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class PointDrawToolView extends edit_tool_1.EditToolView {\r\n        _tap(ev) {\r\n            const renderers = this._select_event(ev, this._select_mode(ev), this.model.renderers);\r\n            if (renderers.length || !this.model.add) {\r\n                return;\r\n            }\r\n            const renderer = this.model.renderers[0];\r\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n            if (point == null)\r\n                return;\r\n            // Type once dataspecs are typed\r\n            const glyph = renderer.glyph;\r\n            const cds = renderer.data_source;\r\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\r\n            const [x, y] = point;\r\n            this._pop_glyphs(cds, this.model.num_objects);\r\n            if (xkey)\r\n                cds.get_array(xkey).push(x);\r\n            if (ykey)\r\n                cds.get_array(ykey).push(y);\r\n            this._pad_empty_columns(cds, [xkey, ykey]);\r\n            cds.change.emit();\r\n            cds.data = cds.data;\r\n            cds.properties.data.change.emit();\r\n        }\r\n        _keyup(ev) {\r\n            if (!this.model.active || !this._mouse_in_frame)\r\n                return;\r\n            for (const renderer of this.model.renderers) {\r\n                if (ev.keyCode === dom_1.Keys.Backspace) {\r\n                    this._delete_selected(renderer);\r\n                }\r\n                else if (ev.keyCode == dom_1.Keys.Esc) {\r\n                    renderer.data_source.selection_manager.clear();\r\n                }\r\n            }\r\n        }\r\n        _pan_start(ev) {\r\n            if (!this.model.drag)\r\n                return;\r\n            this._select_event(ev, \"append\", this.model.renderers);\r\n            this._basepoint = [ev.sx, ev.sy];\r\n        }\r\n        _pan(ev) {\r\n            if (!this.model.drag || this._basepoint == null)\r\n                return;\r\n            this._drag_points(ev, this.model.renderers);\r\n        }\r\n        _pan_end(ev) {\r\n            if (!this.model.drag)\r\n                return;\r\n            this._pan(ev);\r\n            for (const renderer of this.model.renderers)\r\n                this._emit_cds_changes(renderer.data_source, false, true, true);\r\n            this._basepoint = null;\r\n        }\r\n    }\r\n    exports.PointDrawToolView = PointDrawToolView;\r\n    PointDrawToolView.__name__ = \"PointDrawToolView\";\r\n    class PointDrawTool extends edit_tool_1.EditTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Point Draw Tool\";\r\n            this.icon = icons_1.bk_tool_icon_point_draw;\r\n            this.event_type = [\"tap\", \"pan\", \"move\"];\r\n            this.default_order = 2;\r\n        }\r\n        static init_PointDrawTool() {\r\n            this.prototype.default_view = PointDrawToolView;\r\n            this.define({\r\n                add: [p.Boolean, true],\r\n                drag: [p.Boolean, true],\r\n                num_objects: [p.Int, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.PointDrawTool = PointDrawTool;\r\n    PointDrawTool.__name__ = \"PointDrawTool\";\r\n    PointDrawTool.init_PointDrawTool();\r\n}\r\n","/* models\\tools\\edit\\poly_draw_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const types_1 = require(8) /* ../../../core/util/types */;\r\n    const poly_tool_1 = require(361) /* ./poly_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class PolyDrawToolView extends poly_tool_1.PolyToolView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._drawing = false;\r\n            this._initialized = false;\r\n        }\r\n        _tap(ev) {\r\n            if (this._drawing)\r\n                this._draw(ev, 'add', true);\r\n            else\r\n                this._select_event(ev, this._select_mode(ev), this.model.renderers);\r\n        }\r\n        _draw(ev, mode, emit = false) {\r\n            const renderer = this.model.renderers[0];\r\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n            if (!this._initialized)\r\n                this.activate(); // Ensure that activate has been called\r\n            if (point == null)\r\n                return;\r\n            const [x, y] = this._snap_to_vertex(ev, ...point);\r\n            const cds = renderer.data_source;\r\n            const glyph = renderer.glyph;\r\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\r\n            if (mode == 'new') {\r\n                this._pop_glyphs(cds, this.model.num_objects);\r\n                if (xkey)\r\n                    cds.get_array(xkey).push([x, x]);\r\n                if (ykey)\r\n                    cds.get_array(ykey).push([y, y]);\r\n                this._pad_empty_columns(cds, [xkey, ykey]);\r\n            }\r\n            else if (mode == 'edit') {\r\n                if (xkey) {\r\n                    const xs = cds.data[xkey][cds.data[xkey].length - 1];\r\n                    xs[xs.length - 1] = x;\r\n                }\r\n                if (ykey) {\r\n                    const ys = cds.data[ykey][cds.data[ykey].length - 1];\r\n                    ys[ys.length - 1] = y;\r\n                }\r\n            }\r\n            else if (mode == 'add') {\r\n                if (xkey) {\r\n                    const xidx = cds.data[xkey].length - 1;\r\n                    let xs = cds.get_array(xkey)[xidx];\r\n                    const nx = xs[xs.length - 1];\r\n                    xs[xs.length - 1] = x;\r\n                    if (!types_1.isArray(xs)) {\r\n                        xs = Array.from(xs);\r\n                        cds.data[xkey][xidx] = xs;\r\n                    }\r\n                    xs.push(nx);\r\n                }\r\n                if (ykey) {\r\n                    const yidx = cds.data[ykey].length - 1;\r\n                    let ys = cds.get_array(ykey)[yidx];\r\n                    const ny = ys[ys.length - 1];\r\n                    ys[ys.length - 1] = y;\r\n                    if (!types_1.isArray(ys)) {\r\n                        ys = Array.from(ys);\r\n                        cds.data[ykey][yidx] = ys;\r\n                    }\r\n                    ys.push(ny);\r\n                }\r\n            }\r\n            this._emit_cds_changes(cds, true, false, emit);\r\n        }\r\n        _show_vertices() {\r\n            if (!this.model.active) {\r\n                return;\r\n            }\r\n            const xs = [];\r\n            const ys = [];\r\n            for (let i = 0; i < this.model.renderers.length; i++) {\r\n                const renderer = this.model.renderers[i];\r\n                const cds = renderer.data_source;\r\n                const glyph = renderer.glyph;\r\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\r\n                if (xkey) {\r\n                    for (const array of cds.get_array(xkey))\r\n                        Array.prototype.push.apply(xs, array);\r\n                }\r\n                if (ykey) {\r\n                    for (const array of cds.get_array(ykey))\r\n                        Array.prototype.push.apply(ys, array);\r\n                }\r\n                if (this._drawing && (i == (this.model.renderers.length - 1))) {\r\n                    // Skip currently drawn vertex\r\n                    xs.splice(xs.length - 1, 1);\r\n                    ys.splice(ys.length - 1, 1);\r\n                }\r\n            }\r\n            this._set_vertices(xs, ys);\r\n        }\r\n        _doubletap(ev) {\r\n            if (!this.model.active)\r\n                return;\r\n            if (this._drawing) {\r\n                this._drawing = false;\r\n                this._draw(ev, 'edit', true);\r\n            }\r\n            else {\r\n                this._drawing = true;\r\n                this._draw(ev, 'new', true);\r\n            }\r\n        }\r\n        _move(ev) {\r\n            if (this._drawing) {\r\n                this._draw(ev, 'edit');\r\n            }\r\n        }\r\n        _remove() {\r\n            const renderer = this.model.renderers[0];\r\n            const cds = renderer.data_source;\r\n            const glyph = renderer.glyph;\r\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\r\n            if (xkey) {\r\n                const xidx = cds.data[xkey].length - 1;\r\n                const xs = cds.get_array(xkey)[xidx];\r\n                xs.splice(xs.length - 1, 1);\r\n            }\r\n            if (ykey) {\r\n                const yidx = cds.data[ykey].length - 1;\r\n                const ys = cds.get_array(ykey)[yidx];\r\n                ys.splice(ys.length - 1, 1);\r\n            }\r\n            this._emit_cds_changes(cds);\r\n        }\r\n        _keyup(ev) {\r\n            if (!this.model.active || !this._mouse_in_frame)\r\n                return;\r\n            for (const renderer of this.model.renderers) {\r\n                if (ev.keyCode === dom_1.Keys.Backspace) {\r\n                    this._delete_selected(renderer);\r\n                }\r\n                else if (ev.keyCode == dom_1.Keys.Esc) {\r\n                    if (this._drawing) {\r\n                        this._remove();\r\n                        this._drawing = false;\r\n                    }\r\n                    renderer.data_source.selection_manager.clear();\r\n                }\r\n            }\r\n        }\r\n        _pan_start(ev) {\r\n            if (!this.model.drag)\r\n                return;\r\n            this._select_event(ev, \"append\", this.model.renderers);\r\n            this._basepoint = [ev.sx, ev.sy];\r\n        }\r\n        _pan(ev) {\r\n            if (this._basepoint == null || !this.model.drag)\r\n                return;\r\n            const [bx, by] = this._basepoint;\r\n            // Process polygon/line dragging\r\n            for (const renderer of this.model.renderers) {\r\n                const basepoint = this._map_drag(bx, by, renderer);\r\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n                if (point == null || basepoint == null)\r\n                    continue;\r\n                const cds = renderer.data_source;\r\n                // Type once dataspecs are typed\r\n                const glyph = renderer.glyph;\r\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\r\n                if (!xkey && !ykey)\r\n                    continue;\r\n                const [x, y] = point;\r\n                const [px, py] = basepoint;\r\n                const [dx, dy] = [x - px, y - py];\r\n                for (const index of cds.selected.indices) {\r\n                    let length, xs, ys;\r\n                    if (xkey)\r\n                        xs = cds.data[xkey][index];\r\n                    if (ykey) {\r\n                        ys = cds.data[ykey][index];\r\n                        length = ys.length;\r\n                    }\r\n                    else {\r\n                        length = xs.length;\r\n                    }\r\n                    for (let i = 0; i < length; i++) {\r\n                        if (xs)\r\n                            xs[i] += dx;\r\n                        if (ys)\r\n                            ys[i] += dy;\r\n                    }\r\n                }\r\n                cds.change.emit();\r\n            }\r\n            this._basepoint = [ev.sx, ev.sy];\r\n        }\r\n        _pan_end(ev) {\r\n            if (!this.model.drag)\r\n                return;\r\n            this._pan(ev);\r\n            for (const renderer of this.model.renderers)\r\n                this._emit_cds_changes(renderer.data_source);\r\n            this._basepoint = null;\r\n        }\r\n        activate() {\r\n            if (!this.model.vertex_renderer || !this.model.active)\r\n                return;\r\n            this._show_vertices();\r\n            if (!this._initialized) {\r\n                for (const renderer of this.model.renderers) {\r\n                    const cds = renderer.data_source;\r\n                    cds.connect(cds.properties.data.change, () => this._show_vertices());\r\n                }\r\n            }\r\n            this._initialized = true;\r\n        }\r\n        deactivate() {\r\n            if (this._drawing) {\r\n                this._remove();\r\n                this._drawing = false;\r\n            }\r\n            if (this.model.vertex_renderer)\r\n                this._hide_vertices();\r\n        }\r\n    }\r\n    exports.PolyDrawToolView = PolyDrawToolView;\r\n    PolyDrawToolView.__name__ = \"PolyDrawToolView\";\r\n    class PolyDrawTool extends poly_tool_1.PolyTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Polygon Draw Tool\";\r\n            this.icon = icons_1.bk_tool_icon_poly_draw;\r\n            this.event_type = [\"pan\", \"tap\", \"move\"];\r\n            this.default_order = 3;\r\n        }\r\n        static init_PolyDrawTool() {\r\n            this.prototype.default_view = PolyDrawToolView;\r\n            this.define({\r\n                drag: [p.Boolean, true],\r\n                num_objects: [p.Int, 0],\r\n            });\r\n        }\r\n    }\r\n    exports.PolyDrawTool = PolyDrawTool;\r\n    PolyDrawTool.__name__ = \"PolyDrawTool\";\r\n    PolyDrawTool.init_PolyDrawTool();\r\n}\r\n","/* models\\tools\\edit\\poly_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const types_1 = require(8) /* ../../../core/util/types */;\r\n    const edit_tool_1 = require(356) /* ./edit_tool */;\r\n    class PolyToolView extends edit_tool_1.EditToolView {\r\n        _set_vertices(xs, ys) {\r\n            const point_glyph = this.model.vertex_renderer.glyph;\r\n            const point_cds = this.model.vertex_renderer.data_source;\r\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\r\n            if (pxkey) {\r\n                if (types_1.isArray(xs))\r\n                    point_cds.data[pxkey] = xs;\r\n                else\r\n                    point_glyph.x = { value: xs };\r\n            }\r\n            if (pykey) {\r\n                if (types_1.isArray(ys))\r\n                    point_cds.data[pykey] = ys;\r\n                else\r\n                    point_glyph.y = { value: ys };\r\n            }\r\n            this._emit_cds_changes(point_cds, true, true, false);\r\n        }\r\n        _hide_vertices() {\r\n            this._set_vertices([], []);\r\n        }\r\n        _snap_to_vertex(ev, x, y) {\r\n            if (this.model.vertex_renderer) {\r\n                // If an existing vertex is hit snap to it\r\n                const vertex_selected = this._select_event(ev, \"replace\", [this.model.vertex_renderer]);\r\n                const point_ds = this.model.vertex_renderer.data_source;\r\n                // Type once dataspecs are typed\r\n                const point_glyph = this.model.vertex_renderer.glyph;\r\n                const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\r\n                if (vertex_selected.length) {\r\n                    const index = point_ds.selected.indices[0];\r\n                    if (pxkey)\r\n                        x = point_ds.data[pxkey][index];\r\n                    if (pykey)\r\n                        y = point_ds.data[pykey][index];\r\n                    point_ds.selection_manager.clear();\r\n                }\r\n            }\r\n            return [x, y];\r\n        }\r\n    }\r\n    exports.PolyToolView = PolyToolView;\r\n    PolyToolView.__name__ = \"PolyToolView\";\r\n    class PolyTool extends edit_tool_1.EditTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_PolyTool() {\r\n            this.prototype.default_view = PolyToolView;\r\n            this.define({\r\n                vertex_renderer: [p.Instance],\r\n            });\r\n        }\r\n    }\r\n    exports.PolyTool = PolyTool;\r\n    PolyTool.__name__ = \"PolyTool\";\r\n    PolyTool.init_PolyTool();\r\n}\r\n","/* models\\tools\\edit\\poly_edit_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const types_1 = require(8) /* ../../../core/util/types */;\r\n    const poly_tool_1 = require(361) /* ./poly_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class PolyEditToolView extends poly_tool_1.PolyToolView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._drawing = false;\r\n            this._cur_index = null;\r\n        }\r\n        _doubletap(ev) {\r\n            if (!this.model.active)\r\n                return;\r\n            const point = this._map_drag(ev.sx, ev.sy, this.model.vertex_renderer);\r\n            if (point == null)\r\n                return;\r\n            const [x, y] = point;\r\n            // Perform hit testing\r\n            const vertex_selected = this._select_event(ev, \"replace\", [this.model.vertex_renderer]);\r\n            const point_cds = this.model.vertex_renderer.data_source;\r\n            // Type once dataspecs are typed\r\n            const point_glyph = this.model.vertex_renderer.glyph;\r\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\r\n            if (vertex_selected.length && this._selected_renderer != null) {\r\n                // Insert a new point after the selected vertex and enter draw mode\r\n                const index = point_cds.selected.indices[0];\r\n                if (this._drawing) {\r\n                    this._drawing = false;\r\n                    point_cds.selection_manager.clear();\r\n                }\r\n                else {\r\n                    point_cds.selected.indices = [index + 1];\r\n                    if (pxkey)\r\n                        point_cds.get_array(pxkey).splice(index + 1, 0, x);\r\n                    if (pykey)\r\n                        point_cds.get_array(pykey).splice(index + 1, 0, y);\r\n                    this._drawing = true;\r\n                }\r\n                point_cds.change.emit();\r\n                this._emit_cds_changes(this._selected_renderer.data_source);\r\n            }\r\n            else {\r\n                this._show_vertices(ev);\r\n            }\r\n        }\r\n        _show_vertices(ev) {\r\n            if (!this.model.active)\r\n                return;\r\n            const vsync_renderer = this.model.renderers[0];\r\n            const vsync_updater = () => this._update_vertices(vsync_renderer);\r\n            const vsync_ds = vsync_renderer === null || vsync_renderer === void 0 ? void 0 : vsync_renderer.data_source;\r\n            const renderers = this._select_event(ev, \"replace\", this.model.renderers);\r\n            if (!renderers.length) {\r\n                this._set_vertices([], []);\r\n                this._selected_renderer = null;\r\n                this._drawing = false;\r\n                this._cur_index = null;\r\n                if (vsync_ds != null)\r\n                    vsync_ds.disconnect(vsync_ds.properties.data.change, vsync_updater);\r\n                return;\r\n            }\r\n            if (vsync_ds != null)\r\n                vsync_ds.connect(vsync_ds.properties.data.change, vsync_updater);\r\n            this._cur_index = renderers[0].data_source.selected.indices[0];\r\n            this._update_vertices(renderers[0]);\r\n        }\r\n        _update_vertices(renderer) {\r\n            const glyph = renderer.glyph;\r\n            const cds = renderer.data_source;\r\n            const index = this._cur_index;\r\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\r\n            if (this._drawing)\r\n                return;\r\n            if ((index === null) && (xkey || ykey))\r\n                return;\r\n            let xs;\r\n            let ys;\r\n            if (xkey && index != null) { // redundant xkey null check to satisfy build-time checks\r\n                xs = cds.data[xkey][index];\r\n                if (!types_1.isArray(xs))\r\n                    cds.data[xkey][index] = xs = Array.from(xs);\r\n            }\r\n            else {\r\n                xs = glyph.xs.value;\r\n            }\r\n            if (ykey && index != null) {\r\n                ys = cds.data[ykey][index];\r\n                if (!types_1.isArray(ys))\r\n                    cds.data[ykey][index] = ys = Array.from(ys);\r\n            }\r\n            else {\r\n                ys = glyph.ys.value;\r\n            }\r\n            this._selected_renderer = renderer;\r\n            this._set_vertices(xs, ys);\r\n        }\r\n        _move(ev) {\r\n            if (this._drawing && this._selected_renderer != null) {\r\n                const renderer = this.model.vertex_renderer;\r\n                const cds = renderer.data_source;\r\n                const glyph = renderer.glyph;\r\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n                if (point == null)\r\n                    return;\r\n                let [x, y] = point;\r\n                const indices = cds.selected.indices;\r\n                [x, y] = this._snap_to_vertex(ev, x, y);\r\n                cds.selected.indices = indices;\r\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\r\n                const index = indices[0];\r\n                if (xkey)\r\n                    cds.data[xkey][index] = x;\r\n                if (ykey)\r\n                    cds.data[ykey][index] = y;\r\n                cds.change.emit();\r\n                this._selected_renderer.data_source.change.emit();\r\n            }\r\n        }\r\n        _tap(ev) {\r\n            const renderer = this.model.vertex_renderer;\r\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n            if (point == null)\r\n                return;\r\n            else if (this._drawing && this._selected_renderer) {\r\n                let [x, y] = point;\r\n                const cds = renderer.data_source;\r\n                // Type once dataspecs are typed\r\n                const glyph = renderer.glyph;\r\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\r\n                const indices = cds.selected.indices;\r\n                [x, y] = this._snap_to_vertex(ev, x, y);\r\n                const index = indices[0];\r\n                cds.selected.indices = [index + 1];\r\n                if (xkey) {\r\n                    const xs = cds.get_array(xkey);\r\n                    const nx = xs[index];\r\n                    xs[index] = x;\r\n                    xs.splice(index + 1, 0, nx);\r\n                }\r\n                if (ykey) {\r\n                    const ys = cds.get_array(ykey);\r\n                    const ny = ys[index];\r\n                    ys[index] = y;\r\n                    ys.splice(index + 1, 0, ny);\r\n                }\r\n                cds.change.emit();\r\n                this._emit_cds_changes(this._selected_renderer.data_source, true, false, true);\r\n                return;\r\n            }\r\n            const mode = this._select_mode(ev);\r\n            this._select_event(ev, mode, [renderer]);\r\n            this._select_event(ev, mode, this.model.renderers);\r\n        }\r\n        _remove_vertex() {\r\n            if (!this._drawing || !this._selected_renderer)\r\n                return;\r\n            const renderer = this.model.vertex_renderer;\r\n            const cds = renderer.data_source;\r\n            // Type once dataspecs are typed\r\n            const glyph = renderer.glyph;\r\n            const index = cds.selected.indices[0];\r\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\r\n            if (xkey)\r\n                cds.get_array(xkey).splice(index, 1);\r\n            if (ykey)\r\n                cds.get_array(ykey).splice(index, 1);\r\n            cds.change.emit();\r\n            this._emit_cds_changes(this._selected_renderer.data_source);\r\n        }\r\n        _pan_start(ev) {\r\n            this._select_event(ev, \"append\", [this.model.vertex_renderer]);\r\n            this._basepoint = [ev.sx, ev.sy];\r\n        }\r\n        _pan(ev) {\r\n            if (this._basepoint == null)\r\n                return;\r\n            this._drag_points(ev, [this.model.vertex_renderer]);\r\n            if (this._selected_renderer)\r\n                this._selected_renderer.data_source.change.emit();\r\n        }\r\n        _pan_end(ev) {\r\n            if (this._basepoint == null)\r\n                return;\r\n            this._drag_points(ev, [this.model.vertex_renderer]);\r\n            this._emit_cds_changes(this.model.vertex_renderer.data_source, false, true, true);\r\n            if (this._selected_renderer) {\r\n                this._emit_cds_changes(this._selected_renderer.data_source);\r\n            }\r\n            this._basepoint = null;\r\n        }\r\n        _keyup(ev) {\r\n            if (!this.model.active || !this._mouse_in_frame)\r\n                return;\r\n            let renderers;\r\n            if (this._selected_renderer) {\r\n                renderers = [this.model.vertex_renderer];\r\n            }\r\n            else {\r\n                renderers = this.model.renderers;\r\n            }\r\n            for (const renderer of renderers) {\r\n                if (ev.keyCode === dom_1.Keys.Backspace) {\r\n                    this._delete_selected(renderer);\r\n                    if (this._selected_renderer) {\r\n                        this._emit_cds_changes(this._selected_renderer.data_source);\r\n                    }\r\n                }\r\n                else if (ev.keyCode == dom_1.Keys.Esc) {\r\n                    if (this._drawing) {\r\n                        this._remove_vertex();\r\n                        this._drawing = false;\r\n                    }\r\n                    else if (this._selected_renderer) {\r\n                        this._hide_vertices();\r\n                    }\r\n                    renderer.data_source.selection_manager.clear();\r\n                }\r\n            }\r\n        }\r\n        deactivate() {\r\n            if (!this._selected_renderer) {\r\n                return;\r\n            }\r\n            else if (this._drawing) {\r\n                this._remove_vertex();\r\n                this._drawing = false;\r\n            }\r\n            this._hide_vertices();\r\n        }\r\n    }\r\n    exports.PolyEditToolView = PolyEditToolView;\r\n    PolyEditToolView.__name__ = \"PolyEditToolView\";\r\n    class PolyEditTool extends poly_tool_1.PolyTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Poly Edit Tool\";\r\n            this.icon = icons_1.bk_tool_icon_poly_edit;\r\n            this.event_type = [\"tap\", \"pan\", \"move\"];\r\n            this.default_order = 4;\r\n        }\r\n        static init_PolyEditTool() {\r\n            this.prototype.default_view = PolyEditToolView;\r\n        }\r\n    }\r\n    exports.PolyEditTool = PolyEditTool;\r\n    PolyEditTool.__name__ = \"PolyEditTool\";\r\n    PolyEditTool.init_PolyEditTool();\r\n}\r\n","/* models\\tools\\gestures\\box_select_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const select_tool_1 = require(364) /* ./select_tool */;\r\n    const box_annotation_1 = require(124) /* ../../annotations/box_annotation */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class BoxSelectToolView extends select_tool_1.SelectToolView {\r\n        _compute_limits(curpoint) {\r\n            const frame = this.plot_view.frame;\r\n            const dims = this.model.dimensions;\r\n            let base_point = this._base_point;\r\n            if (this.model.origin == \"center\") {\r\n                const [cx, cy] = base_point;\r\n                const [dx, dy] = curpoint;\r\n                base_point = [cx - (dx - cx), cy - (dy - cy)];\r\n            }\r\n            return this.model._get_dim_limits(base_point, curpoint, frame, dims);\r\n        }\r\n        _pan_start(ev) {\r\n            const { sx, sy } = ev;\r\n            this._base_point = [sx, sy];\r\n        }\r\n        _pan(ev) {\r\n            const { sx, sy } = ev;\r\n            const curpoint = [sx, sy];\r\n            const [sxlim, sylim] = this._compute_limits(curpoint);\r\n            this.model.overlay.update({ left: sxlim[0], right: sxlim[1], top: sylim[0], bottom: sylim[1] });\r\n            if (this.model.select_every_mousemove) {\r\n                this._do_select(sxlim, sylim, false, this._select_mode(ev));\r\n            }\r\n        }\r\n        _pan_end(ev) {\r\n            const { sx, sy } = ev;\r\n            const curpoint = [sx, sy];\r\n            const [sxlim, sylim] = this._compute_limits(curpoint);\r\n            this._do_select(sxlim, sylim, true, this._select_mode(ev));\r\n            this.model.overlay.update({ left: null, right: null, top: null, bottom: null });\r\n            this._base_point = null;\r\n            this.plot_view.push_state('box_select', { selection: this.plot_view.get_selection() });\r\n        }\r\n        _do_select([sx0, sx1], [sy0, sy1], final, mode = \"replace\") {\r\n            const geometry = { type: 'rect', sx0, sx1, sy0, sy1 };\r\n            this._select(geometry, final, mode);\r\n        }\r\n    }\r\n    exports.BoxSelectToolView = BoxSelectToolView;\r\n    BoxSelectToolView.__name__ = \"BoxSelectToolView\";\r\n    const DEFAULT_BOX_OVERLAY = () => {\r\n        return new box_annotation_1.BoxAnnotation({\r\n            level: \"overlay\",\r\n            top_units: \"screen\",\r\n            left_units: \"screen\",\r\n            bottom_units: \"screen\",\r\n            right_units: \"screen\",\r\n            fill_color: \"lightgrey\",\r\n            fill_alpha: 0.5,\r\n            line_color: \"black\",\r\n            line_alpha: 1.0,\r\n            line_width: 2,\r\n            line_dash: [4, 4],\r\n        });\r\n    };\r\n    class BoxSelectTool extends select_tool_1.SelectTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Box Select\";\r\n            this.icon = icons_1.bk_tool_icon_box_select;\r\n            this.event_type = \"pan\";\r\n            this.default_order = 30;\r\n        }\r\n        static init_BoxSelectTool() {\r\n            this.prototype.default_view = BoxSelectToolView;\r\n            this.define({\r\n                dimensions: [p.Dimensions, \"both\"],\r\n                select_every_mousemove: [p.Boolean, false],\r\n                overlay: [p.Instance, DEFAULT_BOX_OVERLAY],\r\n                origin: [p.BoxOrigin, \"corner\"],\r\n            });\r\n            this.register_alias(\"box_select\", () => new BoxSelectTool());\r\n            this.register_alias(\"xbox_select\", () => new BoxSelectTool({ dimensions: 'width' }));\r\n            this.register_alias(\"ybox_select\", () => new BoxSelectTool({ dimensions: 'height' }));\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\r\n        }\r\n    }\r\n    exports.BoxSelectTool = BoxSelectTool;\r\n    BoxSelectTool.__name__ = \"BoxSelectTool\";\r\n    BoxSelectTool.init_BoxSelectTool();\r\n}\r\n","/* models\\tools\\gestures\\select_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const gesture_tool_1 = require(306) /* ./gesture_tool */;\r\n    const glyph_renderer_1 = require(90) /* ../../renderers/glyph_renderer */;\r\n    const graph_renderer_1 = require(116) /* ../../renderers/graph_renderer */;\r\n    const util_1 = require(365) /* ../util */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const bokeh_events_1 = require(313) /* ../../../core/bokeh_events */;\r\n    const signaling_1 = require(15) /* ../../../core/signaling */;\r\n    const assert_1 = require(11) /* ../../../core/util/assert */;\r\n    class SelectToolView extends gesture_tool_1.GestureToolView {\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.model.clear.connect(() => this._clear());\r\n        }\r\n        get computed_renderers() {\r\n            const renderers = this.model.renderers;\r\n            const all_renderers = this.plot_model.renderers;\r\n            const names = this.model.names;\r\n            return util_1.compute_renderers(renderers, all_renderers, names);\r\n        }\r\n        _computed_renderers_by_data_source() {\r\n            var _a;\r\n            const renderers_by_source = new Map();\r\n            for (const r of this.computed_renderers) {\r\n                let source;\r\n                if (r instanceof glyph_renderer_1.GlyphRenderer)\r\n                    source = r.data_source;\r\n                else if (r instanceof graph_renderer_1.GraphRenderer)\r\n                    source = r.node_renderer.data_source;\r\n                else\r\n                    continue;\r\n                const renderers = (_a = renderers_by_source.get(source)) !== null && _a !== void 0 ? _a : [];\r\n                renderers_by_source.set(source, [...renderers, r]);\r\n            }\r\n            return renderers_by_source;\r\n        }\r\n        _select_mode(ev) {\r\n            const { shiftKey, ctrlKey } = ev;\r\n            if (!shiftKey && !ctrlKey)\r\n                return this.model.mode;\r\n            else if (shiftKey && !ctrlKey)\r\n                return \"append\";\r\n            else if (!shiftKey && ctrlKey)\r\n                return \"intersect\";\r\n            else if (shiftKey && ctrlKey)\r\n                return \"subtract\";\r\n            else\r\n                assert_1.unreachable();\r\n        }\r\n        _keyup(ev) {\r\n            if (ev.keyCode == dom_1.Keys.Esc) {\r\n                this._clear();\r\n            }\r\n        }\r\n        _clear() {\r\n            for (const renderer of this.computed_renderers) {\r\n                renderer.get_selection_manager().clear();\r\n            }\r\n            this.plot_view.request_render();\r\n        }\r\n        _select(geometry, final, mode) {\r\n            const renderers_by_source = this._computed_renderers_by_data_source();\r\n            for (const [, renderers] of renderers_by_source) {\r\n                const sm = renderers[0].get_selection_manager();\r\n                const r_views = [];\r\n                for (const r of renderers) {\r\n                    const r_view = this.plot_view.renderer_views.get(r);\r\n                    if (r_view != null) {\r\n                        r_views.push(r_view);\r\n                    }\r\n                }\r\n                sm.select(r_views, geometry, final, mode);\r\n            }\r\n            // XXX: messed up class structure\r\n            if (this.model.callback != null)\r\n                this._emit_callback(geometry);\r\n            this._emit_selection_event(geometry, final);\r\n        }\r\n        _emit_selection_event(geometry, final = true) {\r\n            const { x_scale, y_scale } = this.plot_view.frame;\r\n            let geometry_data;\r\n            switch (geometry.type) {\r\n                case \"point\": {\r\n                    const { sx, sy } = geometry;\r\n                    const x = x_scale.invert(sx);\r\n                    const y = y_scale.invert(sy);\r\n                    geometry_data = Object.assign(Object.assign({}, geometry), { x, y });\r\n                    break;\r\n                }\r\n                case \"span\": {\r\n                    const { sx, sy } = geometry;\r\n                    const x = x_scale.invert(sx);\r\n                    const y = y_scale.invert(sy);\r\n                    geometry_data = Object.assign(Object.assign({}, geometry), { x, y });\r\n                    break;\r\n                }\r\n                case \"rect\": {\r\n                    const { sx0, sx1, sy0, sy1 } = geometry;\r\n                    const [x0, x1] = x_scale.r_invert(sx0, sx1);\r\n                    const [y0, y1] = y_scale.r_invert(sy0, sy1);\r\n                    geometry_data = Object.assign(Object.assign({}, geometry), { x0, y0, x1, y1 });\r\n                    break;\r\n                }\r\n                case \"poly\": {\r\n                    const { sx, sy } = geometry;\r\n                    const x = x_scale.v_invert(sx);\r\n                    const y = y_scale.v_invert(sy);\r\n                    geometry_data = Object.assign(Object.assign({}, geometry), { x, y });\r\n                    break;\r\n                }\r\n            }\r\n            this.plot_model.trigger_event(new bokeh_events_1.SelectionGeometry(geometry_data, final));\r\n        }\r\n    }\r\n    exports.SelectToolView = SelectToolView;\r\n    SelectToolView.__name__ = \"SelectToolView\";\r\n    class SelectTool extends gesture_tool_1.GestureTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.clear = new signaling_1.Signal0(this, \"clear\");\r\n        }\r\n        static init_SelectTool() {\r\n            this.define({\r\n                renderers: [p.Any, 'auto'],\r\n                names: [p.Array, []],\r\n                mode: [p.Any, \"replace\"],\r\n            });\r\n        }\r\n        get menu() {\r\n            return [\r\n                {\r\n                    icon: \"bk-tool-icon-replace-mode\",\r\n                    tooltip: \"Replace the current selection\",\r\n                    active: () => this.mode == \"replace\",\r\n                    handler: () => {\r\n                        this.mode = \"replace\";\r\n                        this.active = true;\r\n                    },\r\n                }, {\r\n                    icon: \"bk-tool-icon-append-mode\",\r\n                    tooltip: \"Append to the current selection (Shift)\",\r\n                    active: () => this.mode == \"append\",\r\n                    handler: () => {\r\n                        this.mode = \"append\";\r\n                        this.active = true;\r\n                    },\r\n                }, {\r\n                    icon: \"bk-tool-icon-intersect-mode\",\r\n                    tooltip: \"Intersect with the current selection (Ctrl)\",\r\n                    active: () => this.mode == \"intersect\",\r\n                    handler: () => {\r\n                        this.mode = \"intersect\";\r\n                        this.active = true;\r\n                    },\r\n                }, {\r\n                    icon: \"bk-tool-icon-subtract-mode\",\r\n                    tooltip: \"Subtract from the current selection (Shift+Ctrl)\",\r\n                    active: () => this.mode == \"subtract\",\r\n                    handler: () => {\r\n                        this.mode = \"subtract\";\r\n                        this.active = true;\r\n                    },\r\n                },\r\n                null,\r\n                {\r\n                    icon: \"bk-tool-icon-clear-selection\",\r\n                    tooltip: \"Clear the current selection (Esc)\",\r\n                    handler: () => {\r\n                        this.clear.emit();\r\n                    },\r\n                },\r\n            ];\r\n        }\r\n    }\r\n    exports.SelectTool = SelectTool;\r\n    SelectTool.__name__ = \"SelectTool\";\r\n    SelectTool.init_SelectTool();\r\n}\r\n","/* models\\tools\\util.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    function compute_renderers(renderers, all_renderers, names) {\r\n        if (renderers == null)\r\n            return [];\r\n        let result = renderers == 'auto' ? all_renderers : renderers;\r\n        if (names.length > 0)\r\n            result = result.filter((r) => array_1.includes(names, r.name));\r\n        return result;\r\n    }\r\n    exports.compute_renderers = compute_renderers;\r\n}\r\n","/* models\\tools\\gestures\\box_zoom_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const gesture_tool_1 = require(306) /* ./gesture_tool */;\r\n    const box_annotation_1 = require(124) /* ../../annotations/box_annotation */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class BoxZoomToolView extends gesture_tool_1.GestureToolView {\r\n        _match_aspect(base_point, curpoint, frame) {\r\n            // aspect ratio of plot frame\r\n            const a = frame.bbox.aspect;\r\n            const hend = frame.bbox.h_range.end;\r\n            const hstart = frame.bbox.h_range.start;\r\n            const vend = frame.bbox.v_range.end;\r\n            const vstart = frame.bbox.v_range.start;\r\n            // current aspect of cursor-defined box\r\n            let vw = Math.abs(base_point[0] - curpoint[0]);\r\n            let vh = Math.abs(base_point[1] - curpoint[1]);\r\n            const va = vh == 0 ? 0 : vw / vh;\r\n            const [xmod] = va >= a ? [1, va / a] : [a / va, 1];\r\n            // OK the code blocks below merit some explanation. They do:\r\n            //\r\n            // compute left/right, pin to frame if necessary\r\n            // compute top/bottom (based on new left/right), pin to frame if necessary\r\n            // recompute left/right (based on top/bottom), in case top/bottom were pinned\r\n            // base_point[0] is left\r\n            let left;\r\n            let right;\r\n            if (base_point[0] <= curpoint[0]) {\r\n                left = base_point[0];\r\n                right = base_point[0] + vw * xmod;\r\n                if (right > hend)\r\n                    right = hend;\r\n                // base_point[0] is right\r\n            }\r\n            else {\r\n                right = base_point[0];\r\n                left = base_point[0] - vw * xmod;\r\n                if (left < hstart)\r\n                    left = hstart;\r\n            }\r\n            vw = Math.abs(right - left);\r\n            // base_point[1] is bottom\r\n            let top;\r\n            let bottom;\r\n            if (base_point[1] <= curpoint[1]) {\r\n                bottom = base_point[1];\r\n                top = base_point[1] + vw / a;\r\n                if (top > vend)\r\n                    top = vend;\r\n                // base_point[1] is top\r\n            }\r\n            else {\r\n                top = base_point[1];\r\n                bottom = base_point[1] - vw / a;\r\n                if (bottom < vstart)\r\n                    bottom = vstart;\r\n            }\r\n            vh = Math.abs(top - bottom);\r\n            // base_point[0] is left\r\n            if (base_point[0] <= curpoint[0])\r\n                right = base_point[0] + a * vh;\r\n            // base_point[0] is right\r\n            else\r\n                left = base_point[0] - a * vh;\r\n            return [[left, right], [bottom, top]];\r\n        }\r\n        _compute_limits(curpoint) {\r\n            const frame = this.plot_view.frame;\r\n            const dims = this.model.dimensions;\r\n            let base_point = this._base_point;\r\n            if (this.model.origin == \"center\") {\r\n                const [cx, cy] = base_point;\r\n                const [dx, dy] = curpoint;\r\n                base_point = [cx - (dx - cx), cy - (dy - cy)];\r\n            }\r\n            let sx;\r\n            let sy;\r\n            if (this.model.match_aspect && dims == 'both')\r\n                [sx, sy] = this._match_aspect(base_point, curpoint, frame);\r\n            else\r\n                [sx, sy] = this.model._get_dim_limits(base_point, curpoint, frame, dims);\r\n            return [sx, sy];\r\n        }\r\n        _pan_start(ev) {\r\n            this._base_point = [ev.sx, ev.sy];\r\n        }\r\n        _pan(ev) {\r\n            const curpoint = [ev.sx, ev.sy];\r\n            const [sx, sy] = this._compute_limits(curpoint);\r\n            this.model.overlay.update({ left: sx[0], right: sx[1], top: sy[0], bottom: sy[1] });\r\n        }\r\n        _pan_end(ev) {\r\n            const curpoint = [ev.sx, ev.sy];\r\n            const [sx, sy] = this._compute_limits(curpoint);\r\n            this._update(sx, sy);\r\n            this.model.overlay.update({ left: null, right: null, top: null, bottom: null });\r\n            this._base_point = null;\r\n        }\r\n        _update([sx0, sx1], [sy0, sy1]) {\r\n            // If the viewing window is too small, no-op: it is likely that the user did\r\n            // not intend to make this box zoom and instead was trying to cancel out of the\r\n            // zoom, a la matplotlib's ToolZoom. Like matplotlib, set the threshold at 5 pixels.\r\n            if (Math.abs(sx1 - sx0) <= 5 || Math.abs(sy1 - sy0) <= 5)\r\n                return;\r\n            const { x_scales, y_scales } = this.plot_view.frame;\r\n            const xrs = new Map();\r\n            for (const [name, scale] of x_scales) {\r\n                const [start, end] = scale.r_invert(sx0, sx1);\r\n                xrs.set(name, { start, end });\r\n            }\r\n            const yrs = new Map();\r\n            for (const [name, scale] of y_scales) {\r\n                const [start, end] = scale.r_invert(sy0, sy1);\r\n                yrs.set(name, { start, end });\r\n            }\r\n            const zoom_info = { xrs, yrs };\r\n            this.plot_view.push_state('box_zoom', { range: zoom_info });\r\n            this.plot_view.update_range(zoom_info);\r\n        }\r\n    }\r\n    exports.BoxZoomToolView = BoxZoomToolView;\r\n    BoxZoomToolView.__name__ = \"BoxZoomToolView\";\r\n    const DEFAULT_BOX_OVERLAY = () => {\r\n        return new box_annotation_1.BoxAnnotation({\r\n            level: \"overlay\",\r\n            top_units: \"screen\",\r\n            left_units: \"screen\",\r\n            bottom_units: \"screen\",\r\n            right_units: \"screen\",\r\n            fill_color: \"lightgrey\",\r\n            fill_alpha: 0.5,\r\n            line_color: \"black\",\r\n            line_alpha: 1.0,\r\n            line_width: 2,\r\n            line_dash: [4, 4],\r\n        });\r\n    };\r\n    class BoxZoomTool extends gesture_tool_1.GestureTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Box Zoom\";\r\n            this.icon = icons_1.bk_tool_icon_box_zoom;\r\n            this.event_type = \"pan\";\r\n            this.default_order = 20;\r\n        }\r\n        static init_BoxZoomTool() {\r\n            this.prototype.default_view = BoxZoomToolView;\r\n            this.define({\r\n                dimensions: [p.Dimensions, \"both\"],\r\n                overlay: [p.Instance, DEFAULT_BOX_OVERLAY],\r\n                match_aspect: [p.Boolean, false],\r\n                origin: [p.BoxOrigin, \"corner\"],\r\n            });\r\n            this.register_alias(\"box_zoom\", () => new BoxZoomTool({ dimensions: 'both' }));\r\n            this.register_alias(\"xbox_zoom\", () => new BoxZoomTool({ dimensions: 'width' }));\r\n            this.register_alias(\"ybox_zoom\", () => new BoxZoomTool({ dimensions: 'height' }));\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\r\n        }\r\n    }\r\n    exports.BoxZoomTool = BoxZoomTool;\r\n    BoxZoomTool.__name__ = \"BoxZoomTool\";\r\n    BoxZoomTool.init_BoxZoomTool();\r\n}\r\n","/* models\\tools\\gestures\\lasso_select_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const select_tool_1 = require(364) /* ./select_tool */;\r\n    const poly_select_tool_1 = require(368) /* ./poly_select_tool */;\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class LassoSelectToolView extends select_tool_1.SelectToolView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.data = null;\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.active.change, () => this._active_change());\r\n        }\r\n        _active_change() {\r\n            if (!this.model.active)\r\n                this._clear_overlay();\r\n        }\r\n        _keyup(ev) {\r\n            if (ev.keyCode == dom_1.Keys.Enter)\r\n                this._clear_overlay();\r\n        }\r\n        _pan_start(ev) {\r\n            const { sx, sy } = ev;\r\n            this.data = { sx: [sx], sy: [sy] };\r\n        }\r\n        _pan(ev) {\r\n            const { sx: _sx, sy: _sy } = ev;\r\n            const [sx, sy] = this.plot_view.frame.bbox.clip(_sx, _sy);\r\n            this.data.sx.push(sx);\r\n            this.data.sy.push(sy);\r\n            const overlay = this.model.overlay;\r\n            overlay.update({ xs: this.data.sx, ys: this.data.sy });\r\n            if (this.model.select_every_mousemove) {\r\n                this._do_select(this.data.sx, this.data.sy, false, this._select_mode(ev));\r\n            }\r\n        }\r\n        _pan_end(ev) {\r\n            this._clear_overlay();\r\n            this._do_select(this.data.sx, this.data.sy, true, this._select_mode(ev));\r\n            this.plot_view.push_state('lasso_select', { selection: this.plot_view.get_selection() });\r\n        }\r\n        _clear_overlay() {\r\n            this.model.overlay.update({ xs: [], ys: [] });\r\n        }\r\n        _do_select(sx, sy, final, mode) {\r\n            const geometry = { type: 'poly', sx, sy };\r\n            this._select(geometry, final, mode);\r\n        }\r\n    }\r\n    exports.LassoSelectToolView = LassoSelectToolView;\r\n    LassoSelectToolView.__name__ = \"LassoSelectToolView\";\r\n    class LassoSelectTool extends select_tool_1.SelectTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Lasso Select\";\r\n            this.icon = icons_1.bk_tool_icon_lasso_select;\r\n            this.event_type = \"pan\";\r\n            this.default_order = 12;\r\n        }\r\n        static init_LassoSelectTool() {\r\n            this.prototype.default_view = LassoSelectToolView;\r\n            this.define({\r\n                select_every_mousemove: [p.Boolean, true],\r\n                overlay: [p.Instance, poly_select_tool_1.DEFAULT_POLY_OVERLAY],\r\n            });\r\n            this.register_alias(\"lasso_select\", () => new LassoSelectTool());\r\n        }\r\n    }\r\n    exports.LassoSelectTool = LassoSelectTool;\r\n    LassoSelectTool.__name__ = \"LassoSelectTool\";\r\n    LassoSelectTool.init_LassoSelectTool();\r\n}\r\n","/* models\\tools\\gestures\\poly_select_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const select_tool_1 = require(364) /* ./select_tool */;\r\n    const poly_annotation_1 = require(166) /* ../../annotations/poly_annotation */;\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const array_1 = require(9) /* ../../../core/util/array */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class PolySelectToolView extends select_tool_1.SelectToolView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.data = { sx: [], sy: [] };\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.model.properties.active.change, () => this._active_change());\r\n        }\r\n        _active_change() {\r\n            if (!this.model.active)\r\n                this._clear_data();\r\n        }\r\n        _keyup(ev) {\r\n            if (ev.keyCode == dom_1.Keys.Enter)\r\n                this._clear_data();\r\n        }\r\n        _doubletap(ev) {\r\n            this._do_select(this.data.sx, this.data.sy, true, this._select_mode(ev));\r\n            this.plot_view.push_state('poly_select', { selection: this.plot_view.get_selection() });\r\n            this._clear_data();\r\n        }\r\n        _clear_data() {\r\n            this.data = { sx: [], sy: [] };\r\n            this.model.overlay.update({ xs: [], ys: [] });\r\n        }\r\n        _tap(ev) {\r\n            const { sx, sy } = ev;\r\n            const frame = this.plot_view.frame;\r\n            if (!frame.bbox.contains(sx, sy))\r\n                return;\r\n            this.data.sx.push(sx);\r\n            this.data.sy.push(sy);\r\n            this.model.overlay.update({ xs: array_1.copy(this.data.sx), ys: array_1.copy(this.data.sy) });\r\n        }\r\n        _do_select(sx, sy, final, mode) {\r\n            const geometry = { type: 'poly', sx, sy };\r\n            this._select(geometry, final, mode);\r\n        }\r\n    }\r\n    exports.PolySelectToolView = PolySelectToolView;\r\n    PolySelectToolView.__name__ = \"PolySelectToolView\";\r\n    exports.DEFAULT_POLY_OVERLAY = () => {\r\n        return new poly_annotation_1.PolyAnnotation({\r\n            level: \"overlay\",\r\n            xs_units: \"screen\",\r\n            ys_units: \"screen\",\r\n            fill_color: \"lightgrey\",\r\n            fill_alpha: 0.5,\r\n            line_color: \"black\",\r\n            line_alpha: 1.0,\r\n            line_width: 2,\r\n            line_dash: [4, 4],\r\n        });\r\n    };\r\n    class PolySelectTool extends select_tool_1.SelectTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Poly Select\";\r\n            this.icon = icons_1.bk_tool_icon_polygon_select;\r\n            this.event_type = \"tap\";\r\n            this.default_order = 11;\r\n        }\r\n        static init_PolySelectTool() {\r\n            this.prototype.default_view = PolySelectToolView;\r\n            this.define({\r\n                overlay: [p.Instance, exports.DEFAULT_POLY_OVERLAY],\r\n            });\r\n            this.register_alias(\"poly_select\", () => new PolySelectTool());\r\n        }\r\n    }\r\n    exports.PolySelectTool = PolySelectTool;\r\n    PolySelectTool.__name__ = \"PolySelectTool\";\r\n    PolySelectTool.init_PolySelectTool();\r\n}\r\n","/* models\\tools\\edit\\line_edit_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const line_tool_1 = require(370) /* ./line_tool */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class LineEditToolView extends line_tool_1.LineToolView {\r\n        constructor() {\r\n            super(...arguments);\r\n            this._drawing = false;\r\n        }\r\n        _doubletap(ev) {\r\n            if (!this.model.active)\r\n                return;\r\n            const renderers = this.model.renderers;\r\n            for (const renderer of renderers) {\r\n                const line_selected = this._select_event(ev, \"replace\", [renderer]);\r\n                if (line_selected.length == 1) {\r\n                    this._selected_renderer = renderer;\r\n                }\r\n            }\r\n            this._show_intersections();\r\n            this._update_line_cds();\r\n        }\r\n        _show_intersections() {\r\n            if (!this.model.active)\r\n                return;\r\n            if (this._selected_renderer == null)\r\n                return;\r\n            const renderers = this.model.renderers;\r\n            if (!renderers.length) {\r\n                this._set_intersection([], []);\r\n                this._selected_renderer = null;\r\n                this._drawing = false;\r\n                return;\r\n            }\r\n            const cds = this._selected_renderer.data_source;\r\n            const glyph = this._selected_renderer.glyph;\r\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\r\n            const x = cds.get_array(xkey);\r\n            const y = cds.get_array(ykey);\r\n            this._set_intersection(x, y);\r\n        }\r\n        _tap(ev) {\r\n            const renderer = this.model.intersection_renderer;\r\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\r\n            if (point == null)\r\n                return;\r\n            else if (this._drawing && this._selected_renderer) {\r\n                const mode = this._select_mode(ev);\r\n                const selected_points = this._select_event(ev, mode, [renderer]);\r\n                if (selected_points.length == 0) {\r\n                    return;\r\n                }\r\n            }\r\n            const mode = this._select_mode(ev);\r\n            this._select_event(ev, mode, [renderer]);\r\n            this._select_event(ev, mode, this.model.renderers);\r\n        }\r\n        _update_line_cds() {\r\n            if (this._selected_renderer == null)\r\n                return;\r\n            const point_glyph = this.model.intersection_renderer.glyph;\r\n            const point_cds = this.model.intersection_renderer.data_source;\r\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\r\n            if (pxkey && pykey) {\r\n                const x = point_cds.data[pxkey];\r\n                const y = point_cds.data[pykey];\r\n                this._selected_renderer.data_source.data[pxkey] = x;\r\n                this._selected_renderer.data_source.data[pykey] = y;\r\n            }\r\n            this._emit_cds_changes(this._selected_renderer.data_source, true, true, false);\r\n        }\r\n        _pan_start(ev) {\r\n            this._select_event(ev, \"append\", [this.model.intersection_renderer]);\r\n            this._basepoint = [ev.sx, ev.sy];\r\n        }\r\n        _pan(ev) {\r\n            if (this._basepoint == null)\r\n                return;\r\n            this._drag_points(ev, [this.model.intersection_renderer], this.model.dimensions);\r\n            if (this._selected_renderer)\r\n                this._selected_renderer.data_source.change.emit();\r\n        }\r\n        _pan_end(ev) {\r\n            if (this._basepoint == null)\r\n                return;\r\n            this._drag_points(ev, [this.model.intersection_renderer]);\r\n            this._emit_cds_changes(this.model.intersection_renderer.data_source, false, true, true);\r\n            if (this._selected_renderer) {\r\n                this._emit_cds_changes(this._selected_renderer.data_source);\r\n            }\r\n            this._basepoint = null;\r\n        }\r\n        activate() {\r\n            this._drawing = true;\r\n        }\r\n        deactivate() {\r\n            if (!this._selected_renderer) {\r\n                return;\r\n            }\r\n            else if (this._drawing) {\r\n                this._drawing = false;\r\n            }\r\n            this._hide_intersections();\r\n        }\r\n    }\r\n    exports.LineEditToolView = LineEditToolView;\r\n    LineEditToolView.__name__ = \"LineEditToolView\";\r\n    class LineEditTool extends line_tool_1.LineTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Line Edit Tool\";\r\n            this.icon = icons_1.bk_tool_icon_line_edit;\r\n            this.event_type = [\"tap\", \"pan\", \"move\"];\r\n            this.default_order = 4;\r\n        }\r\n        static init_LineEditTool() {\r\n            this.prototype.default_view = LineEditToolView;\r\n            this.define({\r\n                dimensions: [p.Dimensions, \"both\"],\r\n            });\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\r\n        }\r\n    }\r\n    exports.LineEditTool = LineEditTool;\r\n    LineEditTool.__name__ = \"LineEditTool\";\r\n    LineEditTool.init_LineEditTool();\r\n}\r\n","/* models\\tools\\edit\\line_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const types_1 = require(8) /* ../../../core/util/types */;\r\n    const edit_tool_1 = require(356) /* ./edit_tool */;\r\n    class LineToolView extends edit_tool_1.EditToolView {\r\n        _set_intersection(x, y) {\r\n            const point_glyph = this.model.intersection_renderer.glyph;\r\n            const point_cds = this.model.intersection_renderer.data_source;\r\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\r\n            if (pxkey) {\r\n                if (types_1.isArray(x))\r\n                    point_cds.data[pxkey] = x;\r\n                else\r\n                    point_glyph.x = { value: x };\r\n            }\r\n            if (pykey) {\r\n                if (types_1.isArray(y))\r\n                    point_cds.data[pykey] = y;\r\n                else\r\n                    point_glyph.y = { value: y };\r\n            }\r\n            this._emit_cds_changes(point_cds, true, true, false);\r\n        }\r\n        _hide_intersections() {\r\n            this._set_intersection([], []);\r\n        }\r\n    }\r\n    exports.LineToolView = LineToolView;\r\n    LineToolView.__name__ = \"LineToolView\";\r\n    class LineTool extends edit_tool_1.EditTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_LineTool() {\r\n            this.prototype.default_view = LineToolView;\r\n            this.define({\r\n                intersection_renderer: [p.Instance],\r\n            });\r\n        }\r\n    }\r\n    exports.LineTool = LineTool;\r\n    LineTool.__name__ = \"LineTool\";\r\n    LineTool.init_LineTool();\r\n}\r\n","/* models\\tools\\gestures\\pan_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const gesture_tool_1 = require(306) /* ./gesture_tool */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    function update_ranges(scales, p0, p1) {\r\n        const r = new Map();\r\n        for (const [name, scale] of scales) {\r\n            const [start, end] = scale.r_invert(p0, p1);\r\n            r.set(name, { start, end });\r\n        }\r\n        return r;\r\n    }\r\n    exports.update_ranges = update_ranges;\r\n    class PanToolView extends gesture_tool_1.GestureToolView {\r\n        _pan_start(ev) {\r\n            this.last_dx = 0;\r\n            this.last_dy = 0;\r\n            const { sx, sy } = ev;\r\n            const bbox = this.plot_view.frame.bbox;\r\n            if (!bbox.contains(sx, sy)) {\r\n                const hr = bbox.h_range;\r\n                const vr = bbox.v_range;\r\n                if (sx < hr.start || sx > hr.end)\r\n                    this.v_axis_only = true;\r\n                if (sy < vr.start || sy > vr.end)\r\n                    this.h_axis_only = true;\r\n            }\r\n            if (this.model.document != null)\r\n                this.model.document.interactive_start(this.plot_model);\r\n        }\r\n        _pan(ev) {\r\n            this._update(ev.deltaX, ev.deltaY);\r\n            if (this.model.document != null)\r\n                this.model.document.interactive_start(this.plot_model);\r\n        }\r\n        _pan_end(_e) {\r\n            this.h_axis_only = false;\r\n            this.v_axis_only = false;\r\n            if (this.pan_info != null)\r\n                this.plot_view.push_state('pan', { range: this.pan_info });\r\n        }\r\n        _update(dx, dy) {\r\n            const frame = this.plot_view.frame;\r\n            const new_dx = dx - this.last_dx;\r\n            const new_dy = dy - this.last_dy;\r\n            const hr = frame.bbox.h_range;\r\n            const sx_low = hr.start - new_dx;\r\n            const sx_high = hr.end - new_dx;\r\n            const vr = frame.bbox.v_range;\r\n            const sy_low = vr.start - new_dy;\r\n            const sy_high = vr.end - new_dy;\r\n            const dims = this.model.dimensions;\r\n            let sx0;\r\n            let sx1;\r\n            let sdx;\r\n            if ((dims == 'width' || dims == 'both') && !this.v_axis_only) {\r\n                sx0 = sx_low;\r\n                sx1 = sx_high;\r\n                sdx = -new_dx;\r\n            }\r\n            else {\r\n                sx0 = hr.start;\r\n                sx1 = hr.end;\r\n                sdx = 0;\r\n            }\r\n            let sy0;\r\n            let sy1;\r\n            let sdy;\r\n            if ((dims == 'height' || dims == 'both') && !this.h_axis_only) {\r\n                sy0 = sy_low;\r\n                sy1 = sy_high;\r\n                sdy = -new_dy;\r\n            }\r\n            else {\r\n                sy0 = vr.start;\r\n                sy1 = vr.end;\r\n                sdy = 0;\r\n            }\r\n            this.last_dx = dx;\r\n            this.last_dy = dy;\r\n            const { x_scales, y_scales } = frame;\r\n            const xrs = update_ranges(x_scales, sx0, sx1);\r\n            const yrs = update_ranges(y_scales, sy0, sy1);\r\n            this.pan_info = { xrs, yrs, sdx, sdy };\r\n            this.plot_view.update_range(this.pan_info, true);\r\n        }\r\n    }\r\n    exports.PanToolView = PanToolView;\r\n    PanToolView.__name__ = \"PanToolView\";\r\n    class PanTool extends gesture_tool_1.GestureTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Pan\";\r\n            this.event_type = \"pan\";\r\n            this.default_order = 10;\r\n        }\r\n        static init_PanTool() {\r\n            this.prototype.default_view = PanToolView;\r\n            this.define({\r\n                dimensions: [p.Dimensions, \"both\"],\r\n            });\r\n            this.register_alias(\"pan\", () => new PanTool({ dimensions: 'both' }));\r\n            this.register_alias(\"xpan\", () => new PanTool({ dimensions: 'width' }));\r\n            this.register_alias(\"ypan\", () => new PanTool({ dimensions: 'height' }));\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(\"Pan\", this.dimensions);\r\n        }\r\n        get icon() {\r\n            switch (this.dimensions) {\r\n                case \"both\": return icons_1.bk_tool_icon_pan;\r\n                case \"width\": return icons_1.bk_tool_icon_xpan;\r\n                case \"height\": return icons_1.bk_tool_icon_ypan;\r\n            }\r\n        }\r\n    }\r\n    exports.PanTool = PanTool;\r\n    PanTool.__name__ = \"PanTool\";\r\n    PanTool.init_PanTool();\r\n}\r\n","/* models\\tools\\gestures\\range_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const box_annotation_1 = require(124) /* ../../annotations/box_annotation */;\r\n    const logging_1 = require(19) /* ../../../core/logging */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const gesture_tool_1 = require(306) /* ./gesture_tool */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    function flip_side(side) {\r\n        switch (side) {\r\n            case 1 /* Left */: return 2 /* Right */;\r\n            case 2 /* Right */: return 1 /* Left */;\r\n            case 4 /* Bottom */: return 5 /* Top */;\r\n            case 5 /* Top */: return 4 /* Bottom */;\r\n            default: return side;\r\n        }\r\n    }\r\n    exports.flip_side = flip_side;\r\n    // TODO (bev) This would be better directly with BoxAnnotation, but hard\r\n    // to test on a view. Move when \"View Models\" are implemented\r\n    function is_near(pos, value, scale, tolerance) {\r\n        if (value == null)\r\n            return false;\r\n        const svalue = scale.compute(value);\r\n        return Math.abs(pos - svalue) < tolerance;\r\n    }\r\n    exports.is_near = is_near;\r\n    // TODO (bev) This would be better directly with BoxAnnotation, but hard\r\n    // to test on a view. Move when \"View Models\" are implemented\r\n    function is_inside(sx, sy, xscale, yscale, overlay) {\r\n        let result = true;\r\n        if (overlay.left != null && overlay.right != null) {\r\n            const x = xscale.invert(sx);\r\n            if (x < overlay.left || x > overlay.right)\r\n                result = false;\r\n        }\r\n        if (overlay.bottom != null && overlay.top != null) {\r\n            const y = yscale.invert(sy);\r\n            if (y < overlay.bottom || y > overlay.top)\r\n                result = false;\r\n        }\r\n        return result;\r\n    }\r\n    exports.is_inside = is_inside;\r\n    function sides_inside(start, end, range) {\r\n        let result = 0;\r\n        if (start >= range.start && start <= range.end)\r\n            result += 1;\r\n        if (end >= range.start && end <= range.end)\r\n            result += 1;\r\n        return result;\r\n    }\r\n    exports.sides_inside = sides_inside;\r\n    function compute_value(value, scale, sdelta, range) {\r\n        const svalue = scale.compute(value);\r\n        const new_value = scale.invert(svalue + sdelta);\r\n        if (new_value >= range.start && new_value <= range.end)\r\n            return new_value;\r\n        return value;\r\n    }\r\n    exports.compute_value = compute_value;\r\n    function update_range_end_side(end, range, side) {\r\n        if (end > range.start) {\r\n            range.end = end;\r\n            return side;\r\n        }\r\n        else {\r\n            range.end = range.start;\r\n            range.start = end;\r\n            return flip_side(side);\r\n        }\r\n    }\r\n    exports.update_range_end_side = update_range_end_side;\r\n    function update_range_start_side(start, range, side) {\r\n        if (start < range.end) {\r\n            range.start = start;\r\n            return side;\r\n        }\r\n        else {\r\n            range.start = range.end;\r\n            range.end = start;\r\n            return flip_side(side);\r\n        }\r\n    }\r\n    exports.update_range_start_side = update_range_start_side;\r\n    function update_range(range, scale, delta, plot_range) {\r\n        const [sstart, send] = scale.r_compute(range.start, range.end);\r\n        const [start, end] = scale.r_invert(sstart + delta, send + delta);\r\n        const initial_sides_inside = sides_inside(range.start, range.end, plot_range);\r\n        const final_sides_inside = sides_inside(start, end, plot_range);\r\n        // Allow the update as long as the number of sides in-bounds does not decrease\r\n        if (final_sides_inside >= initial_sides_inside) {\r\n            range.start = start;\r\n            range.end = end;\r\n        }\r\n    }\r\n    exports.update_range = update_range;\r\n    class RangeToolView extends gesture_tool_1.GestureToolView {\r\n        initialize() {\r\n            super.initialize();\r\n            this.side = 0 /* None */;\r\n            this.model.update_overlay_from_ranges();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            if (this.model.x_range != null)\r\n                this.connect(this.model.x_range.change, () => this.model.update_overlay_from_ranges());\r\n            if (this.model.y_range != null)\r\n                this.connect(this.model.y_range.change, () => this.model.update_overlay_from_ranges());\r\n        }\r\n        _pan_start(ev) {\r\n            this.last_dx = 0;\r\n            this.last_dy = 0;\r\n            const xr = this.model.x_range;\r\n            const yr = this.model.y_range;\r\n            const { frame } = this.plot_view;\r\n            const xscale = frame.x_scale;\r\n            const yscale = frame.y_scale;\r\n            const overlay = this.model.overlay;\r\n            const { left, right, top, bottom } = overlay;\r\n            const tolerance = this.model.overlay.properties.line_width.value() + box_annotation_1.EDGE_TOLERANCE;\r\n            if (xr != null && this.model.x_interaction) {\r\n                if (is_near(ev.sx, left, xscale, tolerance))\r\n                    this.side = 1 /* Left */;\r\n                else if (is_near(ev.sx, right, xscale, tolerance))\r\n                    this.side = 2 /* Right */;\r\n                else if (is_inside(ev.sx, ev.sy, xscale, yscale, overlay)) {\r\n                    this.side = 3 /* LeftRight */;\r\n                }\r\n            }\r\n            if (yr != null && this.model.y_interaction) {\r\n                if (this.side == 0 /* None */ && is_near(ev.sy, bottom, yscale, tolerance))\r\n                    this.side = 4 /* Bottom */;\r\n                if (this.side == 0 /* None */ && is_near(ev.sy, top, yscale, tolerance))\r\n                    this.side = 5 /* Top */;\r\n                else if (is_inside(ev.sx, ev.sy, xscale, yscale, this.model.overlay)) {\r\n                    if (this.side == 3 /* LeftRight */)\r\n                        this.side = 7 /* LeftRightBottomTop */;\r\n                    else\r\n                        this.side = 6 /* BottomTop */;\r\n                }\r\n            }\r\n        }\r\n        _pan(ev) {\r\n            const frame = this.plot_view.frame;\r\n            const new_dx = ev.deltaX - this.last_dx;\r\n            const new_dy = ev.deltaY - this.last_dy;\r\n            const xr = this.model.x_range;\r\n            const yr = this.model.y_range;\r\n            const xscale = frame.x_scale;\r\n            const yscale = frame.y_scale;\r\n            if (xr != null) {\r\n                if (this.side == 3 /* LeftRight */ || this.side == 7 /* LeftRightBottomTop */)\r\n                    update_range(xr, xscale, new_dx, frame.x_range);\r\n                else if (this.side == 1 /* Left */) {\r\n                    const start = compute_value(xr.start, xscale, new_dx, frame.x_range);\r\n                    this.side = update_range_start_side(start, xr, this.side);\r\n                }\r\n                else if (this.side == 2 /* Right */) {\r\n                    const end = compute_value(xr.end, xscale, new_dx, frame.x_range);\r\n                    this.side = update_range_end_side(end, xr, this.side);\r\n                }\r\n            }\r\n            if (yr != null) {\r\n                if (this.side == 6 /* BottomTop */ || this.side == 7 /* LeftRightBottomTop */)\r\n                    update_range(yr, yscale, new_dy, frame.y_range);\r\n                else if (this.side == 4 /* Bottom */) {\r\n                    const start = compute_value(yr.start, yscale, new_dy, frame.y_range);\r\n                    this.side = update_range_start_side(start, yr, this.side);\r\n                }\r\n                else if (this.side == 5 /* Top */) {\r\n                    const end = compute_value(yr.end, yscale, new_dy, frame.y_range);\r\n                    this.side = update_range_end_side(end, yr, this.side);\r\n                }\r\n            }\r\n            this.last_dx = ev.deltaX;\r\n            this.last_dy = ev.deltaY;\r\n        }\r\n        _pan_end(_ev) {\r\n            this.side = 0 /* None */;\r\n        }\r\n    }\r\n    exports.RangeToolView = RangeToolView;\r\n    RangeToolView.__name__ = \"RangeToolView\";\r\n    const DEFAULT_RANGE_OVERLAY = () => {\r\n        return new box_annotation_1.BoxAnnotation({\r\n            level: \"overlay\",\r\n            fill_color: \"lightgrey\",\r\n            fill_alpha: 0.5,\r\n            line_color: \"black\",\r\n            line_alpha: 1.0,\r\n            line_width: 0.5,\r\n            line_dash: [2, 2],\r\n        });\r\n    };\r\n    class RangeTool extends gesture_tool_1.GestureTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Range Tool\";\r\n            this.icon = icons_1.bk_tool_icon_range;\r\n            this.event_type = \"pan\";\r\n            this.default_order = 1;\r\n        }\r\n        static init_RangeTool() {\r\n            this.prototype.default_view = RangeToolView;\r\n            this.define({\r\n                x_range: [p.Instance, null],\r\n                x_interaction: [p.Boolean, true],\r\n                y_range: [p.Instance, null],\r\n                y_interaction: [p.Boolean, true],\r\n                overlay: [p.Instance, DEFAULT_RANGE_OVERLAY],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.overlay.in_cursor = \"grab\";\r\n            this.overlay.ew_cursor = this.x_range != null && this.x_interaction ? \"ew-resize\" : null;\r\n            this.overlay.ns_cursor = this.y_range != null && this.y_interaction ? \"ns-resize\" : null;\r\n        }\r\n        update_overlay_from_ranges() {\r\n            if (this.x_range == null && this.y_range == null) {\r\n                this.overlay.left = null;\r\n                this.overlay.right = null;\r\n                this.overlay.bottom = null;\r\n                this.overlay.top = null;\r\n                logging_1.logger.warn('RangeTool not configured with any Ranges.');\r\n            }\r\n            if (this.x_range == null) {\r\n                this.overlay.left = null;\r\n                this.overlay.right = null;\r\n            }\r\n            else {\r\n                this.overlay.left = this.x_range.start;\r\n                this.overlay.right = this.x_range.end;\r\n            }\r\n            if (this.y_range == null) {\r\n                this.overlay.bottom = null;\r\n                this.overlay.top = null;\r\n            }\r\n            else {\r\n                this.overlay.bottom = this.y_range.start;\r\n                this.overlay.top = this.y_range.end;\r\n            }\r\n        }\r\n    }\r\n    exports.RangeTool = RangeTool;\r\n    RangeTool.__name__ = \"RangeTool\";\r\n    RangeTool.init_RangeTool();\r\n}\r\n","/* models\\tools\\gestures\\tap_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const select_tool_1 = require(364) /* ./select_tool */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class TapToolView extends select_tool_1.SelectToolView {\r\n        _tap(ev) {\r\n            const { sx, sy } = ev;\r\n            const geometry = { type: \"point\", sx, sy };\r\n            this._select(geometry, true, this._select_mode(ev));\r\n        }\r\n        _select(geometry, final, mode) {\r\n            const callback = this.model.callback;\r\n            if (this.model.behavior == \"select\") {\r\n                const renderers_by_source = this._computed_renderers_by_data_source();\r\n                for (const [, renderers] of renderers_by_source) {\r\n                    const sm = renderers[0].get_selection_manager();\r\n                    const r_views = renderers.map((r) => this.plot_view.renderer_views.get(r));\r\n                    const did_hit = sm.select(r_views, geometry, final, mode);\r\n                    if (did_hit && callback != null) {\r\n                        const x = r_views[0].coordinates.x_scale.invert(geometry.sx);\r\n                        const y = r_views[0].coordinates.y_scale.invert(geometry.sy);\r\n                        const data = { geometries: Object.assign(Object.assign({}, geometry), { x, y }), source: sm.source };\r\n                        callback.execute(this.model, data);\r\n                    }\r\n                }\r\n                this._emit_selection_event(geometry);\r\n                this.plot_view.push_state('tap', { selection: this.plot_view.get_selection() });\r\n            }\r\n            else {\r\n                for (const r of this.computed_renderers) {\r\n                    const rv = this.plot_view.renderer_views.get(r);\r\n                    const sm = r.get_selection_manager();\r\n                    const did_hit = sm.inspect(rv, geometry);\r\n                    if (did_hit && callback != null) {\r\n                        const x = rv.coordinates.x_scale.invert(geometry.sx);\r\n                        const y = rv.coordinates.y_scale.invert(geometry.sy);\r\n                        const data = { geometries: Object.assign(Object.assign({}, geometry), { x, y }), source: sm.source };\r\n                        callback.execute(this.model, data);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.TapToolView = TapToolView;\r\n    TapToolView.__name__ = \"TapToolView\";\r\n    class TapTool extends select_tool_1.SelectTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Tap\";\r\n            this.icon = icons_1.bk_tool_icon_tap_select;\r\n            this.event_type = \"tap\";\r\n            this.default_order = 10;\r\n        }\r\n        static init_TapTool() {\r\n            this.prototype.default_view = TapToolView;\r\n            this.define({\r\n                behavior: [p.TapBehavior, \"select\"],\r\n                callback: [p.Any],\r\n            });\r\n            this.register_alias(\"click\", () => new TapTool({ behavior: \"inspect\" }));\r\n            this.register_alias(\"tap\", () => new TapTool());\r\n        }\r\n    }\r\n    exports.TapTool = TapTool;\r\n    TapTool.__name__ = \"TapTool\";\r\n    TapTool.init_TapTool();\r\n}\r\n","/* models\\tools\\gestures\\wheel_pan_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const gesture_tool_1 = require(306) /* ./gesture_tool */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    const pan_tool_1 = require(371) /* ./pan_tool */;\r\n    class WheelPanToolView extends gesture_tool_1.GestureToolView {\r\n        _scroll(ev) {\r\n            let factor = this.model.speed * ev.delta;\r\n            // clamp the magnitude of factor, if it is > 1 bad things happen\r\n            if (factor > 0.9)\r\n                factor = 0.9;\r\n            else if (factor < -0.9)\r\n                factor = -0.9;\r\n            this._update_ranges(factor);\r\n        }\r\n        _update_ranges(factor) {\r\n            const { frame } = this.plot_view;\r\n            const hr = frame.bbox.h_range;\r\n            const vr = frame.bbox.v_range;\r\n            const [sx_low, sx_high] = [hr.start, hr.end];\r\n            const [sy_low, sy_high] = [vr.start, vr.end];\r\n            let sx0;\r\n            let sx1;\r\n            let sy0;\r\n            let sy1;\r\n            switch (this.model.dimension) {\r\n                case \"height\": {\r\n                    const sy_range = Math.abs(sy_high - sy_low);\r\n                    sx0 = sx_low;\r\n                    sx1 = sx_high;\r\n                    sy0 = sy_low - sy_range * factor;\r\n                    sy1 = sy_high - sy_range * factor;\r\n                    break;\r\n                }\r\n                case \"width\": {\r\n                    const sx_range = Math.abs(sx_high - sx_low);\r\n                    sx0 = sx_low - sx_range * factor;\r\n                    sx1 = sx_high - sx_range * factor;\r\n                    sy0 = sy_low;\r\n                    sy1 = sy_high;\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new Error(\"this shouldn't have happened\");\r\n            }\r\n            const { x_scales, y_scales } = frame;\r\n            const xrs = pan_tool_1.update_ranges(x_scales, sx0, sx1);\r\n            const yrs = pan_tool_1.update_ranges(y_scales, sy0, sy1);\r\n            // OK this sucks we can't set factor independently in each direction. It is used\r\n            // for GMap plots, and GMap plots always preserve aspect, so effective the value\r\n            // of 'dimensions' is ignored.\r\n            const pan_info = { xrs, yrs, factor };\r\n            this.plot_view.push_state('wheel_pan', { range: pan_info });\r\n            this.plot_view.update_range(pan_info, false, true);\r\n            if (this.model.document != null)\r\n                this.model.document.interactive_start(this.plot_model);\r\n        }\r\n    }\r\n    exports.WheelPanToolView = WheelPanToolView;\r\n    WheelPanToolView.__name__ = \"WheelPanToolView\";\r\n    class WheelPanTool extends gesture_tool_1.GestureTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Wheel Pan\";\r\n            this.icon = icons_1.bk_tool_icon_wheel_pan;\r\n            this.event_type = \"scroll\";\r\n            this.default_order = 12;\r\n        }\r\n        static init_WheelPanTool() {\r\n            this.prototype.default_view = WheelPanToolView;\r\n            this.define({\r\n                dimension: [p.Dimension, \"width\"],\r\n            });\r\n            this.internal({\r\n                speed: [p.Number, 1 / 1000],\r\n            });\r\n            this.register_alias(\"xwheel_pan\", () => new WheelPanTool({ dimension: \"width\" }));\r\n            this.register_alias(\"ywheel_pan\", () => new WheelPanTool({ dimension: \"height\" }));\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(this.tool_name, this.dimension);\r\n        }\r\n    }\r\n    exports.WheelPanTool = WheelPanTool;\r\n    WheelPanTool.__name__ = \"WheelPanTool\";\r\n    WheelPanTool.init_WheelPanTool();\r\n}\r\n","/* models\\tools\\gestures\\wheel_zoom_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const gesture_tool_1 = require(306) /* ./gesture_tool */;\r\n    const zoom_1 = require(354) /* ../../../core/util/zoom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const compat_1 = require(32) /* ../../../core/util/compat */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class WheelZoomToolView extends gesture_tool_1.GestureToolView {\r\n        _pinch(ev) {\r\n            // TODO (bev) this can probably be done much better\r\n            const { sx, sy, scale, ctrlKey, shiftKey } = ev;\r\n            let delta;\r\n            if (scale >= 1)\r\n                delta = (scale - 1) * 20.0;\r\n            else\r\n                delta = -20.0 / scale;\r\n            this._scroll({ type: \"wheel\", sx, sy, delta, ctrlKey, shiftKey });\r\n        }\r\n        _scroll(ev) {\r\n            const { frame } = this.plot_view;\r\n            const hr = frame.bbox.h_range;\r\n            const vr = frame.bbox.v_range;\r\n            const { sx, sy } = ev;\r\n            const dims = this.model.dimensions;\r\n            // restrict to axis configured in tool's dimensions property and if\r\n            // zoom origin is inside of frame range/domain\r\n            const h_axis = (dims == 'width' || dims == 'both') && hr.start < sx && sx < hr.end;\r\n            const v_axis = (dims == 'height' || dims == 'both') && vr.start < sy && sy < vr.end;\r\n            if ((!h_axis || !v_axis) && !this.model.zoom_on_axis) {\r\n                return;\r\n            }\r\n            const factor = this.model.speed * ev.delta;\r\n            const zoom_info = zoom_1.scale_range(frame, factor, h_axis, v_axis, { x: sx, y: sy });\r\n            this.plot_view.push_state('wheel_zoom', { range: zoom_info });\r\n            this.plot_view.update_range(zoom_info, false, true, this.model.maintain_focus);\r\n            if (this.model.document != null)\r\n                this.model.document.interactive_start(this.plot_model);\r\n        }\r\n    }\r\n    exports.WheelZoomToolView = WheelZoomToolView;\r\n    WheelZoomToolView.__name__ = \"WheelZoomToolView\";\r\n    class WheelZoomTool extends gesture_tool_1.GestureTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Wheel Zoom\";\r\n            this.icon = icons_1.bk_tool_icon_wheel_zoom;\r\n            this.event_type = compat_1.is_mobile ? \"pinch\" : \"scroll\";\r\n            this.default_order = 10;\r\n        }\r\n        static init_WheelZoomTool() {\r\n            this.prototype.default_view = WheelZoomToolView;\r\n            this.define({\r\n                dimensions: [p.Dimensions, \"both\"],\r\n                maintain_focus: [p.Boolean, true],\r\n                zoom_on_axis: [p.Boolean, true],\r\n                speed: [p.Number, 1 / 600],\r\n            });\r\n            this.register_alias(\"wheel_zoom\", () => new WheelZoomTool({ dimensions: 'both' }));\r\n            this.register_alias(\"xwheel_zoom\", () => new WheelZoomTool({ dimensions: 'width' }));\r\n            this.register_alias(\"ywheel_zoom\", () => new WheelZoomTool({ dimensions: 'height' }));\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\r\n        }\r\n    }\r\n    exports.WheelZoomTool = WheelZoomTool;\r\n    WheelZoomTool.__name__ = \"WheelZoomTool\";\r\n    WheelZoomTool.init_WheelZoomTool();\r\n}\r\n","/* models\\tools\\inspectors\\crosshair_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const inspect_tool_1 = require(295) /* ./inspect_tool */;\r\n    const span_1 = require(168) /* ../../annotations/span */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const object_1 = require(13) /* ../../../core/util/object */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    class CrosshairToolView extends inspect_tool_1.InspectToolView {\r\n        _move(ev) {\r\n            if (!this.model.active)\r\n                return;\r\n            const { sx, sy } = ev;\r\n            if (!this.plot_view.frame.bbox.contains(sx, sy))\r\n                this._update_spans(null, null);\r\n            else\r\n                this._update_spans(sx, sy);\r\n        }\r\n        _move_exit(_e) {\r\n            this._update_spans(null, null);\r\n        }\r\n        _update_spans(x, y) {\r\n            const dims = this.model.dimensions;\r\n            if (dims == \"width\" || dims == \"both\")\r\n                this.model.spans.width.location = y;\r\n            if (dims == \"height\" || dims == \"both\")\r\n                this.model.spans.height.location = x;\r\n        }\r\n    }\r\n    exports.CrosshairToolView = CrosshairToolView;\r\n    CrosshairToolView.__name__ = \"CrosshairToolView\";\r\n    class CrosshairTool extends inspect_tool_1.InspectTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Crosshair\";\r\n            this.icon = icons_1.bk_tool_icon_crosshair;\r\n        }\r\n        static init_CrosshairTool() {\r\n            this.prototype.default_view = CrosshairToolView;\r\n            this.define({\r\n                dimensions: [p.Dimensions, \"both\"],\r\n                line_color: [p.Color, 'black'],\r\n                line_width: [p.Number, 1],\r\n                line_alpha: [p.Number, 1.0],\r\n            });\r\n            this.internal({\r\n                spans: [p.Any],\r\n            });\r\n            this.register_alias(\"crosshair\", () => new CrosshairTool());\r\n        }\r\n        get tooltip() {\r\n            return this._get_dim_tooltip(\"Crosshair\", this.dimensions);\r\n        }\r\n        get synthetic_renderers() {\r\n            return object_1.values(this.spans);\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.spans = {\r\n                width: new span_1.Span({\r\n                    for_hover: true,\r\n                    dimension: \"width\",\r\n                    location_units: \"screen\",\r\n                    level: \"overlay\",\r\n                    line_color: this.line_color,\r\n                    line_width: this.line_width,\r\n                    line_alpha: this.line_alpha,\r\n                }),\r\n                height: new span_1.Span({\r\n                    for_hover: true,\r\n                    dimension: \"height\",\r\n                    location_units: \"screen\",\r\n                    level: \"overlay\",\r\n                    line_color: this.line_color,\r\n                    line_width: this.line_width,\r\n                    line_alpha: this.line_alpha,\r\n                }),\r\n            };\r\n        }\r\n    }\r\n    exports.CrosshairTool = CrosshairTool;\r\n    CrosshairTool.__name__ = \"CrosshairTool\";\r\n    CrosshairTool.init_CrosshairTool();\r\n}\r\n","/* models\\tools\\inspectors\\customjs_hover.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const model_1 = require(81) /* ../../../model */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const object_1 = require(13) /* ../../../core/util/object */;\r\n    const string_1 = require(29) /* ../../../core/util/string */;\r\n    class CustomJSHover extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_CustomJSHover() {\r\n            this.define({\r\n                args: [p.Any, {}],\r\n                code: [p.String, \"\"],\r\n            });\r\n        }\r\n        get values() {\r\n            return object_1.values(this.args);\r\n        }\r\n        /*protected*/ _make_code(valname, formatname, varsname, fn) {\r\n            // this relies on keys(args) and values(args) returning keys and values\r\n            // in the same order\r\n            return new Function(...object_1.keys(this.args), valname, formatname, varsname, string_1.use_strict(fn));\r\n        }\r\n        format(value, format, special_vars) {\r\n            const formatter = this._make_code(\"value\", \"format\", \"special_vars\", this.code);\r\n            return formatter(...this.values, value, format, special_vars);\r\n        }\r\n    }\r\n    exports.CustomJSHover = CustomJSHover;\r\n    CustomJSHover.__name__ = \"CustomJSHover\";\r\n    CustomJSHover.init_CustomJSHover();\r\n}\r\n","/* models\\tools\\inspectors\\hover_tool.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const inspect_tool_1 = require(295) /* ./inspect_tool */;\r\n    const tooltip_1 = require(171) /* ../../annotations/tooltip */;\r\n    const glyph_renderer_1 = require(90) /* ../../renderers/glyph_renderer */;\r\n    const graph_renderer_1 = require(116) /* ../../renderers/graph_renderer */;\r\n    const util_1 = require(365) /* ../util */;\r\n    const hittest = tslib_1.__importStar(require(101) /* ../../../core/hittest */);\r\n    const templating_1 = require(187) /* ../../../core/util/templating */;\r\n    const dom_1 = require(72) /* ../../../core/dom */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../../core/properties */);\r\n    const color_1 = require(22) /* ../../../core/util/color */;\r\n    const object_1 = require(13) /* ../../../core/util/object */;\r\n    const iterator_1 = require(303) /* ../../../core/util/iterator */;\r\n    const types_1 = require(8) /* ../../../core/util/types */;\r\n    const build_views_1 = require(115) /* ../../../core/build_views */;\r\n    const icons_1 = require(309) /* ../../../styles/icons */;\r\n    const tooltips_1 = require(172) /* ../../../styles/tooltips */;\r\n    function _nearest_line_hit(i, geometry, sx, sy, dx, dy) {\r\n        const d1 = { x: dx[i], y: dy[i] };\r\n        const d2 = { x: dx[i + 1], y: dy[i + 1] };\r\n        let dist1;\r\n        let dist2;\r\n        if (geometry.type == \"span\") {\r\n            if (geometry.direction == \"h\") {\r\n                dist1 = Math.abs(d1.x - sx);\r\n                dist2 = Math.abs(d2.x - sx);\r\n            }\r\n            else {\r\n                dist1 = Math.abs(d1.y - sy);\r\n                dist2 = Math.abs(d2.y - sy);\r\n            }\r\n        }\r\n        else {\r\n            const s = { x: sx, y: sy };\r\n            dist1 = hittest.dist_2_pts(d1, s);\r\n            dist2 = hittest.dist_2_pts(d2, s);\r\n        }\r\n        if (dist1 < dist2)\r\n            return [[d1.x, d1.y], i];\r\n        else\r\n            return [[d2.x, d2.y], i + 1];\r\n    }\r\n    exports._nearest_line_hit = _nearest_line_hit;\r\n    function _line_hit(xs, ys, ind) {\r\n        return [[xs[ind], ys[ind]], ind];\r\n    }\r\n    exports._line_hit = _line_hit;\r\n    class HoverToolView extends inspect_tool_1.InspectToolView {\r\n        initialize() {\r\n            super.initialize();\r\n            this._ttmodels = null;\r\n            this._ttviews = new Map();\r\n            const { tooltips } = this.model;\r\n            if (types_1.isArray(tooltips)) {\r\n                this._template_el = this._create_template(tooltips);\r\n            }\r\n        }\r\n        remove() {\r\n            build_views_1.remove_views(this._ttviews);\r\n            super.remove();\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            for (const r of this.computed_renderers) {\r\n                if (r instanceof glyph_renderer_1.GlyphRenderer)\r\n                    this.connect(r.data_source.inspect, this._update);\r\n                else if (r instanceof graph_renderer_1.GraphRenderer) {\r\n                    this.connect(r.node_renderer.data_source.inspect, this._update);\r\n                    this.connect(r.edge_renderer.data_source.inspect, this._update);\r\n                }\r\n            }\r\n            // TODO: this.connect(this.plot_model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null)\r\n            this.connect(this.model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null);\r\n            this.connect(this.model.properties.names.change, () => this._computed_renderers = this._ttmodels = null);\r\n            this.connect(this.model.properties.tooltips.change, () => this._ttmodels = null);\r\n        }\r\n        _compute_ttmodels() {\r\n            const ttmodels = new Map();\r\n            const tooltips = this.model.tooltips;\r\n            if (tooltips != null) {\r\n                for (const r of this.computed_renderers) {\r\n                    const tooltip = new tooltip_1.Tooltip({\r\n                        custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),\r\n                        attachment: this.model.attachment,\r\n                        show_arrow: this.model.show_arrow,\r\n                    });\r\n                    if (r instanceof glyph_renderer_1.GlyphRenderer) {\r\n                        ttmodels.set(r, tooltip);\r\n                    }\r\n                    else if (r instanceof graph_renderer_1.GraphRenderer) {\r\n                        ttmodels.set(r.node_renderer, tooltip);\r\n                        ttmodels.set(r.edge_renderer, tooltip);\r\n                    }\r\n                }\r\n            }\r\n            // XXX: move this to lazy_initialize()\r\n            (async () => {\r\n                const views = await build_views_1.build_views(this._ttviews, [...ttmodels.values()], { parent: this.plot_view });\r\n                for (const ttview of views) {\r\n                    ttview.render();\r\n                }\r\n            })();\r\n            return ttmodels;\r\n        }\r\n        get computed_renderers() {\r\n            if (this._computed_renderers == null) {\r\n                const renderers = this.model.renderers;\r\n                const all_renderers = this.plot_model.renderers;\r\n                const names = this.model.names;\r\n                this._computed_renderers = util_1.compute_renderers(renderers, all_renderers, names);\r\n            }\r\n            return this._computed_renderers;\r\n        }\r\n        get ttmodels() {\r\n            if (this._ttmodels == null)\r\n                this._ttmodels = this._compute_ttmodels();\r\n            return this._ttmodels;\r\n        }\r\n        _clear() {\r\n            this._inspect(Infinity, Infinity);\r\n            for (const [, tooltip] of this.ttmodels) {\r\n                tooltip.clear();\r\n            }\r\n        }\r\n        _move(ev) {\r\n            if (!this.model.active)\r\n                return;\r\n            const { sx, sy } = ev;\r\n            if (!this.plot_view.frame.bbox.contains(sx, sy))\r\n                this._clear();\r\n            else\r\n                this._inspect(sx, sy);\r\n        }\r\n        _move_exit() {\r\n            this._clear();\r\n        }\r\n        _inspect(sx, sy) {\r\n            let geometry;\r\n            if (this.model.mode == 'mouse')\r\n                geometry = { type: 'point', sx, sy };\r\n            else {\r\n                const direction = this.model.mode == 'vline' ? 'h' : 'v';\r\n                geometry = { type: 'span', direction, sx, sy };\r\n            }\r\n            for (const r of this.computed_renderers) {\r\n                const sm = r.get_selection_manager();\r\n                sm.inspect(this.plot_view.renderer_views.get(r), geometry);\r\n            }\r\n            if (this.model.callback != null)\r\n                this._emit_callback(geometry);\r\n        }\r\n        _update([renderer_view, { geometry }]) {\r\n            if (!this.model.active)\r\n                return;\r\n            if (!(renderer_view instanceof glyph_renderer_1.GlyphRendererView)) // || renderer_view instanceof GraphRendererView))\r\n                return;\r\n            const { model: renderer } = renderer_view;\r\n            if (this.model.muted_policy == 'ignore' && renderer instanceof glyph_renderer_1.GlyphRenderer && renderer.muted)\r\n                return;\r\n            const tooltip = this.ttmodels.get(renderer);\r\n            if (tooltip == null)\r\n                return;\r\n            const selection_manager = renderer.get_selection_manager();\r\n            let indices = selection_manager.inspectors.get(renderer);\r\n            if (renderer instanceof glyph_renderer_1.GlyphRenderer)\r\n                indices = renderer.view.convert_selection_to_subset(indices);\r\n            if (indices.is_empty()) {\r\n                tooltip.clear();\r\n                return;\r\n            }\r\n            const ds = selection_manager.source;\r\n            const { sx, sy } = geometry;\r\n            const xscale = renderer_view.coordinates.x_scale;\r\n            const yscale = renderer_view.coordinates.y_scale;\r\n            const x = xscale.invert(sx);\r\n            const y = yscale.invert(sy);\r\n            const glyph = renderer_view.glyph; // XXX\r\n            const tooltips = [];\r\n            for (const i of indices.line_indices) {\r\n                let data_x = glyph._x[i + 1];\r\n                let data_y = glyph._y[i + 1];\r\n                let ii = i;\r\n                let rx;\r\n                let ry;\r\n                switch (this.model.line_policy) {\r\n                    case \"interp\": { // and renderer.get_interpolation_hit?\r\n                        [data_x, data_y] = glyph.get_interpolation_hit(i, geometry);\r\n                        rx = xscale.compute(data_x);\r\n                        ry = yscale.compute(data_y);\r\n                        break;\r\n                    }\r\n                    case \"prev\": {\r\n                        [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i);\r\n                        break;\r\n                    }\r\n                    case \"next\": {\r\n                        [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i + 1);\r\n                        break;\r\n                    }\r\n                    case \"nearest\": {\r\n                        [[rx, ry], ii] = _nearest_line_hit(i, geometry, sx, sy, glyph.sx, glyph.sy);\r\n                        data_x = glyph._x[ii];\r\n                        data_y = glyph._y[ii];\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        [rx, ry] = [sx, sy];\r\n                    }\r\n                }\r\n                const vars = {\r\n                    index: ii,\r\n                    x, y, sx, sy, data_x, data_y, rx, ry,\r\n                    indices: indices.line_indices,\r\n                    name: renderer_view.model.name,\r\n                };\r\n                tooltips.push([rx, ry, this._render_tooltips(ds, ii, vars)]);\r\n            }\r\n            for (const struct of indices.image_indices) {\r\n                const vars = {\r\n                    index: struct.index,\r\n                    x, y, sx, sy,\r\n                    name: renderer_view.model.name,\r\n                };\r\n                const rendered = this._render_tooltips(ds, struct, vars);\r\n                tooltips.push([sx, sy, rendered]);\r\n            }\r\n            for (const i of indices.indices) {\r\n                // multiglyphs set additional indices, e.g. multiline_indices for different tooltips\r\n                if (!object_1.isEmpty(indices.multiline_indices)) {\r\n                    for (const j of indices.multiline_indices[i.toString()]) { // TODO: indices.multiline_indices.get(i)\r\n                        let data_x = glyph._xs[i][j];\r\n                        let data_y = glyph._ys[i][j];\r\n                        let jj = j;\r\n                        let rx;\r\n                        let ry;\r\n                        switch (this.model.line_policy) {\r\n                            case \"interp\": { // and renderer.get_interpolation_hit?\r\n                                [data_x, data_y] = glyph.get_interpolation_hit(i, j, geometry);\r\n                                rx = xscale.compute(data_x);\r\n                                ry = yscale.compute(data_y);\r\n                                break;\r\n                            }\r\n                            case \"prev\": {\r\n                                [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j);\r\n                                break;\r\n                            }\r\n                            case \"next\": {\r\n                                [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j + 1);\r\n                                break;\r\n                            }\r\n                            case \"nearest\": {\r\n                                [[rx, ry], jj] = _nearest_line_hit(j, geometry, sx, sy, glyph.sxs[i], glyph.sys[i]);\r\n                                data_x = glyph._xs[i][jj];\r\n                                data_y = glyph._ys[i][jj];\r\n                                break;\r\n                            }\r\n                            default:\r\n                                throw new Error(\"should't have happened\");\r\n                        }\r\n                        let index;\r\n                        if (renderer instanceof glyph_renderer_1.GlyphRenderer)\r\n                            index = renderer.view.convert_indices_from_subset([i])[0];\r\n                        else\r\n                            index = i;\r\n                        const vars = {\r\n                            index, x, y, sx, sy, data_x, data_y,\r\n                            segment_index: jj,\r\n                            indices: indices.multiline_indices,\r\n                            name: renderer_view.model.name,\r\n                        };\r\n                        tooltips.push([rx, ry, this._render_tooltips(ds, index, vars)]);\r\n                    }\r\n                }\r\n                else {\r\n                    // handle non-multiglyphs\r\n                    const data_x = glyph._x != null ? glyph._x[i] : undefined;\r\n                    const data_y = glyph._y != null ? glyph._y[i] : undefined;\r\n                    let rx;\r\n                    let ry;\r\n                    if (this.model.point_policy == 'snap_to_data') { // and renderer.glyph.sx? and renderer.glyph.sy?\r\n                        // Pass in our screen position so we can determine which patch we're\r\n                        // over if there are discontinuous patches.\r\n                        let pt = glyph.get_anchor_point(this.model.anchor, i, [sx, sy]);\r\n                        if (pt == null)\r\n                            pt = glyph.get_anchor_point(\"center\", i, [sx, sy]);\r\n                        rx = pt.x;\r\n                        ry = pt.y;\r\n                    }\r\n                    else\r\n                        [rx, ry] = [sx, sy];\r\n                    let index;\r\n                    if (renderer instanceof glyph_renderer_1.GlyphRenderer)\r\n                        index = renderer.view.convert_indices_from_subset([i])[0];\r\n                    else\r\n                        index = i;\r\n                    const vars = {\r\n                        index, x, y, sx, sy, data_x, data_y,\r\n                        indices: indices.indices,\r\n                        name: renderer_view.model.name,\r\n                    };\r\n                    tooltips.push([rx, ry, this._render_tooltips(ds, index, vars)]);\r\n                }\r\n            }\r\n            if (tooltips.length == 0)\r\n                tooltip.clear();\r\n            else {\r\n                const { content } = tooltip;\r\n                dom_1.empty(tooltip.content);\r\n                for (const [, , node] of tooltips) {\r\n                    content.appendChild(node);\r\n                }\r\n                const [x, y] = tooltips[tooltips.length - 1];\r\n                tooltip.setv({ position: [x, y] }, { check_eq: false }); // XXX: force update\r\n            }\r\n        }\r\n        _emit_callback(geometry) {\r\n            for (const r of this.computed_renderers) {\r\n                const rv = this.plot_view.renderer_views.get(r);\r\n                const x = rv.coordinates.x_scale.invert(geometry.sx);\r\n                const y = rv.coordinates.y_scale.invert(geometry.sy);\r\n                const index = r.data_source.inspected;\r\n                const g = Object.assign({ x, y }, geometry);\r\n                this.model.callback.execute(this.model, { index, geometry: g, renderer: r });\r\n            }\r\n        }\r\n        _create_template(tooltips) {\r\n            const rows = dom_1.div({ style: { display: \"table\", borderSpacing: \"2px\" } });\r\n            for (const [label] of tooltips) {\r\n                const row = dom_1.div({ style: { display: \"table-row\" } });\r\n                rows.appendChild(row);\r\n                const label_cell = dom_1.div({ style: { display: \"table-cell\" }, class: tooltips_1.bk_tooltip_row_label }, label.length != 0 ? `${label}: ` : \"\");\r\n                row.appendChild(label_cell);\r\n                const value_el = dom_1.span();\r\n                value_el.dataset.value = \"\";\r\n                const swatch_el = dom_1.span({ class: tooltips_1.bk_tooltip_color_block }, \" \");\r\n                swatch_el.dataset.swatch = \"\";\r\n                dom_1.undisplay(swatch_el);\r\n                const value_cell = dom_1.div({ style: { display: \"table-cell\" }, class: tooltips_1.bk_tooltip_row_value }, value_el, swatch_el);\r\n                row.appendChild(value_cell);\r\n            }\r\n            return rows;\r\n        }\r\n        _render_template(template, tooltips, ds, i, vars) {\r\n            const el = template.cloneNode(true);\r\n            const value_els = el.querySelectorAll(\"[data-value]\");\r\n            const swatch_els = el.querySelectorAll(\"[data-swatch]\");\r\n            const color_re = /\\$color(\\[.*\\])?:(\\w*)/;\r\n            for (const [[, value], j] of iterator_1.enumerate(tooltips)) {\r\n                const result = value.match(color_re);\r\n                if (result != null) {\r\n                    const [, opts = \"\", colname] = result;\r\n                    const column = ds.get_column(colname); // XXX: change to columnar ds\r\n                    if (column == null) {\r\n                        value_els[j].textContent = `${colname} unknown`;\r\n                        continue;\r\n                    }\r\n                    const hex = opts.indexOf(\"hex\") >= 0;\r\n                    const swatch = opts.indexOf(\"swatch\") >= 0;\r\n                    let color = types_1.isNumber(i) ? column[i] : null;\r\n                    if (color == null) {\r\n                        value_els[j].textContent = \"(null)\";\r\n                        continue;\r\n                    }\r\n                    if (hex)\r\n                        color = color_1.color2hex(color);\r\n                    value_els[j].textContent = color;\r\n                    if (swatch) {\r\n                        swatch_els[j].style.backgroundColor = color;\r\n                        dom_1.display(swatch_els[j]);\r\n                    }\r\n                }\r\n                else {\r\n                    const content = templating_1.replace_placeholders(value.replace(\"$~\", \"$data_\"), ds, i, this.model.formatters, vars);\r\n                    if (types_1.isString(content)) {\r\n                        value_els[j].textContent = content;\r\n                    }\r\n                    else {\r\n                        for (const el of content) {\r\n                            value_els[j].appendChild(el);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return el;\r\n        }\r\n        _render_tooltips(ds, i, vars) {\r\n            const tooltips = this.model.tooltips;\r\n            if (types_1.isString(tooltips)) {\r\n                const content = templating_1.replace_placeholders({ html: tooltips }, ds, i, this.model.formatters, vars);\r\n                return dom_1.div({}, content);\r\n            }\r\n            else if (types_1.isFunction(tooltips)) {\r\n                return tooltips(ds, vars);\r\n            }\r\n            else {\r\n                return this._render_template(this._template_el, tooltips, ds, i, vars);\r\n            }\r\n        }\r\n    }\r\n    exports.HoverToolView = HoverToolView;\r\n    HoverToolView.__name__ = \"HoverToolView\";\r\n    class HoverTool extends inspect_tool_1.InspectTool {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n            this.tool_name = \"Hover\";\r\n            this.icon = icons_1.bk_tool_icon_hover;\r\n        }\r\n        static init_HoverTool() {\r\n            this.prototype.default_view = HoverToolView;\r\n            this.define({\r\n                tooltips: [p.Any, [\r\n                        [\"index\", \"$index\"],\r\n                        [\"data (x, y)\", \"($x, $y)\"],\r\n                        [\"screen (x, y)\", \"($sx, $sy)\"],\r\n                    ]],\r\n                formatters: [p.Any, {}],\r\n                renderers: [p.Any, 'auto'],\r\n                names: [p.Array, []],\r\n                mode: [p.HoverMode, 'mouse'],\r\n                muted_policy: [p.MutedPolicy, 'show'],\r\n                point_policy: [p.PointPolicy, 'snap_to_data'],\r\n                line_policy: [p.LinePolicy, 'nearest'],\r\n                show_arrow: [p.Boolean, true],\r\n                anchor: [p.Anchor, 'center'],\r\n                attachment: [p.TooltipAttachment, 'horizontal'],\r\n                callback: [p.Any],\r\n            });\r\n            this.register_alias(\"hover\", () => new HoverTool());\r\n        }\r\n    }\r\n    exports.HoverTool = HoverTool;\r\n    HoverTool.__name__ = \"HoverTool\";\r\n    HoverTool.init_HoverTool();\r\n}\r\n","/* models\\tools\\tool_proxy.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const signaling_1 = require(15) /* ../../core/signaling */;\r\n    const model_1 = require(81) /* ../../model */;\r\n    const inspect_tool_1 = require(295) /* ./inspectors/inspect_tool */;\r\n    const iterator_1 = require(303) /* ../../core/util/iterator */;\r\n    class ToolProxy extends model_1.Model {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ToolProxy() {\r\n            this.define({\r\n                tools: [p.Array, []],\r\n                active: [p.Boolean, false],\r\n                disabled: [p.Boolean, false],\r\n            });\r\n        }\r\n        // Operates all the tools given only one button\r\n        get button_view() {\r\n            return this.tools[0].button_view;\r\n        }\r\n        get event_type() {\r\n            return this.tools[0].event_type;\r\n        }\r\n        get tooltip() {\r\n            return this.tools[0].tooltip;\r\n        }\r\n        get tool_name() {\r\n            return this.tools[0].tool_name;\r\n        }\r\n        get icon() {\r\n            return this.tools[0].computed_icon;\r\n        }\r\n        get computed_icon() {\r\n            return this.icon;\r\n        }\r\n        get toggleable() {\r\n            const tool = this.tools[0];\r\n            return tool instanceof inspect_tool_1.InspectTool && tool.toggleable;\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this.do = new signaling_1.Signal0(this, \"do\");\r\n        }\r\n        connect_signals() {\r\n            super.connect_signals();\r\n            this.connect(this.do, () => this.doit());\r\n            this.connect(this.properties.active.change, () => this.set_active());\r\n            for (const tool of this.tools) {\r\n                this.connect(tool.properties.active.change, () => {\r\n                    this.active = tool.active;\r\n                });\r\n            }\r\n        }\r\n        doit() {\r\n            for (const tool of this.tools) {\r\n                tool.do.emit();\r\n            }\r\n        }\r\n        set_active() {\r\n            for (const tool of this.tools) {\r\n                tool.active = this.active;\r\n            }\r\n        }\r\n        get menu() {\r\n            const { menu } = this.tools[0];\r\n            if (menu == null)\r\n                return null;\r\n            const items = [];\r\n            for (const [item, i] of iterator_1.enumerate(menu)) {\r\n                if (item == null)\r\n                    items.push(null);\r\n                else {\r\n                    const handler = () => {\r\n                        var _a, _b;\r\n                        for (const tool of this.tools) {\r\n                            (_b = (_a = tool.menu) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.handler();\r\n                        }\r\n                    };\r\n                    items.push(Object.assign(Object.assign({}, item), { handler }));\r\n                }\r\n            }\r\n            return items;\r\n        }\r\n    }\r\n    exports.ToolProxy = ToolProxy;\r\n    ToolProxy.__name__ = \"ToolProxy\";\r\n    ToolProxy.init_ToolProxy();\r\n}\r\n","/* models\\tools\\toolbar_box.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    const p = tslib_1.__importStar(require(18) /* ../../core/properties */);\r\n    const array_1 = require(9) /* ../../core/util/array */;\r\n    const object_1 = require(13) /* ../../core/util/object */;\r\n    const toolbar_base_1 = require(305) /* ./toolbar_base */;\r\n    const tool_proxy_1 = require(379) /* ./tool_proxy */;\r\n    const layout_dom_1 = require(272) /* ../layouts/layout_dom */;\r\n    const layout_1 = require(212) /* ../../core/layout */;\r\n    class ProxyToolbar extends toolbar_base_1.ToolbarBase {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ProxyToolbar() {\r\n            this.define({\r\n                toolbars: [p.Array, []],\r\n            });\r\n        }\r\n        initialize() {\r\n            super.initialize();\r\n            this._merge_tools();\r\n        }\r\n        _merge_tools() {\r\n            // Go through all the tools on the toolbar and replace them with\r\n            // a proxy e.g. PanTool, BoxSelectTool, etc.\r\n            this._proxied_tools = [];\r\n            const inspectors = {};\r\n            const actions = {};\r\n            const gestures = {};\r\n            const new_help_tools = [];\r\n            const new_help_urls = [];\r\n            for (const helptool of this.help) {\r\n                if (!array_1.includes(new_help_urls, helptool.redirect)) {\r\n                    new_help_tools.push(helptool);\r\n                    new_help_urls.push(helptool.redirect);\r\n                }\r\n            }\r\n            this._proxied_tools.push(...new_help_tools);\r\n            this.help = new_help_tools;\r\n            for (const [event_type, gesture] of object_1.entries(this.gestures)) {\r\n                if (!(event_type in gestures)) {\r\n                    gestures[event_type] = {};\r\n                }\r\n                for (const tool of gesture.tools) {\r\n                    if (!(tool.type in gestures[event_type])) {\r\n                        gestures[event_type][tool.type] = [];\r\n                    }\r\n                    gestures[event_type][tool.type].push(tool);\r\n                }\r\n            }\r\n            for (const tool of this.inspectors) {\r\n                if (!(tool.type in inspectors)) {\r\n                    inspectors[tool.type] = [];\r\n                }\r\n                inspectors[tool.type].push(tool);\r\n            }\r\n            for (const tool of this.actions) {\r\n                if (!(tool.type in actions)) {\r\n                    actions[tool.type] = [];\r\n                }\r\n                actions[tool.type].push(tool);\r\n            }\r\n            // Add a proxy for each of the groups of tools.\r\n            const make_proxy = (tools, active = false) => {\r\n                const proxy = new tool_proxy_1.ToolProxy({ tools, active });\r\n                this._proxied_tools.push(proxy);\r\n                return proxy;\r\n            };\r\n            for (const event_type of object_1.keys(gestures)) {\r\n                const gesture = this.gestures[event_type];\r\n                gesture.tools = [];\r\n                for (const tool_type of object_1.keys(gestures[event_type])) {\r\n                    const tools = gestures[event_type][tool_type];\r\n                    if (tools.length > 0) {\r\n                        if (event_type == 'multi') {\r\n                            for (const tool of tools) {\r\n                                const proxy = make_proxy([tool]);\r\n                                gesture.tools.push(proxy);\r\n                                this.connect(proxy.properties.active.change, () => this._active_change(proxy));\r\n                            }\r\n                        }\r\n                        else {\r\n                            const proxy = make_proxy(tools);\r\n                            gesture.tools.push(proxy);\r\n                            this.connect(proxy.properties.active.change, () => this._active_change(proxy));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.actions = [];\r\n            for (const [tool_type, tools] of object_1.entries(actions)) {\r\n                if (tool_type == 'CustomAction') {\r\n                    for (const tool of tools)\r\n                        this.actions.push(make_proxy([tool]));\r\n                }\r\n                else if (tools.length > 0) {\r\n                    this.actions.push(make_proxy(tools)); // XXX\r\n                }\r\n            }\r\n            this.inspectors = [];\r\n            for (const tools of object_1.values(inspectors)) {\r\n                if (tools.length > 0)\r\n                    this.inspectors.push(make_proxy(tools, true)); // XXX\r\n            }\r\n            for (const [et, gesture] of object_1.entries(this.gestures)) {\r\n                if (gesture.tools.length == 0)\r\n                    continue;\r\n                gesture.tools = array_1.sort_by(gesture.tools, (tool) => tool.default_order);\r\n                if (!(et == 'pinch' || et == 'scroll' || et == 'multi'))\r\n                    gesture.tools[0].active = true;\r\n            }\r\n        }\r\n    }\r\n    exports.ProxyToolbar = ProxyToolbar;\r\n    ProxyToolbar.__name__ = \"ProxyToolbar\";\r\n    ProxyToolbar.init_ProxyToolbar();\r\n    class ToolbarBoxView extends layout_dom_1.LayoutDOMView {\r\n        initialize() {\r\n            this.model.toolbar.toolbar_location = this.model.toolbar_location;\r\n            super.initialize();\r\n        }\r\n        get child_models() {\r\n            return [this.model.toolbar]; // XXX\r\n        }\r\n        _update_layout() {\r\n            this.layout = new layout_1.ContentBox(this.child_views[0].el);\r\n            const { toolbar } = this.model;\r\n            if (toolbar.horizontal) {\r\n                this.layout.set_sizing({\r\n                    width_policy: \"fit\", min_width: 100, height_policy: \"fixed\",\r\n                });\r\n            }\r\n            else {\r\n                this.layout.set_sizing({\r\n                    width_policy: \"fixed\", height_policy: \"fit\", min_height: 100,\r\n                });\r\n            }\r\n        }\r\n    }\r\n    exports.ToolbarBoxView = ToolbarBoxView;\r\n    ToolbarBoxView.__name__ = \"ToolbarBoxView\";\r\n    class ToolbarBox extends layout_dom_1.LayoutDOM {\r\n        constructor(attrs) {\r\n            super(attrs);\r\n        }\r\n        static init_ToolbarBox() {\r\n            this.prototype.default_view = ToolbarBoxView;\r\n            this.define({\r\n                toolbar: [p.Instance],\r\n                toolbar_location: [p.Location, \"right\"],\r\n            });\r\n        }\r\n    }\r\n    exports.ToolbarBox = ToolbarBox;\r\n    ToolbarBox.__name__ = \"ToolbarBox\";\r\n    ToolbarBox.init_ToolbarBox();\r\n}\r\n","/* embed\\standalone.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const document_1 = require(5) /* ../document */;\r\n    const dom_view_1 = require(78) /* ../core/dom_view */;\r\n    const build_views_1 = require(115) /* ../core/build_views */;\r\n    const dom_1 = require(72) /* ../core/dom */;\r\n    const dom_2 = require(382) /* ./dom */;\r\n    // A map from the root model IDs to their views.\r\n    exports.index = {};\r\n    async function add_document_standalone(document, element, roots = [], use_for_title = false) {\r\n        // this is a LOCAL index of views used only by this particular rendering\r\n        // call, so we can remove the views we create.\r\n        const views = new Map();\r\n        async function render_model(model) {\r\n            let root_el;\r\n            const root_models = document.roots();\r\n            const idx = root_models.indexOf(model);\r\n            const root = roots[idx];\r\n            if (root != null)\r\n                root_el = root;\r\n            else if (element.classList.contains(dom_2.BOKEH_ROOT))\r\n                root_el = element;\r\n            else {\r\n                root_el = dom_1.div({ class: dom_2.BOKEH_ROOT });\r\n                element.appendChild(root_el);\r\n            }\r\n            const view = await build_views_1.build_view(model, { parent: null });\r\n            if (view instanceof dom_view_1.DOMView)\r\n                view.renderTo(root_el);\r\n            views.set(model, view);\r\n            exports.index[model.id] = view;\r\n            return view;\r\n        }\r\n        function unrender_model(model) {\r\n            const view = views.get(model);\r\n            if (view != null) {\r\n                view.remove();\r\n                views.delete(model);\r\n                delete exports.index[model.id];\r\n            }\r\n        }\r\n        for (const model of document.roots())\r\n            await render_model(model);\r\n        if (use_for_title)\r\n            window.document.title = document.title();\r\n        document.on_change((event) => {\r\n            if (event instanceof document_1.RootAddedEvent)\r\n                render_model(event.model);\r\n            else if (event instanceof document_1.RootRemovedEvent)\r\n                unrender_model(event.model);\r\n            else if (use_for_title && event instanceof document_1.TitleChangedEvent)\r\n                window.document.title = event.title;\r\n        });\r\n        return [...views.values()];\r\n    }\r\n    exports.add_document_standalone = add_document_standalone;\r\n}\r\n","/* embed\\dom.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const dom_1 = require(72) /* ../core/dom */;\r\n    const root_1 = require(273) /* ../styles/root */;\r\n    // Matches Bokeh CSS class selector. Setting all Bokeh parent element class names\r\n    // with this var prevents user configurations where css styling is unset.\r\n    exports.BOKEH_ROOT = root_1.bk_root;\r\n    function _get_element(elementid) {\r\n        let element = document.getElementById(elementid);\r\n        if (element == null)\r\n            throw new Error(`Error rendering Bokeh model: could not find #${elementid} HTML tag`);\r\n        if (!document.body.contains(element))\r\n            throw new Error(`Error rendering Bokeh model: element #${elementid} must be under <body>`);\r\n        // If autoload script, replace script tag with div for embedding.\r\n        if (element.tagName == \"SCRIPT\") {\r\n            const root_el = dom_1.div({ class: exports.BOKEH_ROOT });\r\n            dom_1.replaceWith(element, root_el);\r\n            element = root_el;\r\n        }\r\n        return element;\r\n    }\r\n    function _resolve_element(item) {\r\n        const { elementid } = item;\r\n        if (elementid != null)\r\n            return _get_element(elementid);\r\n        else\r\n            return document.body;\r\n    }\r\n    exports._resolve_element = _resolve_element;\r\n    function _resolve_root_elements(item) {\r\n        const roots = [];\r\n        if ((item.root_ids != null) && (item.roots != null)) {\r\n            for (const root_id of item.root_ids)\r\n                roots.push(_get_element(item.roots[root_id]));\r\n        }\r\n        return roots;\r\n    }\r\n    exports._resolve_root_elements = _resolve_root_elements;\r\n}\r\n","/* embed\\server.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const connection_1 = require(384) /* ../client/connection */;\r\n    const logging_1 = require(19) /* ../core/logging */;\r\n    const standalone_1 = require(381) /* ./standalone */;\r\n    // @internal\r\n    function _get_ws_url(app_path, absolute_url) {\r\n        let protocol = 'ws:';\r\n        if (window.location.protocol == 'https:')\r\n            protocol = 'wss:';\r\n        let loc;\r\n        if (absolute_url != null) {\r\n            loc = document.createElement('a');\r\n            loc.href = absolute_url;\r\n        }\r\n        else\r\n            loc = window.location;\r\n        if (app_path != null) {\r\n            if (app_path == \"/\")\r\n                app_path = \"\";\r\n        }\r\n        else\r\n            app_path = loc.pathname.replace(/\\/+$/, '');\r\n        return protocol + '//' + loc.host + app_path + '/ws';\r\n    }\r\n    exports._get_ws_url = _get_ws_url;\r\n    // map { websocket url to map { session id to promise of ClientSession } }\r\n    const _sessions = {};\r\n    function _get_session(websocket_url, token, args_string) {\r\n        const session_id = connection_1.parse_token(token).session_id;\r\n        if (!(websocket_url in _sessions))\r\n            _sessions[websocket_url] = {};\r\n        const subsessions = _sessions[websocket_url];\r\n        if (!(session_id in subsessions))\r\n            subsessions[session_id] = connection_1.pull_session(websocket_url, token, args_string);\r\n        return subsessions[session_id];\r\n    }\r\n    // Fill element with the roots from token\r\n    async function add_document_from_session(websocket_url, token, element, roots = [], use_for_title = false) {\r\n        const args_string = window.location.search.substr(1);\r\n        let session;\r\n        try {\r\n            session = await _get_session(websocket_url, token, args_string);\r\n        }\r\n        catch (error) {\r\n            const session_id = connection_1.parse_token(token).session_id;\r\n            logging_1.logger.error(`Failed to load Bokeh session ${session_id}: ${error}`);\r\n            throw error;\r\n        }\r\n        return standalone_1.add_document_standalone(session.document, element, roots, use_for_title);\r\n    }\r\n    exports.add_document_from_session = add_document_from_session;\r\n}\r\n","/* client\\connection.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const logging_1 = require(19) /* ../core/logging */;\r\n    const document_1 = require(5) /* ../document */;\r\n    const message_1 = require(385) /* ../protocol/message */;\r\n    const receiver_1 = require(386) /* ../protocol/receiver */;\r\n    const session_1 = require(387) /* ./session */;\r\n    exports.DEFAULT_SERVER_WEBSOCKET_URL = \"ws://localhost:5006/ws\";\r\n    exports.DEFAULT_TOKEN = \"eyJzZXNzaW9uX2lkIjogImRlZmF1bHQifQ\";\r\n    let _connection_count = 0;\r\n    function parse_token(token) {\r\n        let payload = token.split('.')[0];\r\n        const mod = payload.length % 4;\r\n        if (mod != 0)\r\n            payload = payload + \"=\".repeat(4 - mod);\r\n        return JSON.parse(atob(payload.replace(/_/g, '/').replace(/-/g, '+')));\r\n    }\r\n    exports.parse_token = parse_token;\r\n    class ClientConnection {\r\n        constructor(url = exports.DEFAULT_SERVER_WEBSOCKET_URL, token = exports.DEFAULT_TOKEN, args_string = null) {\r\n            this.url = url;\r\n            this.token = token;\r\n            this.args_string = args_string;\r\n            this._number = _connection_count++;\r\n            this.socket = null;\r\n            this.session = null;\r\n            this.closed_permanently = false;\r\n            this._current_handler = null;\r\n            this._pending_replies = new Map();\r\n            this._pending_messages = [];\r\n            this._receiver = new receiver_1.Receiver();\r\n            this.id = parse_token(token).session_id.split('.')[0];\r\n            logging_1.logger.debug(`Creating websocket ${this._number} to '${this.url}' session '${this.id}'`);\r\n        }\r\n        async connect() {\r\n            if (this.closed_permanently)\r\n                throw new Error(\"Cannot connect() a closed ClientConnection\");\r\n            if (this.socket != null)\r\n                throw new Error(\"Already connected\");\r\n            this._current_handler = null;\r\n            this._pending_replies.clear();\r\n            this._pending_messages = [];\r\n            try {\r\n                let versioned_url = `${this.url}`;\r\n                if (this.args_string != null && this.args_string.length > 0)\r\n                    versioned_url += `?${this.args_string}`;\r\n                this.socket = new WebSocket(versioned_url, [\"bokeh\", this.token]);\r\n                return new Promise((resolve, reject) => {\r\n                    // \"arraybuffer\" gives us binary data we can look at;\r\n                    // if we just needed an opaque blob we could use \"blob\"\r\n                    this.socket.binaryType = \"arraybuffer\";\r\n                    this.socket.onopen = () => this._on_open(resolve, reject);\r\n                    this.socket.onmessage = (event) => this._on_message(event);\r\n                    this.socket.onclose = (event) => this._on_close(event, reject);\r\n                    this.socket.onerror = () => this._on_error(reject);\r\n                });\r\n            }\r\n            catch (error) {\r\n                logging_1.logger.error(`websocket creation failed to url: ${this.url}`);\r\n                logging_1.logger.error(` - ${error}`);\r\n                throw error;\r\n            }\r\n        }\r\n        close() {\r\n            if (!this.closed_permanently) {\r\n                logging_1.logger.debug(`Permanently closing websocket connection ${this._number}`);\r\n                this.closed_permanently = true;\r\n                if (this.socket != null)\r\n                    this.socket.close(1000, `close method called on ClientConnection ${this._number}`);\r\n                this.session._connection_closed();\r\n            }\r\n        }\r\n        _schedule_reconnect(milliseconds) {\r\n            const retry = () => {\r\n                // TODO commented code below until we fix reconnection to repull\r\n                // the document when required. Otherwise, we get a lot of\r\n                // confusing errors that are causing trouble when debugging.\r\n                /*\r\n                if (this.closed_permanently) {\r\n                */\r\n                if (!this.closed_permanently)\r\n                    logging_1.logger.info(`Websocket connection ${this._number} disconnected, will not attempt to reconnect`);\r\n                return;\r\n                /*\r\n                } else {\r\n                  logger.debug(`Attempting to reconnect websocket ${this._number}`)\r\n                  this.connect()\r\n                }\r\n                */\r\n            };\r\n            setTimeout(retry, milliseconds);\r\n        }\r\n        send(message) {\r\n            if (this.socket == null)\r\n                throw new Error(`not connected so cannot send ${message}`);\r\n            message.send(this.socket);\r\n        }\r\n        async send_with_reply(message) {\r\n            const reply = await new Promise((resolve, reject) => {\r\n                this._pending_replies.set(message.msgid(), { resolve, reject });\r\n                this.send(message);\r\n            });\r\n            if (reply.msgtype() === \"ERROR\")\r\n                throw new Error(`Error reply ${reply.content.text}`);\r\n            else\r\n                return reply;\r\n        }\r\n        async _pull_doc_json() {\r\n            const message = message_1.Message.create(\"PULL-DOC-REQ\", {});\r\n            const reply = await this.send_with_reply(message);\r\n            if (!(\"doc\" in reply.content))\r\n                throw new Error(\"No 'doc' field in PULL-DOC-REPLY\");\r\n            return reply.content.doc;\r\n        }\r\n        async _repull_session_doc(resolve, reject) {\r\n            var _a;\r\n            logging_1.logger.debug(this.session ? \"Repulling session\" : \"Pulling session for first time\");\r\n            try {\r\n                const doc_json = await this._pull_doc_json();\r\n                if (this.session == null) {\r\n                    if (this.closed_permanently) {\r\n                        logging_1.logger.debug(\"Got new document after connection was already closed\");\r\n                        reject(new Error(\"The connection has been closed\"));\r\n                    }\r\n                    else {\r\n                        const document = document_1.Document.from_json(doc_json);\r\n                        // Constructing models changes some of their attributes, we deal with that\r\n                        // here. This happens when models set attributes during construction\r\n                        // or initialization.\r\n                        const patch = document_1.Document._compute_patch_since_json(doc_json, document);\r\n                        if (patch.events.length > 0) {\r\n                            logging_1.logger.debug(`Sending ${patch.events.length} changes from model construction back to server`);\r\n                            const patch_message = message_1.Message.create('PATCH-DOC', {}, patch);\r\n                            this.send(patch_message);\r\n                        }\r\n                        this.session = new session_1.ClientSession(this, document, this.id);\r\n                        for (const msg of this._pending_messages) {\r\n                            this.session.handle(msg);\r\n                        }\r\n                        this._pending_messages = [];\r\n                        logging_1.logger.debug(\"Created a new session from new pulled doc\");\r\n                        resolve(this.session);\r\n                    }\r\n                }\r\n                else {\r\n                    this.session.document.replace_with_json(doc_json);\r\n                    logging_1.logger.debug(\"Updated existing session with new pulled doc\");\r\n                    // Since the session already exists, we don't need to call `resolve` again.\r\n                }\r\n            }\r\n            catch (error) {\r\n                (_a = console.trace) === null || _a === void 0 ? void 0 : _a.call(console, error);\r\n                logging_1.logger.error(`Failed to repull session ${error}`);\r\n                reject(error);\r\n            }\r\n        }\r\n        _on_open(resolve, reject) {\r\n            logging_1.logger.info(`Websocket connection ${this._number} is now open`);\r\n            this._current_handler = (message) => {\r\n                this._awaiting_ack_handler(message, resolve, reject);\r\n            };\r\n        }\r\n        _on_message(event) {\r\n            if (this._current_handler == null)\r\n                logging_1.logger.error(\"Got a message with no current handler set\");\r\n            try {\r\n                this._receiver.consume(event.data);\r\n            }\r\n            catch (e) {\r\n                this._close_bad_protocol(e.toString());\r\n            }\r\n            const msg = this._receiver.message;\r\n            if (msg != null) {\r\n                const problem = msg.problem();\r\n                if (problem != null)\r\n                    this._close_bad_protocol(problem);\r\n                this._current_handler(msg);\r\n            }\r\n        }\r\n        _on_close(event, reject) {\r\n            logging_1.logger.info(`Lost websocket ${this._number} connection, ${event.code} (${event.reason})`);\r\n            this.socket = null;\r\n            this._pending_replies.forEach((pr) => pr.reject(\"Disconnected\"));\r\n            this._pending_replies.clear();\r\n            if (!this.closed_permanently)\r\n                this._schedule_reconnect(2000);\r\n            reject(new Error(`Lost websocket connection, ${event.code} (${event.reason})`));\r\n        }\r\n        _on_error(reject) {\r\n            logging_1.logger.debug(`Websocket error on socket ${this._number}`);\r\n            const msg = \"Could not open websocket\";\r\n            logging_1.logger.error(`Failed to connect to Bokeh server: ${msg}`);\r\n            reject(new Error(msg));\r\n        }\r\n        _close_bad_protocol(detail) {\r\n            logging_1.logger.error(`Closing connection: ${detail}`);\r\n            if (this.socket != null)\r\n                this.socket.close(1002, detail); // 1002 = protocol error\r\n        }\r\n        _awaiting_ack_handler(message, resolve, reject) {\r\n            if (message.msgtype() === \"ACK\") {\r\n                this._current_handler = (message) => this._steady_state_handler(message);\r\n                // Reload any sessions\r\n                this._repull_session_doc(resolve, reject);\r\n            }\r\n            else\r\n                this._close_bad_protocol(\"First message was not an ACK\");\r\n        }\r\n        _steady_state_handler(message) {\r\n            const reqid = message.reqid();\r\n            const pr = this._pending_replies.get(reqid);\r\n            if (pr) {\r\n                this._pending_replies.delete(reqid);\r\n                pr.resolve(message);\r\n            }\r\n            else if (this.session) {\r\n                this.session.handle(message);\r\n            }\r\n            else if (message.msgtype() != 'PATCH-DOC') {\r\n                // This branch can be executed only before we get the document.\r\n                // When we get the document, all of the patches will already be incorporated.\r\n                // In general, it's not possible to apply patches received before the document,\r\n                // since they may change some models that were removed before serving the document.\r\n                this._pending_messages.push(message);\r\n            }\r\n        }\r\n    }\r\n    exports.ClientConnection = ClientConnection;\r\n    ClientConnection.__name__ = \"ClientConnection\";\r\n    function pull_session(url, token, args_string) {\r\n        const connection = new ClientConnection(url, token, args_string);\r\n        return connection.connect();\r\n    }\r\n    exports.pull_session = pull_session;\r\n}\r\n","/* protocol\\message.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const string_1 = require(29) /* ../core/util/string */;\r\n    class Message {\r\n        constructor(header, metadata, content) {\r\n            this.header = header;\r\n            this.metadata = metadata;\r\n            this.content = content;\r\n            this.buffers = new Map();\r\n        }\r\n        static assemble(header_json, metadata_json, content_json) {\r\n            const header = JSON.parse(header_json);\r\n            const metadata = JSON.parse(metadata_json);\r\n            const content = JSON.parse(content_json);\r\n            return new Message(header, metadata, content);\r\n        }\r\n        assemble_buffer(buf_header, buf_payload) {\r\n            const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\r\n            if (nb <= this.buffers.size)\r\n                throw new Error(`too many buffers received, expecting ${nb}`);\r\n            const { id } = JSON.parse(buf_header);\r\n            this.buffers.set(id, buf_payload);\r\n        }\r\n        // not defined for BokehJS, only *receiving* buffers is supported\r\n        // add_buffer: (buf_header, buf_payload) ->\r\n        // write_buffers: (socket)\r\n        static create(msgtype, metadata, content = {}) {\r\n            const header = Message.create_header(msgtype);\r\n            return new Message(header, metadata, content);\r\n        }\r\n        static create_header(msgtype) {\r\n            return {\r\n                msgid: string_1.uniqueId(),\r\n                msgtype,\r\n            };\r\n        }\r\n        complete() {\r\n            if (this.header != null && this.metadata != null && this.content != null) {\r\n                if (this.header.num_buffers != undefined)\r\n                    return this.buffers.size == this.header.num_buffers;\r\n                else\r\n                    return true;\r\n            }\r\n            else\r\n                return false;\r\n        }\r\n        send(socket) {\r\n            const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\r\n            if (nb > 0)\r\n                throw new Error(\"BokehJS only supports receiving buffers, not sending\");\r\n            const header_json = JSON.stringify(this.header);\r\n            const metadata_json = JSON.stringify(this.metadata);\r\n            const content_json = JSON.stringify(this.content);\r\n            socket.send(header_json);\r\n            socket.send(metadata_json);\r\n            socket.send(content_json);\r\n        }\r\n        msgid() {\r\n            return this.header.msgid;\r\n        }\r\n        msgtype() {\r\n            return this.header.msgtype;\r\n        }\r\n        reqid() {\r\n            return this.header.reqid;\r\n        }\r\n        // return the reason we should close on bad protocol, if there is one\r\n        problem() {\r\n            if (!('msgid' in this.header))\r\n                return \"No msgid in header\";\r\n            else if (!('msgtype' in this.header))\r\n                return \"No msgtype in header\";\r\n            else\r\n                return null;\r\n        }\r\n    }\r\n    exports.Message = Message;\r\n    Message.__name__ = \"Message\";\r\n}\r\n","/* protocol\\receiver.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const message_1 = require(385) /* ./message */;\r\n    const types_1 = require(8) /* ../core/util/types */;\r\n    class Receiver {\r\n        constructor() {\r\n            this.message = null;\r\n            this._partial = null;\r\n            this._fragments = [];\r\n            this._buf_header = null;\r\n            this._current_consumer = this._HEADER;\r\n        }\r\n        consume(fragment) {\r\n            this._current_consumer(fragment);\r\n        }\r\n        _HEADER(fragment) {\r\n            this._assume_text(fragment);\r\n            this.message = null;\r\n            this._partial = null;\r\n            this._fragments = [fragment];\r\n            this._buf_header = null;\r\n            this._current_consumer = this._METADATA;\r\n        }\r\n        _METADATA(fragment) {\r\n            this._assume_text(fragment);\r\n            this._fragments.push(fragment);\r\n            this._current_consumer = this._CONTENT;\r\n        }\r\n        _CONTENT(fragment) {\r\n            this._assume_text(fragment);\r\n            this._fragments.push(fragment);\r\n            const [header_json, metadata_json, content_json] = this._fragments.slice(0, 3);\r\n            this._partial = message_1.Message.assemble(header_json, metadata_json, content_json);\r\n            this._check_complete();\r\n        }\r\n        _BUFFER_HEADER(fragment) {\r\n            this._assume_text(fragment);\r\n            this._buf_header = fragment;\r\n            this._current_consumer = this._BUFFER_PAYLOAD;\r\n        }\r\n        _BUFFER_PAYLOAD(fragment) {\r\n            this._assume_binary(fragment);\r\n            this._partial.assemble_buffer(this._buf_header, fragment);\r\n            this._check_complete();\r\n        }\r\n        _assume_text(fragment) {\r\n            if (!types_1.isString(fragment))\r\n                throw new Error(\"Expected text fragment but received binary fragment\");\r\n        }\r\n        _assume_binary(fragment) {\r\n            if (!(fragment instanceof ArrayBuffer))\r\n                throw new Error(\"Expected binary fragment but received text fragment\");\r\n        }\r\n        _check_complete() {\r\n            if (this._partial.complete()) {\r\n                this.message = this._partial;\r\n                this._current_consumer = this._HEADER;\r\n            }\r\n            else\r\n                this._current_consumer = this._BUFFER_HEADER;\r\n        }\r\n    }\r\n    exports.Receiver = Receiver;\r\n    Receiver.__name__ = \"Receiver\";\r\n}\r\n","/* client\\session.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const document_1 = require(5) /* ../document */;\r\n    const message_1 = require(385) /* ../protocol/message */;\r\n    const logging_1 = require(19) /* ../core/logging */;\r\n    class ClientSession {\r\n        constructor(_connection, document, id) {\r\n            this._connection = _connection;\r\n            this.document = document;\r\n            this.id = id;\r\n            this._document_listener = (event) => {\r\n                this._document_changed(event);\r\n            };\r\n            this.document.on_change(this._document_listener, true);\r\n        }\r\n        handle(message) {\r\n            const msgtype = message.msgtype();\r\n            if (msgtype === 'PATCH-DOC')\r\n                this._handle_patch(message);\r\n            else if (msgtype === 'OK')\r\n                this._handle_ok(message);\r\n            else if (msgtype === 'ERROR')\r\n                this._handle_error(message);\r\n            else\r\n                logging_1.logger.debug(`Doing nothing with message ${message.msgtype()}`);\r\n        }\r\n        close() {\r\n            this._connection.close();\r\n        }\r\n        /*protected*/ _connection_closed() {\r\n            this.document.remove_on_change(this._document_listener);\r\n        }\r\n        // Sends a request to the server for info about the server, such as its Bokeh\r\n        // version. Returns a promise, the value of the promise is a free-form dictionary\r\n        // of server details.\r\n        async request_server_info() {\r\n            const message = message_1.Message.create('SERVER-INFO-REQ', {});\r\n            const reply = await this._connection.send_with_reply(message);\r\n            return reply.content;\r\n        }\r\n        // Sends some request to the server (no guarantee about which one) and returns\r\n        // a promise which is completed when the server replies. The purpose of this\r\n        // is that if you wait for the promise to be completed, you know the server\r\n        // has processed the request. This is useful when writing tests because once\r\n        // the server has processed this request it should also have processed any\r\n        // events or requests you sent previously, which means you can check for the\r\n        // results of that processing without a race condition. (This assumes the\r\n        // server processes events in sequence, which it mostly has to semantically,\r\n        // since reordering events might change the final state.)\r\n        async force_roundtrip() {\r\n            await this.request_server_info();\r\n        }\r\n        _document_changed(event) {\r\n            // Filter out events that were initiated by the ClientSession itself\r\n            if (event.setter_id === this.id) // XXX: not all document events define this\r\n                return;\r\n            const events = event instanceof document_1.DocumentEventBatch ? event.events : [event];\r\n            const patch = this.document.create_json_patch(events);\r\n            // TODO (havocp) the connection may be closed here, which will\r\n            // cause this send to throw an error - need to deal with it more cleanly.\r\n            const message = message_1.Message.create('PATCH-DOC', {}, patch);\r\n            this._connection.send(message);\r\n        }\r\n        _handle_patch(message) {\r\n            this.document.apply_json_patch(message.content, message.buffers, this.id);\r\n        }\r\n        _handle_ok(message) {\r\n            logging_1.logger.trace(`Unhandled OK reply to ${message.reqid()}`);\r\n        }\r\n        _handle_error(message) {\r\n            logging_1.logger.error(`Unhandled ERROR reply to ${message.reqid()}: ${message.content.text}`);\r\n        }\r\n    }\r\n    exports.ClientSession = ClientSession;\r\n    ClientSession.__name__ = \"ClientSession\";\r\n}\r\n","/* embed\\notebook.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    var __asyncValues = (this && this.__asyncValues) || function (o) {\r\n        if (!Symbol.asyncIterator)\r\n            throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n    const document_1 = require(5) /* ../document */;\r\n    const receiver_1 = require(386) /* ../protocol/receiver */;\r\n    const logging_1 = require(19) /* ../core/logging */;\r\n    const dom_1 = require(72) /* ../core/dom */;\r\n    const object_1 = require(13) /* ../core/util/object */;\r\n    const standalone_1 = require(381) /* ./standalone */;\r\n    const dom_2 = require(382) /* ./dom */;\r\n    const root_css_1 = tslib_1.__importDefault(require(73) /* ../styles/root.css */);\r\n    const logo_css_1 = tslib_1.__importDefault(require(311) /* ../styles/logo.css */);\r\n    const notebook_css_1 = tslib_1.__importDefault(require(389) /* ../styles/notebook.css */);\r\n    dom_1.stylesheet.append(root_css_1.default);\r\n    dom_1.stylesheet.append(logo_css_1.default);\r\n    dom_1.stylesheet.append(notebook_css_1.default);\r\n    // This exists to allow the @bokeh/jupyter_bokeh extension to store the\r\n    // notebook kernel so that _init_comms can register the comms target.\r\n    // This has to be available at Bokeh.embed.kernels in JupyterLab.\r\n    exports.kernels = {};\r\n    function _handle_notebook_comms(receiver, comm_msg) {\r\n        if (comm_msg.buffers.length > 0)\r\n            receiver.consume(comm_msg.buffers[0].buffer);\r\n        else\r\n            receiver.consume(comm_msg.content.data);\r\n        const msg = receiver.message;\r\n        if (msg != null)\r\n            this.apply_json_patch(msg.content, msg.buffers);\r\n    }\r\n    function _init_comms(target, doc) {\r\n        if (typeof Jupyter !== 'undefined' && Jupyter.notebook.kernel != null) {\r\n            logging_1.logger.info(`Registering Jupyter comms for target ${target}`);\r\n            const comm_manager = Jupyter.notebook.kernel.comm_manager;\r\n            try {\r\n                comm_manager.register_target(target, (comm) => {\r\n                    logging_1.logger.info(`Registering Jupyter comms for target ${target}`);\r\n                    const r = new receiver_1.Receiver();\r\n                    comm.on_msg(_handle_notebook_comms.bind(doc, r));\r\n                });\r\n            }\r\n            catch (e) {\r\n                logging_1.logger.warn(`Jupyter comms failed to register. push_notebook() will not function. (exception reported: ${e})`);\r\n            }\r\n        }\r\n        else if (doc.roots()[0].id in exports.kernels) {\r\n            logging_1.logger.info(`Registering JupyterLab comms for target ${target}`);\r\n            const kernel = exports.kernels[doc.roots()[0].id];\r\n            try {\r\n                kernel.registerCommTarget(target, (comm) => {\r\n                    logging_1.logger.info(`Registering JupyterLab comms for target ${target}`);\r\n                    const r = new receiver_1.Receiver();\r\n                    comm.onMsg = _handle_notebook_comms.bind(doc, r);\r\n                });\r\n            }\r\n            catch (e) {\r\n                logging_1.logger.warn(`Jupyter comms failed to register. push_notebook() will not function. (exception reported: ${e})`);\r\n            }\r\n        }\r\n        else if (typeof google != 'undefined' && google.colab.kernel != null) {\r\n            logging_1.logger.info(`Registering Google Colab comms for target ${target}`);\r\n            const comm_manager = google.colab.kernel.comms;\r\n            try {\r\n                comm_manager.registerTarget(target, async (comm) => {\r\n                    var e_1, _a;\r\n                    var _b;\r\n                    logging_1.logger.info(`Registering Google Colab comms for target ${target}`);\r\n                    const r = new receiver_1.Receiver();\r\n                    try {\r\n                        for (var _c = __asyncValues(comm.messages), _d; _d = await _c.next(), !_d.done;) {\r\n                            const message = _d.value;\r\n                            const content = { data: message.data };\r\n                            const buffers = [];\r\n                            for (const buffer of (_b = message.buffers) !== null && _b !== void 0 ? _b : []) {\r\n                                buffers.push(new DataView(buffer));\r\n                            }\r\n                            const msg = { content, buffers };\r\n                            _handle_notebook_comms.bind(doc)(r, msg);\r\n                        }\r\n                    }\r\n                    catch (e_1_1) {\r\n                        e_1 = { error: e_1_1 };\r\n                    }\r\n                    finally {\r\n                        try {\r\n                            if (_d && !_d.done && (_a = _c.return))\r\n                                await _a.call(_c);\r\n                        }\r\n                        finally {\r\n                            if (e_1)\r\n                                throw e_1.error;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                logging_1.logger.warn(`Google Colab comms failed to register. push_notebook() will not function. (exception reported: ${e})`);\r\n            }\r\n        }\r\n        else {\r\n            console.warn(`Jupyter notebooks comms not available. push_notebook() will not function. If running JupyterLab ensure the latest @bokeh/jupyter_bokeh extension is installed. In an exported notebook this warning is expected.`);\r\n        }\r\n    }\r\n    function embed_items_notebook(docs_json, render_items) {\r\n        if (object_1.size(docs_json) != 1)\r\n            throw new Error(\"embed_items_notebook expects exactly one document in docs_json\");\r\n        const document = document_1.Document.from_json(object_1.values(docs_json)[0]);\r\n        for (const item of render_items) {\r\n            if (item.notebook_comms_target != null)\r\n                _init_comms(item.notebook_comms_target, document);\r\n            const element = dom_2._resolve_element(item);\r\n            const roots = dom_2._resolve_root_elements(item);\r\n            standalone_1.add_document_standalone(document, element, roots);\r\n        }\r\n    }\r\n    exports.embed_items_notebook = embed_items_notebook;\r\n}\r\n","/* styles\\notebook.css.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const css = `\n/* notebook specific tweaks so no black outline and matching padding\n/* can't be wrapped inside bk-root. here are the offending jupyter lines:\n/* https://github.com/jupyter/notebook/blob/master/notebook/static/notebook/less/renderedhtml.less#L59-L76 */\n.rendered_html .bk-root .bk-tooltip table,\n.rendered_html .bk-root .bk-tooltip tr,\n.rendered_html .bk-root .bk-tooltip th,\n.rendered_html .bk-root .bk-tooltip td {\n  border: none;\n  padding: 1px;\n}\n`;\r\n    exports.default = css;\r\n}\r\n","/* protocol\\index.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    const tslib_1 = require(1) /* tslib */;\r\n    tslib_1.__exportStar(require(385) /* ./message */, exports);\r\n    tslib_1.__exportStar(require(386) /* ./receiver */, exports);\r\n}\r\n","/* testing.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    // Just a dumb key/value record for collecting arbitrary info for tests\r\n    exports.results = {};\r\n    // Selenium has race conditions that make it difficult to read out the\r\n    // results structure. This function deletes/creates a div that can act as\r\n    // a semaphore. Tests should wait for the previous div to be stale, then\r\n    // find the new div. At that point the results should be available\r\n    function update_test_div() {\r\n        const body = document.getElementsByTagName(\"body\")[0];\r\n        const col = document.getElementsByClassName(\"bokeh-test-div\");\r\n        if (col.length == 1) {\r\n            body.removeChild(col[0]);\r\n            delete col[0];\r\n        }\r\n        const box = document.createElement(\"div\");\r\n        box.classList.add(\"bokeh-test-div\");\r\n        box.style.display = \"none\";\r\n        body.insertBefore(box, body.firstChild);\r\n    }\r\n    function init() {\r\n        update_test_div();\r\n    }\r\n    exports.init = init;\r\n    function record0(key, value) {\r\n        exports.results[key] = value;\r\n    }\r\n    exports.record0 = record0;\r\n    function record(key, value) {\r\n        exports.results[key] = value;\r\n        update_test_div();\r\n    }\r\n    exports.record = record;\r\n    function count(key) {\r\n        if (exports.results[key] == undefined)\r\n            exports.results[key] = 0;\r\n        exports.results[key] += 1;\r\n        update_test_div();\r\n    }\r\n    exports.count = count;\r\n}\r\n","/* safely.js */ function _(require, module, exports) {\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    // Keep this code as terse and as close to vanila JS as possible. If we\r\n    // arrived here, it means we should trust no one and need to act properly.\r\n    function _burst_into_flames(error) {\r\n        // Make box\r\n        const box = document.createElement(\"div\");\r\n        box.style.backgroundColor = \"#f2dede\";\r\n        box.style.border = \"1px solid #a94442\";\r\n        box.style.borderRadius = \"4px\";\r\n        box.style.display = \"inline-block\";\r\n        box.style.fontFamily = \"sans-serif\";\r\n        box.style.marginTop = \"5px\";\r\n        box.style.minWidth = \"200px\";\r\n        box.style.padding = \"5px 5px 5px 10px\";\r\n        box.classList.add(\"bokeh-error-box-into-flames\");\r\n        // Make button\r\n        const button = document.createElement(\"span\");\r\n        button.style.backgroundColor = \"#a94442\";\r\n        button.style.borderRadius = \"0px 4px 0px 0px\";\r\n        button.style.color = \"white\";\r\n        button.style.cursor = \"pointer\";\r\n        button.style.cssFloat = \"right\";\r\n        button.style.fontSize = \"0.8em\";\r\n        button.style.margin = \"-6px -6px 0px 0px\";\r\n        button.style.padding = \"2px 5px 4px 5px\";\r\n        button.title = \"close\";\r\n        button.setAttribute(\"aria-label\", \"close\");\r\n        button.appendChild(document.createTextNode(\"x\"));\r\n        button.addEventListener(\"click\", () => body.removeChild(box));\r\n        // Make title\r\n        const title = document.createElement(\"h3\");\r\n        title.style.color = \"#a94442\";\r\n        title.style.margin = \"8px 0px 0px 0px\";\r\n        title.style.padding = \"0px\";\r\n        title.appendChild(document.createTextNode(\"Bokeh Error\"));\r\n        // Make message\r\n        const message = document.createElement(\"pre\");\r\n        message.style.whiteSpace = \"unset\";\r\n        message.style.overflowX = \"auto\";\r\n        const text = error instanceof Error ? error.message : error;\r\n        message.appendChild(document.createTextNode(text));\r\n        // Add pieces to box\r\n        box.appendChild(button);\r\n        box.appendChild(title);\r\n        box.appendChild(message);\r\n        // Put box in doc\r\n        const body = document.getElementsByTagName(\"body\")[0];\r\n        body.insertBefore(box, body.firstChild);\r\n    }\r\n    function safely(fn, silent = false) {\r\n        try {\r\n            return fn();\r\n        }\r\n        catch (error) {\r\n            _burst_into_flames(error);\r\n            if (!silent)\r\n                throw error;\r\n            else\r\n                return;\r\n        }\r\n    }\r\n    exports.safely = safely;\r\n}\r\n"]}